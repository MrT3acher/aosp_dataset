diff -bur /home/mrt3acher/thesis-implementation/.avuln-workdir/code/CVE-2021-0394_12/secure/out/20-cfg.dot /home/mrt3acher/thesis-implementation/.avuln-workdir/code/CVE-2021-0394_12/vulnerable/out/20-cfg.dot
--- /home/mrt3acher/thesis-implementation/.avuln-workdir/code/CVE-2021-0394_12/secure/out/20-cfg.dot	2023-06-07 19:34:12.187391795 +0330
+++ /home/mrt3acher/thesis-implementation/.avuln-workdir/code/CVE-2021-0394_12/vulnerable/out/20-cfg.dot	2023-06-07 19:34:15.767391441 +0330
@@ -1,44 +1,44 @@
 digraph "numberToEnglish" {  
-"653" [label = <(&lt;operator&gt;.assignment,*const kDigits[] = {\012 &quot;zero&quot;,\012 &quot;one&quot;,\012 &quot;two&quot;,\012 &quot;three&quot;,\012 &quot;four&quot;,\012 &quot;five&quot;,\012 &quot;six&quot;,\012 &quot;seven&quot;,\012 &quot;eight&quot;,\012 &quot;nine&quot;,\012 })<SUB>429</SUB>> ]
-"759" [label = <(RETURN,return &quot;positively huge!&quot;;,return &quot;positively huge!&quot;;)<SUB>471</SUB>> ]
-"655" [label = <(&lt;operator&gt;.arrayInitializer,{\012 &quot;zero&quot;,\012 &quot;one&quot;,\012 &quot;two&quot;,\012 &quot;three&quot;,\012 &quot;four&quot;,\012 &quot;five&quot;,\012 &quot;six&quot;,\012 &quot;seven&quot;,\012 &quot;eight&quot;,\012 &quot;nine&quot;,\012 })<SUB>429</SUB>> ]
-"667" [label = <(&lt;operator&gt;.lessThan,x &lt; 0)<SUB>442</SUB>> ]
-"678" [label = <(&lt;operator&gt;.lessThan,x &lt; 10)<SUB>446</SUB>> ]
-"687" [label = <(&lt;operator&gt;.lessEqualsThan,x &lt;= 15)<SUB>450</SUB>> ]
-"708" [label = <(&lt;operator&gt;.lessThan,x &lt; 20)<SUB>458</SUB>> ]
-"725" [label = <(&lt;operator&gt;.lessThan,x &lt; 100)<SUB>462</SUB>> ]
-"671" [label = <(RETURN,return &quot;negative &quot; + numberToEnglish(-x);,return &quot;negative &quot; + numberToEnglish(-x);)<SUB>443</SUB>> ]
-"682" [label = <(RETURN,return kDigits[x];,return kDigits[x];)<SUB>447</SUB>> ]
-"692" [label = <(&lt;operator&gt;.assignment,*const kSpecialTens[] = {\012 &quot;ten&quot;, &quot;eleven&quot;, &quot;twelve&quot;, &quot;thirteen&quot;, &quot;fourteen&quot;, &quot;fifteen&quot;,\012 })<SUB>451</SUB>> ]
-"701" [label = <(RETURN,return kSpecialTens[x - 10];,return kSpecialTens[x - 10];)<SUB>455</SUB>> ]
-"712" [label = <(RETURN,return std::string(kDigits[x % 10]) + &quot;teen&quot;;,return std::string(kDigits[x % 10]) + &quot;teen&quot;;)<SUB>459</SUB>> ]
-"730" [label = <(&lt;operator&gt;.assignment,*const kDecades[] = {\012 &quot;twenty&quot;, &quot;thirty&quot;, &quot;forty&quot;, &quot;fifty&quot;, &quot;sixty&quot;, &quot;seventy&quot;,\012 &quot;eighty&quot;, &quot;ninety&quot;,\012 })<SUB>463</SUB>> ]
-"741" [label = <(RETURN,return std::string(kDecades[x / 10 - 2]) + kDigits[x % 10];,return std::string(kDecades[x / 10 - 2]) + kDigits[x % 10];)<SUB>468</SUB>> ]
-"672" [label = <(&lt;operator&gt;.addition,&quot;negative &quot; + numberToEnglish(-x))<SUB>443</SUB>> ]
-"683" [label = <(&lt;operator&gt;.indirectIndexAccess,kDigits[x])<SUB>447</SUB>> ]
-"694" [label = <(&lt;operator&gt;.arrayInitializer,{\012 &quot;ten&quot;, &quot;eleven&quot;, &quot;twelve&quot;, &quot;thirteen&quot;, &quot;fourteen&quot;, &quot;fifteen&quot;,\012 })<SUB>451</SUB>> ]
-"702" [label = <(&lt;operator&gt;.indirectIndexAccess,kSpecialTens[x - 10])<SUB>455</SUB>> ]
-"713" [label = <(&lt;operator&gt;.addition,std::string(kDigits[x % 10]) + &quot;teen&quot;)<SUB>459</SUB>> ]
-"732" [label = <(&lt;operator&gt;.arrayInitializer,{\012 &quot;twenty&quot;, &quot;thirty&quot;, &quot;forty&quot;, &quot;fifty&quot;, &quot;sixty&quot;, &quot;seventy&quot;,\012 &quot;eighty&quot;, &quot;ninety&quot;,\012 })<SUB>463</SUB>> ]
-"742" [label = <(&lt;operator&gt;.addition,std::string(kDecades[x / 10 - 2]) + kDigits[x % 10])<SUB>468</SUB>> ]
-"674" [label = <(numberToEnglish,numberToEnglish(-x))<SUB>443</SUB>> ]
-"704" [label = <(&lt;operator&gt;.subtraction,x - 10)<SUB>455</SUB>> ]
-"714" [label = <(std::string,std::string(kDigits[x % 10]))<SUB>459</SUB>> ]
-"743" [label = <(std::string,std::string(kDecades[x / 10 - 2]))<SUB>468</SUB>> ]
-"754" [label = <(&lt;operator&gt;.indirectIndexAccess,kDigits[x % 10])<SUB>468</SUB>> ]
-"675" [label = <(&lt;operator&gt;.minus,-x)<SUB>443</SUB>> ]
-"715" [label = <(&lt;operator&gt;.fieldAccess,std::string)<SUB>459</SUB>> ]
-"718" [label = <(&lt;operator&gt;.indirectIndexAccess,kDigits[x % 10])<SUB>459</SUB>> ]
-"744" [label = <(&lt;operator&gt;.fieldAccess,std::string)<SUB>468</SUB>> ]
-"747" [label = <(&lt;operator&gt;.indirectIndexAccess,kDecades[x / 10 - 2])<SUB>468</SUB>> ]
-"756" [label = <(&lt;operator&gt;.modulo,x % 10)<SUB>468</SUB>> ]
-"717" [label = <(FIELD_IDENTIFIER,string,string)<SUB>459</SUB>> ]
-"720" [label = <(&lt;operator&gt;.modulo,x % 10)<SUB>459</SUB>> ]
-"746" [label = <(FIELD_IDENTIFIER,string,string)<SUB>468</SUB>> ]
-"749" [label = <(&lt;operator&gt;.subtraction,x / 10 - 2)<SUB>468</SUB>> ]
-"750" [label = <(&lt;operator&gt;.division,x / 10)<SUB>468</SUB>> ]
-"649" [label = <(METHOD,numberToEnglish)<SUB>428</SUB>> ]
-"761" [label = <(METHOD_RETURN,string)<SUB>428</SUB>> ]
+"653" [label = <(&lt;operator&gt;.assignment,*const kDigits[] = {\012 &quot;zero&quot;,\012 &quot;one&quot;,\012 &quot;two&quot;,\012 &quot;three&quot;,\012 &quot;four&quot;,\012 &quot;five&quot;,\012 &quot;six&quot;,\012 &quot;seven&quot;,\012 &quot;eight&quot;,\012 &quot;nine&quot;,\012 })<SUB>431</SUB>> ]
+"759" [label = <(RETURN,return &quot;positively huge!&quot;;,return &quot;positively huge!&quot;;)<SUB>473</SUB>> ]
+"655" [label = <(&lt;operator&gt;.arrayInitializer,{\012 &quot;zero&quot;,\012 &quot;one&quot;,\012 &quot;two&quot;,\012 &quot;three&quot;,\012 &quot;four&quot;,\012 &quot;five&quot;,\012 &quot;six&quot;,\012 &quot;seven&quot;,\012 &quot;eight&quot;,\012 &quot;nine&quot;,\012 })<SUB>431</SUB>> ]
+"667" [label = <(&lt;operator&gt;.lessThan,x &lt; 0)<SUB>444</SUB>> ]
+"678" [label = <(&lt;operator&gt;.lessThan,x &lt; 10)<SUB>448</SUB>> ]
+"687" [label = <(&lt;operator&gt;.lessEqualsThan,x &lt;= 15)<SUB>452</SUB>> ]
+"708" [label = <(&lt;operator&gt;.lessThan,x &lt; 20)<SUB>460</SUB>> ]
+"725" [label = <(&lt;operator&gt;.lessThan,x &lt; 100)<SUB>464</SUB>> ]
+"671" [label = <(RETURN,return &quot;negative &quot; + numberToEnglish(-x);,return &quot;negative &quot; + numberToEnglish(-x);)<SUB>445</SUB>> ]
+"682" [label = <(RETURN,return kDigits[x];,return kDigits[x];)<SUB>449</SUB>> ]
+"692" [label = <(&lt;operator&gt;.assignment,*const kSpecialTens[] = {\012 &quot;ten&quot;, &quot;eleven&quot;, &quot;twelve&quot;, &quot;thirteen&quot;, &quot;fourteen&quot;, &quot;fifteen&quot;,\012 })<SUB>453</SUB>> ]
+"701" [label = <(RETURN,return kSpecialTens[x - 10];,return kSpecialTens[x - 10];)<SUB>457</SUB>> ]
+"712" [label = <(RETURN,return std::string(kDigits[x % 10]) + &quot;teen&quot;;,return std::string(kDigits[x % 10]) + &quot;teen&quot;;)<SUB>461</SUB>> ]
+"730" [label = <(&lt;operator&gt;.assignment,*const kDecades[] = {\012 &quot;twenty&quot;, &quot;thirty&quot;, &quot;forty&quot;, &quot;fifty&quot;, &quot;sixty&quot;, &quot;seventy&quot;,\012 &quot;eighty&quot;, &quot;ninety&quot;,\012 })<SUB>465</SUB>> ]
+"741" [label = <(RETURN,return std::string(kDecades[x / 10 - 2]) + kDigits[x % 10];,return std::string(kDecades[x / 10 - 2]) + kDigits[x % 10];)<SUB>470</SUB>> ]
+"672" [label = <(&lt;operator&gt;.addition,&quot;negative &quot; + numberToEnglish(-x))<SUB>445</SUB>> ]
+"683" [label = <(&lt;operator&gt;.indirectIndexAccess,kDigits[x])<SUB>449</SUB>> ]
+"694" [label = <(&lt;operator&gt;.arrayInitializer,{\012 &quot;ten&quot;, &quot;eleven&quot;, &quot;twelve&quot;, &quot;thirteen&quot;, &quot;fourteen&quot;, &quot;fifteen&quot;,\012 })<SUB>453</SUB>> ]
+"702" [label = <(&lt;operator&gt;.indirectIndexAccess,kSpecialTens[x - 10])<SUB>457</SUB>> ]
+"713" [label = <(&lt;operator&gt;.addition,std::string(kDigits[x % 10]) + &quot;teen&quot;)<SUB>461</SUB>> ]
+"732" [label = <(&lt;operator&gt;.arrayInitializer,{\012 &quot;twenty&quot;, &quot;thirty&quot;, &quot;forty&quot;, &quot;fifty&quot;, &quot;sixty&quot;, &quot;seventy&quot;,\012 &quot;eighty&quot;, &quot;ninety&quot;,\012 })<SUB>465</SUB>> ]
+"742" [label = <(&lt;operator&gt;.addition,std::string(kDecades[x / 10 - 2]) + kDigits[x % 10])<SUB>470</SUB>> ]
+"674" [label = <(numberToEnglish,numberToEnglish(-x))<SUB>445</SUB>> ]
+"704" [label = <(&lt;operator&gt;.subtraction,x - 10)<SUB>457</SUB>> ]
+"714" [label = <(std::string,std::string(kDigits[x % 10]))<SUB>461</SUB>> ]
+"743" [label = <(std::string,std::string(kDecades[x / 10 - 2]))<SUB>470</SUB>> ]
+"754" [label = <(&lt;operator&gt;.indirectIndexAccess,kDigits[x % 10])<SUB>470</SUB>> ]
+"675" [label = <(&lt;operator&gt;.minus,-x)<SUB>445</SUB>> ]
+"715" [label = <(&lt;operator&gt;.fieldAccess,std::string)<SUB>461</SUB>> ]
+"718" [label = <(&lt;operator&gt;.indirectIndexAccess,kDigits[x % 10])<SUB>461</SUB>> ]
+"744" [label = <(&lt;operator&gt;.fieldAccess,std::string)<SUB>470</SUB>> ]
+"747" [label = <(&lt;operator&gt;.indirectIndexAccess,kDecades[x / 10 - 2])<SUB>470</SUB>> ]
+"756" [label = <(&lt;operator&gt;.modulo,x % 10)<SUB>470</SUB>> ]
+"717" [label = <(FIELD_IDENTIFIER,string,string)<SUB>461</SUB>> ]
+"720" [label = <(&lt;operator&gt;.modulo,x % 10)<SUB>461</SUB>> ]
+"746" [label = <(FIELD_IDENTIFIER,string,string)<SUB>470</SUB>> ]
+"749" [label = <(&lt;operator&gt;.subtraction,x / 10 - 2)<SUB>470</SUB>> ]
+"750" [label = <(&lt;operator&gt;.division,x / 10)<SUB>470</SUB>> ]
+"649" [label = <(METHOD,numberToEnglish)<SUB>430</SUB>> ]
+"761" [label = <(METHOD_RETURN,string)<SUB>430</SUB>> ]
   "653" -> "667" 
   "759" -> "761" 
   "655" -> "653" 
diff -bur /home/mrt3acher/thesis-implementation/.avuln-workdir/code/CVE-2021-0394_12/secure/out/21-cfg.dot /home/mrt3acher/thesis-implementation/.avuln-workdir/code/CVE-2021-0394_12/vulnerable/out/21-cfg.dot
--- /home/mrt3acher/thesis-implementation/.avuln-workdir/code/CVE-2021-0394_12/secure/out/21-cfg.dot	2023-06-07 19:34:12.187391795 +0330
+++ /home/mrt3acher/thesis-implementation/.avuln-workdir/code/CVE-2021-0394_12/vulnerable/out/21-cfg.dot	2023-06-07 19:34:15.767391441 +0330
@@ -1,45 +1,45 @@
 digraph "checkNativeHandlesDataEquality" {  
-"813" [label = <(ASSERT_NE,ASSERT_NE(reference, result))<SUB>882</SUB>> ]
-"816" [label = <(ASSERT_EQ,ASSERT_EQ(reference-&gt;version, result-&gt;version))<SUB>883</SUB>> ]
-"823" [label = <(EXPECT_EQ,EXPECT_EQ(reference-&gt;numFds, result-&gt;numFds))<SUB>884</SUB>> ]
-"830" [label = <(EXPECT_EQ,EXPECT_EQ(reference-&gt;numInts, result-&gt;numInts))<SUB>885</SUB>> ]
-"838" [label = <(&lt;operator&gt;.assignment,offset = reference-&gt;numFds)<SUB>887</SUB>> ]
-"844" [label = <(&lt;operator&gt;.assignment,numInts = reference-&gt;numInts)<SUB>888</SUB>> ]
-"849" [label = <(EXPECT_TRUE,EXPECT_TRUE(isArrayEqual(&amp;(reference-&gt;data[offset]), &amp;(result-&gt;data[offset]), numInts)))<SUB>889</SUB>> ]
-"797" [label = <(&lt;operator&gt;.logicalOr,reference == nullptr || result == nullptr)<SUB>877</SUB>> ]
-"817" [label = <(&lt;operator&gt;.indirectFieldAccess,reference-&gt;version)<SUB>883</SUB>> ]
-"820" [label = <(&lt;operator&gt;.indirectFieldAccess,result-&gt;version)<SUB>883</SUB>> ]
-"824" [label = <(&lt;operator&gt;.indirectFieldAccess,reference-&gt;numFds)<SUB>884</SUB>> ]
-"827" [label = <(&lt;operator&gt;.indirectFieldAccess,result-&gt;numFds)<SUB>884</SUB>> ]
-"831" [label = <(&lt;operator&gt;.indirectFieldAccess,reference-&gt;numInts)<SUB>885</SUB>> ]
-"834" [label = <(&lt;operator&gt;.indirectFieldAccess,result-&gt;numInts)<SUB>885</SUB>> ]
-"840" [label = <(&lt;operator&gt;.indirectFieldAccess,reference-&gt;numFds)<SUB>887</SUB>> ]
-"846" [label = <(&lt;operator&gt;.indirectFieldAccess,reference-&gt;numInts)<SUB>888</SUB>> ]
-"850" [label = <(isArrayEqual,isArrayEqual(&amp;(reference-&gt;data[offset]), &amp;(result-&gt;data[offset]), numInts))<SUB>889</SUB>> ]
-"798" [label = <(&lt;operator&gt;.equals,reference == nullptr)<SUB>877</SUB>> ]
-"801" [label = <(&lt;operator&gt;.equals,result == nullptr)<SUB>877</SUB>> ]
-"805" [label = <(EXPECT_EQ,EXPECT_EQ(reference == nullptr, result == nullptr))<SUB>878</SUB>> ]
-"812" [label = <(RETURN,return;,return;)<SUB>879</SUB>> ]
-"819" [label = <(FIELD_IDENTIFIER,version,version)<SUB>883</SUB>> ]
-"822" [label = <(FIELD_IDENTIFIER,version,version)<SUB>883</SUB>> ]
-"826" [label = <(FIELD_IDENTIFIER,numFds,numFds)<SUB>884</SUB>> ]
-"829" [label = <(FIELD_IDENTIFIER,numFds,numFds)<SUB>884</SUB>> ]
-"833" [label = <(FIELD_IDENTIFIER,numInts,numInts)<SUB>885</SUB>> ]
-"836" [label = <(FIELD_IDENTIFIER,numInts,numInts)<SUB>885</SUB>> ]
-"842" [label = <(FIELD_IDENTIFIER,numFds,numFds)<SUB>887</SUB>> ]
-"848" [label = <(FIELD_IDENTIFIER,numInts,numInts)<SUB>888</SUB>> ]
-"851" [label = <(&lt;operator&gt;.addressOf,&amp;(reference-&gt;data[offset]))<SUB>889</SUB>> ]
-"857" [label = <(&lt;operator&gt;.addressOf,&amp;(result-&gt;data[offset]))<SUB>889</SUB>> ]
-"806" [label = <(&lt;operator&gt;.equals,reference == nullptr)<SUB>878</SUB>> ]
-"809" [label = <(&lt;operator&gt;.equals,result == nullptr)<SUB>878</SUB>> ]
-"852" [label = <(&lt;operator&gt;.indirectIndexAccess,reference-&gt;data[offset])<SUB>889</SUB>> ]
-"858" [label = <(&lt;operator&gt;.indirectIndexAccess,result-&gt;data[offset])<SUB>889</SUB>> ]
-"853" [label = <(&lt;operator&gt;.indirectFieldAccess,reference-&gt;data)<SUB>889</SUB>> ]
-"859" [label = <(&lt;operator&gt;.indirectFieldAccess,result-&gt;data)<SUB>889</SUB>> ]
-"855" [label = <(FIELD_IDENTIFIER,data,data)<SUB>889</SUB>> ]
-"861" [label = <(FIELD_IDENTIFIER,data,data)<SUB>889</SUB>> ]
-"792" [label = <(METHOD,checkNativeHandlesDataEquality)<SUB>875</SUB>> ]
-"864" [label = <(METHOD_RETURN,void)<SUB>875</SUB>> ]
+"813" [label = <(ASSERT_NE,ASSERT_NE(reference, result))<SUB>884</SUB>> ]
+"816" [label = <(ASSERT_EQ,ASSERT_EQ(reference-&gt;version, result-&gt;version))<SUB>885</SUB>> ]
+"823" [label = <(EXPECT_EQ,EXPECT_EQ(reference-&gt;numFds, result-&gt;numFds))<SUB>886</SUB>> ]
+"830" [label = <(EXPECT_EQ,EXPECT_EQ(reference-&gt;numInts, result-&gt;numInts))<SUB>887</SUB>> ]
+"838" [label = <(&lt;operator&gt;.assignment,offset = reference-&gt;numFds)<SUB>889</SUB>> ]
+"844" [label = <(&lt;operator&gt;.assignment,numInts = reference-&gt;numInts)<SUB>890</SUB>> ]
+"849" [label = <(EXPECT_TRUE,EXPECT_TRUE(isArrayEqual(&amp;(reference-&gt;data[offset]), &amp;(result-&gt;data[offset]), numInts)))<SUB>891</SUB>> ]
+"797" [label = <(&lt;operator&gt;.logicalOr,reference == nullptr || result == nullptr)<SUB>879</SUB>> ]
+"817" [label = <(&lt;operator&gt;.indirectFieldAccess,reference-&gt;version)<SUB>885</SUB>> ]
+"820" [label = <(&lt;operator&gt;.indirectFieldAccess,result-&gt;version)<SUB>885</SUB>> ]
+"824" [label = <(&lt;operator&gt;.indirectFieldAccess,reference-&gt;numFds)<SUB>886</SUB>> ]
+"827" [label = <(&lt;operator&gt;.indirectFieldAccess,result-&gt;numFds)<SUB>886</SUB>> ]
+"831" [label = <(&lt;operator&gt;.indirectFieldAccess,reference-&gt;numInts)<SUB>887</SUB>> ]
+"834" [label = <(&lt;operator&gt;.indirectFieldAccess,result-&gt;numInts)<SUB>887</SUB>> ]
+"840" [label = <(&lt;operator&gt;.indirectFieldAccess,reference-&gt;numFds)<SUB>889</SUB>> ]
+"846" [label = <(&lt;operator&gt;.indirectFieldAccess,reference-&gt;numInts)<SUB>890</SUB>> ]
+"850" [label = <(isArrayEqual,isArrayEqual(&amp;(reference-&gt;data[offset]), &amp;(result-&gt;data[offset]), numInts))<SUB>891</SUB>> ]
+"798" [label = <(&lt;operator&gt;.equals,reference == nullptr)<SUB>879</SUB>> ]
+"801" [label = <(&lt;operator&gt;.equals,result == nullptr)<SUB>879</SUB>> ]
+"805" [label = <(EXPECT_EQ,EXPECT_EQ(reference == nullptr, result == nullptr))<SUB>880</SUB>> ]
+"812" [label = <(RETURN,return;,return;)<SUB>881</SUB>> ]
+"819" [label = <(FIELD_IDENTIFIER,version,version)<SUB>885</SUB>> ]
+"822" [label = <(FIELD_IDENTIFIER,version,version)<SUB>885</SUB>> ]
+"826" [label = <(FIELD_IDENTIFIER,numFds,numFds)<SUB>886</SUB>> ]
+"829" [label = <(FIELD_IDENTIFIER,numFds,numFds)<SUB>886</SUB>> ]
+"833" [label = <(FIELD_IDENTIFIER,numInts,numInts)<SUB>887</SUB>> ]
+"836" [label = <(FIELD_IDENTIFIER,numInts,numInts)<SUB>887</SUB>> ]
+"842" [label = <(FIELD_IDENTIFIER,numFds,numFds)<SUB>889</SUB>> ]
+"848" [label = <(FIELD_IDENTIFIER,numInts,numInts)<SUB>890</SUB>> ]
+"851" [label = <(&lt;operator&gt;.addressOf,&amp;(reference-&gt;data[offset]))<SUB>891</SUB>> ]
+"857" [label = <(&lt;operator&gt;.addressOf,&amp;(result-&gt;data[offset]))<SUB>891</SUB>> ]
+"806" [label = <(&lt;operator&gt;.equals,reference == nullptr)<SUB>880</SUB>> ]
+"809" [label = <(&lt;operator&gt;.equals,result == nullptr)<SUB>880</SUB>> ]
+"852" [label = <(&lt;operator&gt;.indirectIndexAccess,reference-&gt;data[offset])<SUB>891</SUB>> ]
+"858" [label = <(&lt;operator&gt;.indirectIndexAccess,result-&gt;data[offset])<SUB>891</SUB>> ]
+"853" [label = <(&lt;operator&gt;.indirectFieldAccess,reference-&gt;data)<SUB>891</SUB>> ]
+"859" [label = <(&lt;operator&gt;.indirectFieldAccess,result-&gt;data)<SUB>891</SUB>> ]
+"855" [label = <(FIELD_IDENTIFIER,data,data)<SUB>891</SUB>> ]
+"861" [label = <(FIELD_IDENTIFIER,data,data)<SUB>891</SUB>> ]
+"792" [label = <(METHOD,checkNativeHandlesDataEquality)<SUB>877</SUB>> ]
+"864" [label = <(METHOD_RETURN,void)<SUB>877</SUB>> ]
   "813" -> "819" 
   "816" -> "826" 
   "823" -> "833" 
diff -bur /home/mrt3acher/thesis-implementation/.avuln-workdir/code/CVE-2021-0394_12/secure/out/22-cfg.dot /home/mrt3acher/thesis-implementation/.avuln-workdir/code/CVE-2021-0394_12/vulnerable/out/22-cfg.dot
--- /home/mrt3acher/thesis-implementation/.avuln-workdir/code/CVE-2021-0394_12/secure/out/22-cfg.dot	2023-06-07 19:34:12.187391795 +0330
+++ /home/mrt3acher/thesis-implementation/.avuln-workdir/code/CVE-2021-0394_12/vulnerable/out/22-cfg.dot	2023-06-07 19:34:15.767391441 +0330
@@ -1,21 +1,21 @@
 digraph "expectRangeEqual" {  
-"877" [label = <(static_assert,static_assert(start &lt; sizeof(T));)<SUB>1195</SUB>> ]
-"882" [label = <(static_assert,static_assert(end &lt;= sizeof(T));)<SUB>1196</SUB>> ]
-"888" [label = <(&lt;operator&gt;.assignment,* buf = reinterpret_cast&lt;const uint8_t*&gt;(t))<SUB>1198</SUB>> ]
-"878" [label = <(&lt;operator&gt;.lessThan,start &lt; sizeof(T))<SUB>1195</SUB>> ]
-"883" [label = <(&lt;operator&gt;.lessEqualsThan,end &lt;= sizeof(T))<SUB>1196</SUB>> ]
-"890" [label = <(&lt;operator&gt;.cast,reinterpret_cast&lt;const uint8_t*&gt;(t))<SUB>1198</SUB>> ]
-"899" [label = <(&lt;operator&gt;.lessThan,i &lt; end)<SUB>1200</SUB>> ]
-"902" [label = <(&lt;operator&gt;.postIncrement,i++)<SUB>1200</SUB>> ]
-"880" [label = <(&lt;operator&gt;.sizeOf,sizeof(T))<SUB>1195</SUB>> ]
-"885" [label = <(&lt;operator&gt;.sizeOf,sizeof(T))<SUB>1196</SUB>> ]
-"891" [label = <(UNKNOWN,const uint8_t*,const uint8_t*)<SUB>1198</SUB>> ]
-"896" [label = <(&lt;operator&gt;.assignment,i = start)<SUB>1200</SUB>> ]
-"905" [label = <(&lt;operator&gt;.shiftLeft,EXPECT_EQ(byte, buf[i]) &lt;&lt; i)<SUB>1201</SUB>> ]
-"906" [label = <(EXPECT_EQ,EXPECT_EQ(byte, buf[i]))<SUB>1201</SUB>> ]
-"908" [label = <(&lt;operator&gt;.indirectIndexAccess,buf[i])<SUB>1201</SUB>> ]
-"873" [label = <(METHOD,expectRangeEqual)<SUB>1194</SUB>> ]
-"912" [label = <(METHOD_RETURN,void)<SUB>1194</SUB>> ]
+"877" [label = <(static_assert,static_assert(start &lt; sizeof(T));)<SUB>1197</SUB>> ]
+"882" [label = <(static_assert,static_assert(end &lt;= sizeof(T));)<SUB>1198</SUB>> ]
+"888" [label = <(&lt;operator&gt;.assignment,* buf = reinterpret_cast&lt;const uint8_t*&gt;(t))<SUB>1200</SUB>> ]
+"878" [label = <(&lt;operator&gt;.lessThan,start &lt; sizeof(T))<SUB>1197</SUB>> ]
+"883" [label = <(&lt;operator&gt;.lessEqualsThan,end &lt;= sizeof(T))<SUB>1198</SUB>> ]
+"890" [label = <(&lt;operator&gt;.cast,reinterpret_cast&lt;const uint8_t*&gt;(t))<SUB>1200</SUB>> ]
+"899" [label = <(&lt;operator&gt;.lessThan,i &lt; end)<SUB>1202</SUB>> ]
+"902" [label = <(&lt;operator&gt;.postIncrement,i++)<SUB>1202</SUB>> ]
+"880" [label = <(&lt;operator&gt;.sizeOf,sizeof(T))<SUB>1197</SUB>> ]
+"885" [label = <(&lt;operator&gt;.sizeOf,sizeof(T))<SUB>1198</SUB>> ]
+"891" [label = <(UNKNOWN,const uint8_t*,const uint8_t*)<SUB>1200</SUB>> ]
+"896" [label = <(&lt;operator&gt;.assignment,i = start)<SUB>1202</SUB>> ]
+"905" [label = <(&lt;operator&gt;.shiftLeft,EXPECT_EQ(byte, buf[i]) &lt;&lt; i)<SUB>1203</SUB>> ]
+"906" [label = <(EXPECT_EQ,EXPECT_EQ(byte, buf[i]))<SUB>1203</SUB>> ]
+"908" [label = <(&lt;operator&gt;.indirectIndexAccess,buf[i])<SUB>1203</SUB>> ]
+"873" [label = <(METHOD,expectRangeEqual)<SUB>1196</SUB>> ]
+"912" [label = <(METHOD_RETURN,void)<SUB>1196</SUB>> ]
   "877" -> "885" 
   "882" -> "891" 
   "888" -> "896" 
diff -bur /home/mrt3acher/thesis-implementation/.avuln-workdir/code/CVE-2021-0394_12/secure/out/23-cfg.dot /home/mrt3acher/thesis-implementation/.avuln-workdir/code/CVE-2021-0394_12/vulnerable/out/23-cfg.dot
--- /home/mrt3acher/thesis-implementation/.avuln-workdir/code/CVE-2021-0394_12/secure/out/23-cfg.dot	2023-06-07 19:34:12.197391793 +0330
+++ /home/mrt3acher/thesis-implementation/.avuln-workdir/code/CVE-2021-0394_12/vulnerable/out/23-cfg.dot	2023-06-07 19:34:15.787391437 +0330
@@ -1,79 +1,79 @@
 digraph "main" {  
-"919" [label = <(setenv,setenv(&quot;TREBLE_TESTING_OVERRIDE&quot;, &quot;true&quot;, true))<SUB>1229</SUB>> ]
-"924" [label = <(&lt;operator&gt;.assignment,*me = argv[0])<SUB>1233</SUB>> ]
-"930" [label = <(&lt;operator&gt;.assignment,wantClient = false)<SUB>1235</SUB>> ]
-"934" [label = <(&lt;operator&gt;.assignment,wantServer = false)<SUB>1236</SUB>> ]
-"1014" [label = <(configureRpcThreadpool,configureRpcThreadpool(1, true))<SUB>1277</SUB>> ]
-"1017" [label = <(&lt;operator&gt;.assignment,status = registerPassthroughServiceImplementation&lt;IBaz&gt;())<SUB>1279</SUB>> ]
-"1020" [label = <(&lt;operator&gt;.shiftLeft,CHECK(status == ::android::OK) &lt;&lt; &quot;IBaz didn't register&quot;)<SUB>1280</SUB>> ]
-"1028" [label = <(&lt;operator&gt;.assignment,status = registerPassthroughServiceImplementation&lt;ISafeUnion&gt;())<SUB>1282</SUB>> ]
-"1031" [label = <(&lt;operator&gt;.shiftLeft,CHECK(status == ::android::OK) &lt;&lt; &quot;ISafeUnion didn't register&quot;)<SUB>1283</SUB>> ]
-"1039" [label = <(&lt;operator&gt;.assignment,sp&lt;IOtherInterface&gt; otherInterface = new OtherInterface())<SUB>1285</SUB>> ]
-"1047" [label = <(&lt;operator&gt;.assignment,status = otherInterface-&gt;registerAsService())<SUB>1286</SUB>> ]
-"1053" [label = <(&lt;operator&gt;.shiftLeft,CHECK(status == ::android::OK) &lt;&lt; &quot;IOtherInterface didn't register&quot;)<SUB>1287</SUB>> ]
-"1061" [label = <(&lt;operator&gt;.assignment,sp&lt;IMemoryInterface&gt; memoryInterface = new MemoryInterface())<SUB>1289</SUB>> ]
-"1069" [label = <(&lt;operator&gt;.assignment,status = memoryInterface-&gt;registerAsService())<SUB>1290</SUB>> ]
-"1075" [label = <(&lt;operator&gt;.shiftLeft,CHECK(status == ::android::OK) &lt;&lt; &quot;IMemoryInterface didn't register&quot;)<SUB>1291</SUB>> ]
-"1083" [label = <(joinRpcThreadpool,joinRpcThreadpool())<SUB>1293</SUB>> ]
-"1084" [label = <(RETURN,return 0;,return 0;)<SUB>1294</SUB>> ]
-"926" [label = <(&lt;operator&gt;.indirectIndexAccess,argv[0])<SUB>1233</SUB>> ]
-"939" [label = <(&lt;operator&gt;.greaterEqualsThan,(res = getopt(argc, argv, &quot;chs&quot;)) &gt;= 0)<SUB>1239</SUB>> ]
-"977" [label = <(&lt;operator&gt;.logicalOr,(!wantClient &amp;&amp; !wantServer) || (wantClient &amp;&amp; wantServer))<SUB>1264</SUB>> ]
-"1019" [label = <(registerPassthroughServiceImplementation&lt;IBaz&gt;,registerPassthroughServiceImplementation&lt;IBaz&gt;())<SUB>1279</SUB>> ]
-"1021" [label = <(CHECK,CHECK(status == ::android::OK))<SUB>1280</SUB>> ]
-"1030" [label = <(registerPassthroughServiceImplementation&lt;ISafeUnion&gt;,registerPassthroughServiceImplementation&lt;ISafeUnion&gt;())<SUB>1282</SUB>> ]
-"1032" [label = <(CHECK,CHECK(status == ::android::OK))<SUB>1283</SUB>> ]
-"1040" [label = <(&lt;operator&gt;.greaterThan,sp&lt;IOtherInterface&gt; otherInterface)<SUB>1285</SUB>> ]
-"1045" [label = <(&lt;operator&gt;.new,new OtherInterface())<SUB>1285</SUB>> ]
-"1049" [label = <(registerAsService,otherInterface-&gt;registerAsService())<SUB>1286</SUB>> ]
-"1054" [label = <(CHECK,CHECK(status == ::android::OK))<SUB>1287</SUB>> ]
-"1062" [label = <(&lt;operator&gt;.greaterThan,sp&lt;IMemoryInterface&gt; memoryInterface)<SUB>1289</SUB>> ]
-"1067" [label = <(&lt;operator&gt;.new,new MemoryInterface())<SUB>1289</SUB>> ]
-"1071" [label = <(registerAsService,memoryInterface-&gt;registerAsService())<SUB>1290</SUB>> ]
-"1076" [label = <(CHECK,CHECK(status == ::android::OK))<SUB>1291</SUB>> ]
-"940" [label = <(&lt;operator&gt;.assignment,res = getopt(argc, argv, &quot;chs&quot;))<SUB>1239</SUB>> ]
-"978" [label = <(&lt;operator&gt;.logicalAnd,!wantClient &amp;&amp; !wantServer)<SUB>1264</SUB>> ]
-"983" [label = <(&lt;operator&gt;.logicalAnd,wantClient &amp;&amp; wantServer)<SUB>1264</SUB>> ]
-"987" [label = <(usage,usage(me))<SUB>1265</SUB>> ]
-"989" [label = <(exit,exit(1))<SUB>1266</SUB>> ]
-"994" [label = <(::testing::AddGlobalTestEnvironment,::testing::AddGlobalTestEnvironment(new HidlEnvironment))<SUB>1270</SUB>> ]
-"1000" [label = <(::testing::InitGoogleTest,::testing::InitGoogleTest(&amp;argc, argv))<SUB>1271</SUB>> ]
-"1008" [label = <(&lt;operator&gt;.assignment,status = RUN_ALL_TESTS())<SUB>1272</SUB>> ]
-"1011" [label = <(RETURN,return status;,return status;)<SUB>1273</SUB>> ]
-"1022" [label = <(&lt;operator&gt;.equals,status == ::android::OK)<SUB>1280</SUB>> ]
-"1033" [label = <(&lt;operator&gt;.equals,status == ::android::OK)<SUB>1283</SUB>> ]
-"1041" [label = <(&lt;operator&gt;.lessThan,sp&lt;IOtherInterface)<SUB>1285</SUB>> ]
-"1050" [label = <(&lt;operator&gt;.indirectFieldAccess,otherInterface-&gt;registerAsService)<SUB>1286</SUB>> ]
-"1055" [label = <(&lt;operator&gt;.equals,status == ::android::OK)<SUB>1287</SUB>> ]
-"1063" [label = <(&lt;operator&gt;.lessThan,sp&lt;IMemoryInterface)<SUB>1289</SUB>> ]
-"1072" [label = <(&lt;operator&gt;.indirectFieldAccess,memoryInterface-&gt;registerAsService)<SUB>1290</SUB>> ]
-"1077" [label = <(&lt;operator&gt;.equals,status == ::android::OK)<SUB>1291</SUB>> ]
-"942" [label = <(getopt,getopt(argc, argv, &quot;chs&quot;))<SUB>1239</SUB>> ]
-"979" [label = <(&lt;operator&gt;.logicalNot,!wantClient)<SUB>1264</SUB>> ]
-"981" [label = <(&lt;operator&gt;.logicalNot,!wantServer)<SUB>1264</SUB>> ]
-"995" [label = <(&lt;operator&gt;.fieldAccess,::testing::AddGlobalTestEnvironment)<SUB>1270</SUB>> ]
-"998" [label = <(&lt;operator&gt;.new,new HidlEnvironment)<SUB>1270</SUB>> ]
-"1001" [label = <(&lt;operator&gt;.fieldAccess,::testing::InitGoogleTest)<SUB>1271</SUB>> ]
-"1004" [label = <(&lt;operator&gt;.addressOf,&amp;argc)<SUB>1271</SUB>> ]
-"1010" [label = <(RUN_ALL_TESTS,RUN_ALL_TESTS())<SUB>1272</SUB>> ]
-"1024" [label = <(&lt;operator&gt;.fieldAccess,::android::OK)<SUB>1280</SUB>> ]
-"1035" [label = <(&lt;operator&gt;.fieldAccess,::android::OK)<SUB>1283</SUB>> ]
-"1052" [label = <(FIELD_IDENTIFIER,registerAsService,registerAsService)<SUB>1286</SUB>> ]
-"1057" [label = <(&lt;operator&gt;.fieldAccess,::android::OK)<SUB>1287</SUB>> ]
-"1074" [label = <(FIELD_IDENTIFIER,registerAsService,registerAsService)<SUB>1290</SUB>> ]
-"1079" [label = <(&lt;operator&gt;.fieldAccess,::android::OK)<SUB>1291</SUB>> ]
-"997" [label = <(FIELD_IDENTIFIER,AddGlobalTestEnvironment,AddGlobalTestEnvironment)<SUB>1270</SUB>> ]
-"1003" [label = <(FIELD_IDENTIFIER,InitGoogleTest,InitGoogleTest)<SUB>1271</SUB>> ]
-"1026" [label = <(FIELD_IDENTIFIER,OK,OK)<SUB>1280</SUB>> ]
-"1037" [label = <(FIELD_IDENTIFIER,OK,OK)<SUB>1283</SUB>> ]
-"1059" [label = <(FIELD_IDENTIFIER,OK,OK)<SUB>1287</SUB>> ]
-"1081" [label = <(FIELD_IDENTIFIER,OK,OK)<SUB>1291</SUB>> ]
-"954" [label = <(&lt;operator&gt;.assignment,wantClient = true)<SUB>1243</SUB>> ]
-"961" [label = <(&lt;operator&gt;.assignment,wantServer = true)<SUB>1249</SUB>> ]
-"971" [label = <(usage,usage(me))<SUB>1257</SUB>> ]
-"973" [label = <(exit,exit(1))<SUB>1258</SUB>> ]
-"915" [label = <(METHOD,main)<SUB>1228</SUB>> ]
-"1086" [label = <(METHOD_RETURN,int)<SUB>1228</SUB>> ]
+"919" [label = <(setenv,setenv(&quot;TREBLE_TESTING_OVERRIDE&quot;, &quot;true&quot;, true))<SUB>1231</SUB>> ]
+"924" [label = <(&lt;operator&gt;.assignment,*me = argv[0])<SUB>1235</SUB>> ]
+"930" [label = <(&lt;operator&gt;.assignment,wantClient = false)<SUB>1237</SUB>> ]
+"934" [label = <(&lt;operator&gt;.assignment,wantServer = false)<SUB>1238</SUB>> ]
+"1014" [label = <(configureRpcThreadpool,configureRpcThreadpool(1, true))<SUB>1279</SUB>> ]
+"1017" [label = <(&lt;operator&gt;.assignment,status = registerPassthroughServiceImplementation&lt;IBaz&gt;())<SUB>1281</SUB>> ]
+"1020" [label = <(&lt;operator&gt;.shiftLeft,CHECK(status == ::android::OK) &lt;&lt; &quot;IBaz didn't register&quot;)<SUB>1282</SUB>> ]
+"1028" [label = <(&lt;operator&gt;.assignment,status = registerPassthroughServiceImplementation&lt;ISafeUnion&gt;())<SUB>1284</SUB>> ]
+"1031" [label = <(&lt;operator&gt;.shiftLeft,CHECK(status == ::android::OK) &lt;&lt; &quot;ISafeUnion didn't register&quot;)<SUB>1285</SUB>> ]
+"1039" [label = <(&lt;operator&gt;.assignment,sp&lt;IOtherInterface&gt; otherInterface = new OtherInterface())<SUB>1287</SUB>> ]
+"1047" [label = <(&lt;operator&gt;.assignment,status = otherInterface-&gt;registerAsService())<SUB>1288</SUB>> ]
+"1053" [label = <(&lt;operator&gt;.shiftLeft,CHECK(status == ::android::OK) &lt;&lt; &quot;IOtherInterface didn't register&quot;)<SUB>1289</SUB>> ]
+"1061" [label = <(&lt;operator&gt;.assignment,sp&lt;IMemoryInterface&gt; memoryInterface = new MemoryInterface())<SUB>1291</SUB>> ]
+"1069" [label = <(&lt;operator&gt;.assignment,status = memoryInterface-&gt;registerAsService())<SUB>1292</SUB>> ]
+"1075" [label = <(&lt;operator&gt;.shiftLeft,CHECK(status == ::android::OK) &lt;&lt; &quot;IMemoryInterface didn't register&quot;)<SUB>1293</SUB>> ]
+"1083" [label = <(joinRpcThreadpool,joinRpcThreadpool())<SUB>1295</SUB>> ]
+"1084" [label = <(RETURN,return 0;,return 0;)<SUB>1296</SUB>> ]
+"926" [label = <(&lt;operator&gt;.indirectIndexAccess,argv[0])<SUB>1235</SUB>> ]
+"939" [label = <(&lt;operator&gt;.greaterEqualsThan,(res = getopt(argc, argv, &quot;chs&quot;)) &gt;= 0)<SUB>1241</SUB>> ]
+"977" [label = <(&lt;operator&gt;.logicalOr,(!wantClient &amp;&amp; !wantServer) || (wantClient &amp;&amp; wantServer))<SUB>1266</SUB>> ]
+"1019" [label = <(registerPassthroughServiceImplementation&lt;IBaz&gt;,registerPassthroughServiceImplementation&lt;IBaz&gt;())<SUB>1281</SUB>> ]
+"1021" [label = <(CHECK,CHECK(status == ::android::OK))<SUB>1282</SUB>> ]
+"1030" [label = <(registerPassthroughServiceImplementation&lt;ISafeUnion&gt;,registerPassthroughServiceImplementation&lt;ISafeUnion&gt;())<SUB>1284</SUB>> ]
+"1032" [label = <(CHECK,CHECK(status == ::android::OK))<SUB>1285</SUB>> ]
+"1040" [label = <(&lt;operator&gt;.greaterThan,sp&lt;IOtherInterface&gt; otherInterface)<SUB>1287</SUB>> ]
+"1045" [label = <(&lt;operator&gt;.new,new OtherInterface())<SUB>1287</SUB>> ]
+"1049" [label = <(registerAsService,otherInterface-&gt;registerAsService())<SUB>1288</SUB>> ]
+"1054" [label = <(CHECK,CHECK(status == ::android::OK))<SUB>1289</SUB>> ]
+"1062" [label = <(&lt;operator&gt;.greaterThan,sp&lt;IMemoryInterface&gt; memoryInterface)<SUB>1291</SUB>> ]
+"1067" [label = <(&lt;operator&gt;.new,new MemoryInterface())<SUB>1291</SUB>> ]
+"1071" [label = <(registerAsService,memoryInterface-&gt;registerAsService())<SUB>1292</SUB>> ]
+"1076" [label = <(CHECK,CHECK(status == ::android::OK))<SUB>1293</SUB>> ]
+"940" [label = <(&lt;operator&gt;.assignment,res = getopt(argc, argv, &quot;chs&quot;))<SUB>1241</SUB>> ]
+"978" [label = <(&lt;operator&gt;.logicalAnd,!wantClient &amp;&amp; !wantServer)<SUB>1266</SUB>> ]
+"983" [label = <(&lt;operator&gt;.logicalAnd,wantClient &amp;&amp; wantServer)<SUB>1266</SUB>> ]
+"987" [label = <(usage,usage(me))<SUB>1267</SUB>> ]
+"989" [label = <(exit,exit(1))<SUB>1268</SUB>> ]
+"994" [label = <(::testing::AddGlobalTestEnvironment,::testing::AddGlobalTestEnvironment(new HidlEnvironment))<SUB>1272</SUB>> ]
+"1000" [label = <(::testing::InitGoogleTest,::testing::InitGoogleTest(&amp;argc, argv))<SUB>1273</SUB>> ]
+"1008" [label = <(&lt;operator&gt;.assignment,status = RUN_ALL_TESTS())<SUB>1274</SUB>> ]
+"1011" [label = <(RETURN,return status;,return status;)<SUB>1275</SUB>> ]
+"1022" [label = <(&lt;operator&gt;.equals,status == ::android::OK)<SUB>1282</SUB>> ]
+"1033" [label = <(&lt;operator&gt;.equals,status == ::android::OK)<SUB>1285</SUB>> ]
+"1041" [label = <(&lt;operator&gt;.lessThan,sp&lt;IOtherInterface)<SUB>1287</SUB>> ]
+"1050" [label = <(&lt;operator&gt;.indirectFieldAccess,otherInterface-&gt;registerAsService)<SUB>1288</SUB>> ]
+"1055" [label = <(&lt;operator&gt;.equals,status == ::android::OK)<SUB>1289</SUB>> ]
+"1063" [label = <(&lt;operator&gt;.lessThan,sp&lt;IMemoryInterface)<SUB>1291</SUB>> ]
+"1072" [label = <(&lt;operator&gt;.indirectFieldAccess,memoryInterface-&gt;registerAsService)<SUB>1292</SUB>> ]
+"1077" [label = <(&lt;operator&gt;.equals,status == ::android::OK)<SUB>1293</SUB>> ]
+"942" [label = <(getopt,getopt(argc, argv, &quot;chs&quot;))<SUB>1241</SUB>> ]
+"979" [label = <(&lt;operator&gt;.logicalNot,!wantClient)<SUB>1266</SUB>> ]
+"981" [label = <(&lt;operator&gt;.logicalNot,!wantServer)<SUB>1266</SUB>> ]
+"995" [label = <(&lt;operator&gt;.fieldAccess,::testing::AddGlobalTestEnvironment)<SUB>1272</SUB>> ]
+"998" [label = <(&lt;operator&gt;.new,new HidlEnvironment)<SUB>1272</SUB>> ]
+"1001" [label = <(&lt;operator&gt;.fieldAccess,::testing::InitGoogleTest)<SUB>1273</SUB>> ]
+"1004" [label = <(&lt;operator&gt;.addressOf,&amp;argc)<SUB>1273</SUB>> ]
+"1010" [label = <(RUN_ALL_TESTS,RUN_ALL_TESTS())<SUB>1274</SUB>> ]
+"1024" [label = <(&lt;operator&gt;.fieldAccess,::android::OK)<SUB>1282</SUB>> ]
+"1035" [label = <(&lt;operator&gt;.fieldAccess,::android::OK)<SUB>1285</SUB>> ]
+"1052" [label = <(FIELD_IDENTIFIER,registerAsService,registerAsService)<SUB>1288</SUB>> ]
+"1057" [label = <(&lt;operator&gt;.fieldAccess,::android::OK)<SUB>1289</SUB>> ]
+"1074" [label = <(FIELD_IDENTIFIER,registerAsService,registerAsService)<SUB>1292</SUB>> ]
+"1079" [label = <(&lt;operator&gt;.fieldAccess,::android::OK)<SUB>1293</SUB>> ]
+"997" [label = <(FIELD_IDENTIFIER,AddGlobalTestEnvironment,AddGlobalTestEnvironment)<SUB>1272</SUB>> ]
+"1003" [label = <(FIELD_IDENTIFIER,InitGoogleTest,InitGoogleTest)<SUB>1273</SUB>> ]
+"1026" [label = <(FIELD_IDENTIFIER,OK,OK)<SUB>1282</SUB>> ]
+"1037" [label = <(FIELD_IDENTIFIER,OK,OK)<SUB>1285</SUB>> ]
+"1059" [label = <(FIELD_IDENTIFIER,OK,OK)<SUB>1289</SUB>> ]
+"1081" [label = <(FIELD_IDENTIFIER,OK,OK)<SUB>1293</SUB>> ]
+"954" [label = <(&lt;operator&gt;.assignment,wantClient = true)<SUB>1245</SUB>> ]
+"961" [label = <(&lt;operator&gt;.assignment,wantServer = true)<SUB>1251</SUB>> ]
+"971" [label = <(usage,usage(me))<SUB>1259</SUB>> ]
+"973" [label = <(exit,exit(1))<SUB>1260</SUB>> ]
+"915" [label = <(METHOD,main)<SUB>1230</SUB>> ]
+"1086" [label = <(METHOD_RETURN,int)<SUB>1230</SUB>> ]
   "919" -> "926" 
   "924" -> "930" 
   "930" -> "934" 
diff -bur /home/mrt3acher/thesis-implementation/.avuln-workdir/code/CVE-2021-0394_12/secure/out/3-cfg.dot /home/mrt3acher/thesis-implementation/.avuln-workdir/code/CVE-2021-0394_12/vulnerable/out/3-cfg.dot
--- /home/mrt3acher/thesis-implementation/.avuln-workdir/code/CVE-2021-0394_12/secure/out/3-cfg.dot	2023-06-07 19:34:12.147391799 +0330
+++ /home/mrt3acher/thesis-implementation/.avuln-workdir/code/CVE-2021-0394_12/vulnerable/out/3-cfg.dot	2023-06-07 19:34:15.727391445 +0330
@@ -2,48 +2,48 @@
 "641" [label = <(UNKNOWN,TEST_F(HidlTest, GetDescriptorTest) {\012    EXPECT_OK(baz-&gt;interfaceDescriptor([&amp;] (const auto &amp;desc) {\012        EXPECT_EQ(desc, IBaz::descriptor);\012 }));\012},TEST_F(HidlTest, GetDescriptorTest) {\012    EXPECT_OK(baz-&gt;interfaceDescriptor([&amp;] (const auto &amp;desc) {\012        EXPECT_EQ(desc, IBaz::descriptor);\012 }));\012})<SUB>263</SUB>> ]
 "642" [label = <(UNKNOWN,TEST_F(HidlTest, BazSomeBaseMethodTest) {\012    EXPECT_OK(baz-&gt;someBaseMethod());\012},TEST_F(HidlTest, BazSomeBaseMethodTest) {\012    EXPECT_OK(baz-&gt;someBaseMethod());\012})<SUB>269</SUB>> ]
 "643" [label = <(UNKNOWN,TEST_F(HidlTest, BazSomeOtherBaseMethodTest) {\012 IBase::Foo foo;\012    foo.x = 1;\012    foo.y.z = 2.5;\012 // A valid UTF-8 string\012    foo.y.s = &quot;Hello, world, \x46\x6F\x6F\x20\xC2\xA9\x20\x62\x61\x72\x20\xF0\x9D\x8C\x86\x20\x54\x72\x65\x62\x6C\x65\x20\xE2\x98\x83\x20\x72\x6F\x63\x6B\x73&quot;;\012\012    foo.aaa.resize(5);\012 for (size_t i = 0; i &lt; foo.aaa.size(); ++i) {\012        foo.aaa[i].z = 1.0f + (float)i * 0.01f;\012        foo.aaa[i].s = (&quot;Hello, world &quot; + std::to_string(i)).c_str();\012 }\012\012    EXPECT_OK(\012            baz-&gt;someOtherBaseMethod(\012                foo,\012 [&amp;](const auto &amp;result) {\012 // Strings should have the same size as they did before\012 // marshaling. b/35038064\012                    EXPECT_EQ(result.y.s.size(), foo.y.s.size());\012                    EXPECT_EQ(foo, result);\012 }));\012},TEST_F(HidlTest, BazSomeOtherBaseMethodTest) {\012 IBase::Foo foo;\012    foo.x = 1;\012    foo.y.z = 2.5;\012 // A valid UTF-8 string\012    foo.y.s = &quot;Hello, world, \x46\x6F\x6F\x20\xC2\xA9\x20\x62\x61\x72\x20\xF0\x9D\x8C\x86\x20\x54\x72\x65\x62\x6C\x65\x20\xE2\x98\x83\x20\x72\x6F\x63\x6B\x73&quot;;\012\012    foo.aaa.resize(5);\012 for (size_t i = 0; i &lt; foo.aaa.size(); ++i) {\012        foo.aaa[i].z = 1.0f + (float)i * 0.01f;\012        foo.aaa[i].s = (&quot;Hello, world &quot; + std::to_string(i)).c_str();\012 }\012\012    EXPECT_OK(\012            baz-&gt;someOtherBaseMethod(\012                foo,\012 [&amp;](const auto &amp;result) {\012 // Strings should have the same size as they did before\012 // marshaling. b/35038064\012                    EXPECT_EQ(result.y.s.size(), foo.y.s.size());\012                    EXPECT_EQ(foo, result);\012 }));\012})<SUB>273</SUB>> ]
-"644" [label = <(UNKNOWN,TEST_F(HidlTest, SomeOtherBaseMethodInvalidString) {\012 IBase::Foo foo {\012 .y = {\012 .s = &quot;\xff&quot;,\012 }\012 };\012\012 auto ret = baz-&gt;someOtherBaseMethod(foo, [](const IBase::Foo&amp; ret) {\012        EXPECT_EQ(ret.y.s, &quot;?&quot;); // :)\012 });\012\012    EXPECT_TRUE(ret.isOk());\012},TEST_F(HidlTest, SomeOtherBaseMethodInvalidString) {\012 IBase::Foo foo {\012 .y = {\012 .s = &quot;\xff&quot;,\012 }\012 };\012\012 auto ret = baz-&gt;someOtherBaseMethod(foo, [](const IBase::Foo&amp; ret) {\012        EXPECT_EQ(ret.y.s, &quot;?&quot;); // :)\012 });\012\012    EXPECT_TRUE(ret.isOk());\012})<SUB>297</SUB>> ]
-"645" [label = <(UNKNOWN,TEST_F(HidlTest, BazSomeMethodWithFooArraysTest) {\012    hidl_array&lt;IBase::Foo, 2&gt; foo;\012\012    foo[0].x = 1;\012    foo[0].y.z = 2.5;\012    foo[0].y.s = &quot;Hello, world&quot;;\012\012    foo[0].aaa.resize(5);\012 for (size_t i = 0; i &lt; foo[0].aaa.size(); ++i) {\012        foo[0].aaa[i].z = 1.0f + (float)i * 0.01f;\012        foo[0].aaa[i].s = (&quot;Hello, world &quot; + std::to_string(i)).c_str();\012 }\012\012    foo[1].x = 2;\012    foo[1].y.z = -2.5;\012    foo[1].y.s = &quot;Morituri te salutant&quot;;\012\012    foo[1].aaa.resize(3);\012 for (size_t i = 0; i &lt; foo[1].aaa.size(); ++i) {\012        foo[1].aaa[i].z = 2.0f - (float)i * 0.01f;\012        foo[1].aaa[i].s = (&quot;Alea iacta est: &quot; + std::to_string(i)).c_str();\012 }\012\012    hidl_array&lt;IBaz::Foo, 2&gt; fooExpectedOutput;\012    fooExpectedOutput[0] = foo[1];\012    fooExpectedOutput[1] = foo[0];\012\012    EXPECT_OK(\012            baz-&gt;someMethodWithFooArrays(\012                foo,\012 [&amp;](const auto &amp;result) {\012                    EXPECT_EQ(result, fooExpectedOutput);\012 }));\012},TEST_F(HidlTest, BazSomeMethodWithFooArraysTest) {\012    hidl_array&lt;IBase::Foo, 2&gt; foo;\012\012    foo[0].x = 1;\012    foo[0].y.z = 2.5;\012    foo[0].y.s = &quot;Hello, world&quot;;\012\012    foo[0].aaa.resize(5);\012 for (size_t i = 0; i &lt; foo[0].aaa.size(); ++i) {\012        foo[0].aaa[i].z = 1.0f + (float)i * 0.01f;\012        foo[0].aaa[i].s = (&quot;Hello, world &quot; + std::to_string(i)).c_str();\012 }\012\012    foo[1].x = 2;\012    foo[1].y.z = -2.5;\012    foo[1].y.s = &quot;Morituri te salutant&quot;;\012\012    foo[1].aaa.resize(3);\012 for (size_t i = 0; i &lt; foo[1].aaa.size(); ++i) {\012        foo[1].aaa[i].z = 2.0f - (float)i * 0.01f;\012        foo[1].aaa[i].s = (&quot;Alea iacta est: &quot; + std::to_string(i)).c_str();\012 }\012\012    hidl_array&lt;IBaz::Foo, 2&gt; fooExpectedOutput;\012    fooExpectedOutput[0] = foo[1];\012    fooExpectedOutput[1] = foo[0];\012\012    EXPECT_OK(\012            baz-&gt;someMethodWithFooArrays(\012                foo,\012 [&amp;](const auto &amp;result) {\012                    EXPECT_EQ(result, fooExpectedOutput);\012 }));\012})<SUB>311</SUB>> ]
-"646" [label = <(UNKNOWN,TEST_F(HidlTest, BazSomeMethodWithFooVectorsTest) {\012    hidl_vec&lt;IBase::Foo&gt; foo;\012    foo.resize(2);\012\012    foo[0].x = 1;\012    foo[0].y.z = 2.5;\012    foo[0].y.s = &quot;Hello, world&quot;;\012\012    foo[0].aaa.resize(5);\012 for (size_t i = 0; i &lt; foo[0].aaa.size(); ++i) {\012        foo[0].aaa[i].z = 1.0f + (float)i * 0.01f;\012        foo[0].aaa[i].s = (&quot;Hello, world &quot; + std::to_string(i)).c_str();\012 }\012\012    foo[1].x = 2;\012    foo[1].y.z = -2.5;\012    foo[1].y.s = &quot;Morituri te salutant&quot;;\012\012    foo[1].aaa.resize(3);\012 for (size_t i = 0; i &lt; foo[1].aaa.size(); ++i) {\012        foo[1].aaa[i].z = 2.0f - (float)i * 0.01f;\012        foo[1].aaa[i].s = (&quot;Alea iacta est: &quot; + std::to_string(i)).c_str();\012 }\012\012    hidl_vec&lt;IBaz::Foo&gt; fooExpectedOutput;\012    fooExpectedOutput.resize(2);\012    fooExpectedOutput[0] = foo[1];\012    fooExpectedOutput[1] = foo[0];\012\012    EXPECT_OK(\012            baz-&gt;someMethodWithFooVectors(\012                foo,\012 [&amp;](const auto &amp;result) {\012                    EXPECT_EQ(result, fooExpectedOutput);\012 }));\012},TEST_F(HidlTest, BazSomeMethodWithFooVectorsTest) {\012    hidl_vec&lt;IBase::Foo&gt; foo;\012    foo.resize(2);\012\012    foo[0].x = 1;\012    foo[0].y.z = 2.5;\012    foo[0].y.s = &quot;Hello, world&quot;;\012\012    foo[0].aaa.resize(5);\012 for (size_t i = 0; i &lt; foo[0].aaa.size(); ++i) {\012        foo[0].aaa[i].z = 1.0f + (float)i * 0.01f;\012        foo[0].aaa[i].s = (&quot;Hello, world &quot; + std::to_string(i)).c_str();\012 }\012\012    foo[1].x = 2;\012    foo[1].y.z = -2.5;\012    foo[1].y.s = &quot;Morituri te salutant&quot;;\012\012    foo[1].aaa.resize(3);\012 for (size_t i = 0; i &lt; foo[1].aaa.size(); ++i) {\012        foo[1].aaa[i].z = 2.0f - (float)i * 0.01f;\012        foo[1].aaa[i].s = (&quot;Alea iacta est: &quot; + std::to_string(i)).c_str();\012 }\012\012    hidl_vec&lt;IBaz::Foo&gt; fooExpectedOutput;\012    fooExpectedOutput.resize(2);\012    fooExpectedOutput[0] = foo[1];\012    fooExpectedOutput[1] = foo[0];\012\012    EXPECT_OK(\012            baz-&gt;someMethodWithFooVectors(\012                foo,\012 [&amp;](const auto &amp;result) {\012                    EXPECT_EQ(result, fooExpectedOutput);\012 }));\012})<SUB>346</SUB>> ]
-"647" [label = <(UNKNOWN,TEST_F(HidlTest, BazSomeMethodWithVectorOfArray) {\012 IBase::VectorOfArray in, expectedOut;\012    in.addresses.resize(3);\012    expectedOut.addresses.resize(3);\012\012 size_t k = 0;\012 const size_t n = in.addresses.size();\012\012 for (size_t i = 0; i &lt; n; ++i) {\012 for (size_t j = 0; j &lt; 6; ++j, ++k) {\012            in.addresses[i][j] = k;\012            expectedOut.addresses[n - 1 - i][j] = k;\012 }\012 }\012\012    EXPECT_OK(\012            baz-&gt;someMethodWithVectorOfArray(\012                in,\012 [&amp;](const auto &amp;out) {\012                    EXPECT_EQ(expectedOut, out);\012 }));\012},TEST_F(HidlTest, BazSomeMethodWithVectorOfArray) {\012 IBase::VectorOfArray in, expectedOut;\012    in.addresses.resize(3);\012    expectedOut.addresses.resize(3);\012\012 size_t k = 0;\012 const size_t n = in.addresses.size();\012\012 for (size_t i = 0; i &lt; n; ++i) {\012 for (size_t j = 0; j &lt; 6; ++j, ++k) {\012            in.addresses[i][j] = k;\012            expectedOut.addresses[n - 1 - i][j] = k;\012 }\012 }\012\012    EXPECT_OK(\012            baz-&gt;someMethodWithVectorOfArray(\012                in,\012 [&amp;](const auto &amp;out) {\012                    EXPECT_EQ(expectedOut, out);\012 }));\012})<SUB>383</SUB>> ]
-"648" [label = <(UNKNOWN,TEST_F(HidlTest, BazSomeMethodTakingAVectorOfArray) {\012    hidl_vec&lt;hidl_array&lt;uint8_t, 6&gt; &gt; in, expectedOut;\012    in.resize(3);\012    expectedOut.resize(3);\012\012 size_t k = 0;\012 const size_t n = in.size();\012 for (size_t i = 0; i &lt; n; ++i) {\012 for (size_t j = 0; j &lt; 6; ++j, ++k) {\012            in[i][j] = k;\012            expectedOut[n - 1 - i][j] = k;\012 }\012 }\012\012    EXPECT_OK(\012            baz-&gt;someMethodTakingAVectorOfArray(\012                in,\012 [&amp;](const auto &amp;out) {\012                    EXPECT_EQ(expectedOut, out);\012 }));\012},TEST_F(HidlTest, BazSomeMethodTakingAVectorOfArray) {\012    hidl_vec&lt;hidl_array&lt;uint8_t, 6&gt; &gt; in, expectedOut;\012    in.resize(3);\012    expectedOut.resize(3);\012\012 size_t k = 0;\012 const size_t n = in.size();\012 for (size_t i = 0; i &lt; n; ++i) {\012 for (size_t j = 0; j &lt; 6; ++j, ++k) {\012            in[i][j] = k;\012            expectedOut[n - 1 - i][j] = k;\012 }\012 }\012\012    EXPECT_OK(\012            baz-&gt;someMethodTakingAVectorOfArray(\012                in,\012 [&amp;](const auto &amp;out) {\012                    EXPECT_EQ(expectedOut, out);\012 }));\012})<SUB>406</SUB>> ]
-"763" [label = <(UNKNOWN,TEST_F(HidlTest, BazTransposeTest) {\012 IBase::StringMatrix5x3 in;\012 IBase::StringMatrix3x5 expectedOut;\012\012 for (int i = 0; i &lt; 5; ++i) {\012 for (int j = 0; j &lt; 3; ++j) {\012            in.s[i][j] = expectedOut.s[j][i] = numberToEnglish(3 * i + j + 1).c_str();\012 }\012 }\012\012    EXPECT_OK(baz-&gt;transpose(\012                in,\012 [&amp;](const auto &amp;out) {\012                    EXPECT_EQ(expectedOut, out);\012 }));\012},TEST_F(HidlTest, BazTransposeTest) {\012 IBase::StringMatrix5x3 in;\012 IBase::StringMatrix3x5 expectedOut;\012\012 for (int i = 0; i &lt; 5; ++i) {\012 for (int j = 0; j &lt; 3; ++j) {\012            in.s[i][j] = expectedOut.s[j][i] = numberToEnglish(3 * i + j + 1).c_str();\012 }\012 }\012\012    EXPECT_OK(baz-&gt;transpose(\012                in,\012 [&amp;](const auto &amp;out) {\012                    EXPECT_EQ(expectedOut, out);\012 }));\012})<SUB>474</SUB>> ]
-"764" [label = <(UNKNOWN,TEST_F(HidlTest, BazTranspose2Test) {\012    hidl_array&lt;hidl_string, 5, 3&gt; in;\012    hidl_array&lt;hidl_string, 3, 5&gt; expectedOut;\012\012 for (int i = 0; i &lt; 5; ++i) {\012 for (int j = 0; j &lt; 3; ++j) {\012            in[i][j] = expectedOut[j][i] = numberToEnglish(3 * i + j + 1).c_str();\012 }\012 }\012\012    EXPECT_OK(baz-&gt;transpose2(\012                in,\012 [&amp;](const auto &amp;out) {\012                    EXPECT_EQ(expectedOut, out);\012 }));\012},TEST_F(HidlTest, BazTranspose2Test) {\012    hidl_array&lt;hidl_string, 5, 3&gt; in;\012    hidl_array&lt;hidl_string, 3, 5&gt; expectedOut;\012\012 for (int i = 0; i &lt; 5; ++i) {\012 for (int j = 0; j &lt; 3; ++j) {\012            in[i][j] = expectedOut[j][i] = numberToEnglish(3 * i + j + 1).c_str();\012 }\012 }\012\012    EXPECT_OK(baz-&gt;transpose2(\012                in,\012 [&amp;](const auto &amp;out) {\012                    EXPECT_EQ(expectedOut, out);\012 }));\012})<SUB>491</SUB>> ]
-"765" [label = <(UNKNOWN,TEST_F(HidlTest, BazSomeBoolMethodTest) {\012 auto result = baz-&gt;someBoolMethod(true);\012    EXPECT_OK(result);\012    EXPECT_EQ(result, false);\012},TEST_F(HidlTest, BazSomeBoolMethodTest) {\012 auto result = baz-&gt;someBoolMethod(true);\012    EXPECT_OK(result);\012    EXPECT_EQ(result, false);\012})<SUB>508</SUB>> ]
-"766" [label = <(UNKNOWN,TEST_F(HidlTest, BazSomeBoolArrayMethodTest) {\012    hidl_array&lt;bool, 3&gt; someBoolArray;\012    someBoolArray[0] = true;\012    someBoolArray[1] = false;\012    someBoolArray[2] = true;\012\012    hidl_array&lt;bool, 4&gt; expectedOut;\012    expectedOut[0] = false;\012    expectedOut[1] = true;\012    expectedOut[2] = false;\012    expectedOut[3] = true;\012\012    EXPECT_OK(\012            baz-&gt;someBoolArrayMethod(\012                someBoolArray,\012 [&amp;](const auto &amp;result) {\012                    EXPECT_EQ(expectedOut, result);\012 }));\012},TEST_F(HidlTest, BazSomeBoolArrayMethodTest) {\012    hidl_array&lt;bool, 3&gt; someBoolArray;\012    someBoolArray[0] = true;\012    someBoolArray[1] = false;\012    someBoolArray[2] = true;\012\012    hidl_array&lt;bool, 4&gt; expectedOut;\012    expectedOut[0] = false;\012    expectedOut[1] = true;\012    expectedOut[2] = false;\012    expectedOut[3] = true;\012\012    EXPECT_OK(\012            baz-&gt;someBoolArrayMethod(\012                someBoolArray,\012 [&amp;](const auto &amp;result) {\012                    EXPECT_EQ(expectedOut, result);\012 }));\012})<SUB>514</SUB>> ]
-"767" [label = <(UNKNOWN,TEST_F(HidlTest, BazSomeBoolVectorMethodTest) {\012    hidl_vec&lt;bool&gt; someBoolVector, expected;\012    someBoolVector.resize(4);\012    expected.resize(4);\012\012 for (size_t i = 0; i &lt; someBoolVector.size(); ++i) {\012        someBoolVector[i] = ((i &amp; 1) == 0);\012        expected[i] = !someBoolVector[i];\012 }\012\012    EXPECT_OK(\012            baz-&gt;someBoolVectorMethod(\012                someBoolVector,\012 [&amp;](const auto &amp;result) {\012                    EXPECT_EQ(expected, result);\012 }));\012},TEST_F(HidlTest, BazSomeBoolVectorMethodTest) {\012    hidl_vec&lt;bool&gt; someBoolVector, expected;\012    someBoolVector.resize(4);\012    expected.resize(4);\012\012 for (size_t i = 0; i &lt; someBoolVector.size(); ++i) {\012        someBoolVector[i] = ((i &amp; 1) == 0);\012        expected[i] = !someBoolVector[i];\012 }\012\012    EXPECT_OK(\012            baz-&gt;someBoolVectorMethod(\012                someBoolVector,\012 [&amp;](const auto &amp;result) {\012                    EXPECT_EQ(expected, result);\012 }));\012})<SUB>534</SUB>> ]
-"768" [label = <(UNKNOWN,TEST_F(HidlTest, BazDoThisMethodTest) {\012    EXPECT_OK(baz-&gt;doThis(1.0f));\012},TEST_F(HidlTest, BazDoThisMethodTest) {\012    EXPECT_OK(baz-&gt;doThis(1.0f));\012})<SUB>552</SUB>> ]
-"769" [label = <(UNKNOWN,TEST_F(HidlTest, BazDoThatAndReturnSomethingMethodTest) {\012 auto result = baz-&gt;doThatAndReturnSomething(1);\012    EXPECT_OK(result);\012    EXPECT_EQ(result, 666);\012},TEST_F(HidlTest, BazDoThatAndReturnSomethingMethodTest) {\012 auto result = baz-&gt;doThatAndReturnSomething(1);\012    EXPECT_OK(result);\012    EXPECT_EQ(result, 666);\012})<SUB>556</SUB>> ]
-"770" [label = <(UNKNOWN,TEST_F(HidlTest, BazDoQuiteABitMethodTest) {\012 auto result = baz-&gt;doQuiteABit(1, 2LL, 3.0f, 4.0);\012\012    EXPECT_OK(result);\012    EXPECT_EQ(result, 666.5);\012},TEST_F(HidlTest, BazDoQuiteABitMethodTest) {\012 auto result = baz-&gt;doQuiteABit(1, 2LL, 3.0f, 4.0);\012\012    EXPECT_OK(result);\012    EXPECT_EQ(result, 666.5);\012})<SUB>562</SUB>> ]
-"771" [label = <(UNKNOWN,TEST_F(HidlTest, BazDoSomethingElseMethodTest) {\012    hidl_array&lt;int32_t, 15&gt; param;\012    hidl_array&lt;int32_t, 32&gt; expected;\012\012 for (size_t i = 0; i &lt; 15; ++i) {\012        param[i] = expected[15 + i] = i;\012        expected[i] = 2 * i;\012 }\012\012    expected[30] = 1;\012    expected[31] = 2;\012\012    EXPECT_OK(\012            baz-&gt;doSomethingElse(\012                param,\012 [&amp;](const auto &amp;result) {\012                    EXPECT_EQ(expected, result);\012 }));\012},TEST_F(HidlTest, BazDoSomethingElseMethodTest) {\012    hidl_array&lt;int32_t, 15&gt; param;\012    hidl_array&lt;int32_t, 32&gt; expected;\012\012 for (size_t i = 0; i &lt; 15; ++i) {\012        param[i] = expected[15 + i] = i;\012        expected[i] = 2 * i;\012 }\012\012    expected[30] = 1;\012    expected[31] = 2;\012\012    EXPECT_OK(\012            baz-&gt;doSomethingElse(\012                param,\012 [&amp;](const auto &amp;result) {\012                    EXPECT_EQ(expected, result);\012 }));\012})<SUB>569</SUB>> ]
-"772" [label = <(UNKNOWN,TEST_F(HidlTest, BazDoStuffAndReturnAStringMethodTest) {\012    std::string expected = &quot;Hello, world!&quot;;\012    EXPECT_OK(\012            baz-&gt;doStuffAndReturnAString(\012 [&amp;](const auto &amp;result) {\012                    EXPECT_EQ(expected, result);\012 }));\012},TEST_F(HidlTest, BazDoStuffAndReturnAStringMethodTest) {\012    std::string expected = &quot;Hello, world!&quot;;\012    EXPECT_OK(\012            baz-&gt;doStuffAndReturnAString(\012 [&amp;](const auto &amp;result) {\012                    EXPECT_EQ(expected, result);\012 }));\012})<SUB>589</SUB>> ]
-"773" [label = <(UNKNOWN,TEST_F(HidlTest, BazMapThisVectorMethodTest) {\012    hidl_vec&lt;int32_t&gt; vec_param, expected;\012    vec_param.resize(15);\012    expected.resize(15);\012\012 for (size_t i = 0; i &lt; 15; ++i) {\012        vec_param[i] = i;\012        expected[i] = 2 * i;\012 }\012\012    EXPECT_OK(\012            baz-&gt;mapThisVector(\012                vec_param,\012 [&amp;](const auto &amp;result) {\012                    EXPECT_EQ(expected, result);\012 }));\012},TEST_F(HidlTest, BazMapThisVectorMethodTest) {\012    hidl_vec&lt;int32_t&gt; vec_param, expected;\012    vec_param.resize(15);\012    expected.resize(15);\012\012 for (size_t i = 0; i &lt; 15; ++i) {\012        vec_param[i] = i;\012        expected[i] = 2 * i;\012 }\012\012    EXPECT_OK(\012            baz-&gt;mapThisVector(\012                vec_param,\012 [&amp;](const auto &amp;result) {\012                    EXPECT_EQ(expected, result);\012 }));\012})<SUB>598</SUB>> ]
-"774" [label = <(UNKNOWN,TEST_F(HidlTest, BazCallMeMethodTest) {\012    EXPECT_OK(baz-&gt;callMe(new BazCallback()));\012},TEST_F(HidlTest, BazCallMeMethodTest) {\012    EXPECT_OK(baz-&gt;callMe(new BazCallback()));\012})<SUB>616</SUB>> ]
-"775" [label = <(UNKNOWN,TEST_F(HidlTest, BazCallMeLaterMethodTest) {\012    EXPECT_OK(baz-&gt;callMeLater(new BazCallback()));\012    EXPECT_OK(baz-&gt;iAmFreeNow());\012},TEST_F(HidlTest, BazCallMeLaterMethodTest) {\012    EXPECT_OK(baz-&gt;callMeLater(new BazCallback()));\012    EXPECT_OK(baz-&gt;iAmFreeNow());\012})<SUB>620</SUB>> ]
-"776" [label = <(UNKNOWN,TEST_F(HidlTest, BazUseAnEnumMethodTest) {\012 auto result = baz-&gt;useAnEnum(IBaz::SomeEnum::bar);\012\012    EXPECT_OK(result);\012    EXPECT_TRUE(result == IBaz::SomeEnum::quux);\012},TEST_F(HidlTest, BazUseAnEnumMethodTest) {\012 auto result = baz-&gt;useAnEnum(IBaz::SomeEnum::bar);\012\012    EXPECT_OK(result);\012    EXPECT_TRUE(result == IBaz::SomeEnum::quux);\012})<SUB>625</SUB>> ]
-"777" [label = <(UNKNOWN,TEST_F(HidlTest, BazHaveSomeStringsMethodTest) {\012    hidl_array&lt;hidl_string, 3&gt; string_params;\012    string_params[0] = &quot;one&quot;;\012    string_params[1] = &quot;two&quot;;\012    string_params[2] = &quot;three&quot;;\012\012    hidl_array&lt;hidl_string, 2&gt; expected;\012    expected[0] = &quot;Hello&quot;;\012    expected[1] = &quot;World&quot;;\012\012    EXPECT_OK(\012            baz-&gt;haveSomeStrings(\012                string_params,\012 [&amp;](const auto &amp;result) {\012                    EXPECT_EQ(expected, result);\012 }));\012},TEST_F(HidlTest, BazHaveSomeStringsMethodTest) {\012    hidl_array&lt;hidl_string, 3&gt; string_params;\012    string_params[0] = &quot;one&quot;;\012    string_params[1] = &quot;two&quot;;\012    string_params[2] = &quot;three&quot;;\012\012    hidl_array&lt;hidl_string, 2&gt; expected;\012    expected[0] = &quot;Hello&quot;;\012    expected[1] = &quot;World&quot;;\012\012    EXPECT_OK(\012            baz-&gt;haveSomeStrings(\012                string_params,\012 [&amp;](const auto &amp;result) {\012                    EXPECT_EQ(expected, result);\012 }));\012})<SUB>632</SUB>> ]
-"778" [label = <(UNKNOWN,TEST_F(HidlTest, BazHaveAStringVecMethodTest) {\012    hidl_vec&lt;hidl_string&gt; string_vec{ &quot;Uno&quot;, &quot;Dos&quot;, &quot;Tres&quot;, &quot;Cuatro&quot; };\012    hidl_vec&lt;hidl_string&gt; expected{&quot;Hello&quot;, &quot;World&quot;};\012\012    EXPECT_OK(\012            baz-&gt;haveAStringVec(\012                string_vec,\012 [&amp;](const auto &amp;result) {\012                    EXPECT_EQ(expected, result);\012 }));\012},TEST_F(HidlTest, BazHaveAStringVecMethodTest) {\012    hidl_vec&lt;hidl_string&gt; string_vec{ &quot;Uno&quot;, &quot;Dos&quot;, &quot;Tres&quot;, &quot;Cuatro&quot; };\012    hidl_vec&lt;hidl_string&gt; expected{&quot;Hello&quot;, &quot;World&quot;};\012\012    EXPECT_OK(\012            baz-&gt;haveAStringVec(\012                string_vec,\012 [&amp;](const auto &amp;result) {\012                    EXPECT_EQ(expected, result);\012 }));\012})<SUB>650</SUB>> ]
-"779" [label = <(UNKNOWN,TEST_F(HidlTest, BazRepeatBitfieldVecTest) {\012    hidl_vec&lt;uint8_t&gt; vec{0 | IBaz::BitField::V1, 0 | IBaz::BitField::V2};\012\012    EXPECT_OK(baz-&gt;repeatBitfieldVec(vec, [&amp;](const auto&amp; result) { EXPECT_EQ(vec, result); }));\012},TEST_F(HidlTest, BazRepeatBitfieldVecTest) {\012    hidl_vec&lt;uint8_t&gt; vec{0 | IBaz::BitField::V1, 0 | IBaz::BitField::V2};\012\012    EXPECT_OK(baz-&gt;repeatBitfieldVec(vec, [&amp;](const auto&amp; result) { EXPECT_EQ(vec, result); }));\012})<SUB>662</SUB>> ]
-"780" [label = <(UNKNOWN,TEST_F(HidlTest, BazReturnABunchOfStringsMethodTest) {\012    std::string expectedA = &quot;Eins&quot;;\012    std::string expectedB = &quot;Zwei&quot;;\012    std::string expectedC = &quot;Drei&quot;;\012    EXPECT_OK(\012            baz-&gt;returnABunchOfStrings(\012 [&amp;](const auto &amp;a, const auto &amp;b, const auto &amp;c) {\012                    EXPECT_EQ(a, expectedA);\012                    EXPECT_EQ(b, expectedB);\012                    EXPECT_EQ(c, expectedC);\012 }));\012},TEST_F(HidlTest, BazReturnABunchOfStringsMethodTest) {\012    std::string expectedA = &quot;Eins&quot;;\012    std::string expectedB = &quot;Zwei&quot;;\012    std::string expectedC = &quot;Drei&quot;;\012    EXPECT_OK(\012            baz-&gt;returnABunchOfStrings(\012 [&amp;](const auto &amp;a, const auto &amp;b, const auto &amp;c) {\012                    EXPECT_EQ(a, expectedA);\012                    EXPECT_EQ(b, expectedB);\012                    EXPECT_EQ(c, expectedC);\012 }));\012})<SUB>668</SUB>> ]
-"781" [label = <(UNKNOWN,TEST_F(HidlTest, BazTestArrays) {\012 IBase::LotsOfPrimitiveArrays in;\012\012 for (size_t i = 0; i &lt; 128; ++i) {\012        in.byte1[i] = i;\012        in.boolean1[i] = (i &amp; 4) != 0;\012        in.double1[i] = i;\012 }\012\012 size_t k = 0;\012 for (size_t i = 0; i &lt; 8; ++i) {\012 for (size_t j = 0; j &lt; 128; ++j, ++k) {\012            in.byte2[i][j] = k;\012            in.boolean2[i][j] = (k &amp; 4) != 0;\012            in.double2[i][j] = k;\012 }\012 }\012\012 size_t m = 0;\012 for (size_t i = 0; i &lt; 8; ++i) {\012 for (size_t j = 0; j &lt; 16; ++j) {\012 for (size_t k = 0; k &lt; 128; ++k, ++m) {\012                in.byte3[i][j][k] = m;\012                in.boolean3[i][j][k] = (m &amp; 4) != 0;\012                in.double3[i][j][k] = m;\012 }\012 }\012 }\012\012    EXPECT_OK(\012            baz-&gt;testArrays(in,\012 [&amp;](const auto &amp;out) {\012                    EXPECT_EQ(in, out);\012 }));\012},TEST_F(HidlTest, BazTestArrays) {\012 IBase::LotsOfPrimitiveArrays in;\012\012 for (size_t i = 0; i &lt; 128; ++i) {\012        in.byte1[i] = i;\012        in.boolean1[i] = (i &amp; 4) != 0;\012        in.double1[i] = i;\012 }\012\012 size_t k = 0;\012 for (size_t i = 0; i &lt; 8; ++i) {\012 for (size_t j = 0; j &lt; 128; ++j, ++k) {\012            in.byte2[i][j] = k;\012            in.boolean2[i][j] = (k &amp; 4) != 0;\012            in.double2[i][j] = k;\012 }\012 }\012\012 size_t m = 0;\012 for (size_t i = 0; i &lt; 8; ++i) {\012 for (size_t j = 0; j &lt; 16; ++j) {\012 for (size_t k = 0; k &lt; 128; ++k, ++m) {\012                in.byte3[i][j][k] = m;\012                in.boolean3[i][j][k] = (m &amp; 4) != 0;\012                in.double3[i][j][k] = m;\012 }\012 }\012 }\012\012    EXPECT_OK(\012            baz-&gt;testArrays(in,\012 [&amp;](const auto &amp;out) {\012                    EXPECT_EQ(in, out);\012 }));\012})<SUB>681</SUB>> ]
-"782" [label = <(UNKNOWN,TEST_F(HidlTest, BazTestByteVecs) {\012    hidl_vec&lt;IBase::ByteOneDim&gt; in;\012    in.resize(8);\012\012 size_t k = 0;\012 for (size_t i = 0; i &lt; in.size(); ++i) {\012 for (size_t j = 0; j &lt; 128; ++j, ++k) {\012            in[i][j] = k;\012 }\012 }\012\012    EXPECT_OK(baz-&gt;testByteVecs(\012                in, [&amp;](const auto &amp;out) { EXPECT_EQ(in, out); }));\012},TEST_F(HidlTest, BazTestByteVecs) {\012    hidl_vec&lt;IBase::ByteOneDim&gt; in;\012    in.resize(8);\012\012 size_t k = 0;\012 for (size_t i = 0; i &lt; in.size(); ++i) {\012 for (size_t j = 0; j &lt; 128; ++j, ++k) {\012            in[i][j] = k;\012 }\012 }\012\012    EXPECT_OK(baz-&gt;testByteVecs(\012                in, [&amp;](const auto &amp;out) { EXPECT_EQ(in, out); }));\012})<SUB>717</SUB>> ]
-"783" [label = <(UNKNOWN,TEST_F(HidlTest, BazTestBooleanVecs) {\012    hidl_vec&lt;IBase::BooleanOneDim&gt; in;\012    in.resize(8);\012\012 size_t k = 0;\012 for (size_t i = 0; i &lt; in.size(); ++i) {\012 for (size_t j = 0; j &lt; 128; ++j, ++k) {\012            in[i][j] = (k &amp; 4) != 0;\012 }\012 }\012\012    EXPECT_OK(baz-&gt;testBooleanVecs(\012                in, [&amp;](const auto &amp;out) { EXPECT_EQ(in, out); }));\012},TEST_F(HidlTest, BazTestBooleanVecs) {\012    hidl_vec&lt;IBase::BooleanOneDim&gt; in;\012    in.resize(8);\012\012 size_t k = 0;\012 for (size_t i = 0; i &lt; in.size(); ++i) {\012 for (size_t j = 0; j &lt; 128; ++j, ++k) {\012            in[i][j] = (k &amp; 4) != 0;\012 }\012 }\012\012    EXPECT_OK(baz-&gt;testBooleanVecs(\012                in, [&amp;](const auto &amp;out) { EXPECT_EQ(in, out); }));\012})<SUB>732</SUB>> ]
-"784" [label = <(UNKNOWN,TEST_F(HidlTest, BazTestDoubleVecs) {\012    hidl_vec&lt;IBase::DoubleOneDim&gt; in;\012    in.resize(8);\012\012 size_t k = 0;\012 for (size_t i = 0; i &lt; in.size(); ++i) {\012 for (size_t j = 0; j &lt; 128; ++j, ++k) {\012            in[i][j] = k;\012 }\012 }\012\012    EXPECT_OK(baz-&gt;testDoubleVecs(\012                in, [&amp;](const auto &amp;out) { EXPECT_EQ(in, out); }));\012},TEST_F(HidlTest, BazTestDoubleVecs) {\012    hidl_vec&lt;IBase::DoubleOneDim&gt; in;\012    in.resize(8);\012\012 size_t k = 0;\012 for (size_t i = 0; i &lt; in.size(); ++i) {\012 for (size_t j = 0; j &lt; 128; ++j, ++k) {\012            in[i][j] = k;\012 }\012 }\012\012    EXPECT_OK(baz-&gt;testDoubleVecs(\012                in, [&amp;](const auto &amp;out) { EXPECT_EQ(in, out); }));\012})<SUB>747</SUB>> ]
-"785" [label = <(UNKNOWN,TEST_F(HidlTest, TwowayMethodOnewayEnabledTest) {\012 using ::android::hardware::IBinder;\012 using ::android::hardware::Parcel;\012\012    sp&lt;IBinder&gt; binder = ::android::hardware::toBinder(baz);\012\012 Parcel request, reply;\012    EXPECT_EQ(::android::OK, request.writeInterfaceToken(IBaz::descriptor));\012    EXPECT_EQ(::android::OK, request.writeInt64(1234));\012 // IBaz::doThatAndReturnSomething is two-way but we call it using FLAG_ONEWAY.\012    EXPECT_EQ(::android::OK, binder-&gt;transact(18 /*doThatAndReturnSomething*/, request, &amp;reply,\012 IBinder::FLAG_ONEWAY));\012\012 ::android::hardware::Status status;\012    EXPECT_EQ(::android::NOT_ENOUGH_DATA, ::android::hardware::readFromParcel(&amp;status, reply));\012    EXPECT_EQ(::android::hardware::Status::EX_TRANSACTION_FAILED, status.exceptionCode());\012\012    EXPECT_OK(baz-&gt;ping()); // still works\012},TEST_F(HidlTest, TwowayMethodOnewayEnabledTest) {\012 using ::android::hardware::IBinder;\012 using ::android::hardware::Parcel;\012\012    sp&lt;IBinder&gt; binder = ::android::hardware::toBinder(baz);\012\012 Parcel request, reply;\012    EXPECT_EQ(::android::OK, request.writeInterfaceToken(IBaz::descriptor));\012    EXPECT_EQ(::android::OK, request.writeInt64(1234));\012 // IBaz::doThatAndReturnSomething is two-way but we call it using FLAG_ONEWAY.\012    EXPECT_EQ(::android::OK, binder-&gt;transact(18 /*doThatAndReturnSomething*/, request, &amp;reply,\012 IBinder::FLAG_ONEWAY));\012\012 ::android::hardware::Status status;\012    EXPECT_EQ(::android::NOT_ENOUGH_DATA, ::android::hardware::readFromParcel(&amp;status, reply));\012    EXPECT_EQ(::android::hardware::Status::EX_TRANSACTION_FAILED, status.exceptionCode());\012\012    EXPECT_OK(baz-&gt;ping()); // still works\012})<SUB>762</SUB>> ]
-"786" [label = <(UNKNOWN,TEST_F(HidlTest, OnewayMethodOnewayDisabledTest) {\012 using ::android::hardware::IBinder;\012 using ::android::hardware::Parcel;\012\012    sp&lt;IBinder&gt; binder = ::android::hardware::toBinder(baz);\012\012 Parcel request, reply;\012    EXPECT_EQ(::android::OK, request.writeInterfaceToken(IBaz::descriptor));\012    EXPECT_EQ(::android::OK, request.writeFloat(1.0f));\012 // IBaz::doThis is oneway but we call it without using FLAG_ONEWAY.\012    EXPECT_EQ(\012 // Expect UNKNOWN_ERROR because the JNI class JHwBinder always sets\012 // the reply to UNKNOWN_ERROR for two-way transactions if the\012 // transaction itself did not send a reply.\012 ::android::UNKNOWN_ERROR,\012            binder-&gt;transact(17 /*doThis*/, request, &amp;reply, 0 /* Not FLAG_ONEWAY */));\012\012    EXPECT_OK(baz-&gt;ping()); // still works\012},TEST_F(HidlTest, OnewayMethodOnewayDisabledTest) {\012 using ::android::hardware::IBinder;\012 using ::android::hardware::Parcel;\012\012    sp&lt;IBinder&gt; binder = ::android::hardware::toBinder(baz);\012\012 Parcel request, reply;\012    EXPECT_EQ(::android::OK, request.writeInterfaceToken(IBaz::descriptor));\012    EXPECT_EQ(::android::OK, request.writeFloat(1.0f));\012 // IBaz::doThis is oneway but we call it without using FLAG_ONEWAY.\012    EXPECT_EQ(\012 // Expect UNKNOWN_ERROR because the JNI class JHwBinder always sets\012 // the reply to UNKNOWN_ERROR for two-way transactions if the\012 // transaction itself did not send a reply.\012 ::android::UNKNOWN_ERROR,\012            binder-&gt;transact(17 /*doThis*/, request, &amp;reply, 0 /* Not FLAG_ONEWAY */));\012\012    EXPECT_OK(baz-&gt;ping()); // still works\012})<SUB>782</SUB>> ]
-"787" [label = <(UNKNOWN,TEST_F(HidlTest, SafeUnionNoInitTest) {\012    EXPECT_OK(safeunionInterface-&gt;newLargeSafeUnion([&amp;](const LargeSafeUnion&amp; safeUnion) {\012        EXPECT_EQ(LargeSafeUnion::hidl_discriminator::noinit, safeUnion.getDiscriminator());\012 }));\012},TEST_F(HidlTest, SafeUnionNoInitTest) {\012    EXPECT_OK(safeunionInterface-&gt;newLargeSafeUnion([&amp;](const LargeSafeUnion&amp; safeUnion) {\012        EXPECT_EQ(LargeSafeUnion::hidl_discriminator::noinit, safeUnion.getDiscriminator());\012 }));\012})<SUB>802</SUB>> ]
-"788" [label = <(UNKNOWN,TEST_F(HidlTest, SafeUnionSimpleTest) {\012    EXPECT_OK(safeunionInterface-&gt;newLargeSafeUnion([&amp;](const LargeSafeUnion&amp; safeUnion) {\012        EXPECT_OK(safeunionInterface-&gt;setA(safeUnion, -5, [&amp;](const LargeSafeUnion&amp; safeUnion) {\012            EXPECT_EQ(LargeSafeUnion::hidl_discriminator::a, safeUnion.getDiscriminator());\012            EXPECT_EQ(-5, safeUnion.a());\012\012 uint64_t max = std::numeric_limits&lt;uint64_t&gt;::max();\012            EXPECT_OK(\012                safeunionInterface-&gt;setD(safeUnion, max, [&amp;](const LargeSafeUnion&amp; safeUnion) {\012                    EXPECT_EQ(LargeSafeUnion::hidl_discriminator::d, safeUnion.getDiscriminator());\012                    EXPECT_EQ(max, safeUnion.d());\012 }));\012 }));\012 }));\012},TEST_F(HidlTest, SafeUnionSimpleTest) {\012    EXPECT_OK(safeunionInterface-&gt;newLargeSafeUnion([&amp;](const LargeSafeUnion&amp; safeUnion) {\012        EXPECT_OK(safeunionInterface-&gt;setA(safeUnion, -5, [&amp;](const LargeSafeUnion&amp; safeUnion) {\012            EXPECT_EQ(LargeSafeUnion::hidl_discriminator::a, safeUnion.getDiscriminator());\012            EXPECT_EQ(-5, safeUnion.a());\012\012 uint64_t max = std::numeric_limits&lt;uint64_t&gt;::max();\012            EXPECT_OK(\012                safeunionInterface-&gt;setD(safeUnion, max, [&amp;](const LargeSafeUnion&amp; safeUnion) {\012                    EXPECT_EQ(LargeSafeUnion::hidl_discriminator::d, safeUnion.getDiscriminator());\012                    EXPECT_EQ(max, safeUnion.d());\012 }));\012 }));\012 }));\012})<SUB>808</SUB>> ]
-"789" [label = <(UNKNOWN,TEST_F(HidlTest, SafeUnionArrayLikeTypesTest) {\012 const std::array&lt;int64_t, 5&gt; testArray{1, -2, 3, -4, 5};\012 const hidl_vec&lt;uint64_t&gt; testVector{std::numeric_limits&lt;uint64_t&gt;::max()};\012\012    EXPECT_OK(safeunionInterface-&gt;newLargeSafeUnion([&amp;](const LargeSafeUnion&amp; safeUnion) {\012        EXPECT_OK(\012            safeunionInterface-&gt;setF(safeUnion, testArray, [&amp;](const LargeSafeUnion&amp; safeUnion) {\012                EXPECT_EQ(LargeSafeUnion::hidl_discriminator::f, safeUnion.getDiscriminator());\012\012 for (size_t i = 0; i &lt; testArray.size(); i++) {\012                    EXPECT_EQ(testArray[i], safeUnion.f()[i]);\012 }\012 }));\012\012        EXPECT_OK(\012            safeunionInterface-&gt;setI(safeUnion, testVector, [&amp;](const LargeSafeUnion&amp; safeUnion) {\012                EXPECT_EQ(LargeSafeUnion::hidl_discriminator::i, safeUnion.getDiscriminator());\012                EXPECT_EQ(testVector, safeUnion.i());\012 }));\012 }));\012},TEST_F(HidlTest, SafeUnionArrayLikeTypesTest) {\012 const std::array&lt;int64_t, 5&gt; testArray{1, -2, 3, -4, 5};\012 const hidl_vec&lt;uint64_t&gt; testVector{std::numeric_limits&lt;uint64_t&gt;::max()};\012\012    EXPECT_OK(safeunionInterface-&gt;newLargeSafeUnion([&amp;](const LargeSafeUnion&amp; safeUnion) {\012        EXPECT_OK(\012            safeunionInterface-&gt;setF(safeUnion, testArray, [&amp;](const LargeSafeUnion&amp; safeUnion) {\012                EXPECT_EQ(LargeSafeUnion::hidl_discriminator::f, safeUnion.getDiscriminator());\012\012 for (size_t i = 0; i &lt; testArray.size(); i++) {\012                    EXPECT_EQ(testArray[i], safeUnion.f()[i]);\012 }\012 }));\012\012        EXPECT_OK(\012            safeunionInterface-&gt;setI(safeUnion, testVector, [&amp;](const LargeSafeUnion&amp; safeUnion) {\012                EXPECT_EQ(LargeSafeUnion::hidl_discriminator::i, safeUnion.getDiscriminator());\012                EXPECT_EQ(testVector, safeUnion.i());\012 }));\012 }));\012})<SUB>824</SUB>> ]
-"790" [label = <(UNKNOWN,TEST_F(HidlTest, SafeUnionStringTypeTest) {\012 const std::string testString =\012 &quot;This is an inordinately long test string to exercise hidl_string types in safe unions.&quot;;\012\012    EXPECT_OK(safeunionInterface-&gt;newLargeSafeUnion([&amp;](const LargeSafeUnion&amp; safeUnion) {\012        EXPECT_OK(safeunionInterface-&gt;setG(\012            safeUnion, hidl_string(testString), [&amp;](const LargeSafeUnion&amp; safeUnion) {\012                EXPECT_EQ(LargeSafeUnion::hidl_discriminator::g, safeUnion.getDiscriminator());\012                EXPECT_EQ(testString, std::string(safeUnion.g()));\012 }));\012 }));\012},TEST_F(HidlTest, SafeUnionStringTypeTest) {\012 const std::string testString =\012 &quot;This is an inordinately long test string to exercise hidl_string types in safe unions.&quot;;\012\012    EXPECT_OK(safeunionInterface-&gt;newLargeSafeUnion([&amp;](const LargeSafeUnion&amp; safeUnion) {\012        EXPECT_OK(safeunionInterface-&gt;setG(\012            safeUnion, hidl_string(testString), [&amp;](const LargeSafeUnion&amp; safeUnion) {\012                EXPECT_EQ(LargeSafeUnion::hidl_discriminator::g, safeUnion.getDiscriminator());\012                EXPECT_EQ(testString, std::string(safeUnion.g()));\012 }));\012 }));\012})<SUB>846</SUB>> ]
-"791" [label = <(UNKNOWN,TEST_F(HidlTest, SafeUnionNestedTest) {\012 SmallSafeUnion smallSafeUnion;\012    smallSafeUnion.a(1);\012\012    EXPECT_OK(safeunionInterface-&gt;newLargeSafeUnion([&amp;](const LargeSafeUnion&amp; safeUnion) {\012        EXPECT_OK(safeunionInterface-&gt;setL(\012            safeUnion, smallSafeUnion, [&amp;](const LargeSafeUnion&amp; safeUnion) {\012                EXPECT_EQ(LargeSafeUnion::hidl_discriminator::l, safeUnion.getDiscriminator());\012\012                EXPECT_EQ(SmallSafeUnion::hidl_discriminator::a, safeUnion.l().getDiscriminator());\012                EXPECT_EQ(1, safeUnion.l().a());\012 }));\012 }));\012},TEST_F(HidlTest, SafeUnionNestedTest) {\012 SmallSafeUnion smallSafeUnion;\012    smallSafeUnion.a(1);\012\012    EXPECT_OK(safeunionInterface-&gt;newLargeSafeUnion([&amp;](const LargeSafeUnion&amp; safeUnion) {\012        EXPECT_OK(safeunionInterface-&gt;setL(\012            safeUnion, smallSafeUnion, [&amp;](const LargeSafeUnion&amp; safeUnion) {\012                EXPECT_EQ(LargeSafeUnion::hidl_discriminator::l, safeUnion.getDiscriminator());\012\012                EXPECT_EQ(SmallSafeUnion::hidl_discriminator::a, safeUnion.l().getDiscriminator());\012                EXPECT_EQ(1, safeUnion.l().a());\012 }));\012 }));\012})<SUB>859</SUB>> ]
-"866" [label = <(UNKNOWN,TEST_F(HidlTest, SafeUnionInterfaceNullHandleTest) {\012 InterfaceTypeSafeUnion safeUnion;\012\012    EXPECT_OK(safeunionInterface-&gt;setInterfaceF(\012        safeUnion, hidl_handle(nullptr), [&amp;](const InterfaceTypeSafeUnion&amp; safeUnion) {\012            EXPECT_EQ(InterfaceTypeSafeUnion::hidl_discriminator::f,\012                      safeUnion.getDiscriminator());\012\012            checkNativeHandlesDataEquality(nullptr, safeUnion.f().getNativeHandle());\012 }));\012},TEST_F(HidlTest, SafeUnionInterfaceNullHandleTest) {\012 InterfaceTypeSafeUnion safeUnion;\012\012    EXPECT_OK(safeunionInterface-&gt;setInterfaceF(\012        safeUnion, hidl_handle(nullptr), [&amp;](const InterfaceTypeSafeUnion&amp; safeUnion) {\012            EXPECT_EQ(InterfaceTypeSafeUnion::hidl_discriminator::f,\012                      safeUnion.getDiscriminator());\012\012            checkNativeHandlesDataEquality(nullptr, safeUnion.f().getNativeHandle());\012 }));\012})<SUB>892</SUB>> ]
-"867" [label = <(UNKNOWN,TEST_F(HidlTest, SafeUnionInterfaceTest) {\012 const std::array&lt;int8_t, 7&gt; testArray{-1, -2, -3, 0, 1, 2, 3};\012 const hidl_vec&lt;hidl_string&gt; testVector{&quot;So&quot;, &quot;Many&quot;, &quot;Words&quot;};\012 const std::string testStringA = &quot;Hello&quot;;\012 const std::string testStringB = &quot;World&quot;;\012\012 const std::array&lt;int, 6&gt; testHandleData{2, -32, 10, -4329454, 11, 24};\012 native_handle_t* h = native_handle_create(0, testHandleData.size());\012    CHECK(sizeof(testHandleData) == testHandleData.size() * sizeof(int));\012    std::memcpy(h-&gt;data, testHandleData.data(), sizeof(testHandleData));\012\012    std::vector&lt;hidl_handle&gt; testHandlesVector(256);\012 for (size_t i = 0; i &lt; testHandlesVector.size(); i++) {\012        testHandlesVector[i].setTo(native_handle_clone(h), true /* shouldOwn */);\012 }\012\012    EXPECT_OK(\012        safeunionInterface-&gt;newInterfaceTypeSafeUnion([&amp;](const InterfaceTypeSafeUnion&amp; safeUnion) {\012            EXPECT_EQ(InterfaceTypeSafeUnion::hidl_discriminator::noinit,\012                      safeUnion.getDiscriminator());\012\012            EXPECT_OK(safeunionInterface-&gt;setInterfaceB(\012                safeUnion, testArray, [&amp;](const InterfaceTypeSafeUnion&amp; safeUnion) {\012                    EXPECT_EQ(InterfaceTypeSafeUnion::hidl_discriminator::b,\012                              safeUnion.getDiscriminator());\012\012 for (size_t i = 0; i &lt; testArray.size(); i++) {\012                        EXPECT_EQ(testArray[i], safeUnion.b()[i]);\012 }\012 }));\012\012            EXPECT_OK(safeunionInterface-&gt;setInterfaceD(\012                safeUnion, testStringA, [&amp;](const InterfaceTypeSafeUnion&amp; safeUnion) {\012                    EXPECT_EQ(InterfaceTypeSafeUnion::hidl_discriminator::d,\012                              safeUnion.getDiscriminator());\012                    EXPECT_EQ(testStringA, safeUnion.d());\012 }));\012\012            EXPECT_OK(safeunionInterface-&gt;setInterfaceE(\012                safeUnion, testVector, [&amp;](const InterfaceTypeSafeUnion&amp; safeUnion) {\012                    EXPECT_EQ(InterfaceTypeSafeUnion::hidl_discriminator::e,\012                              safeUnion.getDiscriminator());\012                    EXPECT_EQ(testVector, safeUnion.e());\012 }));\012\012            EXPECT_OK(safeunionInterface-&gt;setInterfaceF(\012                safeUnion, hidl_handle(h), [&amp;](const InterfaceTypeSafeUnion&amp; safeUnion) {\012                    EXPECT_EQ(InterfaceTypeSafeUnion::hidl_discriminator::f,\012                              safeUnion.getDiscriminator());\012\012 const native_handle_t* result = safeUnion.f().getNativeHandle();\012                    checkNativeHandlesDataEquality(h, result);\012 }));\012\012            EXPECT_OK(safeunionInterface-&gt;setInterfaceG(\012                safeUnion, testHandlesVector, [&amp;](const InterfaceTypeSafeUnion&amp; safeUnion) {\012                    EXPECT_EQ(InterfaceTypeSafeUnion::hidl_discriminator::g,\012                              safeUnion.getDiscriminator());\012\012 for (size_t i = 0; i &lt; testHandlesVector.size(); i++) {\012                        checkNativeHandlesDataEquality(h, safeUnion.g()[i].getNativeHandle());\012 }\012 }));\012 }));\012\012 // Same-process interface calls are not supported in Java, so we use\012 // a safe_union instance bound to this (client) process instead of\012 // safeunionInterface to exercise this test-case. Ref: b/110957763.\012 InterfaceTypeSafeUnion safeUnion;\012    safeUnion.c(otherInterface);\012\012    EXPECT_EQ(InterfaceTypeSafeUnion::hidl_discriminator::c, safeUnion.getDiscriminator());\012    EXPECT_OK(safeUnion.c()-&gt;concatTwoStrings(\012        hidl_string(testStringA), hidl_string(testStringB), [&amp;](const hidl_string&amp; result) {\012            EXPECT_EQ(testStringA + testStringB, std::string(result));\012 }));\012\012    native_handle_delete(h);\012},TEST_F(HidlTest, SafeUnionInterfaceTest) {\012 const std::array&lt;int8_t, 7&gt; testArray{-1, -2, -3, 0, 1, 2, 3};\012 const hidl_vec&lt;hidl_string&gt; testVector{&quot;So&quot;, &quot;Many&quot;, &quot;Words&quot;};\012 const std::string testStringA = &quot;Hello&quot;;\012 const std::string testStringB = &quot;World&quot;;\012\012 const std::array&lt;int, 6&gt; testHandleData{2, -32, 10, -4329454, 11, 24};\012 native_handle_t* h = native_handle_create(0, testHandleData.size());\012    CHECK(sizeof(testHandleData) == testHandleData.size() * sizeof(int));\012    std::memcpy(h-&gt;data, testHandleData.data(), sizeof(testHandleData));\012\012    std::vector&lt;hidl_handle&gt; testHandlesVector(256);\012 for (size_t i = 0; i &lt; testHandlesVector.size(); i++) {\012        testHandlesVector[i].setTo(native_handle_clone(h), true /* shouldOwn */);\012 }\012\012    EXPECT_OK(\012        safeunionInterface-&gt;newInterfaceTypeSafeUnion([&amp;](const InterfaceTypeSafeUnion&amp; safeUnion) {\012            EXPECT_EQ(InterfaceTypeSafeUnion::hidl_discriminator::noinit,\012                      safeUnion.getDiscriminator());\012\012            EXPECT_OK(safeunionInterface-&gt;setInterfaceB(\012                safeUnion, testArray, [&amp;](const InterfaceTypeSafeUnion&amp; safeUnion) {\012                    EXPECT_EQ(InterfaceTypeSafeUnion::hidl_discriminator::b,\012                              safeUnion.getDiscriminator());\012\012 for (size_t i = 0; i &lt; testArray.size(); i++) {\012                        EXPECT_EQ(testArray[i], safeUnion.b()[i]);\012 }\012 }));\012\012            EXPECT_OK(safeunionInterface-&gt;setInterfaceD(\012                safeUnion, testStringA, [&amp;](const InterfaceTypeSafeUnion&amp; safeUnion) {\012                    EXPECT_EQ(InterfaceTypeSafeUnion::hidl_discriminator::d,\012                              safeUnion.getDiscriminator());\012                    EXPECT_EQ(testStringA, safeUnion.d());\012 }));\012\012            EXPECT_OK(safeunionInterface-&gt;setInterfaceE(\012                safeUnion, testVector, [&amp;](const InterfaceTypeSafeUnion&amp; safeUnion) {\012                    EXPECT_EQ(InterfaceTypeSafeUnion::hidl_discriminator::e,\012                              safeUnion.getDiscriminator());\012                    EXPECT_EQ(testVector, safeUnion.e());\012 }));\012\012            EXPECT_OK(safeunionInterface-&gt;setInterfaceF(\012                safeUnion, hidl_handle(h), [&amp;](const InterfaceTypeSafeUnion&amp; safeUnion) {\012                    EXPECT_EQ(InterfaceTypeSafeUnion::hidl_discriminator::f,\012                              safeUnion.getDiscriminator());\012\012 const native_handle_t* result = safeUnion.f().getNativeHandle();\012                    checkNativeHandlesDataEquality(h, result);\012 }));\012\012            EXPECT_OK(safeunionInterface-&gt;setInterfaceG(\012                safeUnion, testHandlesVector, [&amp;](const InterfaceTypeSafeUnion&amp; safeUnion) {\012                    EXPECT_EQ(InterfaceTypeSafeUnion::hidl_discriminator::g,\012                              safeUnion.getDiscriminator());\012\012 for (size_t i = 0; i &lt; testHandlesVector.size(); i++) {\012                        checkNativeHandlesDataEquality(h, safeUnion.g()[i].getNativeHandle());\012 }\012 }));\012 }));\012\012 // Same-process interface calls are not supported in Java, so we use\012 // a safe_union instance bound to this (client) process instead of\012 // safeunionInterface to exercise this test-case. Ref: b/110957763.\012 InterfaceTypeSafeUnion safeUnion;\012    safeUnion.c(otherInterface);\012\012    EXPECT_EQ(InterfaceTypeSafeUnion::hidl_discriminator::c, safeUnion.getDiscriminator());\012    EXPECT_OK(safeUnion.c()-&gt;concatTwoStrings(\012        hidl_string(testStringA), hidl_string(testStringB), [&amp;](const hidl_string&amp; result) {\012            EXPECT_EQ(testStringA + testStringB, std::string(result));\012 }));\012\012    native_handle_delete(h);\012})<SUB>904</SUB>> ]
-"868" [label = <(UNKNOWN,TEST_F(HidlTest, SafeUnionNullHandleTest) {\012 HandleTypeSafeUnion safeUnion;\012\012    EXPECT_OK(safeunionInterface-&gt;setHandleA(\012        safeUnion, hidl_handle(nullptr), [&amp;](const HandleTypeSafeUnion&amp; safeUnion) {\012            EXPECT_EQ(HandleTypeSafeUnion::hidl_discriminator::a,\012                      safeUnion.getDiscriminator());\012\012            checkNativeHandlesDataEquality(nullptr, safeUnion.a().getNativeHandle());\012 }));\012},TEST_F(HidlTest, SafeUnionNullHandleTest) {\012 HandleTypeSafeUnion safeUnion;\012\012    EXPECT_OK(safeunionInterface-&gt;setHandleA(\012        safeUnion, hidl_handle(nullptr), [&amp;](const HandleTypeSafeUnion&amp; safeUnion) {\012            EXPECT_EQ(HandleTypeSafeUnion::hidl_discriminator::a,\012                      safeUnion.getDiscriminator());\012\012            checkNativeHandlesDataEquality(nullptr, safeUnion.a().getNativeHandle());\012 }));\012})<SUB>984</SUB>> ]
-"869" [label = <(UNKNOWN,TEST_F(HidlTest, SafeUnionSimpleHandleTest) {\012 const std::array&lt;int, 6&gt; testData{2, -32, 10, -4329454, 11, 24};\012 native_handle_t* h = native_handle_create(0, testData.size());\012    ASSERT_EQ(sizeof(testData), testData.size() * sizeof(int));\012    std::memcpy(h-&gt;data, testData.data(), sizeof(testData));\012\012    std::array&lt;hidl_handle, 5&gt; testArray;\012 for (size_t i = 0; i &lt; testArray.size(); i++) {\012        testArray[i].setTo(native_handle_clone(h), true /* shouldOwn */);\012 }\012\012    std::vector&lt;hidl_handle&gt; testVector(256);\012 for (size_t i = 0; i &lt; testVector.size(); i++) {\012        testVector[i].setTo(native_handle_clone(h), true /* shouldOwn */);\012 }\012\012    EXPECT_OK(\012        safeunionInterface-&gt;newHandleTypeSafeUnion([&amp;](const HandleTypeSafeUnion&amp; safeUnion) {\012            EXPECT_OK(safeunionInterface-&gt;setHandleA(\012                safeUnion, hidl_handle(h), [&amp;](const HandleTypeSafeUnion&amp; safeUnion) {\012                    EXPECT_EQ(HandleTypeSafeUnion::hidl_discriminator::a,\012                              safeUnion.getDiscriminator());\012\012                    checkNativeHandlesDataEquality(h, safeUnion.a().getNativeHandle());\012 }));\012\012            EXPECT_OK(safeunionInterface-&gt;setHandleB(\012                safeUnion, testArray, [&amp;](const HandleTypeSafeUnion&amp; safeUnion) {\012                    EXPECT_EQ(HandleTypeSafeUnion::hidl_discriminator::b,\012                              safeUnion.getDiscriminator());\012\012 for (size_t i = 0; i &lt; testArray.size(); i++) {\012                        checkNativeHandlesDataEquality(h, safeUnion.b()[i].getNativeHandle());\012 }\012 }));\012\012            EXPECT_OK(safeunionInterface-&gt;setHandleC(\012                safeUnion, testVector, [&amp;](const HandleTypeSafeUnion&amp; safeUnion) {\012                    EXPECT_EQ(HandleTypeSafeUnion::hidl_discriminator::c,\012                              safeUnion.getDiscriminator());\012\012 for (size_t i = 0; i &lt; testVector.size(); i++) {\012                        checkNativeHandlesDataEquality(h, safeUnion.c()[i].getNativeHandle());\012 }\012 }));\012 }));\012\012    native_handle_delete(h);\012},TEST_F(HidlTest, SafeUnionSimpleHandleTest) {\012 const std::array&lt;int, 6&gt; testData{2, -32, 10, -4329454, 11, 24};\012 native_handle_t* h = native_handle_create(0, testData.size());\012    ASSERT_EQ(sizeof(testData), testData.size() * sizeof(int));\012    std::memcpy(h-&gt;data, testData.data(), sizeof(testData));\012\012    std::array&lt;hidl_handle, 5&gt; testArray;\012 for (size_t i = 0; i &lt; testArray.size(); i++) {\012        testArray[i].setTo(native_handle_clone(h), true /* shouldOwn */);\012 }\012\012    std::vector&lt;hidl_handle&gt; testVector(256);\012 for (size_t i = 0; i &lt; testVector.size(); i++) {\012        testVector[i].setTo(native_handle_clone(h), true /* shouldOwn */);\012 }\012\012    EXPECT_OK(\012        safeunionInterface-&gt;newHandleTypeSafeUnion([&amp;](const HandleTypeSafeUnion&amp; safeUnion) {\012            EXPECT_OK(safeunionInterface-&gt;setHandleA(\012                safeUnion, hidl_handle(h), [&amp;](const HandleTypeSafeUnion&amp; safeUnion) {\012                    EXPECT_EQ(HandleTypeSafeUnion::hidl_discriminator::a,\012                              safeUnion.getDiscriminator());\012\012                    checkNativeHandlesDataEquality(h, safeUnion.a().getNativeHandle());\012 }));\012\012            EXPECT_OK(safeunionInterface-&gt;setHandleB(\012                safeUnion, testArray, [&amp;](const HandleTypeSafeUnion&amp; safeUnion) {\012                    EXPECT_EQ(HandleTypeSafeUnion::hidl_discriminator::b,\012                              safeUnion.getDiscriminator());\012\012 for (size_t i = 0; i &lt; testArray.size(); i++) {\012                        checkNativeHandlesDataEquality(h, safeUnion.b()[i].getNativeHandle());\012 }\012 }));\012\012            EXPECT_OK(safeunionInterface-&gt;setHandleC(\012                safeUnion, testVector, [&amp;](const HandleTypeSafeUnion&amp; safeUnion) {\012                    EXPECT_EQ(HandleTypeSafeUnion::hidl_discriminator::c,\012                              safeUnion.getDiscriminator());\012\012 for (size_t i = 0; i &lt; testVector.size(); i++) {\012                        checkNativeHandlesDataEquality(h, safeUnion.c()[i].getNativeHandle());\012 }\012 }));\012 }));\012\012    native_handle_delete(h);\012})<SUB>996</SUB>> ]
-"870" [label = <(UNKNOWN,TEST_F(HidlTest, SafeUnionVecOfHandlesWithOneFdTest) {\012 const std::vector&lt;std::string&gt; testStrings{&quot;This &quot;, &quot;is &quot;, &quot;so &quot;, &quot;much &quot;, &quot;data!\n&quot;};\012 const std::string testFileName = &quot;/data/local/tmp/SafeUnionVecOfHandlesWithOneFdTest&quot;;\012 const std::array&lt;int, 6&gt; testData{2, -32, 10, -4329454, 11, 24};\012    ASSERT_EQ(sizeof(testData), testData.size() * sizeof(int));\012\012 const std::string goldenResult = std::accumulate(testStrings.begin(),\012                                                     testStrings.end(),\012                                                     std::string());\012\012 int fd = open(testFileName.c_str(), (O_RDWR | O_TRUNC | O_CREAT), (S_IRUSR | S_IWUSR));\012    ASSERT_TRUE(fd &gt;= 0);\012\012    native_handle* h = native_handle_create(1 /* numFds */, testData.size() /* numInts */);\012    std::memcpy(&amp;(h-&gt;data[1]), testData.data(), sizeof(testData));\012    h-&gt;data[0] = fd;\012\012    hidl_vec&lt;hidl_handle&gt; testHandles(testStrings.size());\012 for (size_t i = 0; i &lt; testHandles.size(); i++) {\012        testHandles[i].setTo(native_handle_clone(h), true /* shouldOwn */);\012 }\012\012    EXPECT_OK(\012        safeunionInterface-&gt;newHandleTypeSafeUnion([&amp;](const HandleTypeSafeUnion&amp; safeUnion) {\012            EXPECT_OK(safeunionInterface-&gt;setHandleC(\012                safeUnion, testHandles, [&amp;](const HandleTypeSafeUnion&amp; safeUnion) {\012                    EXPECT_EQ(HandleTypeSafeUnion::hidl_discriminator::c,\012                              safeUnion.getDiscriminator());\012\012 for (size_t i = 0; i &lt; safeUnion.c().size(); i++) {\012 const native_handle_t* reference = testHandles[i].getNativeHandle();\012 const native_handle_t* result = safeUnion.c()[i].getNativeHandle();\012                        checkNativeHandlesDataEquality(reference, result);\012\012 // Original FDs should be dup'd\012 int resultFd = result-&gt;data[0];\012                        EXPECT_NE(reference-&gt;data[0], resultFd);\012\012                        EXPECT_TRUE(android::base::WriteStringToFd(testStrings[i], resultFd));\012                        EXPECT_EQ(0, fsync(resultFd));\012 }\012 }));\012 }));\012\012    std::string result;\012    lseek(fd, 0, SEEK_SET);\012\012    EXPECT_TRUE(android::base::ReadFdToString(fd, &amp;result));\012    EXPECT_EQ(goldenResult, result);\012\012    native_handle_delete(h);\012    EXPECT_EQ(0, close(fd));\012    EXPECT_EQ(0, remove(testFileName.c_str()));\012},TEST_F(HidlTest, SafeUnionVecOfHandlesWithOneFdTest) {\012 const std::vector&lt;std::string&gt; testStrings{&quot;This &quot;, &quot;is &quot;, &quot;so &quot;, &quot;much &quot;, &quot;data!\n&quot;};\012 const std::string testFileName = &quot;/data/local/tmp/SafeUnionVecOfHandlesWithOneFdTest&quot;;\012 const std::array&lt;int, 6&gt; testData{2, -32, 10, -4329454, 11, 24};\012    ASSERT_EQ(sizeof(testData), testData.size() * sizeof(int));\012\012 const std::string goldenResult = std::accumulate(testStrings.begin(),\012                                                     testStrings.end(),\012                                                     std::string());\012\012 int fd = open(testFileName.c_str(), (O_RDWR | O_TRUNC | O_CREAT), (S_IRUSR | S_IWUSR));\012    ASSERT_TRUE(fd &gt;= 0);\012\012    native_handle* h = native_handle_create(1 /* numFds */, testData.size() /* numInts */);\012    std::memcpy(&amp;(h-&gt;data[1]), testData.data(), sizeof(testData));\012    h-&gt;data[0] = fd;\012\012    hidl_vec&lt;hidl_handle&gt; testHandles(testStrings.size());\012 for (size_t i = 0; i &lt; testHandles.size(); i++) {\012        testHandles[i].setTo(native_handle_clone(h), true /* shouldOwn */);\012 }\012\012    EXPECT_OK(\012        safeunionInterface-&gt;newHandleTypeSafeUnion([&amp;](const HandleTypeSafeUnion&amp; safeUnion) {\012            EXPECT_OK(safeunionInterface-&gt;setHandleC(\012                safeUnion, testHandles, [&amp;](const HandleTypeSafeUnion&amp; safeUnion) {\012                    EXPECT_EQ(HandleTypeSafeUnion::hidl_discriminator::c,\012                              safeUnion.getDiscriminator());\012\012 for (size_t i = 0; i &lt; safeUnion.c().size(); i++) {\012 const native_handle_t* reference = testHandles[i].getNativeHandle();\012 const native_handle_t* result = safeUnion.c()[i].getNativeHandle();\012                        checkNativeHandlesDataEquality(reference, result);\012\012 // Original FDs should be dup'd\012 int resultFd = result-&gt;data[0];\012                        EXPECT_NE(reference-&gt;data[0], resultFd);\012\012                        EXPECT_TRUE(android::base::WriteStringToFd(testStrings[i], resultFd));\012                        EXPECT_EQ(0, fsync(resultFd));\012 }\012 }));\012 }));\012\012    std::string result;\012    lseek(fd, 0, SEEK_SET);\012\012    EXPECT_TRUE(android::base::ReadFdToString(fd, &amp;result));\012    EXPECT_EQ(goldenResult, result);\012\012    native_handle_delete(h);\012    EXPECT_EQ(0, close(fd));\012    EXPECT_EQ(0, remove(testFileName.c_str()));\012})<SUB>1046</SUB>> ]
-"871" [label = <(UNKNOWN,TEST_F(HidlTest, SafeUnionHandleWithMultipleFdsTest) {\012 const std::vector&lt;std::string&gt; testStrings{&quot;This &quot;, &quot;is &quot;, &quot;so &quot;, &quot;much &quot;, &quot;data!\n&quot;};\012 const std::string testFileName = &quot;/data/local/tmp/SafeUnionHandleWithMultipleFdsTest&quot;;\012 const std::array&lt;int, 6&gt; testData{2, -32, 10, -4329454, 11, 24};\012    ASSERT_EQ(sizeof(testData), testData.size() * sizeof(int));\012\012 const std::string goldenResult = std::accumulate(testStrings.begin(),\012                                                     testStrings.end(),\012                                                     std::string());\012\012 int fd = open(testFileName.c_str(), (O_RDWR | O_TRUNC | O_CREAT), (S_IRUSR | S_IWUSR));\012    ASSERT_TRUE(fd &gt;= 0);\012\012 const int numFds = testStrings.size();\012    native_handle* h = native_handle_create(numFds, testData.size() /* numInts */);\012    std::memcpy(&amp;(h-&gt;data[numFds]), testData.data(), sizeof(testData));\012 for (size_t i = 0; i &lt; numFds; i++) {\012        h-&gt;data[i] = fd;\012 }\012\012    hidl_handle testHandle;\012    testHandle.setTo(h, false /* shouldOwn */);\012\012    EXPECT_OK(\012        safeunionInterface-&gt;newHandleTypeSafeUnion([&amp;](const HandleTypeSafeUnion&amp; safeUnion) {\012            EXPECT_OK(safeunionInterface-&gt;setHandleA(\012                safeUnion, testHandle, [&amp;](const HandleTypeSafeUnion&amp; safeUnion) {\012                    EXPECT_EQ(HandleTypeSafeUnion::hidl_discriminator::a,\012                              safeUnion.getDiscriminator());\012\012 const native_handle_t* result = safeUnion.a().getNativeHandle();\012                    checkNativeHandlesDataEquality(h, result);\012\012 for (size_t i = 0; i &lt; result-&gt;numFds; i++) {\012 // Original FDs should be dup'd\012 int resultFd = result-&gt;data[i];\012                        EXPECT_NE(h-&gt;data[i], resultFd);\012\012                        EXPECT_TRUE(android::base::WriteStringToFd(testStrings[i], resultFd));\012                        EXPECT_EQ(0, fsync(resultFd));\012 }\012 }));\012 }));\012\012    std::string result;\012    lseek(fd, 0, SEEK_SET);\012\012    EXPECT_TRUE(android::base::ReadFdToString(fd, &amp;result));\012    EXPECT_EQ(goldenResult, result);\012\012    native_handle_delete(h);\012    EXPECT_EQ(0, close(fd));\012    EXPECT_EQ(0, remove(testFileName.c_str()));\012},TEST_F(HidlTest, SafeUnionHandleWithMultipleFdsTest) {\012 const std::vector&lt;std::string&gt; testStrings{&quot;This &quot;, &quot;is &quot;, &quot;so &quot;, &quot;much &quot;, &quot;data!\n&quot;};\012 const std::string testFileName = &quot;/data/local/tmp/SafeUnionHandleWithMultipleFdsTest&quot;;\012 const std::array&lt;int, 6&gt; testData{2, -32, 10, -4329454, 11, 24};\012    ASSERT_EQ(sizeof(testData), testData.size() * sizeof(int));\012\012 const std::string goldenResult = std::accumulate(testStrings.begin(),\012                                                     testStrings.end(),\012                                                     std::string());\012\012 int fd = open(testFileName.c_str(), (O_RDWR | O_TRUNC | O_CREAT), (S_IRUSR | S_IWUSR));\012    ASSERT_TRUE(fd &gt;= 0);\012\012 const int numFds = testStrings.size();\012    native_handle* h = native_handle_create(numFds, testData.size() /* numInts */);\012    std::memcpy(&amp;(h-&gt;data[numFds]), testData.data(), sizeof(testData));\012 for (size_t i = 0; i &lt; numFds; i++) {\012        h-&gt;data[i] = fd;\012 }\012\012    hidl_handle testHandle;\012    testHandle.setTo(h, false /* shouldOwn */);\012\012    EXPECT_OK(\012        safeunionInterface-&gt;newHandleTypeSafeUnion([&amp;](const HandleTypeSafeUnion&amp; safeUnion) {\012            EXPECT_OK(safeunionInterface-&gt;setHandleA(\012                safeUnion, testHandle, [&amp;](const HandleTypeSafeUnion&amp; safeUnion) {\012                    EXPECT_EQ(HandleTypeSafeUnion::hidl_discriminator::a,\012                              safeUnion.getDiscriminator());\012\012 const native_handle_t* result = safeUnion.a().getNativeHandle();\012                    checkNativeHandlesDataEquality(h, result);\012\012 for (size_t i = 0; i &lt; result-&gt;numFds; i++) {\012 // Original FDs should be dup'd\012 int resultFd = result-&gt;data[i];\012                        EXPECT_NE(h-&gt;data[i], resultFd);\012\012                        EXPECT_TRUE(android::base::WriteStringToFd(testStrings[i], resultFd));\012                        EXPECT_EQ(0, fsync(resultFd));\012 }\012 }));\012 }));\012\012    std::string result;\012    lseek(fd, 0, SEEK_SET);\012\012    EXPECT_TRUE(android::base::ReadFdToString(fd, &amp;result));\012    EXPECT_EQ(goldenResult, result);\012\012    native_handle_delete(h);\012    EXPECT_EQ(0, close(fd));\012    EXPECT_EQ(0, remove(testFileName.c_str()));\012})<SUB>1101</SUB>> ]
-"872" [label = <(UNKNOWN,TEST_F(HidlTest, SafeUnionEqualityTest) {\012    EXPECT_OK(safeunionInterface-&gt;newLargeSafeUnion([&amp;](const LargeSafeUnion&amp; one) {\012        EXPECT_OK(safeunionInterface-&gt;newLargeSafeUnion([&amp;](const LargeSafeUnion&amp; two) {\012            EXPECT_TRUE(one == two);\012            EXPECT_FALSE(one != two);\012 }));\012\012        EXPECT_OK(safeunionInterface-&gt;setA(one, 1, [&amp;](const LargeSafeUnion&amp; one) {\012            EXPECT_OK(safeunionInterface-&gt;newLargeSafeUnion([&amp;](const LargeSafeUnion&amp; two) {\012                EXPECT_FALSE(one == two);\012                EXPECT_TRUE(one != two);\012 }));\012\012            EXPECT_OK(safeunionInterface-&gt;newLargeSafeUnion([&amp;](const LargeSafeUnion&amp; two) {\012                EXPECT_OK(safeunionInterface-&gt;setB(two, 1, [&amp;](const LargeSafeUnion&amp; two) {\012                    EXPECT_FALSE(one == two);\012                    EXPECT_TRUE(one != two);\012 }));\012 }));\012\012            EXPECT_OK(safeunionInterface-&gt;newLargeSafeUnion([&amp;](const LargeSafeUnion&amp; two) {\012                EXPECT_OK(safeunionInterface-&gt;setA(two, 2, [&amp;](const LargeSafeUnion&amp; two) {\012                    EXPECT_FALSE(one == two);\012                    EXPECT_TRUE(one != two);\012 }));\012 }));\012\012            EXPECT_OK(safeunionInterface-&gt;newLargeSafeUnion([&amp;](const LargeSafeUnion&amp; two) {\012                EXPECT_OK(safeunionInterface-&gt;setA(two, 1, [&amp;](const LargeSafeUnion&amp; two) {\012                    EXPECT_TRUE(one == two);\012                    EXPECT_FALSE(one != two);\012 }));\012 }));\012 }));\012 }));\012},TEST_F(HidlTest, SafeUnionEqualityTest) {\012    EXPECT_OK(safeunionInterface-&gt;newLargeSafeUnion([&amp;](const LargeSafeUnion&amp; one) {\012        EXPECT_OK(safeunionInterface-&gt;newLargeSafeUnion([&amp;](const LargeSafeUnion&amp; two) {\012            EXPECT_TRUE(one == two);\012            EXPECT_FALSE(one != two);\012 }));\012\012        EXPECT_OK(safeunionInterface-&gt;setA(one, 1, [&amp;](const LargeSafeUnion&amp; one) {\012            EXPECT_OK(safeunionInterface-&gt;newLargeSafeUnion([&amp;](const LargeSafeUnion&amp; two) {\012                EXPECT_FALSE(one == two);\012                EXPECT_TRUE(one != two);\012 }));\012\012            EXPECT_OK(safeunionInterface-&gt;newLargeSafeUnion([&amp;](const LargeSafeUnion&amp; two) {\012                EXPECT_OK(safeunionInterface-&gt;setB(two, 1, [&amp;](const LargeSafeUnion&amp; two) {\012                    EXPECT_FALSE(one == two);\012                    EXPECT_TRUE(one != two);\012 }));\012 }));\012\012            EXPECT_OK(safeunionInterface-&gt;newLargeSafeUnion([&amp;](const LargeSafeUnion&amp; two) {\012                EXPECT_OK(safeunionInterface-&gt;setA(two, 2, [&amp;](const LargeSafeUnion&amp; two) {\012                    EXPECT_FALSE(one == two);\012                    EXPECT_TRUE(one != two);\012 }));\012 }));\012\012            EXPECT_OK(safeunionInterface-&gt;newLargeSafeUnion([&amp;](const LargeSafeUnion&amp; two) {\012                EXPECT_OK(safeunionInterface-&gt;setA(two, 1, [&amp;](const LargeSafeUnion&amp; two) {\012                    EXPECT_TRUE(one == two);\012                    EXPECT_FALSE(one != two);\012 }));\012 }));\012 }));\012 }));\012})<SUB>1156</SUB>> ]
-"914" [label = <(UNKNOWN,TEST_F(HidlTest, UninitTest) {\012 IBase::Foo foo;\012    foo.x = 1;\012    foo.y = {0, &quot;&quot;};\012\012 static_assert(offsetof(IBase::Foo, x) == 0);\012 static_assert(sizeof(foo.x) == 4);\012 static_assert(offsetof(IBase::Foo, aaa) == 8);\012\012 uint8_t* buf = reinterpret_cast&lt;uint8_t*&gt;(&amp;foo);\012    memset(buf + 4, 0xFF, 4);\012\012 // this should not affect the result for remote Java (but would for remote C++)\012    expectRangeEqual&lt;IBase::Foo, 4, 8&gt;(&amp;foo, 0xFF);\012\012 // run many times, if this error case is hit, it will only be hit\012 // sometimes.\012 for (size_t i = 0; i &lt; 100; i++) {\012        EXPECT_OK(baz-&gt;someOtherBaseMethod(\012                foo, [](const IBase::Foo&amp; foo) { expectRangeEqual&lt;IBase::Foo, 4, 8&gt;(&amp;foo, 0); }));\012 }\012},TEST_F(HidlTest, UninitTest) {\012 IBase::Foo foo;\012    foo.x = 1;\012    foo.y = {0, &quot;&quot;};\012\012 static_assert(offsetof(IBase::Foo, x) == 0);\012 static_assert(sizeof(foo.x) == 4);\012 static_assert(offsetof(IBase::Foo, aaa) == 8);\012\012 uint8_t* buf = reinterpret_cast&lt;uint8_t*&gt;(&amp;foo);\012    memset(buf + 4, 0xFF, 4);\012\012 // this should not affect the result for remote Java (but would for remote C++)\012    expectRangeEqual&lt;IBase::Foo, 4, 8&gt;(&amp;foo, 0xFF);\012\012 // run many times, if this error case is hit, it will only be hit\012 // sometimes.\012 for (size_t i = 0; i &lt; 100; i++) {\012        EXPECT_OK(baz-&gt;someOtherBaseMethod(\012                foo, [](const IBase::Foo&amp; foo) { expectRangeEqual&lt;IBase::Foo, 4, 8&gt;(&amp;foo, 0); }));\012 }\012})<SUB>1205</SUB>> ]
+"644" [label = <(UNKNOWN,TEST_F(HidlTest, SomeOtherBaseMethodInvalidString) {\012 IBase::Foo foo {\012 .y = {\012 .s = &quot;\xff&quot;,\012 }\012 };\012\012 auto ret = baz-&gt;someOtherBaseMethod(foo, [&amp;](const auto&amp;) {\012        ADD_FAILURE() &lt;&lt; &quot;Should not accept invalid UTF-8 String&quot;;\012 });\012\012    EXPECT_FALSE(ret.isOk());\012\012    EXPECT_OK(baz-&gt;ping());\012},TEST_F(HidlTest, SomeOtherBaseMethodInvalidString) {\012 IBase::Foo foo {\012 .y = {\012 .s = &quot;\xff&quot;,\012 }\012 };\012\012 auto ret = baz-&gt;someOtherBaseMethod(foo, [&amp;](const auto&amp;) {\012        ADD_FAILURE() &lt;&lt; &quot;Should not accept invalid UTF-8 String&quot;;\012 });\012\012    EXPECT_FALSE(ret.isOk());\012\012    EXPECT_OK(baz-&gt;ping());\012})<SUB>297</SUB>> ]
+"645" [label = <(UNKNOWN,TEST_F(HidlTest, BazSomeMethodWithFooArraysTest) {\012    hidl_array&lt;IBase::Foo, 2&gt; foo;\012\012    foo[0].x = 1;\012    foo[0].y.z = 2.5;\012    foo[0].y.s = &quot;Hello, world&quot;;\012\012    foo[0].aaa.resize(5);\012 for (size_t i = 0; i &lt; foo[0].aaa.size(); ++i) {\012        foo[0].aaa[i].z = 1.0f + (float)i * 0.01f;\012        foo[0].aaa[i].s = (&quot;Hello, world &quot; + std::to_string(i)).c_str();\012 }\012\012    foo[1].x = 2;\012    foo[1].y.z = -2.5;\012    foo[1].y.s = &quot;Morituri te salutant&quot;;\012\012    foo[1].aaa.resize(3);\012 for (size_t i = 0; i &lt; foo[1].aaa.size(); ++i) {\012        foo[1].aaa[i].z = 2.0f - (float)i * 0.01f;\012        foo[1].aaa[i].s = (&quot;Alea iacta est: &quot; + std::to_string(i)).c_str();\012 }\012\012    hidl_array&lt;IBaz::Foo, 2&gt; fooExpectedOutput;\012    fooExpectedOutput[0] = foo[1];\012    fooExpectedOutput[1] = foo[0];\012\012    EXPECT_OK(\012            baz-&gt;someMethodWithFooArrays(\012                foo,\012 [&amp;](const auto &amp;result) {\012                    EXPECT_EQ(result, fooExpectedOutput);\012 }));\012},TEST_F(HidlTest, BazSomeMethodWithFooArraysTest) {\012    hidl_array&lt;IBase::Foo, 2&gt; foo;\012\012    foo[0].x = 1;\012    foo[0].y.z = 2.5;\012    foo[0].y.s = &quot;Hello, world&quot;;\012\012    foo[0].aaa.resize(5);\012 for (size_t i = 0; i &lt; foo[0].aaa.size(); ++i) {\012        foo[0].aaa[i].z = 1.0f + (float)i * 0.01f;\012        foo[0].aaa[i].s = (&quot;Hello, world &quot; + std::to_string(i)).c_str();\012 }\012\012    foo[1].x = 2;\012    foo[1].y.z = -2.5;\012    foo[1].y.s = &quot;Morituri te salutant&quot;;\012\012    foo[1].aaa.resize(3);\012 for (size_t i = 0; i &lt; foo[1].aaa.size(); ++i) {\012        foo[1].aaa[i].z = 2.0f - (float)i * 0.01f;\012        foo[1].aaa[i].s = (&quot;Alea iacta est: &quot; + std::to_string(i)).c_str();\012 }\012\012    hidl_array&lt;IBaz::Foo, 2&gt; fooExpectedOutput;\012    fooExpectedOutput[0] = foo[1];\012    fooExpectedOutput[1] = foo[0];\012\012    EXPECT_OK(\012            baz-&gt;someMethodWithFooArrays(\012                foo,\012 [&amp;](const auto &amp;result) {\012                    EXPECT_EQ(result, fooExpectedOutput);\012 }));\012})<SUB>313</SUB>> ]
+"646" [label = <(UNKNOWN,TEST_F(HidlTest, BazSomeMethodWithFooVectorsTest) {\012    hidl_vec&lt;IBase::Foo&gt; foo;\012    foo.resize(2);\012\012    foo[0].x = 1;\012    foo[0].y.z = 2.5;\012    foo[0].y.s = &quot;Hello, world&quot;;\012\012    foo[0].aaa.resize(5);\012 for (size_t i = 0; i &lt; foo[0].aaa.size(); ++i) {\012        foo[0].aaa[i].z = 1.0f + (float)i * 0.01f;\012        foo[0].aaa[i].s = (&quot;Hello, world &quot; + std::to_string(i)).c_str();\012 }\012\012    foo[1].x = 2;\012    foo[1].y.z = -2.5;\012    foo[1].y.s = &quot;Morituri te salutant&quot;;\012\012    foo[1].aaa.resize(3);\012 for (size_t i = 0; i &lt; foo[1].aaa.size(); ++i) {\012        foo[1].aaa[i].z = 2.0f - (float)i * 0.01f;\012        foo[1].aaa[i].s = (&quot;Alea iacta est: &quot; + std::to_string(i)).c_str();\012 }\012\012    hidl_vec&lt;IBaz::Foo&gt; fooExpectedOutput;\012    fooExpectedOutput.resize(2);\012    fooExpectedOutput[0] = foo[1];\012    fooExpectedOutput[1] = foo[0];\012\012    EXPECT_OK(\012            baz-&gt;someMethodWithFooVectors(\012                foo,\012 [&amp;](const auto &amp;result) {\012                    EXPECT_EQ(result, fooExpectedOutput);\012 }));\012},TEST_F(HidlTest, BazSomeMethodWithFooVectorsTest) {\012    hidl_vec&lt;IBase::Foo&gt; foo;\012    foo.resize(2);\012\012    foo[0].x = 1;\012    foo[0].y.z = 2.5;\012    foo[0].y.s = &quot;Hello, world&quot;;\012\012    foo[0].aaa.resize(5);\012 for (size_t i = 0; i &lt; foo[0].aaa.size(); ++i) {\012        foo[0].aaa[i].z = 1.0f + (float)i * 0.01f;\012        foo[0].aaa[i].s = (&quot;Hello, world &quot; + std::to_string(i)).c_str();\012 }\012\012    foo[1].x = 2;\012    foo[1].y.z = -2.5;\012    foo[1].y.s = &quot;Morituri te salutant&quot;;\012\012    foo[1].aaa.resize(3);\012 for (size_t i = 0; i &lt; foo[1].aaa.size(); ++i) {\012        foo[1].aaa[i].z = 2.0f - (float)i * 0.01f;\012        foo[1].aaa[i].s = (&quot;Alea iacta est: &quot; + std::to_string(i)).c_str();\012 }\012\012    hidl_vec&lt;IBaz::Foo&gt; fooExpectedOutput;\012    fooExpectedOutput.resize(2);\012    fooExpectedOutput[0] = foo[1];\012    fooExpectedOutput[1] = foo[0];\012\012    EXPECT_OK(\012            baz-&gt;someMethodWithFooVectors(\012                foo,\012 [&amp;](const auto &amp;result) {\012                    EXPECT_EQ(result, fooExpectedOutput);\012 }));\012})<SUB>348</SUB>> ]
+"647" [label = <(UNKNOWN,TEST_F(HidlTest, BazSomeMethodWithVectorOfArray) {\012 IBase::VectorOfArray in, expectedOut;\012    in.addresses.resize(3);\012    expectedOut.addresses.resize(3);\012\012 size_t k = 0;\012 const size_t n = in.addresses.size();\012\012 for (size_t i = 0; i &lt; n; ++i) {\012 for (size_t j = 0; j &lt; 6; ++j, ++k) {\012            in.addresses[i][j] = k;\012            expectedOut.addresses[n - 1 - i][j] = k;\012 }\012 }\012\012    EXPECT_OK(\012            baz-&gt;someMethodWithVectorOfArray(\012                in,\012 [&amp;](const auto &amp;out) {\012                    EXPECT_EQ(expectedOut, out);\012 }));\012},TEST_F(HidlTest, BazSomeMethodWithVectorOfArray) {\012 IBase::VectorOfArray in, expectedOut;\012    in.addresses.resize(3);\012    expectedOut.addresses.resize(3);\012\012 size_t k = 0;\012 const size_t n = in.addresses.size();\012\012 for (size_t i = 0; i &lt; n; ++i) {\012 for (size_t j = 0; j &lt; 6; ++j, ++k) {\012            in.addresses[i][j] = k;\012            expectedOut.addresses[n - 1 - i][j] = k;\012 }\012 }\012\012    EXPECT_OK(\012            baz-&gt;someMethodWithVectorOfArray(\012                in,\012 [&amp;](const auto &amp;out) {\012                    EXPECT_EQ(expectedOut, out);\012 }));\012})<SUB>385</SUB>> ]
+"648" [label = <(UNKNOWN,TEST_F(HidlTest, BazSomeMethodTakingAVectorOfArray) {\012    hidl_vec&lt;hidl_array&lt;uint8_t, 6&gt; &gt; in, expectedOut;\012    in.resize(3);\012    expectedOut.resize(3);\012\012 size_t k = 0;\012 const size_t n = in.size();\012 for (size_t i = 0; i &lt; n; ++i) {\012 for (size_t j = 0; j &lt; 6; ++j, ++k) {\012            in[i][j] = k;\012            expectedOut[n - 1 - i][j] = k;\012 }\012 }\012\012    EXPECT_OK(\012            baz-&gt;someMethodTakingAVectorOfArray(\012                in,\012 [&amp;](const auto &amp;out) {\012                    EXPECT_EQ(expectedOut, out);\012 }));\012},TEST_F(HidlTest, BazSomeMethodTakingAVectorOfArray) {\012    hidl_vec&lt;hidl_array&lt;uint8_t, 6&gt; &gt; in, expectedOut;\012    in.resize(3);\012    expectedOut.resize(3);\012\012 size_t k = 0;\012 const size_t n = in.size();\012 for (size_t i = 0; i &lt; n; ++i) {\012 for (size_t j = 0; j &lt; 6; ++j, ++k) {\012            in[i][j] = k;\012            expectedOut[n - 1 - i][j] = k;\012 }\012 }\012\012    EXPECT_OK(\012            baz-&gt;someMethodTakingAVectorOfArray(\012                in,\012 [&amp;](const auto &amp;out) {\012                    EXPECT_EQ(expectedOut, out);\012 }));\012})<SUB>408</SUB>> ]
+"763" [label = <(UNKNOWN,TEST_F(HidlTest, BazTransposeTest) {\012 IBase::StringMatrix5x3 in;\012 IBase::StringMatrix3x5 expectedOut;\012\012 for (int i = 0; i &lt; 5; ++i) {\012 for (int j = 0; j &lt; 3; ++j) {\012            in.s[i][j] = expectedOut.s[j][i] = numberToEnglish(3 * i + j + 1).c_str();\012 }\012 }\012\012    EXPECT_OK(baz-&gt;transpose(\012                in,\012 [&amp;](const auto &amp;out) {\012                    EXPECT_EQ(expectedOut, out);\012 }));\012},TEST_F(HidlTest, BazTransposeTest) {\012 IBase::StringMatrix5x3 in;\012 IBase::StringMatrix3x5 expectedOut;\012\012 for (int i = 0; i &lt; 5; ++i) {\012 for (int j = 0; j &lt; 3; ++j) {\012            in.s[i][j] = expectedOut.s[j][i] = numberToEnglish(3 * i + j + 1).c_str();\012 }\012 }\012\012    EXPECT_OK(baz-&gt;transpose(\012                in,\012 [&amp;](const auto &amp;out) {\012                    EXPECT_EQ(expectedOut, out);\012 }));\012})<SUB>476</SUB>> ]
+"764" [label = <(UNKNOWN,TEST_F(HidlTest, BazTranspose2Test) {\012    hidl_array&lt;hidl_string, 5, 3&gt; in;\012    hidl_array&lt;hidl_string, 3, 5&gt; expectedOut;\012\012 for (int i = 0; i &lt; 5; ++i) {\012 for (int j = 0; j &lt; 3; ++j) {\012            in[i][j] = expectedOut[j][i] = numberToEnglish(3 * i + j + 1).c_str();\012 }\012 }\012\012    EXPECT_OK(baz-&gt;transpose2(\012                in,\012 [&amp;](const auto &amp;out) {\012                    EXPECT_EQ(expectedOut, out);\012 }));\012},TEST_F(HidlTest, BazTranspose2Test) {\012    hidl_array&lt;hidl_string, 5, 3&gt; in;\012    hidl_array&lt;hidl_string, 3, 5&gt; expectedOut;\012\012 for (int i = 0; i &lt; 5; ++i) {\012 for (int j = 0; j &lt; 3; ++j) {\012            in[i][j] = expectedOut[j][i] = numberToEnglish(3 * i + j + 1).c_str();\012 }\012 }\012\012    EXPECT_OK(baz-&gt;transpose2(\012                in,\012 [&amp;](const auto &amp;out) {\012                    EXPECT_EQ(expectedOut, out);\012 }));\012})<SUB>493</SUB>> ]
+"765" [label = <(UNKNOWN,TEST_F(HidlTest, BazSomeBoolMethodTest) {\012 auto result = baz-&gt;someBoolMethod(true);\012    EXPECT_OK(result);\012    EXPECT_EQ(result, false);\012},TEST_F(HidlTest, BazSomeBoolMethodTest) {\012 auto result = baz-&gt;someBoolMethod(true);\012    EXPECT_OK(result);\012    EXPECT_EQ(result, false);\012})<SUB>510</SUB>> ]
+"766" [label = <(UNKNOWN,TEST_F(HidlTest, BazSomeBoolArrayMethodTest) {\012    hidl_array&lt;bool, 3&gt; someBoolArray;\012    someBoolArray[0] = true;\012    someBoolArray[1] = false;\012    someBoolArray[2] = true;\012\012    hidl_array&lt;bool, 4&gt; expectedOut;\012    expectedOut[0] = false;\012    expectedOut[1] = true;\012    expectedOut[2] = false;\012    expectedOut[3] = true;\012\012    EXPECT_OK(\012            baz-&gt;someBoolArrayMethod(\012                someBoolArray,\012 [&amp;](const auto &amp;result) {\012                    EXPECT_EQ(expectedOut, result);\012 }));\012},TEST_F(HidlTest, BazSomeBoolArrayMethodTest) {\012    hidl_array&lt;bool, 3&gt; someBoolArray;\012    someBoolArray[0] = true;\012    someBoolArray[1] = false;\012    someBoolArray[2] = true;\012\012    hidl_array&lt;bool, 4&gt; expectedOut;\012    expectedOut[0] = false;\012    expectedOut[1] = true;\012    expectedOut[2] = false;\012    expectedOut[3] = true;\012\012    EXPECT_OK(\012            baz-&gt;someBoolArrayMethod(\012                someBoolArray,\012 [&amp;](const auto &amp;result) {\012                    EXPECT_EQ(expectedOut, result);\012 }));\012})<SUB>516</SUB>> ]
+"767" [label = <(UNKNOWN,TEST_F(HidlTest, BazSomeBoolVectorMethodTest) {\012    hidl_vec&lt;bool&gt; someBoolVector, expected;\012    someBoolVector.resize(4);\012    expected.resize(4);\012\012 for (size_t i = 0; i &lt; someBoolVector.size(); ++i) {\012        someBoolVector[i] = ((i &amp; 1) == 0);\012        expected[i] = !someBoolVector[i];\012 }\012\012    EXPECT_OK(\012            baz-&gt;someBoolVectorMethod(\012                someBoolVector,\012 [&amp;](const auto &amp;result) {\012                    EXPECT_EQ(expected, result);\012 }));\012},TEST_F(HidlTest, BazSomeBoolVectorMethodTest) {\012    hidl_vec&lt;bool&gt; someBoolVector, expected;\012    someBoolVector.resize(4);\012    expected.resize(4);\012\012 for (size_t i = 0; i &lt; someBoolVector.size(); ++i) {\012        someBoolVector[i] = ((i &amp; 1) == 0);\012        expected[i] = !someBoolVector[i];\012 }\012\012    EXPECT_OK(\012            baz-&gt;someBoolVectorMethod(\012                someBoolVector,\012 [&amp;](const auto &amp;result) {\012                    EXPECT_EQ(expected, result);\012 }));\012})<SUB>536</SUB>> ]
+"768" [label = <(UNKNOWN,TEST_F(HidlTest, BazDoThisMethodTest) {\012    EXPECT_OK(baz-&gt;doThis(1.0f));\012},TEST_F(HidlTest, BazDoThisMethodTest) {\012    EXPECT_OK(baz-&gt;doThis(1.0f));\012})<SUB>554</SUB>> ]
+"769" [label = <(UNKNOWN,TEST_F(HidlTest, BazDoThatAndReturnSomethingMethodTest) {\012 auto result = baz-&gt;doThatAndReturnSomething(1);\012    EXPECT_OK(result);\012    EXPECT_EQ(result, 666);\012},TEST_F(HidlTest, BazDoThatAndReturnSomethingMethodTest) {\012 auto result = baz-&gt;doThatAndReturnSomething(1);\012    EXPECT_OK(result);\012    EXPECT_EQ(result, 666);\012})<SUB>558</SUB>> ]
+"770" [label = <(UNKNOWN,TEST_F(HidlTest, BazDoQuiteABitMethodTest) {\012 auto result = baz-&gt;doQuiteABit(1, 2LL, 3.0f, 4.0);\012\012    EXPECT_OK(result);\012    EXPECT_EQ(result, 666.5);\012},TEST_F(HidlTest, BazDoQuiteABitMethodTest) {\012 auto result = baz-&gt;doQuiteABit(1, 2LL, 3.0f, 4.0);\012\012    EXPECT_OK(result);\012    EXPECT_EQ(result, 666.5);\012})<SUB>564</SUB>> ]
+"771" [label = <(UNKNOWN,TEST_F(HidlTest, BazDoSomethingElseMethodTest) {\012    hidl_array&lt;int32_t, 15&gt; param;\012    hidl_array&lt;int32_t, 32&gt; expected;\012\012 for (size_t i = 0; i &lt; 15; ++i) {\012        param[i] = expected[15 + i] = i;\012        expected[i] = 2 * i;\012 }\012\012    expected[30] = 1;\012    expected[31] = 2;\012\012    EXPECT_OK(\012            baz-&gt;doSomethingElse(\012                param,\012 [&amp;](const auto &amp;result) {\012                    EXPECT_EQ(expected, result);\012 }));\012},TEST_F(HidlTest, BazDoSomethingElseMethodTest) {\012    hidl_array&lt;int32_t, 15&gt; param;\012    hidl_array&lt;int32_t, 32&gt; expected;\012\012 for (size_t i = 0; i &lt; 15; ++i) {\012        param[i] = expected[15 + i] = i;\012        expected[i] = 2 * i;\012 }\012\012    expected[30] = 1;\012    expected[31] = 2;\012\012    EXPECT_OK(\012            baz-&gt;doSomethingElse(\012                param,\012 [&amp;](const auto &amp;result) {\012                    EXPECT_EQ(expected, result);\012 }));\012})<SUB>571</SUB>> ]
+"772" [label = <(UNKNOWN,TEST_F(HidlTest, BazDoStuffAndReturnAStringMethodTest) {\012    std::string expected = &quot;Hello, world!&quot;;\012    EXPECT_OK(\012            baz-&gt;doStuffAndReturnAString(\012 [&amp;](const auto &amp;result) {\012                    EXPECT_EQ(expected, result);\012 }));\012},TEST_F(HidlTest, BazDoStuffAndReturnAStringMethodTest) {\012    std::string expected = &quot;Hello, world!&quot;;\012    EXPECT_OK(\012            baz-&gt;doStuffAndReturnAString(\012 [&amp;](const auto &amp;result) {\012                    EXPECT_EQ(expected, result);\012 }));\012})<SUB>591</SUB>> ]
+"773" [label = <(UNKNOWN,TEST_F(HidlTest, BazMapThisVectorMethodTest) {\012    hidl_vec&lt;int32_t&gt; vec_param, expected;\012    vec_param.resize(15);\012    expected.resize(15);\012\012 for (size_t i = 0; i &lt; 15; ++i) {\012        vec_param[i] = i;\012        expected[i] = 2 * i;\012 }\012\012    EXPECT_OK(\012            baz-&gt;mapThisVector(\012                vec_param,\012 [&amp;](const auto &amp;result) {\012                    EXPECT_EQ(expected, result);\012 }));\012},TEST_F(HidlTest, BazMapThisVectorMethodTest) {\012    hidl_vec&lt;int32_t&gt; vec_param, expected;\012    vec_param.resize(15);\012    expected.resize(15);\012\012 for (size_t i = 0; i &lt; 15; ++i) {\012        vec_param[i] = i;\012        expected[i] = 2 * i;\012 }\012\012    EXPECT_OK(\012            baz-&gt;mapThisVector(\012                vec_param,\012 [&amp;](const auto &amp;result) {\012                    EXPECT_EQ(expected, result);\012 }));\012})<SUB>600</SUB>> ]
+"774" [label = <(UNKNOWN,TEST_F(HidlTest, BazCallMeMethodTest) {\012    EXPECT_OK(baz-&gt;callMe(new BazCallback()));\012},TEST_F(HidlTest, BazCallMeMethodTest) {\012    EXPECT_OK(baz-&gt;callMe(new BazCallback()));\012})<SUB>618</SUB>> ]
+"775" [label = <(UNKNOWN,TEST_F(HidlTest, BazCallMeLaterMethodTest) {\012    EXPECT_OK(baz-&gt;callMeLater(new BazCallback()));\012    EXPECT_OK(baz-&gt;iAmFreeNow());\012},TEST_F(HidlTest, BazCallMeLaterMethodTest) {\012    EXPECT_OK(baz-&gt;callMeLater(new BazCallback()));\012    EXPECT_OK(baz-&gt;iAmFreeNow());\012})<SUB>622</SUB>> ]
+"776" [label = <(UNKNOWN,TEST_F(HidlTest, BazUseAnEnumMethodTest) {\012 auto result = baz-&gt;useAnEnum(IBaz::SomeEnum::bar);\012\012    EXPECT_OK(result);\012    EXPECT_TRUE(result == IBaz::SomeEnum::quux);\012},TEST_F(HidlTest, BazUseAnEnumMethodTest) {\012 auto result = baz-&gt;useAnEnum(IBaz::SomeEnum::bar);\012\012    EXPECT_OK(result);\012    EXPECT_TRUE(result == IBaz::SomeEnum::quux);\012})<SUB>627</SUB>> ]
+"777" [label = <(UNKNOWN,TEST_F(HidlTest, BazHaveSomeStringsMethodTest) {\012    hidl_array&lt;hidl_string, 3&gt; string_params;\012    string_params[0] = &quot;one&quot;;\012    string_params[1] = &quot;two&quot;;\012    string_params[2] = &quot;three&quot;;\012\012    hidl_array&lt;hidl_string, 2&gt; expected;\012    expected[0] = &quot;Hello&quot;;\012    expected[1] = &quot;World&quot;;\012\012    EXPECT_OK(\012            baz-&gt;haveSomeStrings(\012                string_params,\012 [&amp;](const auto &amp;result) {\012                    EXPECT_EQ(expected, result);\012 }));\012},TEST_F(HidlTest, BazHaveSomeStringsMethodTest) {\012    hidl_array&lt;hidl_string, 3&gt; string_params;\012    string_params[0] = &quot;one&quot;;\012    string_params[1] = &quot;two&quot;;\012    string_params[2] = &quot;three&quot;;\012\012    hidl_array&lt;hidl_string, 2&gt; expected;\012    expected[0] = &quot;Hello&quot;;\012    expected[1] = &quot;World&quot;;\012\012    EXPECT_OK(\012            baz-&gt;haveSomeStrings(\012                string_params,\012 [&amp;](const auto &amp;result) {\012                    EXPECT_EQ(expected, result);\012 }));\012})<SUB>634</SUB>> ]
+"778" [label = <(UNKNOWN,TEST_F(HidlTest, BazHaveAStringVecMethodTest) {\012    hidl_vec&lt;hidl_string&gt; string_vec{ &quot;Uno&quot;, &quot;Dos&quot;, &quot;Tres&quot;, &quot;Cuatro&quot; };\012    hidl_vec&lt;hidl_string&gt; expected{&quot;Hello&quot;, &quot;World&quot;};\012\012    EXPECT_OK(\012            baz-&gt;haveAStringVec(\012                string_vec,\012 [&amp;](const auto &amp;result) {\012                    EXPECT_EQ(expected, result);\012 }));\012},TEST_F(HidlTest, BazHaveAStringVecMethodTest) {\012    hidl_vec&lt;hidl_string&gt; string_vec{ &quot;Uno&quot;, &quot;Dos&quot;, &quot;Tres&quot;, &quot;Cuatro&quot; };\012    hidl_vec&lt;hidl_string&gt; expected{&quot;Hello&quot;, &quot;World&quot;};\012\012    EXPECT_OK(\012            baz-&gt;haveAStringVec(\012                string_vec,\012 [&amp;](const auto &amp;result) {\012                    EXPECT_EQ(expected, result);\012 }));\012})<SUB>652</SUB>> ]
+"779" [label = <(UNKNOWN,TEST_F(HidlTest, BazRepeatBitfieldVecTest) {\012    hidl_vec&lt;uint8_t&gt; vec{0 | IBaz::BitField::V1, 0 | IBaz::BitField::V2};\012\012    EXPECT_OK(baz-&gt;repeatBitfieldVec(vec, [&amp;](const auto&amp; result) { EXPECT_EQ(vec, result); }));\012},TEST_F(HidlTest, BazRepeatBitfieldVecTest) {\012    hidl_vec&lt;uint8_t&gt; vec{0 | IBaz::BitField::V1, 0 | IBaz::BitField::V2};\012\012    EXPECT_OK(baz-&gt;repeatBitfieldVec(vec, [&amp;](const auto&amp; result) { EXPECT_EQ(vec, result); }));\012})<SUB>664</SUB>> ]
+"780" [label = <(UNKNOWN,TEST_F(HidlTest, BazReturnABunchOfStringsMethodTest) {\012    std::string expectedA = &quot;Eins&quot;;\012    std::string expectedB = &quot;Zwei&quot;;\012    std::string expectedC = &quot;Drei&quot;;\012    EXPECT_OK(\012            baz-&gt;returnABunchOfStrings(\012 [&amp;](const auto &amp;a, const auto &amp;b, const auto &amp;c) {\012                    EXPECT_EQ(a, expectedA);\012                    EXPECT_EQ(b, expectedB);\012                    EXPECT_EQ(c, expectedC);\012 }));\012},TEST_F(HidlTest, BazReturnABunchOfStringsMethodTest) {\012    std::string expectedA = &quot;Eins&quot;;\012    std::string expectedB = &quot;Zwei&quot;;\012    std::string expectedC = &quot;Drei&quot;;\012    EXPECT_OK(\012            baz-&gt;returnABunchOfStrings(\012 [&amp;](const auto &amp;a, const auto &amp;b, const auto &amp;c) {\012                    EXPECT_EQ(a, expectedA);\012                    EXPECT_EQ(b, expectedB);\012                    EXPECT_EQ(c, expectedC);\012 }));\012})<SUB>670</SUB>> ]
+"781" [label = <(UNKNOWN,TEST_F(HidlTest, BazTestArrays) {\012 IBase::LotsOfPrimitiveArrays in;\012\012 for (size_t i = 0; i &lt; 128; ++i) {\012        in.byte1[i] = i;\012        in.boolean1[i] = (i &amp; 4) != 0;\012        in.double1[i] = i;\012 }\012\012 size_t k = 0;\012 for (size_t i = 0; i &lt; 8; ++i) {\012 for (size_t j = 0; j &lt; 128; ++j, ++k) {\012            in.byte2[i][j] = k;\012            in.boolean2[i][j] = (k &amp; 4) != 0;\012            in.double2[i][j] = k;\012 }\012 }\012\012 size_t m = 0;\012 for (size_t i = 0; i &lt; 8; ++i) {\012 for (size_t j = 0; j &lt; 16; ++j) {\012 for (size_t k = 0; k &lt; 128; ++k, ++m) {\012                in.byte3[i][j][k] = m;\012                in.boolean3[i][j][k] = (m &amp; 4) != 0;\012                in.double3[i][j][k] = m;\012 }\012 }\012 }\012\012    EXPECT_OK(\012            baz-&gt;testArrays(in,\012 [&amp;](const auto &amp;out) {\012                    EXPECT_EQ(in, out);\012 }));\012},TEST_F(HidlTest, BazTestArrays) {\012 IBase::LotsOfPrimitiveArrays in;\012\012 for (size_t i = 0; i &lt; 128; ++i) {\012        in.byte1[i] = i;\012        in.boolean1[i] = (i &amp; 4) != 0;\012        in.double1[i] = i;\012 }\012\012 size_t k = 0;\012 for (size_t i = 0; i &lt; 8; ++i) {\012 for (size_t j = 0; j &lt; 128; ++j, ++k) {\012            in.byte2[i][j] = k;\012            in.boolean2[i][j] = (k &amp; 4) != 0;\012            in.double2[i][j] = k;\012 }\012 }\012\012 size_t m = 0;\012 for (size_t i = 0; i &lt; 8; ++i) {\012 for (size_t j = 0; j &lt; 16; ++j) {\012 for (size_t k = 0; k &lt; 128; ++k, ++m) {\012                in.byte3[i][j][k] = m;\012                in.boolean3[i][j][k] = (m &amp; 4) != 0;\012                in.double3[i][j][k] = m;\012 }\012 }\012 }\012\012    EXPECT_OK(\012            baz-&gt;testArrays(in,\012 [&amp;](const auto &amp;out) {\012                    EXPECT_EQ(in, out);\012 }));\012})<SUB>683</SUB>> ]
+"782" [label = <(UNKNOWN,TEST_F(HidlTest, BazTestByteVecs) {\012    hidl_vec&lt;IBase::ByteOneDim&gt; in;\012    in.resize(8);\012\012 size_t k = 0;\012 for (size_t i = 0; i &lt; in.size(); ++i) {\012 for (size_t j = 0; j &lt; 128; ++j, ++k) {\012            in[i][j] = k;\012 }\012 }\012\012    EXPECT_OK(baz-&gt;testByteVecs(\012                in, [&amp;](const auto &amp;out) { EXPECT_EQ(in, out); }));\012},TEST_F(HidlTest, BazTestByteVecs) {\012    hidl_vec&lt;IBase::ByteOneDim&gt; in;\012    in.resize(8);\012\012 size_t k = 0;\012 for (size_t i = 0; i &lt; in.size(); ++i) {\012 for (size_t j = 0; j &lt; 128; ++j, ++k) {\012            in[i][j] = k;\012 }\012 }\012\012    EXPECT_OK(baz-&gt;testByteVecs(\012                in, [&amp;](const auto &amp;out) { EXPECT_EQ(in, out); }));\012})<SUB>719</SUB>> ]
+"783" [label = <(UNKNOWN,TEST_F(HidlTest, BazTestBooleanVecs) {\012    hidl_vec&lt;IBase::BooleanOneDim&gt; in;\012    in.resize(8);\012\012 size_t k = 0;\012 for (size_t i = 0; i &lt; in.size(); ++i) {\012 for (size_t j = 0; j &lt; 128; ++j, ++k) {\012            in[i][j] = (k &amp; 4) != 0;\012 }\012 }\012\012    EXPECT_OK(baz-&gt;testBooleanVecs(\012                in, [&amp;](const auto &amp;out) { EXPECT_EQ(in, out); }));\012},TEST_F(HidlTest, BazTestBooleanVecs) {\012    hidl_vec&lt;IBase::BooleanOneDim&gt; in;\012    in.resize(8);\012\012 size_t k = 0;\012 for (size_t i = 0; i &lt; in.size(); ++i) {\012 for (size_t j = 0; j &lt; 128; ++j, ++k) {\012            in[i][j] = (k &amp; 4) != 0;\012 }\012 }\012\012    EXPECT_OK(baz-&gt;testBooleanVecs(\012                in, [&amp;](const auto &amp;out) { EXPECT_EQ(in, out); }));\012})<SUB>734</SUB>> ]
+"784" [label = <(UNKNOWN,TEST_F(HidlTest, BazTestDoubleVecs) {\012    hidl_vec&lt;IBase::DoubleOneDim&gt; in;\012    in.resize(8);\012\012 size_t k = 0;\012 for (size_t i = 0; i &lt; in.size(); ++i) {\012 for (size_t j = 0; j &lt; 128; ++j, ++k) {\012            in[i][j] = k;\012 }\012 }\012\012    EXPECT_OK(baz-&gt;testDoubleVecs(\012                in, [&amp;](const auto &amp;out) { EXPECT_EQ(in, out); }));\012},TEST_F(HidlTest, BazTestDoubleVecs) {\012    hidl_vec&lt;IBase::DoubleOneDim&gt; in;\012    in.resize(8);\012\012 size_t k = 0;\012 for (size_t i = 0; i &lt; in.size(); ++i) {\012 for (size_t j = 0; j &lt; 128; ++j, ++k) {\012            in[i][j] = k;\012 }\012 }\012\012    EXPECT_OK(baz-&gt;testDoubleVecs(\012                in, [&amp;](const auto &amp;out) { EXPECT_EQ(in, out); }));\012})<SUB>749</SUB>> ]
+"785" [label = <(UNKNOWN,TEST_F(HidlTest, TwowayMethodOnewayEnabledTest) {\012 using ::android::hardware::IBinder;\012 using ::android::hardware::Parcel;\012\012    sp&lt;IBinder&gt; binder = ::android::hardware::toBinder(baz);\012\012 Parcel request, reply;\012    EXPECT_EQ(::android::OK, request.writeInterfaceToken(IBaz::descriptor));\012    EXPECT_EQ(::android::OK, request.writeInt64(1234));\012 // IBaz::doThatAndReturnSomething is two-way but we call it using FLAG_ONEWAY.\012    EXPECT_EQ(::android::OK, binder-&gt;transact(18 /*doThatAndReturnSomething*/, request, &amp;reply,\012 IBinder::FLAG_ONEWAY));\012\012 ::android::hardware::Status status;\012    EXPECT_EQ(::android::NOT_ENOUGH_DATA, ::android::hardware::readFromParcel(&amp;status, reply));\012    EXPECT_EQ(::android::hardware::Status::EX_TRANSACTION_FAILED, status.exceptionCode());\012\012    EXPECT_OK(baz-&gt;ping()); // still works\012},TEST_F(HidlTest, TwowayMethodOnewayEnabledTest) {\012 using ::android::hardware::IBinder;\012 using ::android::hardware::Parcel;\012\012    sp&lt;IBinder&gt; binder = ::android::hardware::toBinder(baz);\012\012 Parcel request, reply;\012    EXPECT_EQ(::android::OK, request.writeInterfaceToken(IBaz::descriptor));\012    EXPECT_EQ(::android::OK, request.writeInt64(1234));\012 // IBaz::doThatAndReturnSomething is two-way but we call it using FLAG_ONEWAY.\012    EXPECT_EQ(::android::OK, binder-&gt;transact(18 /*doThatAndReturnSomething*/, request, &amp;reply,\012 IBinder::FLAG_ONEWAY));\012\012 ::android::hardware::Status status;\012    EXPECT_EQ(::android::NOT_ENOUGH_DATA, ::android::hardware::readFromParcel(&amp;status, reply));\012    EXPECT_EQ(::android::hardware::Status::EX_TRANSACTION_FAILED, status.exceptionCode());\012\012    EXPECT_OK(baz-&gt;ping()); // still works\012})<SUB>764</SUB>> ]
+"786" [label = <(UNKNOWN,TEST_F(HidlTest, OnewayMethodOnewayDisabledTest) {\012 using ::android::hardware::IBinder;\012 using ::android::hardware::Parcel;\012\012    sp&lt;IBinder&gt; binder = ::android::hardware::toBinder(baz);\012\012 Parcel request, reply;\012    EXPECT_EQ(::android::OK, request.writeInterfaceToken(IBaz::descriptor));\012    EXPECT_EQ(::android::OK, request.writeFloat(1.0f));\012 // IBaz::doThis is oneway but we call it without using FLAG_ONEWAY.\012    EXPECT_EQ(\012 // Expect UNKNOWN_ERROR because the JNI class JHwBinder always sets\012 // the reply to UNKNOWN_ERROR for two-way transactions if the\012 // transaction itself did not send a reply.\012 ::android::UNKNOWN_ERROR,\012            binder-&gt;transact(17 /*doThis*/, request, &amp;reply, 0 /* Not FLAG_ONEWAY */));\012\012    EXPECT_OK(baz-&gt;ping()); // still works\012},TEST_F(HidlTest, OnewayMethodOnewayDisabledTest) {\012 using ::android::hardware::IBinder;\012 using ::android::hardware::Parcel;\012\012    sp&lt;IBinder&gt; binder = ::android::hardware::toBinder(baz);\012\012 Parcel request, reply;\012    EXPECT_EQ(::android::OK, request.writeInterfaceToken(IBaz::descriptor));\012    EXPECT_EQ(::android::OK, request.writeFloat(1.0f));\012 // IBaz::doThis is oneway but we call it without using FLAG_ONEWAY.\012    EXPECT_EQ(\012 // Expect UNKNOWN_ERROR because the JNI class JHwBinder always sets\012 // the reply to UNKNOWN_ERROR for two-way transactions if the\012 // transaction itself did not send a reply.\012 ::android::UNKNOWN_ERROR,\012            binder-&gt;transact(17 /*doThis*/, request, &amp;reply, 0 /* Not FLAG_ONEWAY */));\012\012    EXPECT_OK(baz-&gt;ping()); // still works\012})<SUB>784</SUB>> ]
+"787" [label = <(UNKNOWN,TEST_F(HidlTest, SafeUnionNoInitTest) {\012    EXPECT_OK(safeunionInterface-&gt;newLargeSafeUnion([&amp;](const LargeSafeUnion&amp; safeUnion) {\012        EXPECT_EQ(LargeSafeUnion::hidl_discriminator::noinit, safeUnion.getDiscriminator());\012 }));\012},TEST_F(HidlTest, SafeUnionNoInitTest) {\012    EXPECT_OK(safeunionInterface-&gt;newLargeSafeUnion([&amp;](const LargeSafeUnion&amp; safeUnion) {\012        EXPECT_EQ(LargeSafeUnion::hidl_discriminator::noinit, safeUnion.getDiscriminator());\012 }));\012})<SUB>804</SUB>> ]
+"788" [label = <(UNKNOWN,TEST_F(HidlTest, SafeUnionSimpleTest) {\012    EXPECT_OK(safeunionInterface-&gt;newLargeSafeUnion([&amp;](const LargeSafeUnion&amp; safeUnion) {\012        EXPECT_OK(safeunionInterface-&gt;setA(safeUnion, -5, [&amp;](const LargeSafeUnion&amp; safeUnion) {\012            EXPECT_EQ(LargeSafeUnion::hidl_discriminator::a, safeUnion.getDiscriminator());\012            EXPECT_EQ(-5, safeUnion.a());\012\012 uint64_t max = std::numeric_limits&lt;uint64_t&gt;::max();\012            EXPECT_OK(\012                safeunionInterface-&gt;setD(safeUnion, max, [&amp;](const LargeSafeUnion&amp; safeUnion) {\012                    EXPECT_EQ(LargeSafeUnion::hidl_discriminator::d, safeUnion.getDiscriminator());\012                    EXPECT_EQ(max, safeUnion.d());\012 }));\012 }));\012 }));\012},TEST_F(HidlTest, SafeUnionSimpleTest) {\012    EXPECT_OK(safeunionInterface-&gt;newLargeSafeUnion([&amp;](const LargeSafeUnion&amp; safeUnion) {\012        EXPECT_OK(safeunionInterface-&gt;setA(safeUnion, -5, [&amp;](const LargeSafeUnion&amp; safeUnion) {\012            EXPECT_EQ(LargeSafeUnion::hidl_discriminator::a, safeUnion.getDiscriminator());\012            EXPECT_EQ(-5, safeUnion.a());\012\012 uint64_t max = std::numeric_limits&lt;uint64_t&gt;::max();\012            EXPECT_OK(\012                safeunionInterface-&gt;setD(safeUnion, max, [&amp;](const LargeSafeUnion&amp; safeUnion) {\012                    EXPECT_EQ(LargeSafeUnion::hidl_discriminator::d, safeUnion.getDiscriminator());\012                    EXPECT_EQ(max, safeUnion.d());\012 }));\012 }));\012 }));\012})<SUB>810</SUB>> ]
+"789" [label = <(UNKNOWN,TEST_F(HidlTest, SafeUnionArrayLikeTypesTest) {\012 const std::array&lt;int64_t, 5&gt; testArray{1, -2, 3, -4, 5};\012 const hidl_vec&lt;uint64_t&gt; testVector{std::numeric_limits&lt;uint64_t&gt;::max()};\012\012    EXPECT_OK(safeunionInterface-&gt;newLargeSafeUnion([&amp;](const LargeSafeUnion&amp; safeUnion) {\012        EXPECT_OK(\012            safeunionInterface-&gt;setF(safeUnion, testArray, [&amp;](const LargeSafeUnion&amp; safeUnion) {\012                EXPECT_EQ(LargeSafeUnion::hidl_discriminator::f, safeUnion.getDiscriminator());\012\012 for (size_t i = 0; i &lt; testArray.size(); i++) {\012                    EXPECT_EQ(testArray[i], safeUnion.f()[i]);\012 }\012 }));\012\012        EXPECT_OK(\012            safeunionInterface-&gt;setI(safeUnion, testVector, [&amp;](const LargeSafeUnion&amp; safeUnion) {\012                EXPECT_EQ(LargeSafeUnion::hidl_discriminator::i, safeUnion.getDiscriminator());\012                EXPECT_EQ(testVector, safeUnion.i());\012 }));\012 }));\012},TEST_F(HidlTest, SafeUnionArrayLikeTypesTest) {\012 const std::array&lt;int64_t, 5&gt; testArray{1, -2, 3, -4, 5};\012 const hidl_vec&lt;uint64_t&gt; testVector{std::numeric_limits&lt;uint64_t&gt;::max()};\012\012    EXPECT_OK(safeunionInterface-&gt;newLargeSafeUnion([&amp;](const LargeSafeUnion&amp; safeUnion) {\012        EXPECT_OK(\012            safeunionInterface-&gt;setF(safeUnion, testArray, [&amp;](const LargeSafeUnion&amp; safeUnion) {\012                EXPECT_EQ(LargeSafeUnion::hidl_discriminator::f, safeUnion.getDiscriminator());\012\012 for (size_t i = 0; i &lt; testArray.size(); i++) {\012                    EXPECT_EQ(testArray[i], safeUnion.f()[i]);\012 }\012 }));\012\012        EXPECT_OK(\012            safeunionInterface-&gt;setI(safeUnion, testVector, [&amp;](const LargeSafeUnion&amp; safeUnion) {\012                EXPECT_EQ(LargeSafeUnion::hidl_discriminator::i, safeUnion.getDiscriminator());\012                EXPECT_EQ(testVector, safeUnion.i());\012 }));\012 }));\012})<SUB>826</SUB>> ]
+"790" [label = <(UNKNOWN,TEST_F(HidlTest, SafeUnionStringTypeTest) {\012 const std::string testString =\012 &quot;This is an inordinately long test string to exercise hidl_string types in safe unions.&quot;;\012\012    EXPECT_OK(safeunionInterface-&gt;newLargeSafeUnion([&amp;](const LargeSafeUnion&amp; safeUnion) {\012        EXPECT_OK(safeunionInterface-&gt;setG(\012            safeUnion, hidl_string(testString), [&amp;](const LargeSafeUnion&amp; safeUnion) {\012                EXPECT_EQ(LargeSafeUnion::hidl_discriminator::g, safeUnion.getDiscriminator());\012                EXPECT_EQ(testString, std::string(safeUnion.g()));\012 }));\012 }));\012},TEST_F(HidlTest, SafeUnionStringTypeTest) {\012 const std::string testString =\012 &quot;This is an inordinately long test string to exercise hidl_string types in safe unions.&quot;;\012\012    EXPECT_OK(safeunionInterface-&gt;newLargeSafeUnion([&amp;](const LargeSafeUnion&amp; safeUnion) {\012        EXPECT_OK(safeunionInterface-&gt;setG(\012            safeUnion, hidl_string(testString), [&amp;](const LargeSafeUnion&amp; safeUnion) {\012                EXPECT_EQ(LargeSafeUnion::hidl_discriminator::g, safeUnion.getDiscriminator());\012                EXPECT_EQ(testString, std::string(safeUnion.g()));\012 }));\012 }));\012})<SUB>848</SUB>> ]
+"791" [label = <(UNKNOWN,TEST_F(HidlTest, SafeUnionNestedTest) {\012 SmallSafeUnion smallSafeUnion;\012    smallSafeUnion.a(1);\012\012    EXPECT_OK(safeunionInterface-&gt;newLargeSafeUnion([&amp;](const LargeSafeUnion&amp; safeUnion) {\012        EXPECT_OK(safeunionInterface-&gt;setL(\012            safeUnion, smallSafeUnion, [&amp;](const LargeSafeUnion&amp; safeUnion) {\012                EXPECT_EQ(LargeSafeUnion::hidl_discriminator::l, safeUnion.getDiscriminator());\012\012                EXPECT_EQ(SmallSafeUnion::hidl_discriminator::a, safeUnion.l().getDiscriminator());\012                EXPECT_EQ(1, safeUnion.l().a());\012 }));\012 }));\012},TEST_F(HidlTest, SafeUnionNestedTest) {\012 SmallSafeUnion smallSafeUnion;\012    smallSafeUnion.a(1);\012\012    EXPECT_OK(safeunionInterface-&gt;newLargeSafeUnion([&amp;](const LargeSafeUnion&amp; safeUnion) {\012        EXPECT_OK(safeunionInterface-&gt;setL(\012            safeUnion, smallSafeUnion, [&amp;](const LargeSafeUnion&amp; safeUnion) {\012                EXPECT_EQ(LargeSafeUnion::hidl_discriminator::l, safeUnion.getDiscriminator());\012\012                EXPECT_EQ(SmallSafeUnion::hidl_discriminator::a, safeUnion.l().getDiscriminator());\012                EXPECT_EQ(1, safeUnion.l().a());\012 }));\012 }));\012})<SUB>861</SUB>> ]
+"866" [label = <(UNKNOWN,TEST_F(HidlTest, SafeUnionInterfaceNullHandleTest) {\012 InterfaceTypeSafeUnion safeUnion;\012\012    EXPECT_OK(safeunionInterface-&gt;setInterfaceF(\012        safeUnion, hidl_handle(nullptr), [&amp;](const InterfaceTypeSafeUnion&amp; safeUnion) {\012            EXPECT_EQ(InterfaceTypeSafeUnion::hidl_discriminator::f,\012                      safeUnion.getDiscriminator());\012\012            checkNativeHandlesDataEquality(nullptr, safeUnion.f().getNativeHandle());\012 }));\012},TEST_F(HidlTest, SafeUnionInterfaceNullHandleTest) {\012 InterfaceTypeSafeUnion safeUnion;\012\012    EXPECT_OK(safeunionInterface-&gt;setInterfaceF(\012        safeUnion, hidl_handle(nullptr), [&amp;](const InterfaceTypeSafeUnion&amp; safeUnion) {\012            EXPECT_EQ(InterfaceTypeSafeUnion::hidl_discriminator::f,\012                      safeUnion.getDiscriminator());\012\012            checkNativeHandlesDataEquality(nullptr, safeUnion.f().getNativeHandle());\012 }));\012})<SUB>894</SUB>> ]
+"867" [label = <(UNKNOWN,TEST_F(HidlTest, SafeUnionInterfaceTest) {\012 const std::array&lt;int8_t, 7&gt; testArray{-1, -2, -3, 0, 1, 2, 3};\012 const hidl_vec&lt;hidl_string&gt; testVector{&quot;So&quot;, &quot;Many&quot;, &quot;Words&quot;};\012 const std::string testStringA = &quot;Hello&quot;;\012 const std::string testStringB = &quot;World&quot;;\012\012 const std::array&lt;int, 6&gt; testHandleData{2, -32, 10, -4329454, 11, 24};\012 native_handle_t* h = native_handle_create(0, testHandleData.size());\012    CHECK(sizeof(testHandleData) == testHandleData.size() * sizeof(int));\012    std::memcpy(h-&gt;data, testHandleData.data(), sizeof(testHandleData));\012\012    std::vector&lt;hidl_handle&gt; testHandlesVector(256);\012 for (size_t i = 0; i &lt; testHandlesVector.size(); i++) {\012        testHandlesVector[i].setTo(native_handle_clone(h), true /* shouldOwn */);\012 }\012\012    EXPECT_OK(\012        safeunionInterface-&gt;newInterfaceTypeSafeUnion([&amp;](const InterfaceTypeSafeUnion&amp; safeUnion) {\012            EXPECT_EQ(InterfaceTypeSafeUnion::hidl_discriminator::noinit,\012                      safeUnion.getDiscriminator());\012\012            EXPECT_OK(safeunionInterface-&gt;setInterfaceB(\012                safeUnion, testArray, [&amp;](const InterfaceTypeSafeUnion&amp; safeUnion) {\012                    EXPECT_EQ(InterfaceTypeSafeUnion::hidl_discriminator::b,\012                              safeUnion.getDiscriminator());\012\012 for (size_t i = 0; i &lt; testArray.size(); i++) {\012                        EXPECT_EQ(testArray[i], safeUnion.b()[i]);\012 }\012 }));\012\012            EXPECT_OK(safeunionInterface-&gt;setInterfaceD(\012                safeUnion, testStringA, [&amp;](const InterfaceTypeSafeUnion&amp; safeUnion) {\012                    EXPECT_EQ(InterfaceTypeSafeUnion::hidl_discriminator::d,\012                              safeUnion.getDiscriminator());\012                    EXPECT_EQ(testStringA, safeUnion.d());\012 }));\012\012            EXPECT_OK(safeunionInterface-&gt;setInterfaceE(\012                safeUnion, testVector, [&amp;](const InterfaceTypeSafeUnion&amp; safeUnion) {\012                    EXPECT_EQ(InterfaceTypeSafeUnion::hidl_discriminator::e,\012                              safeUnion.getDiscriminator());\012                    EXPECT_EQ(testVector, safeUnion.e());\012 }));\012\012            EXPECT_OK(safeunionInterface-&gt;setInterfaceF(\012                safeUnion, hidl_handle(h), [&amp;](const InterfaceTypeSafeUnion&amp; safeUnion) {\012                    EXPECT_EQ(InterfaceTypeSafeUnion::hidl_discriminator::f,\012                              safeUnion.getDiscriminator());\012\012 const native_handle_t* result = safeUnion.f().getNativeHandle();\012                    checkNativeHandlesDataEquality(h, result);\012 }));\012\012            EXPECT_OK(safeunionInterface-&gt;setInterfaceG(\012                safeUnion, testHandlesVector, [&amp;](const InterfaceTypeSafeUnion&amp; safeUnion) {\012                    EXPECT_EQ(InterfaceTypeSafeUnion::hidl_discriminator::g,\012                              safeUnion.getDiscriminator());\012\012 for (size_t i = 0; i &lt; testHandlesVector.size(); i++) {\012                        checkNativeHandlesDataEquality(h, safeUnion.g()[i].getNativeHandle());\012 }\012 }));\012 }));\012\012 // Same-process interface calls are not supported in Java, so we use\012 // a safe_union instance bound to this (client) process instead of\012 // safeunionInterface to exercise this test-case. Ref: b/110957763.\012 InterfaceTypeSafeUnion safeUnion;\012    safeUnion.c(otherInterface);\012\012    EXPECT_EQ(InterfaceTypeSafeUnion::hidl_discriminator::c, safeUnion.getDiscriminator());\012    EXPECT_OK(safeUnion.c()-&gt;concatTwoStrings(\012        hidl_string(testStringA), hidl_string(testStringB), [&amp;](const hidl_string&amp; result) {\012            EXPECT_EQ(testStringA + testStringB, std::string(result));\012 }));\012\012    native_handle_delete(h);\012},TEST_F(HidlTest, SafeUnionInterfaceTest) {\012 const std::array&lt;int8_t, 7&gt; testArray{-1, -2, -3, 0, 1, 2, 3};\012 const hidl_vec&lt;hidl_string&gt; testVector{&quot;So&quot;, &quot;Many&quot;, &quot;Words&quot;};\012 const std::string testStringA = &quot;Hello&quot;;\012 const std::string testStringB = &quot;World&quot;;\012\012 const std::array&lt;int, 6&gt; testHandleData{2, -32, 10, -4329454, 11, 24};\012 native_handle_t* h = native_handle_create(0, testHandleData.size());\012    CHECK(sizeof(testHandleData) == testHandleData.size() * sizeof(int));\012    std::memcpy(h-&gt;data, testHandleData.data(), sizeof(testHandleData));\012\012    std::vector&lt;hidl_handle&gt; testHandlesVector(256);\012 for (size_t i = 0; i &lt; testHandlesVector.size(); i++) {\012        testHandlesVector[i].setTo(native_handle_clone(h), true /* shouldOwn */);\012 }\012\012    EXPECT_OK(\012        safeunionInterface-&gt;newInterfaceTypeSafeUnion([&amp;](const InterfaceTypeSafeUnion&amp; safeUnion) {\012            EXPECT_EQ(InterfaceTypeSafeUnion::hidl_discriminator::noinit,\012                      safeUnion.getDiscriminator());\012\012            EXPECT_OK(safeunionInterface-&gt;setInterfaceB(\012                safeUnion, testArray, [&amp;](const InterfaceTypeSafeUnion&amp; safeUnion) {\012                    EXPECT_EQ(InterfaceTypeSafeUnion::hidl_discriminator::b,\012                              safeUnion.getDiscriminator());\012\012 for (size_t i = 0; i &lt; testArray.size(); i++) {\012                        EXPECT_EQ(testArray[i], safeUnion.b()[i]);\012 }\012 }));\012\012            EXPECT_OK(safeunionInterface-&gt;setInterfaceD(\012                safeUnion, testStringA, [&amp;](const InterfaceTypeSafeUnion&amp; safeUnion) {\012                    EXPECT_EQ(InterfaceTypeSafeUnion::hidl_discriminator::d,\012                              safeUnion.getDiscriminator());\012                    EXPECT_EQ(testStringA, safeUnion.d());\012 }));\012\012            EXPECT_OK(safeunionInterface-&gt;setInterfaceE(\012                safeUnion, testVector, [&amp;](const InterfaceTypeSafeUnion&amp; safeUnion) {\012                    EXPECT_EQ(InterfaceTypeSafeUnion::hidl_discriminator::e,\012                              safeUnion.getDiscriminator());\012                    EXPECT_EQ(testVector, safeUnion.e());\012 }));\012\012            EXPECT_OK(safeunionInterface-&gt;setInterfaceF(\012                safeUnion, hidl_handle(h), [&amp;](const InterfaceTypeSafeUnion&amp; safeUnion) {\012                    EXPECT_EQ(InterfaceTypeSafeUnion::hidl_discriminator::f,\012                              safeUnion.getDiscriminator());\012\012 const native_handle_t* result = safeUnion.f().getNativeHandle();\012                    checkNativeHandlesDataEquality(h, result);\012 }));\012\012            EXPECT_OK(safeunionInterface-&gt;setInterfaceG(\012                safeUnion, testHandlesVector, [&amp;](const InterfaceTypeSafeUnion&amp; safeUnion) {\012                    EXPECT_EQ(InterfaceTypeSafeUnion::hidl_discriminator::g,\012                              safeUnion.getDiscriminator());\012\012 for (size_t i = 0; i &lt; testHandlesVector.size(); i++) {\012                        checkNativeHandlesDataEquality(h, safeUnion.g()[i].getNativeHandle());\012 }\012 }));\012 }));\012\012 // Same-process interface calls are not supported in Java, so we use\012 // a safe_union instance bound to this (client) process instead of\012 // safeunionInterface to exercise this test-case. Ref: b/110957763.\012 InterfaceTypeSafeUnion safeUnion;\012    safeUnion.c(otherInterface);\012\012    EXPECT_EQ(InterfaceTypeSafeUnion::hidl_discriminator::c, safeUnion.getDiscriminator());\012    EXPECT_OK(safeUnion.c()-&gt;concatTwoStrings(\012        hidl_string(testStringA), hidl_string(testStringB), [&amp;](const hidl_string&amp; result) {\012            EXPECT_EQ(testStringA + testStringB, std::string(result));\012 }));\012\012    native_handle_delete(h);\012})<SUB>906</SUB>> ]
+"868" [label = <(UNKNOWN,TEST_F(HidlTest, SafeUnionNullHandleTest) {\012 HandleTypeSafeUnion safeUnion;\012\012    EXPECT_OK(safeunionInterface-&gt;setHandleA(\012        safeUnion, hidl_handle(nullptr), [&amp;](const HandleTypeSafeUnion&amp; safeUnion) {\012            EXPECT_EQ(HandleTypeSafeUnion::hidl_discriminator::a,\012                      safeUnion.getDiscriminator());\012\012            checkNativeHandlesDataEquality(nullptr, safeUnion.a().getNativeHandle());\012 }));\012},TEST_F(HidlTest, SafeUnionNullHandleTest) {\012 HandleTypeSafeUnion safeUnion;\012\012    EXPECT_OK(safeunionInterface-&gt;setHandleA(\012        safeUnion, hidl_handle(nullptr), [&amp;](const HandleTypeSafeUnion&amp; safeUnion) {\012            EXPECT_EQ(HandleTypeSafeUnion::hidl_discriminator::a,\012                      safeUnion.getDiscriminator());\012\012            checkNativeHandlesDataEquality(nullptr, safeUnion.a().getNativeHandle());\012 }));\012})<SUB>986</SUB>> ]
+"869" [label = <(UNKNOWN,TEST_F(HidlTest, SafeUnionSimpleHandleTest) {\012 const std::array&lt;int, 6&gt; testData{2, -32, 10, -4329454, 11, 24};\012 native_handle_t* h = native_handle_create(0, testData.size());\012    ASSERT_EQ(sizeof(testData), testData.size() * sizeof(int));\012    std::memcpy(h-&gt;data, testData.data(), sizeof(testData));\012\012    std::array&lt;hidl_handle, 5&gt; testArray;\012 for (size_t i = 0; i &lt; testArray.size(); i++) {\012        testArray[i].setTo(native_handle_clone(h), true /* shouldOwn */);\012 }\012\012    std::vector&lt;hidl_handle&gt; testVector(256);\012 for (size_t i = 0; i &lt; testVector.size(); i++) {\012        testVector[i].setTo(native_handle_clone(h), true /* shouldOwn */);\012 }\012\012    EXPECT_OK(\012        safeunionInterface-&gt;newHandleTypeSafeUnion([&amp;](const HandleTypeSafeUnion&amp; safeUnion) {\012            EXPECT_OK(safeunionInterface-&gt;setHandleA(\012                safeUnion, hidl_handle(h), [&amp;](const HandleTypeSafeUnion&amp; safeUnion) {\012                    EXPECT_EQ(HandleTypeSafeUnion::hidl_discriminator::a,\012                              safeUnion.getDiscriminator());\012\012                    checkNativeHandlesDataEquality(h, safeUnion.a().getNativeHandle());\012 }));\012\012            EXPECT_OK(safeunionInterface-&gt;setHandleB(\012                safeUnion, testArray, [&amp;](const HandleTypeSafeUnion&amp; safeUnion) {\012                    EXPECT_EQ(HandleTypeSafeUnion::hidl_discriminator::b,\012                              safeUnion.getDiscriminator());\012\012 for (size_t i = 0; i &lt; testArray.size(); i++) {\012                        checkNativeHandlesDataEquality(h, safeUnion.b()[i].getNativeHandle());\012 }\012 }));\012\012            EXPECT_OK(safeunionInterface-&gt;setHandleC(\012                safeUnion, testVector, [&amp;](const HandleTypeSafeUnion&amp; safeUnion) {\012                    EXPECT_EQ(HandleTypeSafeUnion::hidl_discriminator::c,\012                              safeUnion.getDiscriminator());\012\012 for (size_t i = 0; i &lt; testVector.size(); i++) {\012                        checkNativeHandlesDataEquality(h, safeUnion.c()[i].getNativeHandle());\012 }\012 }));\012 }));\012\012    native_handle_delete(h);\012},TEST_F(HidlTest, SafeUnionSimpleHandleTest) {\012 const std::array&lt;int, 6&gt; testData{2, -32, 10, -4329454, 11, 24};\012 native_handle_t* h = native_handle_create(0, testData.size());\012    ASSERT_EQ(sizeof(testData), testData.size() * sizeof(int));\012    std::memcpy(h-&gt;data, testData.data(), sizeof(testData));\012\012    std::array&lt;hidl_handle, 5&gt; testArray;\012 for (size_t i = 0; i &lt; testArray.size(); i++) {\012        testArray[i].setTo(native_handle_clone(h), true /* shouldOwn */);\012 }\012\012    std::vector&lt;hidl_handle&gt; testVector(256);\012 for (size_t i = 0; i &lt; testVector.size(); i++) {\012        testVector[i].setTo(native_handle_clone(h), true /* shouldOwn */);\012 }\012\012    EXPECT_OK(\012        safeunionInterface-&gt;newHandleTypeSafeUnion([&amp;](const HandleTypeSafeUnion&amp; safeUnion) {\012            EXPECT_OK(safeunionInterface-&gt;setHandleA(\012                safeUnion, hidl_handle(h), [&amp;](const HandleTypeSafeUnion&amp; safeUnion) {\012                    EXPECT_EQ(HandleTypeSafeUnion::hidl_discriminator::a,\012                              safeUnion.getDiscriminator());\012\012                    checkNativeHandlesDataEquality(h, safeUnion.a().getNativeHandle());\012 }));\012\012            EXPECT_OK(safeunionInterface-&gt;setHandleB(\012                safeUnion, testArray, [&amp;](const HandleTypeSafeUnion&amp; safeUnion) {\012                    EXPECT_EQ(HandleTypeSafeUnion::hidl_discriminator::b,\012                              safeUnion.getDiscriminator());\012\012 for (size_t i = 0; i &lt; testArray.size(); i++) {\012                        checkNativeHandlesDataEquality(h, safeUnion.b()[i].getNativeHandle());\012 }\012 }));\012\012            EXPECT_OK(safeunionInterface-&gt;setHandleC(\012                safeUnion, testVector, [&amp;](const HandleTypeSafeUnion&amp; safeUnion) {\012                    EXPECT_EQ(HandleTypeSafeUnion::hidl_discriminator::c,\012                              safeUnion.getDiscriminator());\012\012 for (size_t i = 0; i &lt; testVector.size(); i++) {\012                        checkNativeHandlesDataEquality(h, safeUnion.c()[i].getNativeHandle());\012 }\012 }));\012 }));\012\012    native_handle_delete(h);\012})<SUB>998</SUB>> ]
+"870" [label = <(UNKNOWN,TEST_F(HidlTest, SafeUnionVecOfHandlesWithOneFdTest) {\012 const std::vector&lt;std::string&gt; testStrings{&quot;This &quot;, &quot;is &quot;, &quot;so &quot;, &quot;much &quot;, &quot;data!\n&quot;};\012 const std::string testFileName = &quot;/data/local/tmp/SafeUnionVecOfHandlesWithOneFdTest&quot;;\012 const std::array&lt;int, 6&gt; testData{2, -32, 10, -4329454, 11, 24};\012    ASSERT_EQ(sizeof(testData), testData.size() * sizeof(int));\012\012 const std::string goldenResult = std::accumulate(testStrings.begin(),\012                                                     testStrings.end(),\012                                                     std::string());\012\012 int fd = open(testFileName.c_str(), (O_RDWR | O_TRUNC | O_CREAT), (S_IRUSR | S_IWUSR));\012    ASSERT_TRUE(fd &gt;= 0);\012\012    native_handle* h = native_handle_create(1 /* numFds */, testData.size() /* numInts */);\012    std::memcpy(&amp;(h-&gt;data[1]), testData.data(), sizeof(testData));\012    h-&gt;data[0] = fd;\012\012    hidl_vec&lt;hidl_handle&gt; testHandles(testStrings.size());\012 for (size_t i = 0; i &lt; testHandles.size(); i++) {\012        testHandles[i].setTo(native_handle_clone(h), true /* shouldOwn */);\012 }\012\012    EXPECT_OK(\012        safeunionInterface-&gt;newHandleTypeSafeUnion([&amp;](const HandleTypeSafeUnion&amp; safeUnion) {\012            EXPECT_OK(safeunionInterface-&gt;setHandleC(\012                safeUnion, testHandles, [&amp;](const HandleTypeSafeUnion&amp; safeUnion) {\012                    EXPECT_EQ(HandleTypeSafeUnion::hidl_discriminator::c,\012                              safeUnion.getDiscriminator());\012\012 for (size_t i = 0; i &lt; safeUnion.c().size(); i++) {\012 const native_handle_t* reference = testHandles[i].getNativeHandle();\012 const native_handle_t* result = safeUnion.c()[i].getNativeHandle();\012                        checkNativeHandlesDataEquality(reference, result);\012\012 // Original FDs should be dup'd\012 int resultFd = result-&gt;data[0];\012                        EXPECT_NE(reference-&gt;data[0], resultFd);\012\012                        EXPECT_TRUE(android::base::WriteStringToFd(testStrings[i], resultFd));\012                        EXPECT_EQ(0, fsync(resultFd));\012 }\012 }));\012 }));\012\012    std::string result;\012    lseek(fd, 0, SEEK_SET);\012\012    EXPECT_TRUE(android::base::ReadFdToString(fd, &amp;result));\012    EXPECT_EQ(goldenResult, result);\012\012    native_handle_delete(h);\012    EXPECT_EQ(0, close(fd));\012    EXPECT_EQ(0, remove(testFileName.c_str()));\012},TEST_F(HidlTest, SafeUnionVecOfHandlesWithOneFdTest) {\012 const std::vector&lt;std::string&gt; testStrings{&quot;This &quot;, &quot;is &quot;, &quot;so &quot;, &quot;much &quot;, &quot;data!\n&quot;};\012 const std::string testFileName = &quot;/data/local/tmp/SafeUnionVecOfHandlesWithOneFdTest&quot;;\012 const std::array&lt;int, 6&gt; testData{2, -32, 10, -4329454, 11, 24};\012    ASSERT_EQ(sizeof(testData), testData.size() * sizeof(int));\012\012 const std::string goldenResult = std::accumulate(testStrings.begin(),\012                                                     testStrings.end(),\012                                                     std::string());\012\012 int fd = open(testFileName.c_str(), (O_RDWR | O_TRUNC | O_CREAT), (S_IRUSR | S_IWUSR));\012    ASSERT_TRUE(fd &gt;= 0);\012\012    native_handle* h = native_handle_create(1 /* numFds */, testData.size() /* numInts */);\012    std::memcpy(&amp;(h-&gt;data[1]), testData.data(), sizeof(testData));\012    h-&gt;data[0] = fd;\012\012    hidl_vec&lt;hidl_handle&gt; testHandles(testStrings.size());\012 for (size_t i = 0; i &lt; testHandles.size(); i++) {\012        testHandles[i].setTo(native_handle_clone(h), true /* shouldOwn */);\012 }\012\012    EXPECT_OK(\012        safeunionInterface-&gt;newHandleTypeSafeUnion([&amp;](const HandleTypeSafeUnion&amp; safeUnion) {\012            EXPECT_OK(safeunionInterface-&gt;setHandleC(\012                safeUnion, testHandles, [&amp;](const HandleTypeSafeUnion&amp; safeUnion) {\012                    EXPECT_EQ(HandleTypeSafeUnion::hidl_discriminator::c,\012                              safeUnion.getDiscriminator());\012\012 for (size_t i = 0; i &lt; safeUnion.c().size(); i++) {\012 const native_handle_t* reference = testHandles[i].getNativeHandle();\012 const native_handle_t* result = safeUnion.c()[i].getNativeHandle();\012                        checkNativeHandlesDataEquality(reference, result);\012\012 // Original FDs should be dup'd\012 int resultFd = result-&gt;data[0];\012                        EXPECT_NE(reference-&gt;data[0], resultFd);\012\012                        EXPECT_TRUE(android::base::WriteStringToFd(testStrings[i], resultFd));\012                        EXPECT_EQ(0, fsync(resultFd));\012 }\012 }));\012 }));\012\012    std::string result;\012    lseek(fd, 0, SEEK_SET);\012\012    EXPECT_TRUE(android::base::ReadFdToString(fd, &amp;result));\012    EXPECT_EQ(goldenResult, result);\012\012    native_handle_delete(h);\012    EXPECT_EQ(0, close(fd));\012    EXPECT_EQ(0, remove(testFileName.c_str()));\012})<SUB>1048</SUB>> ]
+"871" [label = <(UNKNOWN,TEST_F(HidlTest, SafeUnionHandleWithMultipleFdsTest) {\012 const std::vector&lt;std::string&gt; testStrings{&quot;This &quot;, &quot;is &quot;, &quot;so &quot;, &quot;much &quot;, &quot;data!\n&quot;};\012 const std::string testFileName = &quot;/data/local/tmp/SafeUnionHandleWithMultipleFdsTest&quot;;\012 const std::array&lt;int, 6&gt; testData{2, -32, 10, -4329454, 11, 24};\012    ASSERT_EQ(sizeof(testData), testData.size() * sizeof(int));\012\012 const std::string goldenResult = std::accumulate(testStrings.begin(),\012                                                     testStrings.end(),\012                                                     std::string());\012\012 int fd = open(testFileName.c_str(), (O_RDWR | O_TRUNC | O_CREAT), (S_IRUSR | S_IWUSR));\012    ASSERT_TRUE(fd &gt;= 0);\012\012 const int numFds = testStrings.size();\012    native_handle* h = native_handle_create(numFds, testData.size() /* numInts */);\012    std::memcpy(&amp;(h-&gt;data[numFds]), testData.data(), sizeof(testData));\012 for (size_t i = 0; i &lt; numFds; i++) {\012        h-&gt;data[i] = fd;\012 }\012\012    hidl_handle testHandle;\012    testHandle.setTo(h, false /* shouldOwn */);\012\012    EXPECT_OK(\012        safeunionInterface-&gt;newHandleTypeSafeUnion([&amp;](const HandleTypeSafeUnion&amp; safeUnion) {\012            EXPECT_OK(safeunionInterface-&gt;setHandleA(\012                safeUnion, testHandle, [&amp;](const HandleTypeSafeUnion&amp; safeUnion) {\012                    EXPECT_EQ(HandleTypeSafeUnion::hidl_discriminator::a,\012                              safeUnion.getDiscriminator());\012\012 const native_handle_t* result = safeUnion.a().getNativeHandle();\012                    checkNativeHandlesDataEquality(h, result);\012\012 for (size_t i = 0; i &lt; result-&gt;numFds; i++) {\012 // Original FDs should be dup'd\012 int resultFd = result-&gt;data[i];\012                        EXPECT_NE(h-&gt;data[i], resultFd);\012\012                        EXPECT_TRUE(android::base::WriteStringToFd(testStrings[i], resultFd));\012                        EXPECT_EQ(0, fsync(resultFd));\012 }\012 }));\012 }));\012\012    std::string result;\012    lseek(fd, 0, SEEK_SET);\012\012    EXPECT_TRUE(android::base::ReadFdToString(fd, &amp;result));\012    EXPECT_EQ(goldenResult, result);\012\012    native_handle_delete(h);\012    EXPECT_EQ(0, close(fd));\012    EXPECT_EQ(0, remove(testFileName.c_str()));\012},TEST_F(HidlTest, SafeUnionHandleWithMultipleFdsTest) {\012 const std::vector&lt;std::string&gt; testStrings{&quot;This &quot;, &quot;is &quot;, &quot;so &quot;, &quot;much &quot;, &quot;data!\n&quot;};\012 const std::string testFileName = &quot;/data/local/tmp/SafeUnionHandleWithMultipleFdsTest&quot;;\012 const std::array&lt;int, 6&gt; testData{2, -32, 10, -4329454, 11, 24};\012    ASSERT_EQ(sizeof(testData), testData.size() * sizeof(int));\012\012 const std::string goldenResult = std::accumulate(testStrings.begin(),\012                                                     testStrings.end(),\012                                                     std::string());\012\012 int fd = open(testFileName.c_str(), (O_RDWR | O_TRUNC | O_CREAT), (S_IRUSR | S_IWUSR));\012    ASSERT_TRUE(fd &gt;= 0);\012\012 const int numFds = testStrings.size();\012    native_handle* h = native_handle_create(numFds, testData.size() /* numInts */);\012    std::memcpy(&amp;(h-&gt;data[numFds]), testData.data(), sizeof(testData));\012 for (size_t i = 0; i &lt; numFds; i++) {\012        h-&gt;data[i] = fd;\012 }\012\012    hidl_handle testHandle;\012    testHandle.setTo(h, false /* shouldOwn */);\012\012    EXPECT_OK(\012        safeunionInterface-&gt;newHandleTypeSafeUnion([&amp;](const HandleTypeSafeUnion&amp; safeUnion) {\012            EXPECT_OK(safeunionInterface-&gt;setHandleA(\012                safeUnion, testHandle, [&amp;](const HandleTypeSafeUnion&amp; safeUnion) {\012                    EXPECT_EQ(HandleTypeSafeUnion::hidl_discriminator::a,\012                              safeUnion.getDiscriminator());\012\012 const native_handle_t* result = safeUnion.a().getNativeHandle();\012                    checkNativeHandlesDataEquality(h, result);\012\012 for (size_t i = 0; i &lt; result-&gt;numFds; i++) {\012 // Original FDs should be dup'd\012 int resultFd = result-&gt;data[i];\012                        EXPECT_NE(h-&gt;data[i], resultFd);\012\012                        EXPECT_TRUE(android::base::WriteStringToFd(testStrings[i], resultFd));\012                        EXPECT_EQ(0, fsync(resultFd));\012 }\012 }));\012 }));\012\012    std::string result;\012    lseek(fd, 0, SEEK_SET);\012\012    EXPECT_TRUE(android::base::ReadFdToString(fd, &amp;result));\012    EXPECT_EQ(goldenResult, result);\012\012    native_handle_delete(h);\012    EXPECT_EQ(0, close(fd));\012    EXPECT_EQ(0, remove(testFileName.c_str()));\012})<SUB>1103</SUB>> ]
+"872" [label = <(UNKNOWN,TEST_F(HidlTest, SafeUnionEqualityTest) {\012    EXPECT_OK(safeunionInterface-&gt;newLargeSafeUnion([&amp;](const LargeSafeUnion&amp; one) {\012        EXPECT_OK(safeunionInterface-&gt;newLargeSafeUnion([&amp;](const LargeSafeUnion&amp; two) {\012            EXPECT_TRUE(one == two);\012            EXPECT_FALSE(one != two);\012 }));\012\012        EXPECT_OK(safeunionInterface-&gt;setA(one, 1, [&amp;](const LargeSafeUnion&amp; one) {\012            EXPECT_OK(safeunionInterface-&gt;newLargeSafeUnion([&amp;](const LargeSafeUnion&amp; two) {\012                EXPECT_FALSE(one == two);\012                EXPECT_TRUE(one != two);\012 }));\012\012            EXPECT_OK(safeunionInterface-&gt;newLargeSafeUnion([&amp;](const LargeSafeUnion&amp; two) {\012                EXPECT_OK(safeunionInterface-&gt;setB(two, 1, [&amp;](const LargeSafeUnion&amp; two) {\012                    EXPECT_FALSE(one == two);\012                    EXPECT_TRUE(one != two);\012 }));\012 }));\012\012            EXPECT_OK(safeunionInterface-&gt;newLargeSafeUnion([&amp;](const LargeSafeUnion&amp; two) {\012                EXPECT_OK(safeunionInterface-&gt;setA(two, 2, [&amp;](const LargeSafeUnion&amp; two) {\012                    EXPECT_FALSE(one == two);\012                    EXPECT_TRUE(one != two);\012 }));\012 }));\012\012            EXPECT_OK(safeunionInterface-&gt;newLargeSafeUnion([&amp;](const LargeSafeUnion&amp; two) {\012                EXPECT_OK(safeunionInterface-&gt;setA(two, 1, [&amp;](const LargeSafeUnion&amp; two) {\012                    EXPECT_TRUE(one == two);\012                    EXPECT_FALSE(one != two);\012 }));\012 }));\012 }));\012 }));\012},TEST_F(HidlTest, SafeUnionEqualityTest) {\012    EXPECT_OK(safeunionInterface-&gt;newLargeSafeUnion([&amp;](const LargeSafeUnion&amp; one) {\012        EXPECT_OK(safeunionInterface-&gt;newLargeSafeUnion([&amp;](const LargeSafeUnion&amp; two) {\012            EXPECT_TRUE(one == two);\012            EXPECT_FALSE(one != two);\012 }));\012\012        EXPECT_OK(safeunionInterface-&gt;setA(one, 1, [&amp;](const LargeSafeUnion&amp; one) {\012            EXPECT_OK(safeunionInterface-&gt;newLargeSafeUnion([&amp;](const LargeSafeUnion&amp; two) {\012                EXPECT_FALSE(one == two);\012                EXPECT_TRUE(one != two);\012 }));\012\012            EXPECT_OK(safeunionInterface-&gt;newLargeSafeUnion([&amp;](const LargeSafeUnion&amp; two) {\012                EXPECT_OK(safeunionInterface-&gt;setB(two, 1, [&amp;](const LargeSafeUnion&amp; two) {\012                    EXPECT_FALSE(one == two);\012                    EXPECT_TRUE(one != two);\012 }));\012 }));\012\012            EXPECT_OK(safeunionInterface-&gt;newLargeSafeUnion([&amp;](const LargeSafeUnion&amp; two) {\012                EXPECT_OK(safeunionInterface-&gt;setA(two, 2, [&amp;](const LargeSafeUnion&amp; two) {\012                    EXPECT_FALSE(one == two);\012                    EXPECT_TRUE(one != two);\012 }));\012 }));\012\012            EXPECT_OK(safeunionInterface-&gt;newLargeSafeUnion([&amp;](const LargeSafeUnion&amp; two) {\012                EXPECT_OK(safeunionInterface-&gt;setA(two, 1, [&amp;](const LargeSafeUnion&amp; two) {\012                    EXPECT_TRUE(one == two);\012                    EXPECT_FALSE(one != two);\012 }));\012 }));\012 }));\012 }));\012})<SUB>1158</SUB>> ]
+"914" [label = <(UNKNOWN,TEST_F(HidlTest, UninitTest) {\012 IBase::Foo foo;\012    foo.x = 1;\012    foo.y = {0, &quot;&quot;};\012\012 static_assert(offsetof(IBase::Foo, x) == 0);\012 static_assert(sizeof(foo.x) == 4);\012 static_assert(offsetof(IBase::Foo, aaa) == 8);\012\012 uint8_t* buf = reinterpret_cast&lt;uint8_t*&gt;(&amp;foo);\012    memset(buf + 4, 0xFF, 4);\012\012 // this should not affect the result for remote Java (but would for remote C++)\012    expectRangeEqual&lt;IBase::Foo, 4, 8&gt;(&amp;foo, 0xFF);\012\012 // run many times, if this error case is hit, it will only be hit\012 // sometimes.\012 for (size_t i = 0; i &lt; 100; i++) {\012        EXPECT_OK(baz-&gt;someOtherBaseMethod(\012                foo, [](const IBase::Foo&amp; foo) { expectRangeEqual&lt;IBase::Foo, 4, 8&gt;(&amp;foo, 0); }));\012 }\012},TEST_F(HidlTest, UninitTest) {\012 IBase::Foo foo;\012    foo.x = 1;\012    foo.y = {0, &quot;&quot;};\012\012 static_assert(offsetof(IBase::Foo, x) == 0);\012 static_assert(sizeof(foo.x) == 4);\012 static_assert(offsetof(IBase::Foo, aaa) == 8);\012\012 uint8_t* buf = reinterpret_cast&lt;uint8_t*&gt;(&amp;foo);\012    memset(buf + 4, 0xFF, 4);\012\012 // this should not affect the result for remote Java (but would for remote C++)\012    expectRangeEqual&lt;IBase::Foo, 4, 8&gt;(&amp;foo, 0xFF);\012\012 // run many times, if this error case is hit, it will only be hit\012 // sometimes.\012 for (size_t i = 0; i &lt; 100; i++) {\012        EXPECT_OK(baz-&gt;someOtherBaseMethod(\012                foo, [](const IBase::Foo&amp; foo) { expectRangeEqual&lt;IBase::Foo, 4, 8&gt;(&amp;foo, 0); }));\012 }\012})<SUB>1207</SUB>> ]
 "24" [label = <(METHOD,&lt;global&gt;)<SUB>1</SUB>> ]
 "1088" [label = <(METHOD_RETURN,ANY)<SUB>1</SUB>> ]
   "641" -> "642" 
