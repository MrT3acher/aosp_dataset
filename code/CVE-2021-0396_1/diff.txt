diff -bur /home/mrt3acher/thesis-implementation/.avuln-workdir/code/CVE-2021-0396_1/secure/out/0-cfg.dot /home/mrt3acher/thesis-implementation/.avuln-workdir/code/CVE-2021-0396_1/vulnerable/out/0-cfg.dot
--- /home/mrt3acher/thesis-implementation/.avuln-workdir/code/CVE-2021-0396_1/secure/out/0-cfg.dot	2023-06-07 19:36:12.307380749 +0330
+++ /home/mrt3acher/thesis-implementation/.avuln-workdir/code/CVE-2021-0396_1/vulnerable/out/0-cfg.dot	2023-06-07 19:36:15.767380512 +0330
@@ -1,5 +1,5 @@
 digraph "&lt;global&gt;" {  
-"7" [label = <(UNKNOWN,namespace v8 {\012namespace internal {\012namespace wasm {\012class WasmCode;\012}\012\012// Forward declarations.\012class AbstractCode;\012class FrameArray;\012class JSMessageObject;\012class LookupIterator;\012class SharedFunctionInfo;\012class SourceInfo;\012class WasmInstanceObject;\012\012class MessageLocation {\012 public:\012 MessageLocation(Handle&lt;Script&gt; script, int start_pos, int end_pos);\012 MessageLocation(Handle&lt;Script&gt; script, int start_pos, int end_pos,\012 Handle&lt;SharedFunctionInfo&gt; shared);\012 MessageLocation();\012\012 Handle&lt;Script&gt; script() const { return script_; }\012 int start_pos() const { return start_pos_; }\012 int end_pos() const { return end_pos_; }\012 Handle&lt;SharedFunctionInfo&gt; shared() const { return shared_; }\012\012 private:\012 Handle&lt;Script&gt; script_;\012 int start_pos_;\012 int end_pos_;\012 Handle&lt;SharedFunctionInfo&gt; shared_;\012};\012\012class StackFrameBase {\012 public:\012 virtual ~StackFrameBase() {}\012\012 virtual Handle&lt;Object&gt; GetReceiver() const = 0;\012 virtual Handle&lt;Object&gt; GetFunction() const = 0;\012\012 virtual Handle&lt;Object&gt; GetFileName() = 0;\012 virtual Handle&lt;Object&gt; GetFunctionName() = 0;\012 virtual Handle&lt;Object&gt; GetScriptNameOrSourceUrl() = 0;\012 virtual Handle&lt;Object&gt; GetMethodName() = 0;\012 virtual Handle&lt;Object&gt; GetTypeName() = 0;\012 virtual Handle&lt;Object&gt; GetEvalOrigin();\012\012 virtual int GetPosition() const = 0;\012 // Return 1-based line number, including line offset.\012 virtual int GetLineNumber() = 0;\012 // Return 1-based column number, including column offset if first line.\012 virtual int GetColumnNumber() = 0;\012\012 virtual bool IsNative() = 0;\012 virtual bool IsToplevel() = 0;\012 virtual bool IsEval();\012 virtual bool IsConstructor() = 0;\012 virtual bool IsStrict() const = 0;\012\012 virtual MaybeHandle&lt;String&gt; ToString() = 0;\012\012 protected:\012 StackFrameBase() {}\012 explicit StackFrameBase(Isolate* isolate) : isolate_(isolate) {}\012 Isolate* isolate_;\012\012 private:\012 virtual bool HasScript() const = 0;\012 virtual Handle&lt;Script&gt; GetScript() const = 0;\012};\012\012class JSStackFrame : public StackFrameBase {\012 public:\012 JSStackFrame(Isolate* isolate, Handle&lt;Object&gt; receiver,\012 Handle&lt;JSFunction&gt; function, Handle&lt;AbstractCode&gt; code,\012 int offset);\012 virtual ~JSStackFrame() {}\012\012 Handle&lt;Object&gt; GetReceiver() const override { return receiver_; }\012 Handle&lt;Object&gt; GetFunction() const override;\012\012 Handle&lt;Object&gt; GetFileName() override;\012 Handle&lt;Object&gt; GetFunctionName() override;\012 Handle&lt;Object&gt; GetScriptNameOrSourceUrl() override;\012 Handle&lt;Object&gt; GetMethodName() override;\012 Handle&lt;Object&gt; GetTypeName() override;\012\012 int GetPosition() const override;\012 int GetLineNumber() override;\012 int GetColumnNumber() override;\012\012 bool IsNative() override;\012 bool IsToplevel() override;\012 bool IsConstructor() override { return is_constructor_; }\012 bool IsStrict() const override { return is_strict_; }\012\012 MaybeHandle&lt;String&gt; ToString() override;\012\012 private:\012 JSStackFrame();\012 void FromFrameArray(Isolate* isolate, Handle&lt;FrameArray&gt; array, int frame_ix);\012\012 bool HasScript() const override;\012 Handle&lt;Script&gt; GetScript() const override;\012\012 Handle&lt;Object&gt; receiver_;\012 Handle&lt;JSFunction&gt; function_;\012 Handle&lt;AbstractCode&gt; code_;\012 int offset_;\012\012 bool is_constructor_;\012 bool is_strict_;\012\012 friend class FrameArrayIterator;\012};\012\012class WasmStackFrame : public StackFrameBase {\012 public:\012 virtual ~WasmStackFrame() {}\012\012 Handle&lt;Object&gt; GetReceiver() const override;\012 Handle&lt;Object&gt; GetFunction() const override;\012\012 Handle&lt;Object&gt; GetFileName() override { return Null(); }\012 Handle&lt;Object&gt; GetFunctionName() override;\012 Handle&lt;Object&gt; GetScriptNameOrSourceUrl() override { return Null(); }\012 Handle&lt;Object&gt; GetMethodName() override { return Null(); }\012 Handle&lt;Object&gt; GetTypeName() override { return Null(); }\012\012 int GetPosition() const override;\012 int GetLineNumber() override { return wasm_func_index_; }\012 int GetColumnNumber() override { return -1; }\012\012 bool IsNative() override { return false; }\012 bool IsToplevel() override { return false; }\012 bool IsConstructor() override { return false; }\012 bool IsStrict() const override { return false; }\012 bool IsInterpreted() const { return code_ == nullptr; }\012\012 MaybeHandle&lt;String&gt; ToString() override;\012\012 protected:\012 Handle&lt;Object&gt; Null() const;\012\012 bool HasScript() const override;\012 Handle&lt;Script&gt; GetScript() const override;\012\012 Handle&lt;WasmInstanceObject&gt; wasm_instance_;\012 uint32_t wasm_func_index_;\012  wasm::WasmCode* code_; // null for interpreted frames.\012 int offset_;\012\012 private:\012 WasmStackFrame();\012 void FromFrameArray(Isolate* isolate, Handle&lt;FrameArray&gt; array, int frame_ix);\012\012 friend class FrameArrayIterator;\012 friend class AsmJsWasmStackFrame;\012};\012\012class AsmJsWasmStackFrame : public WasmStackFrame {\012 public:\012 virtual ~AsmJsWasmStackFrame() {}\012\012 Handle&lt;Object&gt; GetReceiver() const override;\012 Handle&lt;Object&gt; GetFunction() const override;\012\012 Handle&lt;Object&gt; GetFileName() override;\012 Handle&lt;Object&gt; GetScriptNameOrSourceUrl() override;\012\012 int GetPosition() const override;\012 int GetLineNumber() override;\012 int GetColumnNumber() override;\012\012 MaybeHandle&lt;String&gt; ToString() override;\012\012 private:\012 friend class FrameArrayIterator;\012 AsmJsWasmStackFrame();\012 void FromFrameArray(Isolate* isolate, Handle&lt;FrameArray&gt; array, int frame_ix);\012\012 bool is_at_number_conversion_;\012};\012\012class FrameArrayIterator {\012 public:\012 FrameArrayIterator(Isolate* isolate, Handle&lt;FrameArray&gt; array,\012 int frame_ix = 0);\012\012 StackFrameBase* Frame();\012\012 bool HasNext() const;\012 void Next();\012\012 private:\012 Isolate* isolate_;\012\012 Handle&lt;FrameArray&gt; array_;\012 int next_frame_ix_;\012\012 WasmStackFrame wasm_frame_;\012 AsmJsWasmStackFrame asm_wasm_frame_;\012 JSStackFrame js_frame_;\012};\012\012// Determines how stack trace collection skips frames.\012enum FrameSkipMode {\012 // Unconditionally skips the first frame. Used e.g. when the Error constructor\012 // is called, in which case the first frame is always a BUILTIN_EXIT frame.\012  SKIP_FIRST,\012 // Skip all frames until a specified caller function is seen.\012  SKIP_UNTIL_SEEN,\012  SKIP_NONE,\012};\012\012class ErrorUtils : public AllStatic {\012 public:\012 static MaybeHandle&lt;Object&gt; Construct(\012 Isolate* isolate, Handle&lt;JSFunction&gt; target, Handle&lt;Object&gt; new_target,\012 Handle&lt;Object&gt; message, FrameSkipMode mode, Handle&lt;Object&gt; caller,\012 bool suppress_detailed_trace);\012\012 static MaybeHandle&lt;String&gt; ToString(Isolate* isolate, Handle&lt;Object&gt; recv);\012\012 static MaybeHandle&lt;Object&gt; MakeGenericError(\012 Isolate* isolate, Handle&lt;JSFunction&gt; constructor, int template_index,\012 Handle&lt;Object&gt; arg0, Handle&lt;Object&gt; arg1, Handle&lt;Object&gt; arg2,\012 FrameSkipMode mode);\012\012 // Formats a textual stack trace from the given structured stack trace.\012 // Note that this can call arbitrary JS code through Error.prepareStackTrace.\012 static MaybeHandle&lt;Object&gt; FormatStackTrace(Isolate* isolate,\012 Handle&lt;JSObject&gt; error,\012 Handle&lt;Object&gt; stack_trace);\012};\012\012#define MESSAGE_TEMPLATES(T)                                                   \\012 /* Error */                                                                  \\012  T(None, &quot;&quot;)                                                                  \\012  T(CyclicProto, &quot;Cyclic __proto__ value&quot;)                                     \\012  T(Debugger, &quot;Debugger: %&quot;)                                                   \\012  T(DebuggerLoading, &quot;Error loading debugger&quot;)                                 \\012  T(DefaultOptionsMissing, &quot;Internal % error. Default options are missing.&quot;)   \\012  T(DeletePrivateField, &quot;Private fields can not be deleted&quot;)                   \\012  T(UncaughtException, &quot;Uncaught %&quot;)                                           \\012  T(Unsupported, &quot;Not supported&quot;)                                              \\012  T(WrongServiceType, &quot;Internal error, wrong service type: %&quot;)                 \\012  T(WrongValueType, &quot;Internal error. Wrong value type.&quot;)                       \\012  T(IcuError, &quot;Internal error. Icu error.&quot;)                                    \\012 /* TypeError */                                                              \\012  T(ApplyNonFunction,                                                          \\012 &quot;Function.prototype.apply was called on %, which is a % and not a &quot;        \\012 &quot;function&quot;)                                                                \\012  T(ArgumentsDisallowedInInitializer,                                          \\012 &quot;'arguments' is not allowed in class field initializer&quot;)                   \\012  T(ArrayBufferTooShort,                                                       \\012 &quot;Derived ArrayBuffer constructor created a buffer which was too small&quot;)    \\012  T(ArrayBufferSpeciesThis,                                                    \\012 &quot;ArrayBuffer subclass returned this from species constructor&quot;)             \\012  T(ArrayItemNotType, &quot;array %[%] is not type %&quot;)                              \\012  T(AwaitNotInAsyncFunction, &quot;await is only valid in async function&quot;)          \\012  T(AtomicsWaitNotAllowed, &quot;Atomics.wait cannot be called in this context&quot;)    \\012  T(BadSortComparisonFunction,                                                 \\012 &quot;The comparison function must be either a function or undefined&quot;)          \\012  T(BigIntFromNumber,                                                          \\012 &quot;The number % cannot be converted to a BigInt because it is not an &quot;       \\012 &quot;integer&quot;)                                                                 \\012  T(BigIntFromObject, &quot;Cannot convert % to a BigInt&quot;)                          \\012  T(BigIntMixedTypes,                                                          \\012 &quot;Cannot mix BigInt and other types, use explicit conversions&quot;)             \\012  T(BigIntSerializeJSON, &quot;Do not know how to serialize a BigInt&quot;)              \\012  T(BigIntShr, &quot;BigInts have no unsigned right shift, use &gt;&gt; instead&quot;)         \\012  T(BigIntToNumber, &quot;Cannot convert a BigInt value to a number&quot;)               \\012  T(CalledNonCallable, &quot;% is not a function&quot;)                                  \\012  T(CalledOnNonObject, &quot;% called on non-object&quot;)                               \\012  T(CalledOnNullOrUndefined, &quot;% called on null or undefined&quot;)                  \\012  T(CallSiteExpectsFunction,                                                   \\012 &quot;CallSite expects wasm object as first or function as second argument, &quot;   \\012 &quot;got &lt;%, %&gt;&quot;)                                                              \\012  T(CallSiteMethod, &quot;CallSite method % expects CallSite as receiver&quot;)          \\012  T(CannotConvertToPrimitive, &quot;Cannot convert object to primitive value&quot;)      \\012  T(CannotPreventExt, &quot;Cannot prevent extensions&quot;)                             \\012  T(CannotFreeze, &quot;Cannot freeze&quot;)                                             \\012  T(CannotFreezeArrayBufferView,                                               \\012 &quot;Cannot freeze array buffer views with elements&quot;)                          \\012  T(CannotSeal, &quot;Cannot seal&quot;)                                                 \\012  T(CircularStructure, &quot;Converting circular structure to JSON&quot;)                \\012  T(ConstructAbstractClass, &quot;Abstract class % not directly constructable&quot;)     \\012  T(ConstAssign, &quot;Assignment to constant variable.&quot;)                           \\012  T(ConstructorClassField, &quot;Classes may not have a field named 'constructor'&quot;) \\012  T(ConstructorNonCallable,                                                    \\012 &quot;Class constructor % cannot be invoked without 'new'&quot;)                     \\012  T(ConstructorNotFunction, &quot;Constructor % requires 'new'&quot;)                    \\012  T(ConstructorNotReceiver, &quot;The .constructor property is not an object&quot;)      \\012  T(CurrencyCode, &quot;Currency code is required with currency style.&quot;)            \\012  T(CyclicModuleDependency, &quot;Detected cycle while resolving name '%' in '%'&quot;)  \\012  T(DataViewNotArrayBuffer,                                                    \\012 &quot;First argument to DataView constructor must be an ArrayBuffer&quot;)           \\012  T(DateType, &quot;this is not a Date object.&quot;)                                    \\012  T(DebuggerFrame, &quot;Debugger: Invalid frame index.&quot;)                           \\012  T(DebuggerType, &quot;Debugger: Parameters have wrong types.&quot;)                    \\012  T(DeclarationMissingInitializer, &quot;Missing initializer in % declaration&quot;)     \\012  T(DefineDisallowed, &quot;Cannot define property %, object is not extensible&quot;)    \\012  T(DetachedOperation, &quot;Cannot perform % on a detached ArrayBuffer&quot;)           \\012  T(DuplicateTemplateProperty, &quot;Object template has duplicate property '%'&quot;)   \\012  T(ExtendsValueNotConstructor,                                                \\012 &quot;Class extends value % is not a constructor or null&quot;)                      \\012  T(FirstArgumentNotRegExp,                                                    \\012 &quot;First argument to % must not be a regular expression&quot;)                    \\012  T(FunctionBind, &quot;Bind must be called on a function&quot;)                         \\012  T(GeneratorRunning, &quot;Generator is already running&quot;)                          \\012  T(IllegalInvocation, &quot;Illegal invocation&quot;)                                   \\012  T(ImmutablePrototypeSet,                                                     \\012 &quot;Immutable prototype object '%' cannot have their prototype set&quot;)          \\012  T(ImportCallNotNewExpression, &quot;Cannot use new with import&quot;)                  \\012  T(ImportMetaOutsideModule, &quot;Cannot use 'import.meta' outside a module&quot;)      \\012  T(ImportMissingSpecifier, &quot;import() requires a specifier&quot;)                   \\012  T(IncompatibleMethodReceiver, &quot;Method % called on incompatible receiver %&quot;)  \\012  T(InstanceofNonobjectProto,                                                  \\012 &quot;Function has non-object prototype '%' in instanceof check&quot;)               \\012  T(InvalidArgument, &quot;invalid_argument&quot;)                                       \\012  T(InvalidInOperatorUse, &quot;Cannot use 'in' operator to search for '%' in %&quot;)   \\012  T(InvalidRegExpExecResult,                                                   \\012 &quot;RegExp exec method returned something other than an Object or null&quot;)      \\012  T(InvalidUnit, &quot;Invalid unit argument for %() '%'&quot;)                          \\012  T(IteratorResultNotAnObject, &quot;Iterator result % is not an object&quot;)           \\012  T(IteratorSymbolNonCallable, &quot;Found non-callable @@iterator&quot;)                \\012  T(IteratorValueNotAnObject, &quot;Iterator value % is not an entry object&quot;)       \\012  T(LanguageID, &quot;Language ID should be string or object.&quot;)                     \\012  T(LocaleNotEmpty,                                                            \\012 &quot;First argument to Intl.Locale constructor can't be empty or missing&quot;)     \\012  T(LocaleBadParameters, &quot;Incorrect locale information provided&quot;)              \\012  T(ListFormatBadParameters, &quot;Incorrect ListFormat information provided&quot;)      \\012  T(MapperFunctionNonCallable, &quot;flatMap mapper function is not callable&quot;)      \\012  T(MethodCalledOnWrongObject,                                                 \\012 &quot;Method % called on a non-object or on a wrong type of object.&quot;)           \\012  T(MethodInvokedOnNullOrUndefined,                                            \\012 &quot;Method invoked on undefined or null value.&quot;)                              \\012  T(MethodInvokedOnWrongType, &quot;Method invoked on an object that is not %.&quot;)    \\012  T(NoAccess, &quot;no access&quot;)                                                     \\012  T(NonCallableInInstanceOfCheck,                                              \\012 &quot;Right-hand side of 'instanceof' is not callable&quot;)                         \\012  T(NonCoercible, &quot;Cannot destructure 'undefined' or 'null'.&quot;)                 \\012  T(NonCoercibleWithProperty,                                                  \\012 &quot;Cannot destructure property `%` of 'undefined' or 'null'.&quot;)               \\012  T(NonExtensibleProto, &quot;% is not extensible&quot;)                                 \\012  T(NonObjectInInstanceOfCheck,                                                \\012 &quot;Right-hand side of 'instanceof' is not an object&quot;)                        \\012  T(NonObjectPropertyLoad, &quot;Cannot read property '%' of %&quot;)                    \\012  T(NonObjectPropertyStore, &quot;Cannot set property '%' of %&quot;)                    \\012  T(NoSetterInCallback, &quot;Cannot set property % of % which has only a getter&quot;)  \\012  T(NotAnIterator, &quot;% is not an iterator&quot;)                                     \\012  T(NotAPromise, &quot;% is not a promise&quot;)                                         \\012  T(NotConstructor, &quot;% is not a constructor&quot;)                                  \\012  T(NotDateObject, &quot;this is not a Date object.&quot;)                               \\012  T(NotGeneric, &quot;% requires that 'this' be a %&quot;)                               \\012  T(NotCallableOrIterable,                                                     \\012 &quot;% is not a function or its return value is not iterable&quot;)                 \\012  T(NotCallableOrAsyncIterable,                                                \\012 &quot;% is not a function or its return value is not async iterable&quot;)           \\012  T(NotFiniteNumber, &quot;Value need to be finite number for %()&quot;)                 \\012  T(NotIterable, &quot;% is not iterable&quot;)                                          \\012  T(NotAsyncIterable, &quot;% is not async iterable&quot;)                               \\012  T(NotPropertyName, &quot;% is not a valid property name&quot;)                         \\012  T(NotTypedArray, &quot;this is not a typed array.&quot;)                               \\012  T(NotSuperConstructor, &quot;Super constructor % of % is not a constructor&quot;)      \\012  T(NotSuperConstructorAnonymousClass,                                         \\012 &quot;Super constructor % of anonymous class is not a constructor&quot;)             \\012  T(NotIntegerSharedTypedArray, &quot;% is not an integer shared typed array.&quot;)     \\012  T(NotInt32SharedTypedArray, &quot;% is not an int32 shared typed array.&quot;)         \\012  T(ObjectGetterExpectingFunction,                                             \\012 &quot;Object.prototype.__defineGetter__: Expecting function&quot;)                   \\012  T(ObjectGetterCallable, &quot;Getter must be a function: %&quot;)                      \\012  T(ObjectNotExtensible, &quot;Cannot add property %, object is not extensible&quot;)    \\012  T(ObjectSetterExpectingFunction,                                             \\012 &quot;Object.prototype.__defineSetter__: Expecting function&quot;)                   \\012  T(ObjectSetterCallable, &quot;Setter must be a function: %&quot;)                      \\012  T(OrdinaryFunctionCalledAsConstructor,                                       \\012 &quot;Function object that's not a constructor was created with new&quot;)           \\012  T(PromiseCyclic, &quot;Chaining cycle detected for promise %&quot;)                    \\012  T(PromiseExecutorAlreadyInvoked,                                             \\012 &quot;Promise executor has already been invoked with non-undefined arguments&quot;)  \\012  T(PromiseNonCallable, &quot;Promise resolve or reject function is not callable&quot;)  \\012  T(PropertyDescObject, &quot;Property description must be an object: %&quot;)           \\012  T(PropertyNotFunction,                                                       \\012 &quot;'%' returned for property '%' of object '%' is not a function&quot;)           \\012  T(ProtoObjectOrNull, &quot;Object prototype may only be an Object or null: %&quot;)    \\012  T(PrototypeParentNotAnObject,                                                \\012 &quot;Class extends value does not have valid prototype property %&quot;)            \\012  T(ProxyConstructNonObject,                                                   \\012 &quot;'construct' on proxy: trap returned non-object ('%')&quot;)                    \\012  T(ProxyDefinePropertyNonConfigurable,                                        \\012 &quot;'defineProperty' on proxy: trap returned truish for defining &quot;            \\012 &quot;non-configurable property '%' which is either non-existant or &quot;           \\012 &quot;configurable in the proxy target&quot;)                                        \\012  T(ProxyDefinePropertyNonExtensible,                                          \\012 &quot;'defineProperty' on proxy: trap returned truish for adding property '%' &quot; \\012 &quot; to the non-extensible proxy target&quot;)                                     \\012  T(ProxyDefinePropertyIncompatible,                                           \\012 &quot;'defineProperty' on proxy: trap returned truish for adding property '%' &quot; \\012 &quot; that is incompatible with the existing property in the proxy target&quot;)    \\012  T(ProxyDeletePropertyNonConfigurable,                                        \\012 &quot;'deleteProperty' on proxy: trap returned truish for property '%' which &quot;  \\012 &quot;is non-configurable in the proxy target&quot;)                                 \\012  T(ProxyGetNonConfigurableData,                                               \\012 &quot;'get' on proxy: property '%' is a read-only and &quot;                         \\012 &quot;non-configurable data property on the proxy target but the proxy &quot;        \\012 &quot;did not return its actual value (expected '%' but got '%')&quot;)              \\012  T(ProxyGetNonConfigurableAccessor,                                           \\012 &quot;'get' on proxy: property '%' is a non-configurable accessor &quot;             \\012 &quot;property on the proxy target and does not have a getter function, but &quot;   \\012 &quot;the trap did not return 'undefined' (got '%')&quot;)                           \\012  T(ProxyGetOwnPropertyDescriptorIncompatible,                                 \\012 &quot;'getOwnPropertyDescriptor' on proxy: trap returned descriptor for &quot;       \\012 &quot;property '%' that is incompatible with the existing property in the &quot;     \\012 &quot;proxy target&quot;)                                                            \\012  T(ProxyGetOwnPropertyDescriptorInvalid,                                      \\012 &quot;'getOwnPropertyDescriptor' on proxy: trap returned neither object nor &quot;   \\012 &quot;undefined for property '%'&quot;)                                              \\012  T(ProxyGetOwnPropertyDescriptorNonConfigurable,                              \\012 &quot;'getOwnPropertyDescriptor' on proxy: trap reported non-configurability &quot;  \\012 &quot;for property '%' which is either non-existant or configurable in the &quot;    \\012 &quot;proxy target&quot;)                                                            \\012  T(ProxyGetOwnPropertyDescriptorNonExtensible,                                \\012 &quot;'getOwnPropertyDescriptor' on proxy: trap returned undefined for &quot;        \\012 &quot;property '%' which exists in the non-extensible proxy target&quot;)            \\012  T(ProxyGetOwnPropertyDescriptorUndefined,                                    \\012 &quot;'getOwnPropertyDescriptor' on proxy: trap returned undefined for &quot;        \\012 &quot;property '%' which is non-configurable in the proxy target&quot;)              \\012  T(ProxyGetPrototypeOfInvalid,                                                \\012 &quot;'getPrototypeOf' on proxy: trap returned neither object nor null&quot;)        \\012  T(ProxyGetPrototypeOfNonExtensible,                                          \\012 &quot;'getPrototypeOf' on proxy: proxy target is non-extensible but the &quot;       \\012 &quot;trap did not return its actual prototype&quot;)                                \\012  T(ProxyHandlerOrTargetRevoked,                                               \\012 &quot;Cannot create proxy with a revoked proxy as target or handler&quot;)           \\012  T(ProxyHasNonConfigurable,                                                   \\012 &quot;'has' on proxy: trap returned falsish for property '%' which exists in &quot;  \\012 &quot;the proxy target as non-configurable&quot;)                                    \\012  T(ProxyHasNonExtensible,                                                     \\012 &quot;'has' on proxy: trap returned falsish for property '%' but the proxy &quot;    \\012 &quot;target is not extensible&quot;)                                                \\012  T(ProxyIsExtensibleInconsistent,                                             \\012 &quot;'isExtensible' on proxy: trap result does not reflect extensibility of &quot;  \\012 &quot;proxy target (which is '%')&quot;)                                             \\012  T(ProxyNonObject,                                                            \\012 &quot;Cannot create proxy with a non-object as target or handler&quot;)              \\012  T(ProxyOwnKeysMissing,                                                       \\012 &quot;'ownKeys' on proxy: trap result did not include '%'&quot;)                     \\012  T(ProxyOwnKeysNonExtensible,                                                 \\012 &quot;'ownKeys' on proxy: trap returned extra keys but proxy target is &quot;        \\012 &quot;non-extensible&quot;)                                                          \\012  T(ProxyPreventExtensionsExtensible,                                          \\012 &quot;'preventExtensions' on proxy: trap returned truish but the proxy target &quot; \\012 &quot;is extensible&quot;)                                                           \\012  T(ProxyPrivate, &quot;Cannot pass private property name to proxy trap&quot;)           \\012  T(ProxyRevoked, &quot;Cannot perform '%' on a proxy that has been revoked&quot;)       \\012  T(ProxySetFrozenData,                                                        \\012 &quot;'set' on proxy: trap returned truish for property '%' which exists in &quot;   \\012 &quot;the proxy target as a non-configurable and non-writable data property &quot;   \\012 &quot;with a different value&quot;)                                                  \\012  T(ProxySetFrozenAccessor,                                                    \\012 &quot;'set' on proxy: trap returned truish for property '%' which exists in &quot;   \\012 &quot;the proxy target as a non-configurable and non-writable accessor &quot;        \\012 &quot;property without a setter&quot;)                                               \\012  T(ProxySetPrototypeOfNonExtensible,                                          \\012 &quot;'setPrototypeOf' on proxy: trap returned truish for setting a new &quot;       \\012 &quot;prototype on the non-extensible proxy target&quot;)                            \\012  T(ProxyTrapReturnedFalsish, &quot;'%' on proxy: trap returned falsish&quot;)           \\012  T(ProxyTrapReturnedFalsishFor,                                               \\012 &quot;'%' on proxy: trap returned falsish for property '%'&quot;)                    \\012  T(RedefineDisallowed, &quot;Cannot redefine property: %&quot;)                         \\012  T(RedefineExternalArray,                                                     \\012 &quot;Cannot redefine a property of an object with external array elements&quot;)    \\012  T(ReduceNoInitial, &quot;Reduce of empty array with no initial value&quot;)            \\012  T(RegExpFlags,                                                               \\012 &quot;Cannot supply flags when constructing one RegExp from another&quot;)           \\012  T(RegExpNonObject, &quot;% getter called on non-object %&quot;)                        \\012  T(RegExpNonRegExp, &quot;% getter called on non-RegExp object&quot;)                   \\012  T(RelativeDateTimeFormatterBadParameters,                                    \\012 &quot;Incorrect RelativeDateTimeFormatter provided&quot;)                            \\012  T(ResolverNotAFunction, &quot;Promise resolver % is not a function&quot;)              \\012  T(ReturnMethodNotCallable, &quot;The iterator's 'return' method is not callable&quot;) \\012  T(SharedArrayBufferTooShort,                                                 \\012 &quot;Derived SharedArrayBuffer constructor created a buffer which was too &quot;    \\012 &quot;small&quot;)                                                                   \\012  T(SharedArrayBufferSpeciesThis,                                              \\012 &quot;SharedArrayBuffer subclass returned this from species constructor&quot;)       \\012  T(StaticPrototype,                                                           \\012 &quot;Classes may not have a static property named 'prototype'&quot;)                \\012  T(StrictDeleteProperty, &quot;Cannot delete property '%' of %&quot;)                   \\012  T(StrictPoisonPill,                                                          \\012 &quot;'caller', 'callee', and 'arguments' properties may not be accessed on &quot;   \\012 &quot;strict mode functions or the arguments objects for calls to them&quot;)        \\012  T(StrictReadOnlyProperty,                                                    \\012 &quot;Cannot assign to read only property '%' of % '%'&quot;)                        \\012  T(StrictCannotCreateProperty, &quot;Cannot create property '%' on % '%'&quot;)         \\012  T(SymbolIteratorInvalid,                                                     \\012 &quot;Result of the Symbol.iterator method is not an object&quot;)                   \\012  T(SymbolAsyncIteratorInvalid,                                                \\012 &quot;Result of the Symbol.asyncIterator method is not an object&quot;)              \\012  T(SymbolKeyFor, &quot;% is not a symbol&quot;)                                         \\012  T(SymbolToNumber, &quot;Cannot convert a Symbol value to a number&quot;)               \\012  T(SymbolToString, &quot;Cannot convert a Symbol value to a string&quot;)               \\012  T(ThrowMethodMissing, &quot;The iterator does not provide a 'throw' method.&quot;)     \\012  T(UndefinedOrNullToObject, &quot;Cannot convert undefined or null to object&quot;)     \\012  T(ValueAndAccessor,                                                          \\012 &quot;Invalid property descriptor. Cannot both specify accessors and a value &quot;  \\012 &quot;or writable attribute, %&quot;)                                                \\012  T(VarRedeclaration, &quot;Identifier '%' has already been declared&quot;)              \\012  T(WrongArgs, &quot;%: Arguments list has wrong type&quot;)                             \\012 /* ReferenceError */                                                         \\012  T(NotDefined, &quot;% is not defined&quot;)                                            \\012  T(SuperAlreadyCalled, &quot;Super constructor may only be called once&quot;)           \\012  T(UnsupportedSuper, &quot;Unsupported reference to 'super'&quot;)                      \\012 /* RangeError */                                                             \\012  T(BigIntDivZero, &quot;Division by zero&quot;)                                         \\012  T(BigIntNegativeExponent, &quot;Exponent must be positive&quot;)                       \\012  T(BigIntTooBig, &quot;Maximum BigInt size exceeded&quot;)                              \\012  T(DateRange, &quot;Provided date is not in valid range.&quot;)                         \\012  T(ExpectedLocation,                                                          \\012 &quot;Expected letters optionally connected with underscores or hyphens for &quot;   \\012 &quot;a location, got %&quot;)                                                       \\012  T(InvalidArrayBufferLength, &quot;Invalid array buffer length&quot;)                   \\012  T(ArrayBufferAllocationFailed, &quot;Array buffer allocation failed&quot;)             \\012  T(InvalidArrayLength, &quot;Invalid array length&quot;)                                \\012  T(InvalidAtomicAccessIndex, &quot;Invalid atomic access index&quot;)                   \\012  T(InvalidCodePoint, &quot;Invalid code point %&quot;)                                  \\012  T(InvalidCountValue, &quot;Invalid count value&quot;)                                  \\012  T(InvalidCurrencyCode, &quot;Invalid currency code: %&quot;)                           \\012  T(InvalidDataViewAccessorOffset,                                             \\012 &quot;Offset is outside the bounds of the DataView&quot;)                            \\012  T(InvalidDataViewLength, &quot;Invalid DataView length %&quot;)                        \\012  T(InvalidOffset, &quot;Start offset % is outside the bounds of the buffer&quot;)       \\012  T(InvalidHint, &quot;Invalid hint: %&quot;)                                            \\012  T(InvalidIndex, &quot;Invalid value: not (convertible to) a safe integer&quot;)        \\012  T(InvalidLanguageTag, &quot;Invalid language tag: %&quot;)                             \\012  T(InvalidWeakMapKey, &quot;Invalid value used as weak map key&quot;)                   \\012  T(InvalidWeakSetValue, &quot;Invalid value used in weak set&quot;)                     \\012  T(InvalidStringLength, &quot;Invalid string length&quot;)                              \\012  T(InvalidTimeValue, &quot;Invalid time value&quot;)                                    \\012  T(InvalidTimeZone, &quot;Invalid time zone specified: %&quot;)                         \\012  T(InvalidTypedArrayAlignment, &quot;% of % should be a multiple of %&quot;)            \\012  T(InvalidTypedArrayIndex, &quot;Invalid typed array index&quot;)                       \\012  T(InvalidTypedArrayLength, &quot;Invalid typed array length: %&quot;)                  \\012  T(LetInLexicalBinding, &quot;let is disallowed as a lexically bound name&quot;)        \\012  T(LocaleMatcher, &quot;Illegal value for localeMatcher:%&quot;)                        \\012  T(NormalizationForm, &quot;The normalization form should be one of %.&quot;)           \\012  T(ZeroDigitNumericSeparator,                                                 \\012 &quot;Numeric separator can not be used after leading 0.&quot;)                      \\012  T(NumberFormatRange, &quot;% argument must be between 0 and 100&quot;)                 \\012  T(TrailingNumericSeparator,                                                  \\012 &quot;Numeric separators are not allowed at the end of numeric literals&quot;)       \\012  T(ContinuousNumericSeparator,                                                \\012 &quot;Only one underscore is allowed as numeric separator&quot;)                     \\012  T(PropertyValueOutOfRange, &quot;% value is out of range.&quot;)                       \\012  T(StackOverflow, &quot;Maximum call stack size exceeded&quot;)                         \\012  T(ToPrecisionFormatRange,                                                    \\012 &quot;toPrecision() argument must be between 1 and 100&quot;)                        \\012  T(ToRadixFormatRange, &quot;toString() radix argument must be between 2 and 36&quot;)  \\012  T(TypedArraySetOffsetOutOfBounds, &quot;offset is out of bounds&quot;)                 \\012  T(TypedArraySetSourceTooLarge, &quot;Source is too large&quot;)                        \\012  T(ValueOutOfRange, &quot;Value % out of range for % options property %&quot;)          \\012 /* SyntaxError */                                                            \\012  T(AmbiguousExport,                                                           \\012 &quot;The requested module '%' contains conflicting star exports for name '%'&quot;) \\012  T(BadGetterArity, &quot;Getter must not have any formal parameters.&quot;)             \\012  T(BadSetterArity, &quot;Setter must have exactly one formal parameter.&quot;)          \\012  T(BigIntInvalidString, &quot;Invalid BigInt string&quot;)                              \\012  T(ConstructorIsAccessor, &quot;Class constructor may not be an accessor&quot;)         \\012  T(ConstructorIsGenerator, &quot;Class constructor may not be a generator&quot;)        \\012  T(ConstructorIsAsync, &quot;Class constructor may not be an async method&quot;)        \\012  T(DerivedConstructorReturnedNonObject,                                       \\012 &quot;Derived constructors may only return object or undefined&quot;)                \\012  T(DuplicateConstructor, &quot;A class may only have one constructor&quot;)             \\012  T(DuplicateExport, &quot;Duplicate export of '%'&quot;)                                \\012  T(DuplicateProto,                                                            \\012 &quot;Duplicate __proto__ fields are not allowed in object literals&quot;)           \\012  T(ForInOfLoopInitializer,                                                    \\012 &quot;% loop variable declaration may not have an initializer.&quot;)                \\012  T(ForInOfLoopMultiBindings,                                                  \\012 &quot;Invalid left-hand side in % loop: Must have a single binding.&quot;)           \\012  T(GeneratorInSingleStatementContext,                                         \\012 &quot;Generators can only be declared at the top level or inside a block.&quot;)     \\012  T(AsyncFunctionInSingleStatementContext,                                     \\012 &quot;Async functions can only be declared at the top level or inside a &quot;       \\012 &quot;block.&quot;)                                                                  \\012  T(IllegalBreak, &quot;Illegal break statement&quot;)                                   \\012  T(NoIterationStatement,                                                      \\012 &quot;Illegal continue statement: no surrounding iteration statement&quot;)          \\012  T(IllegalContinue,                                                           \\012 &quot;Illegal continue statement: '%' does not denote an iteration statement&quot;)  \\012  T(IllegalLanguageModeDirective,                                              \\012 &quot;Illegal '%' directive in function with non-simple parameter list&quot;)        \\012  T(IllegalReturn, &quot;Illegal return statement&quot;)                                 \\012  T(IntrinsicWithSpread, &quot;Intrinsic calls do not support spread arguments&quot;)    \\012  T(InvalidRestBindingPattern,                                                 \\012 &quot;`...` must be followed by an identifier in declaration contexts&quot;)         \\012  T(InvalidRestAssignmentPattern,                                              \\012 &quot;`...` must be followed by an assignable reference in assignment &quot;         \\012 &quot;contexts&quot;)                                                                \\012  T(InvalidEscapedReservedWord, &quot;Keyword must not contain escaped characters&quot;) \\012  T(InvalidEscapedMetaProperty, &quot;'%' must not contain escaped characters&quot;)     \\012  T(InvalidLhsInAssignment, &quot;Invalid left-hand side in assignment&quot;)            \\012  T(InvalidCoverInitializedName, &quot;Invalid shorthand property initializer&quot;)     \\012  T(InvalidDestructuringTarget, &quot;Invalid destructuring assignment target&quot;)     \\012  T(InvalidLhsInFor, &quot;Invalid left-hand side in for-loop&quot;)                     \\012  T(InvalidLhsInPostfixOp,                                                     \\012 &quot;Invalid left-hand side expression in postfix operation&quot;)                  \\012  T(InvalidLhsInPrefixOp,                                                      \\012 &quot;Invalid left-hand side expression in prefix operation&quot;)                   \\012  T(InvalidRegExpFlags, &quot;Invalid flags supplied to RegExp constructor '%'&quot;)    \\012  T(InvalidOrUnexpectedToken, &quot;Invalid or unexpected token&quot;)                   \\012  T(InvalidPrivateFieldAccess, &quot;Invalid private field '%'&quot;)                    \\012  T(JsonParseUnexpectedEOS, &quot;Unexpected end of JSON input&quot;)                    \\012  T(JsonParseUnexpectedToken, &quot;Unexpected token % in JSON at position %&quot;)      \\012  T(JsonParseUnexpectedTokenNumber, &quot;Unexpected number in JSON at position %&quot;) \\012  T(JsonParseUnexpectedTokenString, &quot;Unexpected string in JSON at position %&quot;) \\012  T(LabelRedeclaration, &quot;Label '%' has already been declared&quot;)                 \\012  T(LabelledFunctionDeclaration,                                               \\012 &quot;Labelled function declaration not allowed as the body of a control flow &quot; \\012 &quot;structure&quot;)                                                               \\012  T(MalformedArrowFunParamList, &quot;Malformed arrow function parameter list&quot;)     \\012  T(MalformedRegExp, &quot;Invalid regular expression: /%/: %&quot;)                     \\012  T(MalformedRegExpFlags, &quot;Invalid regular expression flags&quot;)                  \\012  T(ModuleExportUndefined, &quot;Export '%' is not defined in module&quot;)              \\012  T(HtmlCommentInModule, &quot;HTML comments are not allowed in modules&quot;)           \\012  T(MultipleDefaultsInSwitch,                                                  \\012 &quot;More than one default clause in switch statement&quot;)                        \\012  T(NewlineAfterThrow, &quot;Illegal newline after throw&quot;)                          \\012  T(NoCatchOrFinally, &quot;Missing catch or finally after try&quot;)                    \\012  T(NotIsvar, &quot;builtin %%IS_VAR: not a variable&quot;)                              \\012  T(ParamAfterRest, &quot;Rest parameter must be last formal parameter&quot;)            \\012  T(FlattenPastSafeLength,                                                     \\012 &quot;Flattening % elements on an array-like of length % &quot;                      \\012 &quot;is disallowed, as the total surpasses 2**53-1&quot;)                           \\012  T(PushPastSafeLength,                                                        \\012 &quot;Pushing % elements on an array-like of length % &quot;                         \\012 &quot;is disallowed, as the total surpasses 2**53-1&quot;)                           \\012  T(ElementAfterRest, &quot;Rest element must be last element&quot;)                     \\012  T(BadSetterRestParameter,                                                    \\012 &quot;Setter function argument must not be a rest parameter&quot;)                   \\012  T(ParamDupe, &quot;Duplicate parameter name not allowed in this context&quot;)         \\012  T(ParenthesisInArgString, &quot;Function arg string contains parenthesis&quot;)        \\012  T(ArgStringTerminatesParametersEarly,                                        \\012 &quot;Arg string terminates parameters early&quot;)                                  \\012  T(UnexpectedEndOfArgString, &quot;Unexpected end of arg string&quot;)                  \\012  T(RestDefaultInitializer,                                                    \\012 &quot;Rest parameter may not have a default initializer&quot;)                       \\012  T(RuntimeWrongNumArgs, &quot;Runtime function given wrong number of arguments&quot;)   \\012  T(SuperNotCalled,                                                            \\012 &quot;Must call super constructor in derived class before accessing 'this' or &quot; \\012 &quot;returning from derived constructor&quot;)                                      \\012  T(SingleFunctionLiteral, &quot;Single function literal required&quot;)                 \\012  T(SloppyFunction,                                                            \\012 &quot;In non-strict mode code, functions can only be declared at top level, &quot;   \\012 &quot;inside a block, or as the body of an if statement.&quot;)                      \\012  T(SpeciesNotConstructor,                                                     \\012 &quot;object.constructor[Symbol.species] is not a constructor&quot;)                 \\012  T(StrictDelete, &quot;Delete of an unqualified identifier in strict mode.&quot;)       \\012  T(StrictEvalArguments, &quot;Unexpected eval or arguments in strict mode&quot;)        \\012  T(StrictFunction,                                                            \\012 &quot;In strict mode code, functions can only be declared at top level or &quot;     \\012 &quot;inside a block.&quot;)                                                         \\012  T(StrictOctalLiteral, &quot;Octal literals are not allowed in strict mode.&quot;)      \\012  T(StrictDecimalWithLeadingZero,                                              \\012 &quot;Decimals with leading zeros are not allowed in strict mode.&quot;)             \\012  T(StrictOctalEscape,                                                         \\012 &quot;Octal escape sequences are not allowed in strict mode.&quot;)                  \\012  T(StrictWith, &quot;Strict mode code may not include a with statement&quot;)           \\012  T(TemplateOctalLiteral,                                                      \\012 &quot;Octal escape sequences are not allowed in template strings.&quot;)             \\012  T(ThisFormalParameter, &quot;'this' is not a valid formal parameter name&quot;)        \\012  T(AwaitBindingIdentifier,                                                    \\012 &quot;'await' is not a valid identifier name in an async function&quot;)             \\012  T(AwaitExpressionFormalParameter,                                            \\012 &quot;Illegal await-expression in formal parameters of async function&quot;)         \\012  T(TooManyArguments,                                                          \\012 &quot;Too many arguments in function call (only 65535 allowed)&quot;)                \\012  T(TooManyParameters,                                                         \\012 &quot;Too many parameters in function definition (only 65534 allowed)&quot;)         \\012  T(TooManySpreads,                                                            \\012 &quot;Literal containing too many nested spreads (up to 65534 allowed)&quot;)        \\012  T(TooManyVariables, &quot;Too many variables declared (only 4194303 allowed)&quot;)    \\012  T(TooManyElementsInPromiseAll, &quot;Too many elements passed to Promise.all&quot;)    \\012  T(TypedArrayTooShort,                                                        \\012 &quot;Derived TypedArray constructor created an array which was too small&quot;)     \\012  T(UnexpectedEOS, &quot;Unexpected end of input&quot;)                                  \\012  T(UnexpectedReserved, &quot;Unexpected reserved word&quot;)                            \\012  T(UnexpectedStrictReserved, &quot;Unexpected strict mode reserved word&quot;)          \\012  T(UnexpectedSuper, &quot;'super' keyword unexpected here&quot;)                        \\012  T(UnexpectedNewTarget, &quot;new.target expression is not allowed here&quot;)          \\012  T(UnexpectedTemplateString, &quot;Unexpected template string&quot;)                    \\012  T(UnexpectedToken, &quot;Unexpected token %&quot;)                                     \\012  T(UnexpectedTokenIdentifier, &quot;Unexpected identifier&quot;)                        \\012  T(UnexpectedTokenNumber, &quot;Unexpected number&quot;)                                \\012  T(UnexpectedTokenString, &quot;Unexpected string&quot;)                                \\012  T(UnexpectedTokenRegExp, &quot;Unexpected regular expression&quot;)                    \\012  T(UnexpectedLexicalDeclaration,                                              \\012 &quot;Lexical declaration cannot appear in a single-statement context&quot;)         \\012  T(UnknownLabel, &quot;Undefined label '%'&quot;)                                       \\012  T(UnresolvableExport,                                                        \\012 &quot;The requested module '%' does not provide an export named '%'&quot;)           \\012  T(UnterminatedArgList, &quot;missing ) after argument list&quot;)                      \\012  T(UnterminatedRegExp, &quot;Invalid regular expression: missing /&quot;)               \\012  T(UnterminatedTemplate, &quot;Unterminated template literal&quot;)                     \\012  T(UnterminatedTemplateExpr, &quot;Missing } in template expression&quot;)              \\012  T(FoundNonCallableHasInstance, &quot;Found non-callable @@hasInstance&quot;)           \\012  T(InvalidHexEscapeSequence, &quot;Invalid hexadecimal escape sequence&quot;)           \\012  T(InvalidUnicodeEscapeSequence, &quot;Invalid Unicode escape sequence&quot;)           \\012  T(UndefinedUnicodeCodePoint, &quot;Undefined Unicode code-point&quot;)                 \\012  T(YieldInParameter, &quot;Yield expression not allowed in formal parameter&quot;)      \\012 /* EvalError */                                                              \\012  T(CodeGenFromStrings, &quot;%&quot;)                                                   \\012  T(NoSideEffectDebugEvaluate, &quot;Possible side-effect in debug-evaluate&quot;)       \\012 /* URIError */                                                               \\012  T(URIMalformed, &quot;URI malformed&quot;)                                             \\012 /* Wasm errors (currently Error) */                                          \\012  T(WasmTrapUnreachable, &quot;unreachable&quot;)                                        \\012  T(WasmTrapMemOutOfBounds, &quot;memory access out of bounds&quot;)                     \\012  T(WasmTrapUnalignedAccess, &quot;operation does not support unaligned accesses&quot;)  \\012  T(WasmTrapDivByZero, &quot;divide by zero&quot;)                                       \\012  T(WasmTrapDivUnrepresentable, &quot;divide result unrepresentable&quot;)               \\012  T(WasmTrapRemByZero, &quot;remainder by zero&quot;)                                    \\012  T(WasmTrapFloatUnrepresentable, &quot;float unrepresentable in integer range&quot;)    \\012  T(WasmTrapFuncInvalid, &quot;invalid index into function table&quot;)                  \\012  T(WasmTrapFuncSigMismatch, &quot;function signature mismatch&quot;)                    \\012  T(WasmTrapTypeError, &quot;wasm function signature contains illegal type&quot;)        \\012  T(WasmExceptionError, &quot;wasm exception&quot;)                                      \\012 /* Asm.js validation related */                                              \\012  T(AsmJsInvalid, &quot;Invalid asm.js: %&quot;)                                         \\012  T(AsmJsCompiled, &quot;Converted asm.js to WebAssembly: %&quot;)                       \\012  T(AsmJsInstantiated, &quot;Instantiated asm.js: %&quot;)                               \\012  T(AsmJsLinkingFailed, &quot;Linking failure in asm.js: %&quot;)                        \\012 /* DataCloneError messages */                                                \\012  T(DataCloneError, &quot;% could not be cloned.&quot;)                                  \\012  T(DataCloneErrorOutOfMemory, &quot;Data cannot be cloned, out of memory.&quot;)        \\012  T(DataCloneErrorNeuteredArrayBuffer,                                         \\012 &quot;An ArrayBuffer is neutered and could not be cloned.&quot;)                     \\012  T(DataCloneErrorSharedArrayBufferTransferred,                                \\012 &quot;A SharedArrayBuffer could not be cloned. SharedArrayBuffer must not be &quot;  \\012 &quot;transferred.&quot;)                                                            \\012  T(DataCloneDeserializationError, &quot;Unable to deserialize cloned data.&quot;)       \\012  T(DataCloneDeserializationVersionError,                                      \\012 &quot;Unable to deserialize cloned data due to invalid or unsupported &quot;         \\012 &quot;version.&quot;)                                                                \\012 /* Builtins-Trace Errors */                                                  \\012  T(TraceEventCategoryError, &quot;Trace event category must be a string.&quot;)         \\012  T(TraceEventNameError, &quot;Trace event name must be a string.&quot;)                 \\012  T(TraceEventNameLengthError,                                                 \\012 &quot;Trace event name must not be an empty string.&quot;)                           \\012  T(TraceEventPhaseError, &quot;Trace event phase must be a number.&quot;)               \\012  T(TraceEventIDError, &quot;Trace event id must be a number.&quot;)\012\012class MessageTemplate {\012 public:\012 enum Template {\012#define TEMPLATE(NAME, STRING) k##NAME,\012    MESSAGE_TEMPLATES(TEMPLATE)\012#undef TEMPLATE\012        kLastMessage\012 };\012\012 static const char* TemplateString(int template_index);\012\012 static MaybeHandle&lt;String&gt; FormatMessage(Isolate* isolate, int template_index,\012 Handle&lt;String&gt; arg0,\012 Handle&lt;String&gt; arg1,\012 Handle&lt;String&gt; arg2);\012\012 static Handle&lt;String&gt; FormatMessage(Isolate* isolate, int template_index,\012 Handle&lt;Object&gt; arg);\012};\012\012\012// A message handler is a convenience interface for accessing the list\012// of message listeners registered in an environment\012class MessageHandler {\012 public:\012 // Returns a message object for the API to use.\012 static Handle&lt;JSMessageObject&gt; MakeMessageObject(\012 Isolate* isolate, MessageTemplate::Template type,\012 const MessageLocation* location, Handle&lt;Object&gt; argument,\012 Handle&lt;FixedArray&gt; stack_frames);\012\012 // Report a formatted message (needs JS allocation).\012 static void ReportMessage(Isolate* isolate, const MessageLocation* loc,\012 Handle&lt;JSMessageObject&gt; message);\012\012 static void DefaultMessageReport(Isolate* isolate, const MessageLocation* loc,\012 Handle&lt;Object&gt; message_obj);\012 static Handle&lt;String&gt; GetMessage(Isolate* isolate, Handle&lt;Object&gt; data);\012 static std::unique_ptr&lt;char[]&gt; GetLocalizedMessage(Isolate* isolate,\012 Handle&lt;Object&gt; data);\012\012 private:\012 static void ReportMessageNoExceptions(Isolate* isolate,\012 const MessageLocation* loc,\012 Handle&lt;Object&gt; message_obj,\012                                        v8::Local&lt;v8::Value&gt; api_exception_obj);\012};\012\012\012} // namespace internal\012},namespace v8 {\012namespace internal {\012namespace wasm {\012class WasmCode;\012}\012\012// Forward declarations.\012class AbstractCode;\012class FrameArray;\012class JSMessageObject;\012class LookupIterator;\012class SharedFunctionInfo;\012class SourceInfo;\012class WasmInstanceObject;\012\012class MessageLocation {\012 public:\012 MessageLocation(Handle&lt;Script&gt; script, int start_pos, int end_pos);\012 MessageLocation(Handle&lt;Script&gt; script, int start_pos, int end_pos,\012 Handle&lt;SharedFunctionInfo&gt; shared);\012 MessageLocation();\012\012 Handle&lt;Script&gt; script() const { return script_; }\012 int start_pos() const { return start_pos_; }\012 int end_pos() const { return end_pos_; }\012 Handle&lt;SharedFunctionInfo&gt; shared() const { return shared_; }\012\012 private:\012 Handle&lt;Script&gt; script_;\012 int start_pos_;\012 int end_pos_;\012 Handle&lt;SharedFunctionInfo&gt; shared_;\012};\012\012class StackFrameBase {\012 public:\012 virtual ~StackFrameBase() {}\012\012 virtual Handle&lt;Object&gt; GetReceiver() const = 0;\012 virtual Handle&lt;Object&gt; GetFunction() const = 0;\012\012 virtual Handle&lt;Object&gt; GetFileName() = 0;\012 virtual Handle&lt;Object&gt; GetFunctionName() = 0;\012 virtual Handle&lt;Object&gt; GetScriptNameOrSourceUrl() = 0;\012 virtual Handle&lt;Object&gt; GetMethodName() = 0;\012 virtual Handle&lt;Object&gt; GetTypeName() = 0;\012 virtual Handle&lt;Object&gt; GetEvalOrigin();\012\012 virtual int GetPosition() const = 0;\012 // Return 1-based line number, including line offset.\012 virtual int GetLineNumber() = 0;\012 // Return 1-based column number, including column offset if first line.\012 virtual int GetColumnNumber() = 0;\012\012 virtual bool IsNative() = 0;\012 virtual bool IsToplevel() = 0;\012 virtual bool IsEval();\012 virtual bool IsConstructor() = 0;\012 virtual bool IsStrict() const = 0;\012\012 virtual MaybeHandle&lt;String&gt; ToString() = 0;\012\012 protected:\012 StackFrameBase() {}\012 explicit StackFrameBase(Isolate* isolate) : isolate_(isolate) {}\012 Isolate* isolate_;\012\012 private:\012 virtual bool HasScript() const = 0;\012 virtual Handle&lt;Script&gt; GetScript() const = 0;\012};\012\012class JSStackFrame : public StackFrameBase {\012 public:\012 JSStackFrame(Isolate* isolate, Handle&lt;Object&gt; receiver,\012 Handle&lt;JSFunction&gt; function, Handle&lt;AbstractCode&gt; code,\012 int offset);\012 virtual ~JSStackFrame() {}\012\012 Handle&lt;Object&gt; GetReceiver() const override { return receiver_; }\012 Handle&lt;Object&gt; GetFunction() const override;\012\012 Handle&lt;Object&gt; GetFileName() override;\012 Handle&lt;Object&gt; GetFunctionName() override;\012 Handle&lt;Object&gt; GetScriptNameOrSourceUrl() override;\012 Handle&lt;Object&gt; GetMethodName() override;\012 Handle&lt;Object&gt; GetTypeName() override;\012\012 int GetPosition() const override;\012 int GetLineNumber() override;\012 int GetColumnNumber() override;\012\012 bool IsNative() override;\012 bool IsToplevel() override;\012 bool IsConstructor() override { return is_constructor_; }\012 bool IsStrict() const override { return is_strict_; }\012\012 MaybeHandle&lt;String&gt; ToString() override;\012\012 private:\012 JSStackFrame();\012 void FromFrameArray(Isolate* isolate, Handle&lt;FrameArray&gt; array, int frame_ix);\012\012 bool HasScript() const override;\012 Handle&lt;Script&gt; GetScript() const override;\012\012 Handle&lt;Object&gt; receiver_;\012 Handle&lt;JSFunction&gt; function_;\012 Handle&lt;AbstractCode&gt; code_;\012 int offset_;\012\012 bool is_constructor_;\012 bool is_strict_;\012\012 friend class FrameArrayIterator;\012};\012\012class WasmStackFrame : public StackFrameBase {\012 public:\012 virtual ~WasmStackFrame() {}\012\012 Handle&lt;Object&gt; GetReceiver() const override;\012 Handle&lt;Object&gt; GetFunction() const override;\012\012 Handle&lt;Object&gt; GetFileName() override { return Null(); }\012 Handle&lt;Object&gt; GetFunctionName() override;\012 Handle&lt;Object&gt; GetScriptNameOrSourceUrl() override { return Null(); }\012 Handle&lt;Object&gt; GetMethodName() override { return Null(); }\012 Handle&lt;Object&gt; GetTypeName() override { return Null(); }\012\012 int GetPosition() const override;\012 int GetLineNumber() override { return wasm_func_index_; }\012 int GetColumnNumber() override { return -1; }\012\012 bool IsNative() override { return false; }\012 bool IsToplevel() override { return false; }\012 bool IsConstructor() override { return false; }\012 bool IsStrict() const override { return false; }\012 bool IsInterpreted() const { return code_ == nullptr; }\012\012 MaybeHandle&lt;String&gt; ToString() override;\012\012 protected:\012 Handle&lt;Object&gt; Null() const;\012\012 bool HasScript() const override;\012 Handle&lt;Script&gt; GetScript() const override;\012\012 Handle&lt;WasmInstanceObject&gt; wasm_instance_;\012 uint32_t wasm_func_index_;\012  wasm::WasmCode* code_; // null for interpreted frames.\012 int offset_;\012\012 private:\012 WasmStackFrame();\012 void FromFrameArray(Isolate* isolate, Handle&lt;FrameArray&gt; array, int frame_ix);\012\012 friend class FrameArrayIterator;\012 friend class AsmJsWasmStackFrame;\012};\012\012class AsmJsWasmStackFrame : public WasmStackFrame {\012 public:\012 virtual ~AsmJsWasmStackFrame() {}\012\012 Handle&lt;Object&gt; GetReceiver() const override;\012 Handle&lt;Object&gt; GetFunction() const override;\012\012 Handle&lt;Object&gt; GetFileName() override;\012 Handle&lt;Object&gt; GetScriptNameOrSourceUrl() override;\012\012 int GetPosition() const override;\012 int GetLineNumber() override;\012 int GetColumnNumber() override;\012\012 MaybeHandle&lt;String&gt; ToString() override;\012\012 private:\012 friend class FrameArrayIterator;\012 AsmJsWasmStackFrame();\012 void FromFrameArray(Isolate* isolate, Handle&lt;FrameArray&gt; array, int frame_ix);\012\012 bool is_at_number_conversion_;\012};\012\012class FrameArrayIterator {\012 public:\012 FrameArrayIterator(Isolate* isolate, Handle&lt;FrameArray&gt; array,\012 int frame_ix = 0);\012\012 StackFrameBase* Frame();\012\012 bool HasNext() const;\012 void Next();\012\012 private:\012 Isolate* isolate_;\012\012 Handle&lt;FrameArray&gt; array_;\012 int next_frame_ix_;\012\012 WasmStackFrame wasm_frame_;\012 AsmJsWasmStackFrame asm_wasm_frame_;\012 JSStackFrame js_frame_;\012};\012\012// Determines how stack trace collection skips frames.\012enum FrameSkipMode {\012 // Unconditionally skips the first frame. Used e.g. when the Error constructor\012 // is called, in which case the first frame is always a BUILTIN_EXIT frame.\012  SKIP_FIRST,\012 // Skip all frames until a specified caller function is seen.\012  SKIP_UNTIL_SEEN,\012  SKIP_NONE,\012};\012\012class ErrorUtils : public AllStatic {\012 public:\012 static MaybeHandle&lt;Object&gt; Construct(\012 Isolate* isolate, Handle&lt;JSFunction&gt; target, Handle&lt;Object&gt; new_target,\012 Handle&lt;Object&gt; message, FrameSkipMode mode, Handle&lt;Object&gt; caller,\012 bool suppress_detailed_trace);\012\012 static MaybeHandle&lt;String&gt; ToString(Isolate* isolate, Handle&lt;Object&gt; recv);\012\012 static MaybeHandle&lt;Object&gt; MakeGenericError(\012 Isolate* isolate, Handle&lt;JSFunction&gt; constructor, int template_index,\012 Handle&lt;Object&gt; arg0, Handle&lt;Object&gt; arg1, Handle&lt;Object&gt; arg2,\012 FrameSkipMode mode);\012\012 // Formats a textual stack trace from the given structured stack trace.\012 // Note that this can call arbitrary JS code through Error.prepareStackTrace.\012 static MaybeHandle&lt;Object&gt; FormatStackTrace(Isolate* isolate,\012 Handle&lt;JSObject&gt; error,\012 Handle&lt;Object&gt; stack_trace);\012};\012\012#define MESSAGE_TEMPLATES(T)                                                   \\012 /* Error */                                                                  \\012  T(None, &quot;&quot;)                                                                  \\012  T(CyclicProto, &quot;Cyclic __proto__ value&quot;)                                     \\012  T(Debugger, &quot;Debugger: %&quot;)                                                   \\012  T(DebuggerLoading, &quot;Error loading debugger&quot;)                                 \\012  T(DefaultOptionsMissing, &quot;Internal % error. Default options are missing.&quot;)   \\012  T(DeletePrivateField, &quot;Private fields can not be deleted&quot;)                   \\012  T(UncaughtException, &quot;Uncaught %&quot;)                                           \\012  T(Unsupported, &quot;Not supported&quot;)                                              \\012  T(WrongServiceType, &quot;Internal error, wrong service type: %&quot;)                 \\012  T(WrongValueType, &quot;Internal error. Wrong value type.&quot;)                       \\012  T(IcuError, &quot;Internal error. Icu error.&quot;)                                    \\012 /* TypeError */                                                              \\012  T(ApplyNonFunction,                                                          \\012 &quot;Function.prototype.apply was called on %, which is a % and not a &quot;        \\012 &quot;function&quot;)                                                                \\012  T(ArgumentsDisallowedInInitializer,                                          \\012 &quot;'arguments' is not allowed in class field initializer&quot;)                   \\012  T(ArrayBufferTooShort,                                                       \\012 &quot;Derived ArrayBuffer constructor created a buffer which was too small&quot;)    \\012  T(ArrayBufferSpeciesThis,                                                    \\012 &quot;ArrayBuffer subclass returned this from species constructor&quot;)             \\012  T(ArrayItemNotType, &quot;array %[%] is not type %&quot;)                              \\012  T(AwaitNotInAsyncFunction, &quot;await is only valid in async function&quot;)          \\012  T(AtomicsWaitNotAllowed, &quot;Atomics.wait cannot be called in this context&quot;)    \\012  T(BadSortComparisonFunction,                                                 \\012 &quot;The comparison function must be either a function or undefined&quot;)          \\012  T(BigIntFromNumber,                                                          \\012 &quot;The number % cannot be converted to a BigInt because it is not an &quot;       \\012 &quot;integer&quot;)                                                                 \\012  T(BigIntFromObject, &quot;Cannot convert % to a BigInt&quot;)                          \\012  T(BigIntMixedTypes,                                                          \\012 &quot;Cannot mix BigInt and other types, use explicit conversions&quot;)             \\012  T(BigIntSerializeJSON, &quot;Do not know how to serialize a BigInt&quot;)              \\012  T(BigIntShr, &quot;BigInts have no unsigned right shift, use &gt;&gt; instead&quot;)         \\012  T(BigIntToNumber, &quot;Cannot convert a BigInt value to a number&quot;)               \\012  T(CalledNonCallable, &quot;% is not a function&quot;)                                  \\012  T(CalledOnNonObject, &quot;% called on non-object&quot;)                               \\012  T(CalledOnNullOrUndefined, &quot;% called on null or undefined&quot;)                  \\012  T(CallSiteExpectsFunction,                                                   \\012 &quot;CallSite expects wasm object as first or function as second argument, &quot;   \\012 &quot;got &lt;%, %&gt;&quot;)                                                              \\012  T(CallSiteMethod, &quot;CallSite method % expects CallSite as receiver&quot;)          \\012  T(CannotConvertToPrimitive, &quot;Cannot convert object to primitive value&quot;)      \\012  T(CannotPreventExt, &quot;Cannot prevent extensions&quot;)                             \\012  T(CannotFreeze, &quot;Cannot freeze&quot;)                                             \\012  T(CannotFreezeArrayBufferView,                                               \\012 &quot;Cannot freeze array buffer views with elements&quot;)                          \\012  T(CannotSeal, &quot;Cannot seal&quot;)                                                 \\012  T(CircularStructure, &quot;Converting circular structure to JSON&quot;)                \\012  T(ConstructAbstractClass, &quot;Abstract class % not directly constructable&quot;)     \\012  T(ConstAssign, &quot;Assignment to constant variable.&quot;)                           \\012  T(ConstructorClassField, &quot;Classes may not have a field named 'constructor'&quot;) \\012  T(ConstructorNonCallable,                                                    \\012 &quot;Class constructor % cannot be invoked without 'new'&quot;)                     \\012  T(ConstructorNotFunction, &quot;Constructor % requires 'new'&quot;)                    \\012  T(ConstructorNotReceiver, &quot;The .constructor property is not an object&quot;)      \\012  T(CurrencyCode, &quot;Currency code is required with currency style.&quot;)            \\012  T(CyclicModuleDependency, &quot;Detected cycle while resolving name '%' in '%'&quot;)  \\012  T(DataViewNotArrayBuffer,                                                    \\012 &quot;First argument to DataView constructor must be an ArrayBuffer&quot;)           \\012  T(DateType, &quot;this is not a Date object.&quot;)                                    \\012  T(DebuggerFrame, &quot;Debugger: Invalid frame index.&quot;)                           \\012  T(DebuggerType, &quot;Debugger: Parameters have wrong types.&quot;)                    \\012  T(DeclarationMissingInitializer, &quot;Missing initializer in % declaration&quot;)     \\012  T(DefineDisallowed, &quot;Cannot define property %, object is not extensible&quot;)    \\012  T(DetachedOperation, &quot;Cannot perform % on a detached ArrayBuffer&quot;)           \\012  T(DuplicateTemplateProperty, &quot;Object template has duplicate property '%'&quot;)   \\012  T(ExtendsValueNotConstructor,                                                \\012 &quot;Class extends value % is not a constructor or null&quot;)                      \\012  T(FirstArgumentNotRegExp,                                                    \\012 &quot;First argument to % must not be a regular expression&quot;)                    \\012  T(FunctionBind, &quot;Bind must be called on a function&quot;)                         \\012  T(GeneratorRunning, &quot;Generator is already running&quot;)                          \\012  T(IllegalInvocation, &quot;Illegal invocation&quot;)                                   \\012  T(ImmutablePrototypeSet,                                                     \\012 &quot;Immutable prototype object '%' cannot have their prototype set&quot;)          \\012  T(ImportCallNotNewExpression, &quot;Cannot use new with import&quot;)                  \\012  T(ImportMetaOutsideModule, &quot;Cannot use 'import.meta' outside a module&quot;)      \\012  T(ImportMissingSpecifier, &quot;import() requires a specifier&quot;)                   \\012  T(IncompatibleMethodReceiver, &quot;Method % called on incompatible receiver %&quot;)  \\012  T(InstanceofNonobjectProto,                                                  \\012 &quot;Function has non-object prototype '%' in instanceof check&quot;)               \\012  T(InvalidArgument, &quot;invalid_argument&quot;)                                       \\012  T(InvalidInOperatorUse, &quot;Cannot use 'in' operator to search for '%' in %&quot;)   \\012  T(InvalidRegExpExecResult,                                                   \\012 &quot;RegExp exec method returned something other than an Object or null&quot;)      \\012  T(InvalidUnit, &quot;Invalid unit argument for %() '%'&quot;)                          \\012  T(IteratorResultNotAnObject, &quot;Iterator result % is not an object&quot;)           \\012  T(IteratorSymbolNonCallable, &quot;Found non-callable @@iterator&quot;)                \\012  T(IteratorValueNotAnObject, &quot;Iterator value % is not an entry object&quot;)       \\012  T(LanguageID, &quot;Language ID should be string or object.&quot;)                     \\012  T(LocaleNotEmpty,                                                            \\012 &quot;First argument to Intl.Locale constructor can't be empty or missing&quot;)     \\012  T(LocaleBadParameters, &quot;Incorrect locale information provided&quot;)              \\012  T(ListFormatBadParameters, &quot;Incorrect ListFormat information provided&quot;)      \\012  T(MapperFunctionNonCallable, &quot;flatMap mapper function is not callable&quot;)      \\012  T(MethodCalledOnWrongObject,                                                 \\012 &quot;Method % called on a non-object or on a wrong type of object.&quot;)           \\012  T(MethodInvokedOnNullOrUndefined,                                            \\012 &quot;Method invoked on undefined or null value.&quot;)                              \\012  T(MethodInvokedOnWrongType, &quot;Method invoked on an object that is not %.&quot;)    \\012  T(NoAccess, &quot;no access&quot;)                                                     \\012  T(NonCallableInInstanceOfCheck,                                              \\012 &quot;Right-hand side of 'instanceof' is not callable&quot;)                         \\012  T(NonCoercible, &quot;Cannot destructure 'undefined' or 'null'.&quot;)                 \\012  T(NonCoercibleWithProperty,                                                  \\012 &quot;Cannot destructure property `%` of 'undefined' or 'null'.&quot;)               \\012  T(NonExtensibleProto, &quot;% is not extensible&quot;)                                 \\012  T(NonObjectInInstanceOfCheck,                                                \\012 &quot;Right-hand side of 'instanceof' is not an object&quot;)                        \\012  T(NonObjectPropertyLoad, &quot;Cannot read property '%' of %&quot;)                    \\012  T(NonObjectPropertyStore, &quot;Cannot set property '%' of %&quot;)                    \\012  T(NoSetterInCallback, &quot;Cannot set property % of % which has only a getter&quot;)  \\012  T(NotAnIterator, &quot;% is not an iterator&quot;)                                     \\012  T(NotAPromise, &quot;% is not a promise&quot;)                                         \\012  T(NotConstructor, &quot;% is not a constructor&quot;)                                  \\012  T(NotDateObject, &quot;this is not a Date object.&quot;)                               \\012  T(NotGeneric, &quot;% requires that 'this' be a %&quot;)                               \\012  T(NotCallableOrIterable,                                                     \\012 &quot;% is not a function or its return value is not iterable&quot;)                 \\012  T(NotCallableOrAsyncIterable,                                                \\012 &quot;% is not a function or its return value is not async iterable&quot;)           \\012  T(NotFiniteNumber, &quot;Value need to be finite number for %()&quot;)                 \\012  T(NotIterable, &quot;% is not iterable&quot;)                                          \\012  T(NotAsyncIterable, &quot;% is not async iterable&quot;)                               \\012  T(NotPropertyName, &quot;% is not a valid property name&quot;)                         \\012  T(NotTypedArray, &quot;this is not a typed array.&quot;)                               \\012  T(NotSuperConstructor, &quot;Super constructor % of % is not a constructor&quot;)      \\012  T(NotSuperConstructorAnonymousClass,                                         \\012 &quot;Super constructor % of anonymous class is not a constructor&quot;)             \\012  T(NotIntegerSharedTypedArray, &quot;% is not an integer shared typed array.&quot;)     \\012  T(NotInt32SharedTypedArray, &quot;% is not an int32 shared typed array.&quot;)         \\012  T(ObjectGetterExpectingFunction,                                             \\012 &quot;Object.prototype.__defineGetter__: Expecting function&quot;)                   \\012  T(ObjectGetterCallable, &quot;Getter must be a function: %&quot;)                      \\012  T(ObjectNotExtensible, &quot;Cannot add property %, object is not extensible&quot;)    \\012  T(ObjectSetterExpectingFunction,                                             \\012 &quot;Object.prototype.__defineSetter__: Expecting function&quot;)                   \\012  T(ObjectSetterCallable, &quot;Setter must be a function: %&quot;)                      \\012  T(OrdinaryFunctionCalledAsConstructor,                                       \\012 &quot;Function object that's not a constructor was created with new&quot;)           \\012  T(PromiseCyclic, &quot;Chaining cycle detected for promise %&quot;)                    \\012  T(PromiseExecutorAlreadyInvoked,                                             \\012 &quot;Promise executor has already been invoked with non-undefined arguments&quot;)  \\012  T(PromiseNonCallable, &quot;Promise resolve or reject function is not callable&quot;)  \\012  T(PropertyDescObject, &quot;Property description must be an object: %&quot;)           \\012  T(PropertyNotFunction,                                                       \\012 &quot;'%' returned for property '%' of object '%' is not a function&quot;)           \\012  T(ProtoObjectOrNull, &quot;Object prototype may only be an Object or null: %&quot;)    \\012  T(PrototypeParentNotAnObject,                                                \\012 &quot;Class extends value does not have valid prototype property %&quot;)            \\012  T(ProxyConstructNonObject,                                                   \\012 &quot;'construct' on proxy: trap returned non-object ('%')&quot;)                    \\012  T(ProxyDefinePropertyNonConfigurable,                                        \\012 &quot;'defineProperty' on proxy: trap returned truish for defining &quot;            \\012 &quot;non-configurable property '%' which is either non-existant or &quot;           \\012 &quot;configurable in the proxy target&quot;)                                        \\012  T(ProxyDefinePropertyNonExtensible,                                          \\012 &quot;'defineProperty' on proxy: trap returned truish for adding property '%' &quot; \\012 &quot; to the non-extensible proxy target&quot;)                                     \\012  T(ProxyDefinePropertyIncompatible,                                           \\012 &quot;'defineProperty' on proxy: trap returned truish for adding property '%' &quot; \\012 &quot; that is incompatible with the existing property in the proxy target&quot;)    \\012  T(ProxyDeletePropertyNonConfigurable,                                        \\012 &quot;'deleteProperty' on proxy: trap returned truish for property '%' which &quot;  \\012 &quot;is non-configurable in the proxy target&quot;)                                 \\012  T(ProxyGetNonConfigurableData,                                               \\012 &quot;'get' on proxy: property '%' is a read-only and &quot;                         \\012 &quot;non-configurable data property on the proxy target but the proxy &quot;        \\012 &quot;did not return its actual value (expected '%' but got '%')&quot;)              \\012  T(ProxyGetNonConfigurableAccessor,                                           \\012 &quot;'get' on proxy: property '%' is a non-configurable accessor &quot;             \\012 &quot;property on the proxy target and does not have a getter function, but &quot;   \\012 &quot;the trap did not return 'undefined' (got '%')&quot;)                           \\012  T(ProxyGetOwnPropertyDescriptorIncompatible,                                 \\012 &quot;'getOwnPropertyDescriptor' on proxy: trap returned descriptor for &quot;       \\012 &quot;property '%' that is incompatible with the existing property in the &quot;     \\012 &quot;proxy target&quot;)                                                            \\012  T(ProxyGetOwnPropertyDescriptorInvalid,                                      \\012 &quot;'getOwnPropertyDescriptor' on proxy: trap returned neither object nor &quot;   \\012 &quot;undefined for property '%'&quot;)                                              \\012  T(ProxyGetOwnPropertyDescriptorNonConfigurable,                              \\012 &quot;'getOwnPropertyDescriptor' on proxy: trap reported non-configurability &quot;  \\012 &quot;for property '%' which is either non-existant or configurable in the &quot;    \\012 &quot;proxy target&quot;)                                                            \\012  T(ProxyGetOwnPropertyDescriptorNonExtensible,                                \\012 &quot;'getOwnPropertyDescriptor' on proxy: trap returned undefined for &quot;        \\012 &quot;property '%' which exists in the non-extensible proxy target&quot;)            \\012  T(ProxyGetOwnPropertyDescriptorUndefined,                                    \\012 &quot;'getOwnPropertyDescriptor' on proxy: trap returned undefined for &quot;        \\012 &quot;property '%' which is non-configurable in the proxy target&quot;)              \\012  T(ProxyGetPrototypeOfInvalid,                                                \\012 &quot;'getPrototypeOf' on proxy: trap returned neither object nor null&quot;)        \\012  T(ProxyGetPrototypeOfNonExtensible,                                          \\012 &quot;'getPrototypeOf' on proxy: proxy target is non-extensible but the &quot;       \\012 &quot;trap did not return its actual prototype&quot;)                                \\012  T(ProxyHandlerOrTargetRevoked,                                               \\012 &quot;Cannot create proxy with a revoked proxy as target or handler&quot;)           \\012  T(ProxyHasNonConfigurable,                                                   \\012 &quot;'has' on proxy: trap returned falsish for property '%' which exists in &quot;  \\012 &quot;the proxy target as non-configurable&quot;)                                    \\012  T(ProxyHasNonExtensible,                                                     \\012 &quot;'has' on proxy: trap returned falsish for property '%' but the proxy &quot;    \\012 &quot;target is not extensible&quot;)                                                \\012  T(ProxyIsExtensibleInconsistent,                                             \\012 &quot;'isExtensible' on proxy: trap result does not reflect extensibility of &quot;  \\012 &quot;proxy target (which is '%')&quot;)                                             \\012  T(ProxyNonObject,                                                            \\012 &quot;Cannot create proxy with a non-object as target or handler&quot;)              \\012  T(ProxyOwnKeysMissing,                                                       \\012 &quot;'ownKeys' on proxy: trap result did not include '%'&quot;)                     \\012  T(ProxyOwnKeysNonExtensible,                                                 \\012 &quot;'ownKeys' on proxy: trap returned extra keys but proxy target is &quot;        \\012 &quot;non-extensible&quot;)                                                          \\012  T(ProxyPreventExtensionsExtensible,                                          \\012 &quot;'preventExtensions' on proxy: trap returned truish but the proxy target &quot; \\012 &quot;is extensible&quot;)                                                           \\012  T(ProxyPrivate, &quot;Cannot pass private property name to proxy trap&quot;)           \\012  T(ProxyRevoked, &quot;Cannot perform '%' on a proxy that has been revoked&quot;)       \\012  T(ProxySetFrozenData,                                                        \\012 &quot;'set' on proxy: trap returned truish for property '%' which exists in &quot;   \\012 &quot;the proxy target as a non-configurable and non-writable data property &quot;   \\012 &quot;with a different value&quot;)                                                  \\012  T(ProxySetFrozenAccessor,                                                    \\012 &quot;'set' on proxy: trap returned truish for property '%' which exists in &quot;   \\012 &quot;the proxy target as a non-configurable and non-writable accessor &quot;        \\012 &quot;property without a setter&quot;)                                               \\012  T(ProxySetPrototypeOfNonExtensible,                                          \\012 &quot;'setPrototypeOf' on proxy: trap returned truish for setting a new &quot;       \\012 &quot;prototype on the non-extensible proxy target&quot;)                            \\012  T(ProxyTrapReturnedFalsish, &quot;'%' on proxy: trap returned falsish&quot;)           \\012  T(ProxyTrapReturnedFalsishFor,                                               \\012 &quot;'%' on proxy: trap returned falsish for property '%'&quot;)                    \\012  T(RedefineDisallowed, &quot;Cannot redefine property: %&quot;)                         \\012  T(RedefineExternalArray,                                                     \\012 &quot;Cannot redefine a property of an object with external array elements&quot;)    \\012  T(ReduceNoInitial, &quot;Reduce of empty array with no initial value&quot;)            \\012  T(RegExpFlags,                                                               \\012 &quot;Cannot supply flags when constructing one RegExp from another&quot;)           \\012  T(RegExpNonObject, &quot;% getter called on non-object %&quot;)                        \\012  T(RegExpNonRegExp, &quot;% getter called on non-RegExp object&quot;)                   \\012  T(RelativeDateTimeFormatterBadParameters,                                    \\012 &quot;Incorrect RelativeDateTimeFormatter provided&quot;)                            \\012  T(ResolverNotAFunction, &quot;Promise resolver % is not a function&quot;)              \\012  T(ReturnMethodNotCallable, &quot;The iterator's 'return' method is not callable&quot;) \\012  T(SharedArrayBufferTooShort,                                                 \\012 &quot;Derived SharedArrayBuffer constructor created a buffer which was too &quot;    \\012 &quot;small&quot;)                                                                   \\012  T(SharedArrayBufferSpeciesThis,                                              \\012 &quot;SharedArrayBuffer subclass returned this from species constructor&quot;)       \\012  T(StaticPrototype,                                                           \\012 &quot;Classes may not have a static property named 'prototype'&quot;)                \\012  T(StrictDeleteProperty, &quot;Cannot delete property '%' of %&quot;)                   \\012  T(StrictPoisonPill,                                                          \\012 &quot;'caller', 'callee', and 'arguments' properties may not be accessed on &quot;   \\012 &quot;strict mode functions or the arguments objects for calls to them&quot;)        \\012  T(StrictReadOnlyProperty,                                                    \\012 &quot;Cannot assign to read only property '%' of % '%'&quot;)                        \\012  T(StrictCannotCreateProperty, &quot;Cannot create property '%' on % '%'&quot;)         \\012  T(SymbolIteratorInvalid,                                                     \\012 &quot;Result of the Symbol.iterator method is not an object&quot;)                   \\012  T(SymbolAsyncIteratorInvalid,                                                \\012 &quot;Result of the Symbol.asyncIterator method is not an object&quot;)              \\012  T(SymbolKeyFor, &quot;% is not a symbol&quot;)                                         \\012  T(SymbolToNumber, &quot;Cannot convert a Symbol value to a number&quot;)               \\012  T(SymbolToString, &quot;Cannot convert a Symbol value to a string&quot;)               \\012  T(ThrowMethodMissing, &quot;The iterator does not provide a 'throw' method.&quot;)     \\012  T(UndefinedOrNullToObject, &quot;Cannot convert undefined or null to object&quot;)     \\012  T(ValueAndAccessor,                                                          \\012 &quot;Invalid property descriptor. Cannot both specify accessors and a value &quot;  \\012 &quot;or writable attribute, %&quot;)                                                \\012  T(VarRedeclaration, &quot;Identifier '%' has already been declared&quot;)              \\012  T(WrongArgs, &quot;%: Arguments list has wrong type&quot;)                             \\012 /* ReferenceError */                                                         \\012  T(NotDefined, &quot;% is not defined&quot;)                                            \\012  T(SuperAlreadyCalled, &quot;Super constructor may only be called once&quot;)           \\012  T(UnsupportedSuper, &quot;Unsupported reference to 'super'&quot;)                      \\012 /* RangeError */                                                             \\012  T(BigIntDivZero, &quot;Division by zero&quot;)                                         \\012  T(BigIntNegativeExponent, &quot;Exponent must be positive&quot;)                       \\012  T(BigIntTooBig, &quot;Maximum BigInt size exceeded&quot;)                              \\012  T(DateRange, &quot;Provided date is not in valid range.&quot;)                         \\012  T(ExpectedLocation,                                                          \\012 &quot;Expected letters optionally connected with underscores or hyphens for &quot;   \\012 &quot;a location, got %&quot;)                                                       \\012  T(InvalidArrayBufferLength, &quot;Invalid array buffer length&quot;)                   \\012  T(ArrayBufferAllocationFailed, &quot;Array buffer allocation failed&quot;)             \\012  T(InvalidArrayLength, &quot;Invalid array length&quot;)                                \\012  T(InvalidAtomicAccessIndex, &quot;Invalid atomic access index&quot;)                   \\012  T(InvalidCodePoint, &quot;Invalid code point %&quot;)                                  \\012  T(InvalidCountValue, &quot;Invalid count value&quot;)                                  \\012  T(InvalidCurrencyCode, &quot;Invalid currency code: %&quot;)                           \\012  T(InvalidDataViewAccessorOffset,                                             \\012 &quot;Offset is outside the bounds of the DataView&quot;)                            \\012  T(InvalidDataViewLength, &quot;Invalid DataView length %&quot;)                        \\012  T(InvalidOffset, &quot;Start offset % is outside the bounds of the buffer&quot;)       \\012  T(InvalidHint, &quot;Invalid hint: %&quot;)                                            \\012  T(InvalidIndex, &quot;Invalid value: not (convertible to) a safe integer&quot;)        \\012  T(InvalidLanguageTag, &quot;Invalid language tag: %&quot;)                             \\012  T(InvalidWeakMapKey, &quot;Invalid value used as weak map key&quot;)                   \\012  T(InvalidWeakSetValue, &quot;Invalid value used in weak set&quot;)                     \\012  T(InvalidStringLength, &quot;Invalid string length&quot;)                              \\012  T(InvalidTimeValue, &quot;Invalid time value&quot;)                                    \\012  T(InvalidTimeZone, &quot;Invalid time zone specified: %&quot;)                         \\012  T(InvalidTypedArrayAlignment, &quot;% of % should be a multiple of %&quot;)            \\012  T(InvalidTypedArrayIndex, &quot;Invalid typed array index&quot;)                       \\012  T(InvalidTypedArrayLength, &quot;Invalid typed array length: %&quot;)                  \\012  T(LetInLexicalBinding, &quot;let is disallowed as a lexically bound name&quot;)        \\012  T(LocaleMatcher, &quot;Illegal value for localeMatcher:%&quot;)                        \\012  T(NormalizationForm, &quot;The normalization form should be one of %.&quot;)           \\012  T(ZeroDigitNumericSeparator,                                                 \\012 &quot;Numeric separator can not be used after leading 0.&quot;)                      \\012  T(NumberFormatRange, &quot;% argument must be between 0 and 100&quot;)                 \\012  T(TrailingNumericSeparator,                                                  \\012 &quot;Numeric separators are not allowed at the end of numeric literals&quot;)       \\012  T(ContinuousNumericSeparator,                                                \\012 &quot;Only one underscore is allowed as numeric separator&quot;)                     \\012  T(PropertyValueOutOfRange, &quot;% value is out of range.&quot;)                       \\012  T(StackOverflow, &quot;Maximum call stack size exceeded&quot;)                         \\012  T(ToPrecisionFormatRange,                                                    \\012 &quot;toPrecision() argument must be between 1 and 100&quot;)                        \\012  T(ToRadixFormatRange, &quot;toString() radix argument must be between 2 and 36&quot;)  \\012  T(TypedArraySetOffsetOutOfBounds, &quot;offset is out of bounds&quot;)                 \\012  T(TypedArraySetSourceTooLarge, &quot;Source is too large&quot;)                        \\012  T(ValueOutOfRange, &quot;Value % out of range for % options property %&quot;)          \\012 /* SyntaxError */                                                            \\012  T(AmbiguousExport,                                                           \\012 &quot;The requested module '%' contains conflicting star exports for name '%'&quot;) \\012  T(BadGetterArity, &quot;Getter must not have any formal parameters.&quot;)             \\012  T(BadSetterArity, &quot;Setter must have exactly one formal parameter.&quot;)          \\012  T(BigIntInvalidString, &quot;Invalid BigInt string&quot;)                              \\012  T(ConstructorIsAccessor, &quot;Class constructor may not be an accessor&quot;)         \\012  T(ConstructorIsGenerator, &quot;Class constructor may not be a generator&quot;)        \\012  T(ConstructorIsAsync, &quot;Class constructor may not be an async method&quot;)        \\012  T(DerivedConstructorReturnedNonObject,                                       \\012 &quot;Derived constructors may only return object or undefined&quot;)                \\012  T(DuplicateConstructor, &quot;A class may only have one constructor&quot;)             \\012  T(DuplicateExport, &quot;Duplicate export of '%'&quot;)                                \\012  T(DuplicateProto,                                                            \\012 &quot;Duplicate __proto__ fields are not allowed in object literals&quot;)           \\012  T(ForInOfLoopInitializer,                                                    \\012 &quot;% loop variable declaration may not have an initializer.&quot;)                \\012  T(ForInOfLoopMultiBindings,                                                  \\012 &quot;Invalid left-hand side in % loop: Must have a single binding.&quot;)           \\012  T(GeneratorInSingleStatementContext,                                         \\012 &quot;Generators can only be declared at the top level or inside a block.&quot;)     \\012  T(AsyncFunctionInSingleStatementContext,                                     \\012 &quot;Async functions can only be declared at the top level or inside a &quot;       \\012 &quot;block.&quot;)                                                                  \\012  T(IllegalBreak, &quot;Illegal break statement&quot;)                                   \\012  T(NoIterationStatement,                                                      \\012 &quot;Illegal continue statement: no surrounding iteration statement&quot;)          \\012  T(IllegalContinue,                                                           \\012 &quot;Illegal continue statement: '%' does not denote an iteration statement&quot;)  \\012  T(IllegalLanguageModeDirective,                                              \\012 &quot;Illegal '%' directive in function with non-simple parameter list&quot;)        \\012  T(IllegalReturn, &quot;Illegal return statement&quot;)                                 \\012  T(IntrinsicWithSpread, &quot;Intrinsic calls do not support spread arguments&quot;)    \\012  T(InvalidRestBindingPattern,                                                 \\012 &quot;`...` must be followed by an identifier in declaration contexts&quot;)         \\012  T(InvalidRestAssignmentPattern,                                              \\012 &quot;`...` must be followed by an assignable reference in assignment &quot;         \\012 &quot;contexts&quot;)                                                                \\012  T(InvalidEscapedReservedWord, &quot;Keyword must not contain escaped characters&quot;) \\012  T(InvalidEscapedMetaProperty, &quot;'%' must not contain escaped characters&quot;)     \\012  T(InvalidLhsInAssignment, &quot;Invalid left-hand side in assignment&quot;)            \\012  T(InvalidCoverInitializedName, &quot;Invalid shorthand property initializer&quot;)     \\012  T(InvalidDestructuringTarget, &quot;Invalid destructuring assignment target&quot;)     \\012  T(InvalidLhsInFor, &quot;Invalid left-hand side in for-loop&quot;)                     \\012  T(InvalidLhsInPostfixOp,                                                     \\012 &quot;Invalid left-hand side expression in postfix operation&quot;)                  \\012  T(InvalidLhsInPrefixOp,                                                      \\012 &quot;Invalid left-hand side expression in prefix operation&quot;)                   \\012  T(InvalidRegExpFlags, &quot;Invalid flags supplied to RegExp constructor '%'&quot;)    \\012  T(InvalidOrUnexpectedToken, &quot;Invalid or unexpected token&quot;)                   \\012  T(InvalidPrivateFieldAccess, &quot;Invalid private field '%'&quot;)                    \\012  T(JsonParseUnexpectedEOS, &quot;Unexpected end of JSON input&quot;)                    \\012  T(JsonParseUnexpectedToken, &quot;Unexpected token % in JSON at position %&quot;)      \\012  T(JsonParseUnexpectedTokenNumber, &quot;Unexpected number in JSON at position %&quot;) \\012  T(JsonParseUnexpectedTokenString, &quot;Unexpected string in JSON at position %&quot;) \\012  T(LabelRedeclaration, &quot;Label '%' has already been declared&quot;)                 \\012  T(LabelledFunctionDeclaration,                                               \\012 &quot;Labelled function declaration not allowed as the body of a control flow &quot; \\012 &quot;structure&quot;)                                                               \\012  T(MalformedArrowFunParamList, &quot;Malformed arrow function parameter list&quot;)     \\012  T(MalformedRegExp, &quot;Invalid regular expression: /%/: %&quot;)                     \\012  T(MalformedRegExpFlags, &quot;Invalid regular expression flags&quot;)                  \\012  T(ModuleExportUndefined, &quot;Export '%' is not defined in module&quot;)              \\012  T(HtmlCommentInModule, &quot;HTML comments are not allowed in modules&quot;)           \\012  T(MultipleDefaultsInSwitch,                                                  \\012 &quot;More than one default clause in switch statement&quot;)                        \\012  T(NewlineAfterThrow, &quot;Illegal newline after throw&quot;)                          \\012  T(NoCatchOrFinally, &quot;Missing catch or finally after try&quot;)                    \\012  T(NotIsvar, &quot;builtin %%IS_VAR: not a variable&quot;)                              \\012  T(ParamAfterRest, &quot;Rest parameter must be last formal parameter&quot;)            \\012  T(FlattenPastSafeLength,                                                     \\012 &quot;Flattening % elements on an array-like of length % &quot;                      \\012 &quot;is disallowed, as the total surpasses 2**53-1&quot;)                           \\012  T(PushPastSafeLength,                                                        \\012 &quot;Pushing % elements on an array-like of length % &quot;                         \\012 &quot;is disallowed, as the total surpasses 2**53-1&quot;)                           \\012  T(ElementAfterRest, &quot;Rest element must be last element&quot;)                     \\012  T(BadSetterRestParameter,                                                    \\012 &quot;Setter function argument must not be a rest parameter&quot;)                   \\012  T(ParamDupe, &quot;Duplicate parameter name not allowed in this context&quot;)         \\012  T(ParenthesisInArgString, &quot;Function arg string contains parenthesis&quot;)        \\012  T(ArgStringTerminatesParametersEarly,                                        \\012 &quot;Arg string terminates parameters early&quot;)                                  \\012  T(UnexpectedEndOfArgString, &quot;Unexpected end of arg string&quot;)                  \\012  T(RestDefaultInitializer,                                                    \\012 &quot;Rest parameter may not have a default initializer&quot;)                       \\012  T(RuntimeWrongNumArgs, &quot;Runtime function given wrong number of arguments&quot;)   \\012  T(SuperNotCalled,                                                            \\012 &quot;Must call super constructor in derived class before accessing 'this' or &quot; \\012 &quot;returning from derived constructor&quot;)                                      \\012  T(SingleFunctionLiteral, &quot;Single function literal required&quot;)                 \\012  T(SloppyFunction,                                                            \\012 &quot;In non-strict mode code, functions can only be declared at top level, &quot;   \\012 &quot;inside a block, or as the body of an if statement.&quot;)                      \\012  T(SpeciesNotConstructor,                                                     \\012 &quot;object.constructor[Symbol.species] is not a constructor&quot;)                 \\012  T(StrictDelete, &quot;Delete of an unqualified identifier in strict mode.&quot;)       \\012  T(StrictEvalArguments, &quot;Unexpected eval or arguments in strict mode&quot;)        \\012  T(StrictFunction,                                                            \\012 &quot;In strict mode code, functions can only be declared at top level or &quot;     \\012 &quot;inside a block.&quot;)                                                         \\012  T(StrictOctalLiteral, &quot;Octal literals are not allowed in strict mode.&quot;)      \\012  T(StrictDecimalWithLeadingZero,                                              \\012 &quot;Decimals with leading zeros are not allowed in strict mode.&quot;)             \\012  T(StrictOctalEscape,                                                         \\012 &quot;Octal escape sequences are not allowed in strict mode.&quot;)                  \\012  T(StrictWith, &quot;Strict mode code may not include a with statement&quot;)           \\012  T(TemplateOctalLiteral,                                                      \\012 &quot;Octal escape sequences are not allowed in template strings.&quot;)             \\012  T(ThisFormalParameter, &quot;'this' is not a valid formal parameter name&quot;)        \\012  T(AwaitBindingIdentifier,                                                    \\012 &quot;'await' is not a valid identifier name in an async function&quot;)             \\012  T(AwaitExpressionFormalParameter,                                            \\012 &quot;Illegal await-expression in formal parameters of async function&quot;)         \\012  T(TooManyArguments,                                                          \\012 &quot;Too many arguments in function call (only 65535 allowed)&quot;)                \\012  T(TooManyParameters,                                                         \\012 &quot;Too many parameters in function definition (only 65534 allowed)&quot;)         \\012  T(TooManySpreads,                                                            \\012 &quot;Literal containing too many nested spreads (up to 65534 allowed)&quot;)        \\012  T(TooManyVariables, &quot;Too many variables declared (only 4194303 allowed)&quot;)    \\012  T(TooManyElementsInPromiseAll, &quot;Too many elements passed to Promise.all&quot;)    \\012  T(TypedArrayTooShort,                                                        \\012 &quot;Derived TypedArray constructor created an array which was too small&quot;)     \\012  T(UnexpectedEOS, &quot;Unexpected end of input&quot;)                                  \\012  T(UnexpectedReserved, &quot;Unexpected reserved word&quot;)                            \\012  T(UnexpectedStrictReserved, &quot;Unexpected strict mode reserved word&quot;)          \\012  T(UnexpectedSuper, &quot;'super' keyword unexpected here&quot;)                        \\012  T(UnexpectedNewTarget, &quot;new.target expression is not allowed here&quot;)          \\012  T(UnexpectedTemplateString, &quot;Unexpected template string&quot;)                    \\012  T(UnexpectedToken, &quot;Unexpected token %&quot;)                                     \\012  T(UnexpectedTokenIdentifier, &quot;Unexpected identifier&quot;)                        \\012  T(UnexpectedTokenNumber, &quot;Unexpected number&quot;)                                \\012  T(UnexpectedTokenString, &quot;Unexpected string&quot;)                                \\012  T(UnexpectedTokenRegExp, &quot;Unexpected regular expression&quot;)                    \\012  T(UnexpectedLexicalDeclaration,                                              \\012 &quot;Lexical declaration cannot appear in a single-statement context&quot;)         \\012  T(UnknownLabel, &quot;Undefined label '%'&quot;)                                       \\012  T(UnresolvableExport,                                                        \\012 &quot;The requested module '%' does not provide an export named '%'&quot;)           \\012  T(UnterminatedArgList, &quot;missing ) after argument list&quot;)                      \\012  T(UnterminatedRegExp, &quot;Invalid regular expression: missing /&quot;)               \\012  T(UnterminatedTemplate, &quot;Unterminated template literal&quot;)                     \\012  T(UnterminatedTemplateExpr, &quot;Missing } in template expression&quot;)              \\012  T(FoundNonCallableHasInstance, &quot;Found non-callable @@hasInstance&quot;)           \\012  T(InvalidHexEscapeSequence, &quot;Invalid hexadecimal escape sequence&quot;)           \\012  T(InvalidUnicodeEscapeSequence, &quot;Invalid Unicode escape sequence&quot;)           \\012  T(UndefinedUnicodeCodePoint, &quot;Undefined Unicode code-point&quot;)                 \\012  T(YieldInParameter, &quot;Yield expression not allowed in formal parameter&quot;)      \\012 /* EvalError */                                                              \\012  T(CodeGenFromStrings, &quot;%&quot;)                                                   \\012  T(NoSideEffectDebugEvaluate, &quot;Possible side-effect in debug-evaluate&quot;)       \\012 /* URIError */                                                               \\012  T(URIMalformed, &quot;URI malformed&quot;)                                             \\012 /* Wasm errors (currently Error) */                                          \\012  T(WasmTrapUnreachable, &quot;unreachable&quot;)                                        \\012  T(WasmTrapMemOutOfBounds, &quot;memory access out of bounds&quot;)                     \\012  T(WasmTrapUnalignedAccess, &quot;operation does not support unaligned accesses&quot;)  \\012  T(WasmTrapDivByZero, &quot;divide by zero&quot;)                                       \\012  T(WasmTrapDivUnrepresentable, &quot;divide result unrepresentable&quot;)               \\012  T(WasmTrapRemByZero, &quot;remainder by zero&quot;)                                    \\012  T(WasmTrapFloatUnrepresentable, &quot;float unrepresentable in integer range&quot;)    \\012  T(WasmTrapFuncInvalid, &quot;invalid index into function table&quot;)                  \\012  T(WasmTrapFuncSigMismatch, &quot;function signature mismatch&quot;)                    \\012  T(WasmTrapTypeError, &quot;wasm function signature contains illegal type&quot;)        \\012  T(WasmExceptionError, &quot;wasm exception&quot;)                                      \\012 /* Asm.js validation related */                                              \\012  T(AsmJsInvalid, &quot;Invalid asm.js: %&quot;)                                         \\012  T(AsmJsCompiled, &quot;Converted asm.js to WebAssembly: %&quot;)                       \\012  T(AsmJsInstantiated, &quot;Instantiated asm.js: %&quot;)                               \\012  T(AsmJsLinkingFailed, &quot;Linking failure in asm.js: %&quot;)                        \\012 /* DataCloneError messages */                                                \\012  T(DataCloneError, &quot;% could not be cloned.&quot;)                                  \\012  T(DataCloneErrorOutOfMemory, &quot;Data cannot be cloned, out of memory.&quot;)        \\012  T(DataCloneErrorNeuteredArrayBuffer,                                         \\012 &quot;An ArrayBuffer is neutered and could not be cloned.&quot;)                     \\012  T(DataCloneErrorSharedArrayBufferTransferred,                                \\012 &quot;A SharedArrayBuffer could not be cloned. SharedArrayBuffer must not be &quot;  \\012 &quot;transferred.&quot;)                                                            \\012  T(DataCloneDeserializationError, &quot;Unable to deserialize cloned data.&quot;)       \\012  T(DataCloneDeserializationVersionError,                                      \\012 &quot;Unable to deserialize cloned data due to invalid or unsupported &quot;         \\012 &quot;version.&quot;)                                                                \\012 /* Builtins-Trace Errors */                                                  \\012  T(TraceEventCategoryError, &quot;Trace event category must be a string.&quot;)         \\012  T(TraceEventNameError, &quot;Trace event name must be a string.&quot;)                 \\012  T(TraceEventNameLengthError,                                                 \\012 &quot;Trace event name must not be an empty string.&quot;)                           \\012  T(TraceEventPhaseError, &quot;Trace event phase must be a number.&quot;)               \\012  T(TraceEventIDError, &quot;Trace event id must be a number.&quot;)\012\012class MessageTemplate {\012 public:\012 enum Template {\012#define TEMPLATE(NAME, STRING) k##NAME,\012    MESSAGE_TEMPLATES(TEMPLATE)\012#undef TEMPLATE\012        kLastMessage\012 };\012\012 static const char* TemplateString(int template_index);\012\012 static MaybeHandle&lt;String&gt; FormatMessage(Isolate* isolate, int template_index,\012 Handle&lt;String&gt; arg0,\012 Handle&lt;String&gt; arg1,\012 Handle&lt;String&gt; arg2);\012\012 static Handle&lt;String&gt; FormatMessage(Isolate* isolate, int template_index,\012 Handle&lt;Object&gt; arg);\012};\012\012\012// A message handler is a convenience interface for accessing the list\012// of message listeners registered in an environment\012class MessageHandler {\012 public:\012 // Returns a message object for the API to use.\012 static Handle&lt;JSMessageObject&gt; MakeMessageObject(\012 Isolate* isolate, MessageTemplate::Template type,\012 const MessageLocation* location, Handle&lt;Object&gt; argument,\012 Handle&lt;FixedArray&gt; stack_frames);\012\012 // Report a formatted message (needs JS allocation).\012 static void ReportMessage(Isolate* isolate, const MessageLocation* loc,\012 Handle&lt;JSMessageObject&gt; message);\012\012 static void DefaultMessageReport(Isolate* isolate, const MessageLocation* loc,\012 Handle&lt;Object&gt; message_obj);\012 static Handle&lt;String&gt; GetMessage(Isolate* isolate, Handle&lt;Object&gt; data);\012 static std::unique_ptr&lt;char[]&gt; GetLocalizedMessage(Isolate* isolate,\012 Handle&lt;Object&gt; data);\012\012 private:\012 static void ReportMessageNoExceptions(Isolate* isolate,\012 const MessageLocation* loc,\012 Handle&lt;Object&gt; message_obj,\012                                        v8::Local&lt;v8::Value&gt; api_exception_obj);\012};\012\012\012} // namespace internal\012})<SUB>17</SUB>> ]
+"7" [label = <(UNKNOWN,namespace v8 {\012namespace internal {\012namespace wasm {\012class WasmCode;\012}\012\012// Forward declarations.\012class AbstractCode;\012class FrameArray;\012class JSMessageObject;\012class LookupIterator;\012class SharedFunctionInfo;\012class SourceInfo;\012class WasmInstanceObject;\012\012class MessageLocation {\012 public:\012 MessageLocation(Handle&lt;Script&gt; script, int start_pos, int end_pos);\012 MessageLocation(Handle&lt;Script&gt; script, int start_pos, int end_pos,\012 Handle&lt;SharedFunctionInfo&gt; shared);\012 MessageLocation();\012\012 Handle&lt;Script&gt; script() const { return script_; }\012 int start_pos() const { return start_pos_; }\012 int end_pos() const { return end_pos_; }\012 Handle&lt;SharedFunctionInfo&gt; shared() const { return shared_; }\012\012 private:\012 Handle&lt;Script&gt; script_;\012 int start_pos_;\012 int end_pos_;\012 Handle&lt;SharedFunctionInfo&gt; shared_;\012};\012\012class StackFrameBase {\012 public:\012 virtual ~StackFrameBase() {}\012\012 virtual Handle&lt;Object&gt; GetReceiver() const = 0;\012 virtual Handle&lt;Object&gt; GetFunction() const = 0;\012\012 virtual Handle&lt;Object&gt; GetFileName() = 0;\012 virtual Handle&lt;Object&gt; GetFunctionName() = 0;\012 virtual Handle&lt;Object&gt; GetScriptNameOrSourceUrl() = 0;\012 virtual Handle&lt;Object&gt; GetMethodName() = 0;\012 virtual Handle&lt;Object&gt; GetTypeName() = 0;\012 virtual Handle&lt;Object&gt; GetEvalOrigin();\012\012 virtual int GetPosition() const = 0;\012 // Return 1-based line number, including line offset.\012 virtual int GetLineNumber() = 0;\012 // Return 1-based column number, including column offset if first line.\012 virtual int GetColumnNumber() = 0;\012\012 virtual bool IsNative() = 0;\012 virtual bool IsToplevel() = 0;\012 virtual bool IsEval();\012 virtual bool IsConstructor() = 0;\012 virtual bool IsStrict() const = 0;\012\012 virtual MaybeHandle&lt;String&gt; ToString() = 0;\012\012 protected:\012 StackFrameBase() {}\012 explicit StackFrameBase(Isolate* isolate) : isolate_(isolate) {}\012 Isolate* isolate_;\012\012 private:\012 virtual bool HasScript() const = 0;\012 virtual Handle&lt;Script&gt; GetScript() const = 0;\012};\012\012class JSStackFrame : public StackFrameBase {\012 public:\012 JSStackFrame(Isolate* isolate, Handle&lt;Object&gt; receiver,\012 Handle&lt;JSFunction&gt; function, Handle&lt;AbstractCode&gt; code,\012 int offset);\012 virtual ~JSStackFrame() {}\012\012 Handle&lt;Object&gt; GetReceiver() const override { return receiver_; }\012 Handle&lt;Object&gt; GetFunction() const override;\012\012 Handle&lt;Object&gt; GetFileName() override;\012 Handle&lt;Object&gt; GetFunctionName() override;\012 Handle&lt;Object&gt; GetScriptNameOrSourceUrl() override;\012 Handle&lt;Object&gt; GetMethodName() override;\012 Handle&lt;Object&gt; GetTypeName() override;\012\012 int GetPosition() const override;\012 int GetLineNumber() override;\012 int GetColumnNumber() override;\012\012 bool IsNative() override;\012 bool IsToplevel() override;\012 bool IsConstructor() override { return is_constructor_; }\012 bool IsStrict() const override { return is_strict_; }\012\012 MaybeHandle&lt;String&gt; ToString() override;\012\012 private:\012 JSStackFrame();\012 void FromFrameArray(Isolate* isolate, Handle&lt;FrameArray&gt; array, int frame_ix);\012\012 bool HasScript() const override;\012 Handle&lt;Script&gt; GetScript() const override;\012\012 Handle&lt;Object&gt; receiver_;\012 Handle&lt;JSFunction&gt; function_;\012 Handle&lt;AbstractCode&gt; code_;\012 int offset_;\012\012 bool is_constructor_;\012 bool is_strict_;\012\012 friend class FrameArrayIterator;\012};\012\012class WasmStackFrame : public StackFrameBase {\012 public:\012 virtual ~WasmStackFrame() {}\012\012 Handle&lt;Object&gt; GetReceiver() const override;\012 Handle&lt;Object&gt; GetFunction() const override;\012\012 Handle&lt;Object&gt; GetFileName() override { return Null(); }\012 Handle&lt;Object&gt; GetFunctionName() override;\012 Handle&lt;Object&gt; GetScriptNameOrSourceUrl() override { return Null(); }\012 Handle&lt;Object&gt; GetMethodName() override { return Null(); }\012 Handle&lt;Object&gt; GetTypeName() override { return Null(); }\012\012 int GetPosition() const override;\012 int GetLineNumber() override { return wasm_func_index_; }\012 int GetColumnNumber() override { return -1; }\012\012 bool IsNative() override { return false; }\012 bool IsToplevel() override { return false; }\012 bool IsConstructor() override { return false; }\012 bool IsStrict() const override { return false; }\012 bool IsInterpreted() const { return code_ == nullptr; }\012\012 MaybeHandle&lt;String&gt; ToString() override;\012\012 protected:\012 Handle&lt;Object&gt; Null() const;\012\012 bool HasScript() const override;\012 Handle&lt;Script&gt; GetScript() const override;\012\012 Handle&lt;WasmInstanceObject&gt; wasm_instance_;\012 uint32_t wasm_func_index_;\012  wasm::WasmCode* code_; // null for interpreted frames.\012 int offset_;\012\012 private:\012 WasmStackFrame();\012 void FromFrameArray(Isolate* isolate, Handle&lt;FrameArray&gt; array, int frame_ix);\012\012 friend class FrameArrayIterator;\012 friend class AsmJsWasmStackFrame;\012};\012\012class AsmJsWasmStackFrame : public WasmStackFrame {\012 public:\012 virtual ~AsmJsWasmStackFrame() {}\012\012 Handle&lt;Object&gt; GetReceiver() const override;\012 Handle&lt;Object&gt; GetFunction() const override;\012\012 Handle&lt;Object&gt; GetFileName() override;\012 Handle&lt;Object&gt; GetScriptNameOrSourceUrl() override;\012\012 int GetPosition() const override;\012 int GetLineNumber() override;\012 int GetColumnNumber() override;\012\012 MaybeHandle&lt;String&gt; ToString() override;\012\012 private:\012 friend class FrameArrayIterator;\012 AsmJsWasmStackFrame();\012 void FromFrameArray(Isolate* isolate, Handle&lt;FrameArray&gt; array, int frame_ix);\012\012 bool is_at_number_conversion_;\012};\012\012class FrameArrayIterator {\012 public:\012 FrameArrayIterator(Isolate* isolate, Handle&lt;FrameArray&gt; array,\012 int frame_ix = 0);\012\012 StackFrameBase* Frame();\012\012 bool HasNext() const;\012 void Next();\012\012 private:\012 Isolate* isolate_;\012\012 Handle&lt;FrameArray&gt; array_;\012 int next_frame_ix_;\012\012 WasmStackFrame wasm_frame_;\012 AsmJsWasmStackFrame asm_wasm_frame_;\012 JSStackFrame js_frame_;\012};\012\012// Determines how stack trace collection skips frames.\012enum FrameSkipMode {\012 // Unconditionally skips the first frame. Used e.g. when the Error constructor\012 // is called, in which case the first frame is always a BUILTIN_EXIT frame.\012  SKIP_FIRST,\012 // Skip all frames until a specified caller function is seen.\012  SKIP_UNTIL_SEEN,\012  SKIP_NONE,\012};\012\012class ErrorUtils : public AllStatic {\012 public:\012 static MaybeHandle&lt;Object&gt; Construct(\012 Isolate* isolate, Handle&lt;JSFunction&gt; target, Handle&lt;Object&gt; new_target,\012 Handle&lt;Object&gt; message, FrameSkipMode mode, Handle&lt;Object&gt; caller,\012 bool suppress_detailed_trace);\012\012 static MaybeHandle&lt;String&gt; ToString(Isolate* isolate, Handle&lt;Object&gt; recv);\012\012 static MaybeHandle&lt;Object&gt; MakeGenericError(\012 Isolate* isolate, Handle&lt;JSFunction&gt; constructor, int template_index,\012 Handle&lt;Object&gt; arg0, Handle&lt;Object&gt; arg1, Handle&lt;Object&gt; arg2,\012 FrameSkipMode mode);\012\012 // Formats a textual stack trace from the given structured stack trace.\012 // Note that this can call arbitrary JS code through Error.prepareStackTrace.\012 static MaybeHandle&lt;Object&gt; FormatStackTrace(Isolate* isolate,\012 Handle&lt;JSObject&gt; error,\012 Handle&lt;Object&gt; stack_trace);\012};\012\012#define MESSAGE_TEMPLATES(T)                                                   \\012 /* Error */                                                                  \\012  T(None, &quot;&quot;)                                                                  \\012  T(CyclicProto, &quot;Cyclic __proto__ value&quot;)                                     \\012  T(Debugger, &quot;Debugger: %&quot;)                                                   \\012  T(DebuggerLoading, &quot;Error loading debugger&quot;)                                 \\012  T(DefaultOptionsMissing, &quot;Internal % error. Default options are missing.&quot;)   \\012  T(DeletePrivateField, &quot;Private fields can not be deleted&quot;)                   \\012  T(UncaughtException, &quot;Uncaught %&quot;)                                           \\012  T(Unsupported, &quot;Not supported&quot;)                                              \\012  T(WrongServiceType, &quot;Internal error, wrong service type: %&quot;)                 \\012  T(WrongValueType, &quot;Internal error. Wrong value type.&quot;)                       \\012  T(IcuError, &quot;Internal error. Icu error.&quot;)                                    \\012 /* TypeError */                                                              \\012  T(ApplyNonFunction,                                                          \\012 &quot;Function.prototype.apply was called on %, which is a % and not a &quot;        \\012 &quot;function&quot;)                                                                \\012  T(ArgumentsDisallowedInInitializer,                                          \\012 &quot;'arguments' is not allowed in class field initializer&quot;)                   \\012  T(ArrayBufferTooShort,                                                       \\012 &quot;Derived ArrayBuffer constructor created a buffer which was too small&quot;)    \\012  T(ArrayBufferSpeciesThis,                                                    \\012 &quot;ArrayBuffer subclass returned this from species constructor&quot;)             \\012  T(ArrayItemNotType, &quot;array %[%] is not type %&quot;)                              \\012  T(AwaitNotInAsyncFunction, &quot;await is only valid in async function&quot;)          \\012  T(AtomicsWaitNotAllowed, &quot;Atomics.wait cannot be called in this context&quot;)    \\012  T(BadSortComparisonFunction,                                                 \\012 &quot;The comparison function must be either a function or undefined&quot;)          \\012  T(BigIntFromNumber,                                                          \\012 &quot;The number % cannot be converted to a BigInt because it is not an &quot;       \\012 &quot;integer&quot;)                                                                 \\012  T(BigIntFromObject, &quot;Cannot convert % to a BigInt&quot;)                          \\012  T(BigIntMixedTypes,                                                          \\012 &quot;Cannot mix BigInt and other types, use explicit conversions&quot;)             \\012  T(BigIntSerializeJSON, &quot;Do not know how to serialize a BigInt&quot;)              \\012  T(BigIntShr, &quot;BigInts have no unsigned right shift, use &gt;&gt; instead&quot;)         \\012  T(BigIntToNumber, &quot;Cannot convert a BigInt value to a number&quot;)               \\012  T(CalledNonCallable, &quot;% is not a function&quot;)                                  \\012  T(CalledOnNonObject, &quot;% called on non-object&quot;)                               \\012  T(CalledOnNullOrUndefined, &quot;% called on null or undefined&quot;)                  \\012  T(CallSiteExpectsFunction,                                                   \\012 &quot;CallSite expects wasm object as first or function as second argument, &quot;   \\012 &quot;got &lt;%, %&gt;&quot;)                                                              \\012  T(CallSiteMethod, &quot;CallSite method % expects CallSite as receiver&quot;)          \\012  T(CannotConvertToPrimitive, &quot;Cannot convert object to primitive value&quot;)      \\012  T(CannotPreventExt, &quot;Cannot prevent extensions&quot;)                             \\012  T(CannotFreeze, &quot;Cannot freeze&quot;)                                             \\012  T(CannotFreezeArrayBufferView,                                               \\012 &quot;Cannot freeze array buffer views with elements&quot;)                          \\012  T(CannotSeal, &quot;Cannot seal&quot;)                                                 \\012  T(CircularStructure, &quot;Converting circular structure to JSON&quot;)                \\012  T(ConstructAbstractClass, &quot;Abstract class % not directly constructable&quot;)     \\012  T(ConstAssign, &quot;Assignment to constant variable.&quot;)                           \\012  T(ConstructorClassField, &quot;Classes may not have a field named 'constructor'&quot;) \\012  T(ConstructorNonCallable,                                                    \\012 &quot;Class constructor % cannot be invoked without 'new'&quot;)                     \\012  T(ConstructorNotFunction, &quot;Constructor % requires 'new'&quot;)                    \\012  T(ConstructorNotReceiver, &quot;The .constructor property is not an object&quot;)      \\012  T(CurrencyCode, &quot;Currency code is required with currency style.&quot;)            \\012  T(CyclicModuleDependency, &quot;Detected cycle while resolving name '%' in '%'&quot;)  \\012  T(DataViewNotArrayBuffer,                                                    \\012 &quot;First argument to DataView constructor must be an ArrayBuffer&quot;)           \\012  T(DateType, &quot;this is not a Date object.&quot;)                                    \\012  T(DebuggerFrame, &quot;Debugger: Invalid frame index.&quot;)                           \\012  T(DebuggerType, &quot;Debugger: Parameters have wrong types.&quot;)                    \\012  T(DeclarationMissingInitializer, &quot;Missing initializer in % declaration&quot;)     \\012  T(DefineDisallowed, &quot;Cannot define property %, object is not extensible&quot;)    \\012  T(DetachedOperation, &quot;Cannot perform % on a detached ArrayBuffer&quot;)           \\012  T(DuplicateTemplateProperty, &quot;Object template has duplicate property '%'&quot;)   \\012  T(ExtendsValueNotConstructor,                                                \\012 &quot;Class extends value % is not a constructor or null&quot;)                      \\012  T(FirstArgumentNotRegExp,                                                    \\012 &quot;First argument to % must not be a regular expression&quot;)                    \\012  T(FunctionBind, &quot;Bind must be called on a function&quot;)                         \\012  T(GeneratorRunning, &quot;Generator is already running&quot;)                          \\012  T(IllegalInvocation, &quot;Illegal invocation&quot;)                                   \\012  T(ImmutablePrototypeSet,                                                     \\012 &quot;Immutable prototype object '%' cannot have their prototype set&quot;)          \\012  T(ImportCallNotNewExpression, &quot;Cannot use new with import&quot;)                  \\012  T(ImportMetaOutsideModule, &quot;Cannot use 'import.meta' outside a module&quot;)      \\012  T(ImportMissingSpecifier, &quot;import() requires a specifier&quot;)                   \\012  T(IncompatibleMethodReceiver, &quot;Method % called on incompatible receiver %&quot;)  \\012  T(InstanceofNonobjectProto,                                                  \\012 &quot;Function has non-object prototype '%' in instanceof check&quot;)               \\012  T(InvalidArgument, &quot;invalid_argument&quot;)                                       \\012  T(InvalidInOperatorUse, &quot;Cannot use 'in' operator to search for '%' in %&quot;)   \\012  T(InvalidRegExpExecResult,                                                   \\012 &quot;RegExp exec method returned something other than an Object or null&quot;)      \\012  T(InvalidUnit, &quot;Invalid unit argument for %() '%'&quot;)                          \\012  T(IteratorResultNotAnObject, &quot;Iterator result % is not an object&quot;)           \\012  T(IteratorSymbolNonCallable, &quot;Found non-callable @@iterator&quot;)                \\012  T(IteratorValueNotAnObject, &quot;Iterator value % is not an entry object&quot;)       \\012  T(LanguageID, &quot;Language ID should be string or object.&quot;)                     \\012  T(LocaleNotEmpty,                                                            \\012 &quot;First argument to Intl.Locale constructor can't be empty or missing&quot;)     \\012  T(LocaleBadParameters, &quot;Incorrect locale information provided&quot;)              \\012  T(ListFormatBadParameters, &quot;Incorrect ListFormat information provided&quot;)      \\012  T(MapperFunctionNonCallable, &quot;flatMap mapper function is not callable&quot;)      \\012  T(MethodCalledOnWrongObject,                                                 \\012 &quot;Method % called on a non-object or on a wrong type of object.&quot;)           \\012  T(MethodInvokedOnNullOrUndefined,                                            \\012 &quot;Method invoked on undefined or null value.&quot;)                              \\012  T(MethodInvokedOnWrongType, &quot;Method invoked on an object that is not %.&quot;)    \\012  T(NoAccess, &quot;no access&quot;)                                                     \\012  T(NonCallableInInstanceOfCheck,                                              \\012 &quot;Right-hand side of 'instanceof' is not callable&quot;)                         \\012  T(NonCoercible, &quot;Cannot destructure 'undefined' or 'null'.&quot;)                 \\012  T(NonCoercibleWithProperty,                                                  \\012 &quot;Cannot destructure property `%` of 'undefined' or 'null'.&quot;)               \\012  T(NonExtensibleProto, &quot;% is not extensible&quot;)                                 \\012  T(NonObjectInInstanceOfCheck,                                                \\012 &quot;Right-hand side of 'instanceof' is not an object&quot;)                        \\012  T(NonObjectPropertyLoad, &quot;Cannot read property '%' of %&quot;)                    \\012  T(NonObjectPropertyStore, &quot;Cannot set property '%' of %&quot;)                    \\012  T(NoSetterInCallback, &quot;Cannot set property % of % which has only a getter&quot;)  \\012  T(NotAnIterator, &quot;% is not an iterator&quot;)                                     \\012  T(NotAPromise, &quot;% is not a promise&quot;)                                         \\012  T(NotConstructor, &quot;% is not a constructor&quot;)                                  \\012  T(NotDateObject, &quot;this is not a Date object.&quot;)                               \\012  T(NotGeneric, &quot;% requires that 'this' be a %&quot;)                               \\012  T(NotCallableOrIterable,                                                     \\012 &quot;% is not a function or its return value is not iterable&quot;)                 \\012  T(NotCallableOrAsyncIterable,                                                \\012 &quot;% is not a function or its return value is not async iterable&quot;)           \\012  T(NotFiniteNumber, &quot;Value need to be finite number for %()&quot;)                 \\012  T(NotIterable, &quot;% is not iterable&quot;)                                          \\012  T(NotAsyncIterable, &quot;% is not async iterable&quot;)                               \\012  T(NotPropertyName, &quot;% is not a valid property name&quot;)                         \\012  T(NotTypedArray, &quot;this is not a typed array.&quot;)                               \\012  T(NotSuperConstructor, &quot;Super constructor % of % is not a constructor&quot;)      \\012  T(NotSuperConstructorAnonymousClass,                                         \\012 &quot;Super constructor % of anonymous class is not a constructor&quot;)             \\012  T(NotIntegerSharedTypedArray, &quot;% is not an integer shared typed array.&quot;)     \\012  T(NotInt32SharedTypedArray, &quot;% is not an int32 shared typed array.&quot;)         \\012  T(ObjectGetterExpectingFunction,                                             \\012 &quot;Object.prototype.__defineGetter__: Expecting function&quot;)                   \\012  T(ObjectGetterCallable, &quot;Getter must be a function: %&quot;)                      \\012  T(ObjectNotExtensible, &quot;Cannot add property %, object is not extensible&quot;)    \\012  T(ObjectSetterExpectingFunction,                                             \\012 &quot;Object.prototype.__defineSetter__: Expecting function&quot;)                   \\012  T(ObjectSetterCallable, &quot;Setter must be a function: %&quot;)                      \\012  T(OrdinaryFunctionCalledAsConstructor,                                       \\012 &quot;Function object that's not a constructor was created with new&quot;)           \\012  T(PromiseCyclic, &quot;Chaining cycle detected for promise %&quot;)                    \\012  T(PromiseExecutorAlreadyInvoked,                                             \\012 &quot;Promise executor has already been invoked with non-undefined arguments&quot;)  \\012  T(PromiseNonCallable, &quot;Promise resolve or reject function is not callable&quot;)  \\012  T(PropertyDescObject, &quot;Property description must be an object: %&quot;)           \\012  T(PropertyNotFunction,                                                       \\012 &quot;'%' returned for property '%' of object '%' is not a function&quot;)           \\012  T(ProtoObjectOrNull, &quot;Object prototype may only be an Object or null: %&quot;)    \\012  T(PrototypeParentNotAnObject,                                                \\012 &quot;Class extends value does not have valid prototype property %&quot;)            \\012  T(ProxyConstructNonObject,                                                   \\012 &quot;'construct' on proxy: trap returned non-object ('%')&quot;)                    \\012  T(ProxyDefinePropertyNonConfigurable,                                        \\012 &quot;'defineProperty' on proxy: trap returned truish for defining &quot;            \\012 &quot;non-configurable property '%' which is either non-existant or &quot;           \\012 &quot;configurable in the proxy target&quot;)                                        \\012  T(ProxyDefinePropertyNonExtensible,                                          \\012 &quot;'defineProperty' on proxy: trap returned truish for adding property '%' &quot; \\012 &quot; to the non-extensible proxy target&quot;)                                     \\012  T(ProxyDefinePropertyIncompatible,                                           \\012 &quot;'defineProperty' on proxy: trap returned truish for adding property '%' &quot; \\012 &quot; that is incompatible with the existing property in the proxy target&quot;)    \\012  T(ProxyDeletePropertyNonConfigurable,                                        \\012 &quot;'deleteProperty' on proxy: trap returned truish for property '%' which &quot;  \\012 &quot;is non-configurable in the proxy target&quot;)                                 \\012  T(ProxyGetNonConfigurableData,                                               \\012 &quot;'get' on proxy: property '%' is a read-only and &quot;                         \\012 &quot;non-configurable data property on the proxy target but the proxy &quot;        \\012 &quot;did not return its actual value (expected '%' but got '%')&quot;)              \\012  T(ProxyGetNonConfigurableAccessor,                                           \\012 &quot;'get' on proxy: property '%' is a non-configurable accessor &quot;             \\012 &quot;property on the proxy target and does not have a getter function, but &quot;   \\012 &quot;the trap did not return 'undefined' (got '%')&quot;)                           \\012  T(ProxyGetOwnPropertyDescriptorIncompatible,                                 \\012 &quot;'getOwnPropertyDescriptor' on proxy: trap returned descriptor for &quot;       \\012 &quot;property '%' that is incompatible with the existing property in the &quot;     \\012 &quot;proxy target&quot;)                                                            \\012  T(ProxyGetOwnPropertyDescriptorInvalid,                                      \\012 &quot;'getOwnPropertyDescriptor' on proxy: trap returned neither object nor &quot;   \\012 &quot;undefined for property '%'&quot;)                                              \\012  T(ProxyGetOwnPropertyDescriptorNonConfigurable,                              \\012 &quot;'getOwnPropertyDescriptor' on proxy: trap reported non-configurability &quot;  \\012 &quot;for property '%' which is either non-existant or configurable in the &quot;    \\012 &quot;proxy target&quot;)                                                            \\012  T(ProxyGetOwnPropertyDescriptorNonExtensible,                                \\012 &quot;'getOwnPropertyDescriptor' on proxy: trap returned undefined for &quot;        \\012 &quot;property '%' which exists in the non-extensible proxy target&quot;)            \\012  T(ProxyGetOwnPropertyDescriptorUndefined,                                    \\012 &quot;'getOwnPropertyDescriptor' on proxy: trap returned undefined for &quot;        \\012 &quot;property '%' which is non-configurable in the proxy target&quot;)              \\012  T(ProxyGetPrototypeOfInvalid,                                                \\012 &quot;'getPrototypeOf' on proxy: trap returned neither object nor null&quot;)        \\012  T(ProxyGetPrototypeOfNonExtensible,                                          \\012 &quot;'getPrototypeOf' on proxy: proxy target is non-extensible but the &quot;       \\012 &quot;trap did not return its actual prototype&quot;)                                \\012  T(ProxyHandlerOrTargetRevoked,                                               \\012 &quot;Cannot create proxy with a revoked proxy as target or handler&quot;)           \\012  T(ProxyHasNonConfigurable,                                                   \\012 &quot;'has' on proxy: trap returned falsish for property '%' which exists in &quot;  \\012 &quot;the proxy target as non-configurable&quot;)                                    \\012  T(ProxyHasNonExtensible,                                                     \\012 &quot;'has' on proxy: trap returned falsish for property '%' but the proxy &quot;    \\012 &quot;target is not extensible&quot;)                                                \\012  T(ProxyIsExtensibleInconsistent,                                             \\012 &quot;'isExtensible' on proxy: trap result does not reflect extensibility of &quot;  \\012 &quot;proxy target (which is '%')&quot;)                                             \\012  T(ProxyNonObject,                                                            \\012 &quot;Cannot create proxy with a non-object as target or handler&quot;)              \\012  T(ProxyOwnKeysMissing,                                                       \\012 &quot;'ownKeys' on proxy: trap result did not include '%'&quot;)                     \\012  T(ProxyOwnKeysNonExtensible,                                                 \\012 &quot;'ownKeys' on proxy: trap returned extra keys but proxy target is &quot;        \\012 &quot;non-extensible&quot;)                                                          \\012  T(ProxyPreventExtensionsExtensible,                                          \\012 &quot;'preventExtensions' on proxy: trap returned truish but the proxy target &quot; \\012 &quot;is extensible&quot;)                                                           \\012  T(ProxyPrivate, &quot;Cannot pass private property name to proxy trap&quot;)           \\012  T(ProxyRevoked, &quot;Cannot perform '%' on a proxy that has been revoked&quot;)       \\012  T(ProxySetFrozenData,                                                        \\012 &quot;'set' on proxy: trap returned truish for property '%' which exists in &quot;   \\012 &quot;the proxy target as a non-configurable and non-writable data property &quot;   \\012 &quot;with a different value&quot;)                                                  \\012  T(ProxySetFrozenAccessor,                                                    \\012 &quot;'set' on proxy: trap returned truish for property '%' which exists in &quot;   \\012 &quot;the proxy target as a non-configurable and non-writable accessor &quot;        \\012 &quot;property without a setter&quot;)                                               \\012  T(ProxySetPrototypeOfNonExtensible,                                          \\012 &quot;'setPrototypeOf' on proxy: trap returned truish for setting a new &quot;       \\012 &quot;prototype on the non-extensible proxy target&quot;)                            \\012  T(ProxyTrapReturnedFalsish, &quot;'%' on proxy: trap returned falsish&quot;)           \\012  T(ProxyTrapReturnedFalsishFor,                                               \\012 &quot;'%' on proxy: trap returned falsish for property '%'&quot;)                    \\012  T(RedefineDisallowed, &quot;Cannot redefine property: %&quot;)                         \\012  T(RedefineExternalArray,                                                     \\012 &quot;Cannot redefine a property of an object with external array elements&quot;)    \\012  T(ReduceNoInitial, &quot;Reduce of empty array with no initial value&quot;)            \\012  T(RegExpFlags,                                                               \\012 &quot;Cannot supply flags when constructing one RegExp from another&quot;)           \\012  T(RegExpNonObject, &quot;% getter called on non-object %&quot;)                        \\012  T(RegExpNonRegExp, &quot;% getter called on non-RegExp object&quot;)                   \\012  T(RelativeDateTimeFormatterBadParameters,                                    \\012 &quot;Incorrect RelativeDateTimeFormatter provided&quot;)                            \\012  T(ResolverNotAFunction, &quot;Promise resolver % is not a function&quot;)              \\012  T(ReturnMethodNotCallable, &quot;The iterator's 'return' method is not callable&quot;) \\012  T(SharedArrayBufferTooShort,                                                 \\012 &quot;Derived SharedArrayBuffer constructor created a buffer which was too &quot;    \\012 &quot;small&quot;)                                                                   \\012  T(SharedArrayBufferSpeciesThis,                                              \\012 &quot;SharedArrayBuffer subclass returned this from species constructor&quot;)       \\012  T(StaticPrototype,                                                           \\012 &quot;Classes may not have a static property named 'prototype'&quot;)                \\012  T(StrictDeleteProperty, &quot;Cannot delete property '%' of %&quot;)                   \\012  T(StrictPoisonPill,                                                          \\012 &quot;'caller', 'callee', and 'arguments' properties may not be accessed on &quot;   \\012 &quot;strict mode functions or the arguments objects for calls to them&quot;)        \\012  T(StrictReadOnlyProperty,                                                    \\012 &quot;Cannot assign to read only property '%' of % '%'&quot;)                        \\012  T(StrictCannotCreateProperty, &quot;Cannot create property '%' on % '%'&quot;)         \\012  T(SymbolIteratorInvalid,                                                     \\012 &quot;Result of the Symbol.iterator method is not an object&quot;)                   \\012  T(SymbolAsyncIteratorInvalid,                                                \\012 &quot;Result of the Symbol.asyncIterator method is not an object&quot;)              \\012  T(SymbolKeyFor, &quot;% is not a symbol&quot;)                                         \\012  T(SymbolToNumber, &quot;Cannot convert a Symbol value to a number&quot;)               \\012  T(SymbolToString, &quot;Cannot convert a Symbol value to a string&quot;)               \\012  T(ThrowMethodMissing, &quot;The iterator does not provide a 'throw' method.&quot;)     \\012  T(UndefinedOrNullToObject, &quot;Cannot convert undefined or null to object&quot;)     \\012  T(ValueAndAccessor,                                                          \\012 &quot;Invalid property descriptor. Cannot both specify accessors and a value &quot;  \\012 &quot;or writable attribute, %&quot;)                                                \\012  T(VarRedeclaration, &quot;Identifier '%' has already been declared&quot;)              \\012  T(WrongArgs, &quot;%: Arguments list has wrong type&quot;)                             \\012 /* ReferenceError */                                                         \\012  T(NotDefined, &quot;% is not defined&quot;)                                            \\012  T(SuperAlreadyCalled, &quot;Super constructor may only be called once&quot;)           \\012  T(UnsupportedSuper, &quot;Unsupported reference to 'super'&quot;)                      \\012 /* RangeError */                                                             \\012  T(BigIntDivZero, &quot;Division by zero&quot;)                                         \\012  T(BigIntNegativeExponent, &quot;Exponent must be positive&quot;)                       \\012  T(BigIntTooBig, &quot;Maximum BigInt size exceeded&quot;)                              \\012  T(DateRange, &quot;Provided date is not in valid range.&quot;)                         \\012  T(ExpectedLocation,                                                          \\012 &quot;Expected letters optionally connected with underscores or hyphens for &quot;   \\012 &quot;a location, got %&quot;)                                                       \\012  T(InvalidArrayBufferLength, &quot;Invalid array buffer length&quot;)                   \\012  T(ArrayBufferAllocationFailed, &quot;Array buffer allocation failed&quot;)             \\012  T(InvalidArrayLength, &quot;Invalid array length&quot;)                                \\012  T(InvalidAtomicAccessIndex, &quot;Invalid atomic access index&quot;)                   \\012  T(InvalidCodePoint, &quot;Invalid code point %&quot;)                                  \\012  T(InvalidCountValue, &quot;Invalid count value&quot;)                                  \\012  T(InvalidCurrencyCode, &quot;Invalid currency code: %&quot;)                           \\012  T(InvalidDataViewAccessorOffset,                                             \\012 &quot;Offset is outside the bounds of the DataView&quot;)                            \\012  T(InvalidDataViewLength, &quot;Invalid DataView length %&quot;)                        \\012  T(InvalidOffset, &quot;Start offset % is outside the bounds of the buffer&quot;)       \\012  T(InvalidHint, &quot;Invalid hint: %&quot;)                                            \\012  T(InvalidIndex, &quot;Invalid value: not (convertible to) a safe integer&quot;)        \\012  T(InvalidLanguageTag, &quot;Invalid language tag: %&quot;)                             \\012  T(InvalidWeakMapKey, &quot;Invalid value used as weak map key&quot;)                   \\012  T(InvalidWeakSetValue, &quot;Invalid value used in weak set&quot;)                     \\012  T(InvalidStringLength, &quot;Invalid string length&quot;)                              \\012  T(InvalidTimeValue, &quot;Invalid time value&quot;)                                    \\012  T(InvalidTimeZone, &quot;Invalid time zone specified: %&quot;)                         \\012  T(InvalidTypedArrayAlignment, &quot;% of % should be a multiple of %&quot;)            \\012  T(InvalidTypedArrayIndex, &quot;Invalid typed array index&quot;)                       \\012  T(InvalidTypedArrayLength, &quot;Invalid typed array length: %&quot;)                  \\012  T(LetInLexicalBinding, &quot;let is disallowed as a lexically bound name&quot;)        \\012  T(LocaleMatcher, &quot;Illegal value for localeMatcher:%&quot;)                        \\012  T(NormalizationForm, &quot;The normalization form should be one of %.&quot;)           \\012  T(ZeroDigitNumericSeparator,                                                 \\012 &quot;Numeric separator can not be used after leading 0.&quot;)                      \\012  T(NumberFormatRange, &quot;% argument must be between 0 and 100&quot;)                 \\012  T(TrailingNumericSeparator,                                                  \\012 &quot;Numeric separators are not allowed at the end of numeric literals&quot;)       \\012  T(ContinuousNumericSeparator,                                                \\012 &quot;Only one underscore is allowed as numeric separator&quot;)                     \\012  T(PropertyValueOutOfRange, &quot;% value is out of range.&quot;)                       \\012  T(StackOverflow, &quot;Maximum call stack size exceeded&quot;)                         \\012  T(ToPrecisionFormatRange,                                                    \\012 &quot;toPrecision() argument must be between 1 and 100&quot;)                        \\012  T(ToRadixFormatRange, &quot;toString() radix argument must be between 2 and 36&quot;)  \\012  T(TypedArraySetOffsetOutOfBounds, &quot;offset is out of bounds&quot;)                 \\012  T(TypedArraySetSourceTooLarge, &quot;Source is too large&quot;)                        \\012  T(ValueOutOfRange, &quot;Value % out of range for % options property %&quot;)          \\012 /* SyntaxError */                                                            \\012  T(AmbiguousExport,                                                           \\012 &quot;The requested module '%' contains conflicting star exports for name '%'&quot;) \\012  T(BadGetterArity, &quot;Getter must not have any formal parameters.&quot;)             \\012  T(BadSetterArity, &quot;Setter must have exactly one formal parameter.&quot;)          \\012  T(BigIntInvalidString, &quot;Invalid BigInt string&quot;)                              \\012  T(ConstructorIsAccessor, &quot;Class constructor may not be an accessor&quot;)         \\012  T(ConstructorIsGenerator, &quot;Class constructor may not be a generator&quot;)        \\012  T(ConstructorIsAsync, &quot;Class constructor may not be an async method&quot;)        \\012  T(DerivedConstructorReturnedNonObject,                                       \\012 &quot;Derived constructors may only return object or undefined&quot;)                \\012  T(DuplicateConstructor, &quot;A class may only have one constructor&quot;)             \\012  T(DuplicateExport, &quot;Duplicate export of '%'&quot;)                                \\012  T(DuplicateProto,                                                            \\012 &quot;Duplicate __proto__ fields are not allowed in object literals&quot;)           \\012  T(ForInOfLoopInitializer,                                                    \\012 &quot;% loop variable declaration may not have an initializer.&quot;)                \\012  T(ForInOfLoopMultiBindings,                                                  \\012 &quot;Invalid left-hand side in % loop: Must have a single binding.&quot;)           \\012  T(GeneratorInSingleStatementContext,                                         \\012 &quot;Generators can only be declared at the top level or inside a block.&quot;)     \\012  T(AsyncFunctionInSingleStatementContext,                                     \\012 &quot;Async functions can only be declared at the top level or inside a &quot;       \\012 &quot;block.&quot;)                                                                  \\012  T(IllegalBreak, &quot;Illegal break statement&quot;)                                   \\012  T(NoIterationStatement,                                                      \\012 &quot;Illegal continue statement: no surrounding iteration statement&quot;)          \\012  T(IllegalContinue,                                                           \\012 &quot;Illegal continue statement: '%' does not denote an iteration statement&quot;)  \\012  T(IllegalLanguageModeDirective,                                              \\012 &quot;Illegal '%' directive in function with non-simple parameter list&quot;)        \\012  T(IllegalReturn, &quot;Illegal return statement&quot;)                                 \\012  T(IntrinsicWithSpread, &quot;Intrinsic calls do not support spread arguments&quot;)    \\012  T(InvalidRestBindingPattern,                                                 \\012 &quot;`...` must be followed by an identifier in declaration contexts&quot;)         \\012  T(InvalidRestAssignmentPattern,                                              \\012 &quot;`...` must be followed by an assignable reference in assignment &quot;         \\012 &quot;contexts&quot;)                                                                \\012  T(InvalidEscapedReservedWord, &quot;Keyword must not contain escaped characters&quot;) \\012  T(InvalidEscapedMetaProperty, &quot;'%' must not contain escaped characters&quot;)     \\012  T(InvalidLhsInAssignment, &quot;Invalid left-hand side in assignment&quot;)            \\012  T(InvalidCoverInitializedName, &quot;Invalid shorthand property initializer&quot;)     \\012  T(InvalidDestructuringTarget, &quot;Invalid destructuring assignment target&quot;)     \\012  T(InvalidLhsInFor, &quot;Invalid left-hand side in for-loop&quot;)                     \\012  T(InvalidLhsInPostfixOp,                                                     \\012 &quot;Invalid left-hand side expression in postfix operation&quot;)                  \\012  T(InvalidLhsInPrefixOp,                                                      \\012 &quot;Invalid left-hand side expression in prefix operation&quot;)                   \\012  T(InvalidRegExpFlags, &quot;Invalid flags supplied to RegExp constructor '%'&quot;)    \\012  T(InvalidOrUnexpectedToken, &quot;Invalid or unexpected token&quot;)                   \\012  T(InvalidPrivateFieldAccess, &quot;Invalid private field '%'&quot;)                    \\012  T(JsonParseUnexpectedEOS, &quot;Unexpected end of JSON input&quot;)                    \\012  T(JsonParseUnexpectedToken, &quot;Unexpected token % in JSON at position %&quot;)      \\012  T(JsonParseUnexpectedTokenNumber, &quot;Unexpected number in JSON at position %&quot;) \\012  T(JsonParseUnexpectedTokenString, &quot;Unexpected string in JSON at position %&quot;) \\012  T(LabelRedeclaration, &quot;Label '%' has already been declared&quot;)                 \\012  T(LabelledFunctionDeclaration,                                               \\012 &quot;Labelled function declaration not allowed as the body of a control flow &quot; \\012 &quot;structure&quot;)                                                               \\012  T(MalformedArrowFunParamList, &quot;Malformed arrow function parameter list&quot;)     \\012  T(MalformedRegExp, &quot;Invalid regular expression: /%/: %&quot;)                     \\012  T(MalformedRegExpFlags, &quot;Invalid regular expression flags&quot;)                  \\012  T(ModuleExportUndefined, &quot;Export '%' is not defined in module&quot;)              \\012  T(HtmlCommentInModule, &quot;HTML comments are not allowed in modules&quot;)           \\012  T(MultipleDefaultsInSwitch,                                                  \\012 &quot;More than one default clause in switch statement&quot;)                        \\012  T(NewlineAfterThrow, &quot;Illegal newline after throw&quot;)                          \\012  T(NoCatchOrFinally, &quot;Missing catch or finally after try&quot;)                    \\012  T(NotIsvar, &quot;builtin %%IS_VAR: not a variable&quot;)                              \\012  T(ParamAfterRest, &quot;Rest parameter must be last formal parameter&quot;)            \\012  T(FlattenPastSafeLength,                                                     \\012 &quot;Flattening % elements on an array-like of length % &quot;                      \\012 &quot;is disallowed, as the total surpasses 2**53-1&quot;)                           \\012  T(PushPastSafeLength,                                                        \\012 &quot;Pushing % elements on an array-like of length % &quot;                         \\012 &quot;is disallowed, as the total surpasses 2**53-1&quot;)                           \\012  T(ElementAfterRest, &quot;Rest element must be last element&quot;)                     \\012  T(BadSetterRestParameter,                                                    \\012 &quot;Setter function argument must not be a rest parameter&quot;)                   \\012  T(ParamDupe, &quot;Duplicate parameter name not allowed in this context&quot;)         \\012  T(ParenthesisInArgString, &quot;Function arg string contains parenthesis&quot;)        \\012  T(ArgStringTerminatesParametersEarly,                                        \\012 &quot;Arg string terminates parameters early&quot;)                                  \\012  T(UnexpectedEndOfArgString, &quot;Unexpected end of arg string&quot;)                  \\012  T(RestDefaultInitializer,                                                    \\012 &quot;Rest parameter may not have a default initializer&quot;)                       \\012  T(RuntimeWrongNumArgs, &quot;Runtime function given wrong number of arguments&quot;)   \\012  T(SuperNotCalled,                                                            \\012 &quot;Must call super constructor in derived class before accessing 'this' or &quot; \\012 &quot;returning from derived constructor&quot;)                                      \\012  T(SingleFunctionLiteral, &quot;Single function literal required&quot;)                 \\012  T(SloppyFunction,                                                            \\012 &quot;In non-strict mode code, functions can only be declared at top level, &quot;   \\012 &quot;inside a block, or as the body of an if statement.&quot;)                      \\012  T(SpeciesNotConstructor,                                                     \\012 &quot;object.constructor[Symbol.species] is not a constructor&quot;)                 \\012  T(StrictDelete, &quot;Delete of an unqualified identifier in strict mode.&quot;)       \\012  T(StrictEvalArguments, &quot;Unexpected eval or arguments in strict mode&quot;)        \\012  T(StrictFunction,                                                            \\012 &quot;In strict mode code, functions can only be declared at top level or &quot;     \\012 &quot;inside a block.&quot;)                                                         \\012  T(StrictOctalLiteral, &quot;Octal literals are not allowed in strict mode.&quot;)      \\012  T(StrictDecimalWithLeadingZero,                                              \\012 &quot;Decimals with leading zeros are not allowed in strict mode.&quot;)             \\012  T(StrictOctalEscape,                                                         \\012 &quot;Octal escape sequences are not allowed in strict mode.&quot;)                  \\012  T(StrictWith, &quot;Strict mode code may not include a with statement&quot;)           \\012  T(TemplateOctalLiteral,                                                      \\012 &quot;Octal escape sequences are not allowed in template strings.&quot;)             \\012  T(ThisFormalParameter, &quot;'this' is not a valid formal parameter name&quot;)        \\012  T(AwaitBindingIdentifier,                                                    \\012 &quot;'await' is not a valid identifier name in an async function&quot;)             \\012  T(AwaitExpressionFormalParameter,                                            \\012 &quot;Illegal await-expression in formal parameters of async function&quot;)         \\012  T(TooManyArguments,                                                          \\012 &quot;Too many arguments in function call (only 65535 allowed)&quot;)                \\012  T(TooManyParameters,                                                         \\012 &quot;Too many parameters in function definition (only 65535 allowed)&quot;)         \\012  T(TooManySpreads,                                                            \\012 &quot;Literal containing too many nested spreads (up to 65534 allowed)&quot;)        \\012  T(TooManyVariables, &quot;Too many variables declared (only 4194303 allowed)&quot;)    \\012  T(TooManyElementsInPromiseAll, &quot;Too many elements passed to Promise.all&quot;)    \\012  T(TypedArrayTooShort,                                                        \\012 &quot;Derived TypedArray constructor created an array which was too small&quot;)     \\012  T(UnexpectedEOS, &quot;Unexpected end of input&quot;)                                  \\012  T(UnexpectedReserved, &quot;Unexpected reserved word&quot;)                            \\012  T(UnexpectedStrictReserved, &quot;Unexpected strict mode reserved word&quot;)          \\012  T(UnexpectedSuper, &quot;'super' keyword unexpected here&quot;)                        \\012  T(UnexpectedNewTarget, &quot;new.target expression is not allowed here&quot;)          \\012  T(UnexpectedTemplateString, &quot;Unexpected template string&quot;)                    \\012  T(UnexpectedToken, &quot;Unexpected token %&quot;)                                     \\012  T(UnexpectedTokenIdentifier, &quot;Unexpected identifier&quot;)                        \\012  T(UnexpectedTokenNumber, &quot;Unexpected number&quot;)                                \\012  T(UnexpectedTokenString, &quot;Unexpected string&quot;)                                \\012  T(UnexpectedTokenRegExp, &quot;Unexpected regular expression&quot;)                    \\012  T(UnexpectedLexicalDeclaration,                                              \\012 &quot;Lexical declaration cannot appear in a single-statement context&quot;)         \\012  T(UnknownLabel, &quot;Undefined label '%'&quot;)                                       \\012  T(UnresolvableExport,                                                        \\012 &quot;The requested module '%' does not provide an export named '%'&quot;)           \\012  T(UnterminatedArgList, &quot;missing ) after argument list&quot;)                      \\012  T(UnterminatedRegExp, &quot;Invalid regular expression: missing /&quot;)               \\012  T(UnterminatedTemplate, &quot;Unterminated template literal&quot;)                     \\012  T(UnterminatedTemplateExpr, &quot;Missing } in template expression&quot;)              \\012  T(FoundNonCallableHasInstance, &quot;Found non-callable @@hasInstance&quot;)           \\012  T(InvalidHexEscapeSequence, &quot;Invalid hexadecimal escape sequence&quot;)           \\012  T(InvalidUnicodeEscapeSequence, &quot;Invalid Unicode escape sequence&quot;)           \\012  T(UndefinedUnicodeCodePoint, &quot;Undefined Unicode code-point&quot;)                 \\012  T(YieldInParameter, &quot;Yield expression not allowed in formal parameter&quot;)      \\012 /* EvalError */                                                              \\012  T(CodeGenFromStrings, &quot;%&quot;)                                                   \\012  T(NoSideEffectDebugEvaluate, &quot;Possible side-effect in debug-evaluate&quot;)       \\012 /* URIError */                                                               \\012  T(URIMalformed, &quot;URI malformed&quot;)                                             \\012 /* Wasm errors (currently Error) */                                          \\012  T(WasmTrapUnreachable, &quot;unreachable&quot;)                                        \\012  T(WasmTrapMemOutOfBounds, &quot;memory access out of bounds&quot;)                     \\012  T(WasmTrapUnalignedAccess, &quot;operation does not support unaligned accesses&quot;)  \\012  T(WasmTrapDivByZero, &quot;divide by zero&quot;)                                       \\012  T(WasmTrapDivUnrepresentable, &quot;divide result unrepresentable&quot;)               \\012  T(WasmTrapRemByZero, &quot;remainder by zero&quot;)                                    \\012  T(WasmTrapFloatUnrepresentable, &quot;float unrepresentable in integer range&quot;)    \\012  T(WasmTrapFuncInvalid, &quot;invalid index into function table&quot;)                  \\012  T(WasmTrapFuncSigMismatch, &quot;function signature mismatch&quot;)                    \\012  T(WasmTrapTypeError, &quot;wasm function signature contains illegal type&quot;)        \\012  T(WasmExceptionError, &quot;wasm exception&quot;)                                      \\012 /* Asm.js validation related */                                              \\012  T(AsmJsInvalid, &quot;Invalid asm.js: %&quot;)                                         \\012  T(AsmJsCompiled, &quot;Converted asm.js to WebAssembly: %&quot;)                       \\012  T(AsmJsInstantiated, &quot;Instantiated asm.js: %&quot;)                               \\012  T(AsmJsLinkingFailed, &quot;Linking failure in asm.js: %&quot;)                        \\012 /* DataCloneError messages */                                                \\012  T(DataCloneError, &quot;% could not be cloned.&quot;)                                  \\012  T(DataCloneErrorOutOfMemory, &quot;Data cannot be cloned, out of memory.&quot;)        \\012  T(DataCloneErrorNeuteredArrayBuffer,                                         \\012 &quot;An ArrayBuffer is neutered and could not be cloned.&quot;)                     \\012  T(DataCloneErrorSharedArrayBufferTransferred,                                \\012 &quot;A SharedArrayBuffer could not be cloned. SharedArrayBuffer must not be &quot;  \\012 &quot;transferred.&quot;)                                                            \\012  T(DataCloneDeserializationError, &quot;Unable to deserialize cloned data.&quot;)       \\012  T(DataCloneDeserializationVersionError,                                      \\012 &quot;Unable to deserialize cloned data due to invalid or unsupported &quot;         \\012 &quot;version.&quot;)                                                                \\012 /* Builtins-Trace Errors */                                                  \\012  T(TraceEventCategoryError, &quot;Trace event category must be a string.&quot;)         \\012  T(TraceEventNameError, &quot;Trace event name must be a string.&quot;)                 \\012  T(TraceEventNameLengthError,                                                 \\012 &quot;Trace event name must not be an empty string.&quot;)                           \\012  T(TraceEventPhaseError, &quot;Trace event phase must be a number.&quot;)               \\012  T(TraceEventIDError, &quot;Trace event id must be a number.&quot;)\012\012class MessageTemplate {\012 public:\012 enum Template {\012#define TEMPLATE(NAME, STRING) k##NAME,\012    MESSAGE_TEMPLATES(TEMPLATE)\012#undef TEMPLATE\012        kLastMessage\012 };\012\012 static const char* TemplateString(int template_index);\012\012 static MaybeHandle&lt;String&gt; FormatMessage(Isolate* isolate, int template_index,\012 Handle&lt;String&gt; arg0,\012 Handle&lt;String&gt; arg1,\012 Handle&lt;String&gt; arg2);\012\012 static Handle&lt;String&gt; FormatMessage(Isolate* isolate, int template_index,\012 Handle&lt;Object&gt; arg);\012};\012\012\012// A message handler is a convenience interface for accessing the list\012// of message listeners registered in an environment\012class MessageHandler {\012 public:\012 // Returns a message object for the API to use.\012 static Handle&lt;JSMessageObject&gt; MakeMessageObject(\012 Isolate* isolate, MessageTemplate::Template type,\012 const MessageLocation* location, Handle&lt;Object&gt; argument,\012 Handle&lt;FixedArray&gt; stack_frames);\012\012 // Report a formatted message (needs JS allocation).\012 static void ReportMessage(Isolate* isolate, const MessageLocation* loc,\012 Handle&lt;JSMessageObject&gt; message);\012\012 static void DefaultMessageReport(Isolate* isolate, const MessageLocation* loc,\012 Handle&lt;Object&gt; message_obj);\012 static Handle&lt;String&gt; GetMessage(Isolate* isolate, Handle&lt;Object&gt; data);\012 static std::unique_ptr&lt;char[]&gt; GetLocalizedMessage(Isolate* isolate,\012 Handle&lt;Object&gt; data);\012\012 private:\012 static void ReportMessageNoExceptions(Isolate* isolate,\012 const MessageLocation* loc,\012 Handle&lt;Object&gt; message_obj,\012                                        v8::Local&lt;v8::Value&gt; api_exception_obj);\012};\012\012\012} // namespace internal\012},namespace v8 {\012namespace internal {\012namespace wasm {\012class WasmCode;\012}\012\012// Forward declarations.\012class AbstractCode;\012class FrameArray;\012class JSMessageObject;\012class LookupIterator;\012class SharedFunctionInfo;\012class SourceInfo;\012class WasmInstanceObject;\012\012class MessageLocation {\012 public:\012 MessageLocation(Handle&lt;Script&gt; script, int start_pos, int end_pos);\012 MessageLocation(Handle&lt;Script&gt; script, int start_pos, int end_pos,\012 Handle&lt;SharedFunctionInfo&gt; shared);\012 MessageLocation();\012\012 Handle&lt;Script&gt; script() const { return script_; }\012 int start_pos() const { return start_pos_; }\012 int end_pos() const { return end_pos_; }\012 Handle&lt;SharedFunctionInfo&gt; shared() const { return shared_; }\012\012 private:\012 Handle&lt;Script&gt; script_;\012 int start_pos_;\012 int end_pos_;\012 Handle&lt;SharedFunctionInfo&gt; shared_;\012};\012\012class StackFrameBase {\012 public:\012 virtual ~StackFrameBase() {}\012\012 virtual Handle&lt;Object&gt; GetReceiver() const = 0;\012 virtual Handle&lt;Object&gt; GetFunction() const = 0;\012\012 virtual Handle&lt;Object&gt; GetFileName() = 0;\012 virtual Handle&lt;Object&gt; GetFunctionName() = 0;\012 virtual Handle&lt;Object&gt; GetScriptNameOrSourceUrl() = 0;\012 virtual Handle&lt;Object&gt; GetMethodName() = 0;\012 virtual Handle&lt;Object&gt; GetTypeName() = 0;\012 virtual Handle&lt;Object&gt; GetEvalOrigin();\012\012 virtual int GetPosition() const = 0;\012 // Return 1-based line number, including line offset.\012 virtual int GetLineNumber() = 0;\012 // Return 1-based column number, including column offset if first line.\012 virtual int GetColumnNumber() = 0;\012\012 virtual bool IsNative() = 0;\012 virtual bool IsToplevel() = 0;\012 virtual bool IsEval();\012 virtual bool IsConstructor() = 0;\012 virtual bool IsStrict() const = 0;\012\012 virtual MaybeHandle&lt;String&gt; ToString() = 0;\012\012 protected:\012 StackFrameBase() {}\012 explicit StackFrameBase(Isolate* isolate) : isolate_(isolate) {}\012 Isolate* isolate_;\012\012 private:\012 virtual bool HasScript() const = 0;\012 virtual Handle&lt;Script&gt; GetScript() const = 0;\012};\012\012class JSStackFrame : public StackFrameBase {\012 public:\012 JSStackFrame(Isolate* isolate, Handle&lt;Object&gt; receiver,\012 Handle&lt;JSFunction&gt; function, Handle&lt;AbstractCode&gt; code,\012 int offset);\012 virtual ~JSStackFrame() {}\012\012 Handle&lt;Object&gt; GetReceiver() const override { return receiver_; }\012 Handle&lt;Object&gt; GetFunction() const override;\012\012 Handle&lt;Object&gt; GetFileName() override;\012 Handle&lt;Object&gt; GetFunctionName() override;\012 Handle&lt;Object&gt; GetScriptNameOrSourceUrl() override;\012 Handle&lt;Object&gt; GetMethodName() override;\012 Handle&lt;Object&gt; GetTypeName() override;\012\012 int GetPosition() const override;\012 int GetLineNumber() override;\012 int GetColumnNumber() override;\012\012 bool IsNative() override;\012 bool IsToplevel() override;\012 bool IsConstructor() override { return is_constructor_; }\012 bool IsStrict() const override { return is_strict_; }\012\012 MaybeHandle&lt;String&gt; ToString() override;\012\012 private:\012 JSStackFrame();\012 void FromFrameArray(Isolate* isolate, Handle&lt;FrameArray&gt; array, int frame_ix);\012\012 bool HasScript() const override;\012 Handle&lt;Script&gt; GetScript() const override;\012\012 Handle&lt;Object&gt; receiver_;\012 Handle&lt;JSFunction&gt; function_;\012 Handle&lt;AbstractCode&gt; code_;\012 int offset_;\012\012 bool is_constructor_;\012 bool is_strict_;\012\012 friend class FrameArrayIterator;\012};\012\012class WasmStackFrame : public StackFrameBase {\012 public:\012 virtual ~WasmStackFrame() {}\012\012 Handle&lt;Object&gt; GetReceiver() const override;\012 Handle&lt;Object&gt; GetFunction() const override;\012\012 Handle&lt;Object&gt; GetFileName() override { return Null(); }\012 Handle&lt;Object&gt; GetFunctionName() override;\012 Handle&lt;Object&gt; GetScriptNameOrSourceUrl() override { return Null(); }\012 Handle&lt;Object&gt; GetMethodName() override { return Null(); }\012 Handle&lt;Object&gt; GetTypeName() override { return Null(); }\012\012 int GetPosition() const override;\012 int GetLineNumber() override { return wasm_func_index_; }\012 int GetColumnNumber() override { return -1; }\012\012 bool IsNative() override { return false; }\012 bool IsToplevel() override { return false; }\012 bool IsConstructor() override { return false; }\012 bool IsStrict() const override { return false; }\012 bool IsInterpreted() const { return code_ == nullptr; }\012\012 MaybeHandle&lt;String&gt; ToString() override;\012\012 protected:\012 Handle&lt;Object&gt; Null() const;\012\012 bool HasScript() const override;\012 Handle&lt;Script&gt; GetScript() const override;\012\012 Handle&lt;WasmInstanceObject&gt; wasm_instance_;\012 uint32_t wasm_func_index_;\012  wasm::WasmCode* code_; // null for interpreted frames.\012 int offset_;\012\012 private:\012 WasmStackFrame();\012 void FromFrameArray(Isolate* isolate, Handle&lt;FrameArray&gt; array, int frame_ix);\012\012 friend class FrameArrayIterator;\012 friend class AsmJsWasmStackFrame;\012};\012\012class AsmJsWasmStackFrame : public WasmStackFrame {\012 public:\012 virtual ~AsmJsWasmStackFrame() {}\012\012 Handle&lt;Object&gt; GetReceiver() const override;\012 Handle&lt;Object&gt; GetFunction() const override;\012\012 Handle&lt;Object&gt; GetFileName() override;\012 Handle&lt;Object&gt; GetScriptNameOrSourceUrl() override;\012\012 int GetPosition() const override;\012 int GetLineNumber() override;\012 int GetColumnNumber() override;\012\012 MaybeHandle&lt;String&gt; ToString() override;\012\012 private:\012 friend class FrameArrayIterator;\012 AsmJsWasmStackFrame();\012 void FromFrameArray(Isolate* isolate, Handle&lt;FrameArray&gt; array, int frame_ix);\012\012 bool is_at_number_conversion_;\012};\012\012class FrameArrayIterator {\012 public:\012 FrameArrayIterator(Isolate* isolate, Handle&lt;FrameArray&gt; array,\012 int frame_ix = 0);\012\012 StackFrameBase* Frame();\012\012 bool HasNext() const;\012 void Next();\012\012 private:\012 Isolate* isolate_;\012\012 Handle&lt;FrameArray&gt; array_;\012 int next_frame_ix_;\012\012 WasmStackFrame wasm_frame_;\012 AsmJsWasmStackFrame asm_wasm_frame_;\012 JSStackFrame js_frame_;\012};\012\012// Determines how stack trace collection skips frames.\012enum FrameSkipMode {\012 // Unconditionally skips the first frame. Used e.g. when the Error constructor\012 // is called, in which case the first frame is always a BUILTIN_EXIT frame.\012  SKIP_FIRST,\012 // Skip all frames until a specified caller function is seen.\012  SKIP_UNTIL_SEEN,\012  SKIP_NONE,\012};\012\012class ErrorUtils : public AllStatic {\012 public:\012 static MaybeHandle&lt;Object&gt; Construct(\012 Isolate* isolate, Handle&lt;JSFunction&gt; target, Handle&lt;Object&gt; new_target,\012 Handle&lt;Object&gt; message, FrameSkipMode mode, Handle&lt;Object&gt; caller,\012 bool suppress_detailed_trace);\012\012 static MaybeHandle&lt;String&gt; ToString(Isolate* isolate, Handle&lt;Object&gt; recv);\012\012 static MaybeHandle&lt;Object&gt; MakeGenericError(\012 Isolate* isolate, Handle&lt;JSFunction&gt; constructor, int template_index,\012 Handle&lt;Object&gt; arg0, Handle&lt;Object&gt; arg1, Handle&lt;Object&gt; arg2,\012 FrameSkipMode mode);\012\012 // Formats a textual stack trace from the given structured stack trace.\012 // Note that this can call arbitrary JS code through Error.prepareStackTrace.\012 static MaybeHandle&lt;Object&gt; FormatStackTrace(Isolate* isolate,\012 Handle&lt;JSObject&gt; error,\012 Handle&lt;Object&gt; stack_trace);\012};\012\012#define MESSAGE_TEMPLATES(T)                                                   \\012 /* Error */                                                                  \\012  T(None, &quot;&quot;)                                                                  \\012  T(CyclicProto, &quot;Cyclic __proto__ value&quot;)                                     \\012  T(Debugger, &quot;Debugger: %&quot;)                                                   \\012  T(DebuggerLoading, &quot;Error loading debugger&quot;)                                 \\012  T(DefaultOptionsMissing, &quot;Internal % error. Default options are missing.&quot;)   \\012  T(DeletePrivateField, &quot;Private fields can not be deleted&quot;)                   \\012  T(UncaughtException, &quot;Uncaught %&quot;)                                           \\012  T(Unsupported, &quot;Not supported&quot;)                                              \\012  T(WrongServiceType, &quot;Internal error, wrong service type: %&quot;)                 \\012  T(WrongValueType, &quot;Internal error. Wrong value type.&quot;)                       \\012  T(IcuError, &quot;Internal error. Icu error.&quot;)                                    \\012 /* TypeError */                                                              \\012  T(ApplyNonFunction,                                                          \\012 &quot;Function.prototype.apply was called on %, which is a % and not a &quot;        \\012 &quot;function&quot;)                                                                \\012  T(ArgumentsDisallowedInInitializer,                                          \\012 &quot;'arguments' is not allowed in class field initializer&quot;)                   \\012  T(ArrayBufferTooShort,                                                       \\012 &quot;Derived ArrayBuffer constructor created a buffer which was too small&quot;)    \\012  T(ArrayBufferSpeciesThis,                                                    \\012 &quot;ArrayBuffer subclass returned this from species constructor&quot;)             \\012  T(ArrayItemNotType, &quot;array %[%] is not type %&quot;)                              \\012  T(AwaitNotInAsyncFunction, &quot;await is only valid in async function&quot;)          \\012  T(AtomicsWaitNotAllowed, &quot;Atomics.wait cannot be called in this context&quot;)    \\012  T(BadSortComparisonFunction,                                                 \\012 &quot;The comparison function must be either a function or undefined&quot;)          \\012  T(BigIntFromNumber,                                                          \\012 &quot;The number % cannot be converted to a BigInt because it is not an &quot;       \\012 &quot;integer&quot;)                                                                 \\012  T(BigIntFromObject, &quot;Cannot convert % to a BigInt&quot;)                          \\012  T(BigIntMixedTypes,                                                          \\012 &quot;Cannot mix BigInt and other types, use explicit conversions&quot;)             \\012  T(BigIntSerializeJSON, &quot;Do not know how to serialize a BigInt&quot;)              \\012  T(BigIntShr, &quot;BigInts have no unsigned right shift, use &gt;&gt; instead&quot;)         \\012  T(BigIntToNumber, &quot;Cannot convert a BigInt value to a number&quot;)               \\012  T(CalledNonCallable, &quot;% is not a function&quot;)                                  \\012  T(CalledOnNonObject, &quot;% called on non-object&quot;)                               \\012  T(CalledOnNullOrUndefined, &quot;% called on null or undefined&quot;)                  \\012  T(CallSiteExpectsFunction,                                                   \\012 &quot;CallSite expects wasm object as first or function as second argument, &quot;   \\012 &quot;got &lt;%, %&gt;&quot;)                                                              \\012  T(CallSiteMethod, &quot;CallSite method % expects CallSite as receiver&quot;)          \\012  T(CannotConvertToPrimitive, &quot;Cannot convert object to primitive value&quot;)      \\012  T(CannotPreventExt, &quot;Cannot prevent extensions&quot;)                             \\012  T(CannotFreeze, &quot;Cannot freeze&quot;)                                             \\012  T(CannotFreezeArrayBufferView,                                               \\012 &quot;Cannot freeze array buffer views with elements&quot;)                          \\012  T(CannotSeal, &quot;Cannot seal&quot;)                                                 \\012  T(CircularStructure, &quot;Converting circular structure to JSON&quot;)                \\012  T(ConstructAbstractClass, &quot;Abstract class % not directly constructable&quot;)     \\012  T(ConstAssign, &quot;Assignment to constant variable.&quot;)                           \\012  T(ConstructorClassField, &quot;Classes may not have a field named 'constructor'&quot;) \\012  T(ConstructorNonCallable,                                                    \\012 &quot;Class constructor % cannot be invoked without 'new'&quot;)                     \\012  T(ConstructorNotFunction, &quot;Constructor % requires 'new'&quot;)                    \\012  T(ConstructorNotReceiver, &quot;The .constructor property is not an object&quot;)      \\012  T(CurrencyCode, &quot;Currency code is required with currency style.&quot;)            \\012  T(CyclicModuleDependency, &quot;Detected cycle while resolving name '%' in '%'&quot;)  \\012  T(DataViewNotArrayBuffer,                                                    \\012 &quot;First argument to DataView constructor must be an ArrayBuffer&quot;)           \\012  T(DateType, &quot;this is not a Date object.&quot;)                                    \\012  T(DebuggerFrame, &quot;Debugger: Invalid frame index.&quot;)                           \\012  T(DebuggerType, &quot;Debugger: Parameters have wrong types.&quot;)                    \\012  T(DeclarationMissingInitializer, &quot;Missing initializer in % declaration&quot;)     \\012  T(DefineDisallowed, &quot;Cannot define property %, object is not extensible&quot;)    \\012  T(DetachedOperation, &quot;Cannot perform % on a detached ArrayBuffer&quot;)           \\012  T(DuplicateTemplateProperty, &quot;Object template has duplicate property '%'&quot;)   \\012  T(ExtendsValueNotConstructor,                                                \\012 &quot;Class extends value % is not a constructor or null&quot;)                      \\012  T(FirstArgumentNotRegExp,                                                    \\012 &quot;First argument to % must not be a regular expression&quot;)                    \\012  T(FunctionBind, &quot;Bind must be called on a function&quot;)                         \\012  T(GeneratorRunning, &quot;Generator is already running&quot;)                          \\012  T(IllegalInvocation, &quot;Illegal invocation&quot;)                                   \\012  T(ImmutablePrototypeSet,                                                     \\012 &quot;Immutable prototype object '%' cannot have their prototype set&quot;)          \\012  T(ImportCallNotNewExpression, &quot;Cannot use new with import&quot;)                  \\012  T(ImportMetaOutsideModule, &quot;Cannot use 'import.meta' outside a module&quot;)      \\012  T(ImportMissingSpecifier, &quot;import() requires a specifier&quot;)                   \\012  T(IncompatibleMethodReceiver, &quot;Method % called on incompatible receiver %&quot;)  \\012  T(InstanceofNonobjectProto,                                                  \\012 &quot;Function has non-object prototype '%' in instanceof check&quot;)               \\012  T(InvalidArgument, &quot;invalid_argument&quot;)                                       \\012  T(InvalidInOperatorUse, &quot;Cannot use 'in' operator to search for '%' in %&quot;)   \\012  T(InvalidRegExpExecResult,                                                   \\012 &quot;RegExp exec method returned something other than an Object or null&quot;)      \\012  T(InvalidUnit, &quot;Invalid unit argument for %() '%'&quot;)                          \\012  T(IteratorResultNotAnObject, &quot;Iterator result % is not an object&quot;)           \\012  T(IteratorSymbolNonCallable, &quot;Found non-callable @@iterator&quot;)                \\012  T(IteratorValueNotAnObject, &quot;Iterator value % is not an entry object&quot;)       \\012  T(LanguageID, &quot;Language ID should be string or object.&quot;)                     \\012  T(LocaleNotEmpty,                                                            \\012 &quot;First argument to Intl.Locale constructor can't be empty or missing&quot;)     \\012  T(LocaleBadParameters, &quot;Incorrect locale information provided&quot;)              \\012  T(ListFormatBadParameters, &quot;Incorrect ListFormat information provided&quot;)      \\012  T(MapperFunctionNonCallable, &quot;flatMap mapper function is not callable&quot;)      \\012  T(MethodCalledOnWrongObject,                                                 \\012 &quot;Method % called on a non-object or on a wrong type of object.&quot;)           \\012  T(MethodInvokedOnNullOrUndefined,                                            \\012 &quot;Method invoked on undefined or null value.&quot;)                              \\012  T(MethodInvokedOnWrongType, &quot;Method invoked on an object that is not %.&quot;)    \\012  T(NoAccess, &quot;no access&quot;)                                                     \\012  T(NonCallableInInstanceOfCheck,                                              \\012 &quot;Right-hand side of 'instanceof' is not callable&quot;)                         \\012  T(NonCoercible, &quot;Cannot destructure 'undefined' or 'null'.&quot;)                 \\012  T(NonCoercibleWithProperty,                                                  \\012 &quot;Cannot destructure property `%` of 'undefined' or 'null'.&quot;)               \\012  T(NonExtensibleProto, &quot;% is not extensible&quot;)                                 \\012  T(NonObjectInInstanceOfCheck,                                                \\012 &quot;Right-hand side of 'instanceof' is not an object&quot;)                        \\012  T(NonObjectPropertyLoad, &quot;Cannot read property '%' of %&quot;)                    \\012  T(NonObjectPropertyStore, &quot;Cannot set property '%' of %&quot;)                    \\012  T(NoSetterInCallback, &quot;Cannot set property % of % which has only a getter&quot;)  \\012  T(NotAnIterator, &quot;% is not an iterator&quot;)                                     \\012  T(NotAPromise, &quot;% is not a promise&quot;)                                         \\012  T(NotConstructor, &quot;% is not a constructor&quot;)                                  \\012  T(NotDateObject, &quot;this is not a Date object.&quot;)                               \\012  T(NotGeneric, &quot;% requires that 'this' be a %&quot;)                               \\012  T(NotCallableOrIterable,                                                     \\012 &quot;% is not a function or its return value is not iterable&quot;)                 \\012  T(NotCallableOrAsyncIterable,                                                \\012 &quot;% is not a function or its return value is not async iterable&quot;)           \\012  T(NotFiniteNumber, &quot;Value need to be finite number for %()&quot;)                 \\012  T(NotIterable, &quot;% is not iterable&quot;)                                          \\012  T(NotAsyncIterable, &quot;% is not async iterable&quot;)                               \\012  T(NotPropertyName, &quot;% is not a valid property name&quot;)                         \\012  T(NotTypedArray, &quot;this is not a typed array.&quot;)                               \\012  T(NotSuperConstructor, &quot;Super constructor % of % is not a constructor&quot;)      \\012  T(NotSuperConstructorAnonymousClass,                                         \\012 &quot;Super constructor % of anonymous class is not a constructor&quot;)             \\012  T(NotIntegerSharedTypedArray, &quot;% is not an integer shared typed array.&quot;)     \\012  T(NotInt32SharedTypedArray, &quot;% is not an int32 shared typed array.&quot;)         \\012  T(ObjectGetterExpectingFunction,                                             \\012 &quot;Object.prototype.__defineGetter__: Expecting function&quot;)                   \\012  T(ObjectGetterCallable, &quot;Getter must be a function: %&quot;)                      \\012  T(ObjectNotExtensible, &quot;Cannot add property %, object is not extensible&quot;)    \\012  T(ObjectSetterExpectingFunction,                                             \\012 &quot;Object.prototype.__defineSetter__: Expecting function&quot;)                   \\012  T(ObjectSetterCallable, &quot;Setter must be a function: %&quot;)                      \\012  T(OrdinaryFunctionCalledAsConstructor,                                       \\012 &quot;Function object that's not a constructor was created with new&quot;)           \\012  T(PromiseCyclic, &quot;Chaining cycle detected for promise %&quot;)                    \\012  T(PromiseExecutorAlreadyInvoked,                                             \\012 &quot;Promise executor has already been invoked with non-undefined arguments&quot;)  \\012  T(PromiseNonCallable, &quot;Promise resolve or reject function is not callable&quot;)  \\012  T(PropertyDescObject, &quot;Property description must be an object: %&quot;)           \\012  T(PropertyNotFunction,                                                       \\012 &quot;'%' returned for property '%' of object '%' is not a function&quot;)           \\012  T(ProtoObjectOrNull, &quot;Object prototype may only be an Object or null: %&quot;)    \\012  T(PrototypeParentNotAnObject,                                                \\012 &quot;Class extends value does not have valid prototype property %&quot;)            \\012  T(ProxyConstructNonObject,                                                   \\012 &quot;'construct' on proxy: trap returned non-object ('%')&quot;)                    \\012  T(ProxyDefinePropertyNonConfigurable,                                        \\012 &quot;'defineProperty' on proxy: trap returned truish for defining &quot;            \\012 &quot;non-configurable property '%' which is either non-existant or &quot;           \\012 &quot;configurable in the proxy target&quot;)                                        \\012  T(ProxyDefinePropertyNonExtensible,                                          \\012 &quot;'defineProperty' on proxy: trap returned truish for adding property '%' &quot; \\012 &quot; to the non-extensible proxy target&quot;)                                     \\012  T(ProxyDefinePropertyIncompatible,                                           \\012 &quot;'defineProperty' on proxy: trap returned truish for adding property '%' &quot; \\012 &quot; that is incompatible with the existing property in the proxy target&quot;)    \\012  T(ProxyDeletePropertyNonConfigurable,                                        \\012 &quot;'deleteProperty' on proxy: trap returned truish for property '%' which &quot;  \\012 &quot;is non-configurable in the proxy target&quot;)                                 \\012  T(ProxyGetNonConfigurableData,                                               \\012 &quot;'get' on proxy: property '%' is a read-only and &quot;                         \\012 &quot;non-configurable data property on the proxy target but the proxy &quot;        \\012 &quot;did not return its actual value (expected '%' but got '%')&quot;)              \\012  T(ProxyGetNonConfigurableAccessor,                                           \\012 &quot;'get' on proxy: property '%' is a non-configurable accessor &quot;             \\012 &quot;property on the proxy target and does not have a getter function, but &quot;   \\012 &quot;the trap did not return 'undefined' (got '%')&quot;)                           \\012  T(ProxyGetOwnPropertyDescriptorIncompatible,                                 \\012 &quot;'getOwnPropertyDescriptor' on proxy: trap returned descriptor for &quot;       \\012 &quot;property '%' that is incompatible with the existing property in the &quot;     \\012 &quot;proxy target&quot;)                                                            \\012  T(ProxyGetOwnPropertyDescriptorInvalid,                                      \\012 &quot;'getOwnPropertyDescriptor' on proxy: trap returned neither object nor &quot;   \\012 &quot;undefined for property '%'&quot;)                                              \\012  T(ProxyGetOwnPropertyDescriptorNonConfigurable,                              \\012 &quot;'getOwnPropertyDescriptor' on proxy: trap reported non-configurability &quot;  \\012 &quot;for property '%' which is either non-existant or configurable in the &quot;    \\012 &quot;proxy target&quot;)                                                            \\012  T(ProxyGetOwnPropertyDescriptorNonExtensible,                                \\012 &quot;'getOwnPropertyDescriptor' on proxy: trap returned undefined for &quot;        \\012 &quot;property '%' which exists in the non-extensible proxy target&quot;)            \\012  T(ProxyGetOwnPropertyDescriptorUndefined,                                    \\012 &quot;'getOwnPropertyDescriptor' on proxy: trap returned undefined for &quot;        \\012 &quot;property '%' which is non-configurable in the proxy target&quot;)              \\012  T(ProxyGetPrototypeOfInvalid,                                                \\012 &quot;'getPrototypeOf' on proxy: trap returned neither object nor null&quot;)        \\012  T(ProxyGetPrototypeOfNonExtensible,                                          \\012 &quot;'getPrototypeOf' on proxy: proxy target is non-extensible but the &quot;       \\012 &quot;trap did not return its actual prototype&quot;)                                \\012  T(ProxyHandlerOrTargetRevoked,                                               \\012 &quot;Cannot create proxy with a revoked proxy as target or handler&quot;)           \\012  T(ProxyHasNonConfigurable,                                                   \\012 &quot;'has' on proxy: trap returned falsish for property '%' which exists in &quot;  \\012 &quot;the proxy target as non-configurable&quot;)                                    \\012  T(ProxyHasNonExtensible,                                                     \\012 &quot;'has' on proxy: trap returned falsish for property '%' but the proxy &quot;    \\012 &quot;target is not extensible&quot;)                                                \\012  T(ProxyIsExtensibleInconsistent,                                             \\012 &quot;'isExtensible' on proxy: trap result does not reflect extensibility of &quot;  \\012 &quot;proxy target (which is '%')&quot;)                                             \\012  T(ProxyNonObject,                                                            \\012 &quot;Cannot create proxy with a non-object as target or handler&quot;)              \\012  T(ProxyOwnKeysMissing,                                                       \\012 &quot;'ownKeys' on proxy: trap result did not include '%'&quot;)                     \\012  T(ProxyOwnKeysNonExtensible,                                                 \\012 &quot;'ownKeys' on proxy: trap returned extra keys but proxy target is &quot;        \\012 &quot;non-extensible&quot;)                                                          \\012  T(ProxyPreventExtensionsExtensible,                                          \\012 &quot;'preventExtensions' on proxy: trap returned truish but the proxy target &quot; \\012 &quot;is extensible&quot;)                                                           \\012  T(ProxyPrivate, &quot;Cannot pass private property name to proxy trap&quot;)           \\012  T(ProxyRevoked, &quot;Cannot perform '%' on a proxy that has been revoked&quot;)       \\012  T(ProxySetFrozenData,                                                        \\012 &quot;'set' on proxy: trap returned truish for property '%' which exists in &quot;   \\012 &quot;the proxy target as a non-configurable and non-writable data property &quot;   \\012 &quot;with a different value&quot;)                                                  \\012  T(ProxySetFrozenAccessor,                                                    \\012 &quot;'set' on proxy: trap returned truish for property '%' which exists in &quot;   \\012 &quot;the proxy target as a non-configurable and non-writable accessor &quot;        \\012 &quot;property without a setter&quot;)                                               \\012  T(ProxySetPrototypeOfNonExtensible,                                          \\012 &quot;'setPrototypeOf' on proxy: trap returned truish for setting a new &quot;       \\012 &quot;prototype on the non-extensible proxy target&quot;)                            \\012  T(ProxyTrapReturnedFalsish, &quot;'%' on proxy: trap returned falsish&quot;)           \\012  T(ProxyTrapReturnedFalsishFor,                                               \\012 &quot;'%' on proxy: trap returned falsish for property '%'&quot;)                    \\012  T(RedefineDisallowed, &quot;Cannot redefine property: %&quot;)                         \\012  T(RedefineExternalArray,                                                     \\012 &quot;Cannot redefine a property of an object with external array elements&quot;)    \\012  T(ReduceNoInitial, &quot;Reduce of empty array with no initial value&quot;)            \\012  T(RegExpFlags,                                                               \\012 &quot;Cannot supply flags when constructing one RegExp from another&quot;)           \\012  T(RegExpNonObject, &quot;% getter called on non-object %&quot;)                        \\012  T(RegExpNonRegExp, &quot;% getter called on non-RegExp object&quot;)                   \\012  T(RelativeDateTimeFormatterBadParameters,                                    \\012 &quot;Incorrect RelativeDateTimeFormatter provided&quot;)                            \\012  T(ResolverNotAFunction, &quot;Promise resolver % is not a function&quot;)              \\012  T(ReturnMethodNotCallable, &quot;The iterator's 'return' method is not callable&quot;) \\012  T(SharedArrayBufferTooShort,                                                 \\012 &quot;Derived SharedArrayBuffer constructor created a buffer which was too &quot;    \\012 &quot;small&quot;)                                                                   \\012  T(SharedArrayBufferSpeciesThis,                                              \\012 &quot;SharedArrayBuffer subclass returned this from species constructor&quot;)       \\012  T(StaticPrototype,                                                           \\012 &quot;Classes may not have a static property named 'prototype'&quot;)                \\012  T(StrictDeleteProperty, &quot;Cannot delete property '%' of %&quot;)                   \\012  T(StrictPoisonPill,                                                          \\012 &quot;'caller', 'callee', and 'arguments' properties may not be accessed on &quot;   \\012 &quot;strict mode functions or the arguments objects for calls to them&quot;)        \\012  T(StrictReadOnlyProperty,                                                    \\012 &quot;Cannot assign to read only property '%' of % '%'&quot;)                        \\012  T(StrictCannotCreateProperty, &quot;Cannot create property '%' on % '%'&quot;)         \\012  T(SymbolIteratorInvalid,                                                     \\012 &quot;Result of the Symbol.iterator method is not an object&quot;)                   \\012  T(SymbolAsyncIteratorInvalid,                                                \\012 &quot;Result of the Symbol.asyncIterator method is not an object&quot;)              \\012  T(SymbolKeyFor, &quot;% is not a symbol&quot;)                                         \\012  T(SymbolToNumber, &quot;Cannot convert a Symbol value to a number&quot;)               \\012  T(SymbolToString, &quot;Cannot convert a Symbol value to a string&quot;)               \\012  T(ThrowMethodMissing, &quot;The iterator does not provide a 'throw' method.&quot;)     \\012  T(UndefinedOrNullToObject, &quot;Cannot convert undefined or null to object&quot;)     \\012  T(ValueAndAccessor,                                                          \\012 &quot;Invalid property descriptor. Cannot both specify accessors and a value &quot;  \\012 &quot;or writable attribute, %&quot;)                                                \\012  T(VarRedeclaration, &quot;Identifier '%' has already been declared&quot;)              \\012  T(WrongArgs, &quot;%: Arguments list has wrong type&quot;)                             \\012 /* ReferenceError */                                                         \\012  T(NotDefined, &quot;% is not defined&quot;)                                            \\012  T(SuperAlreadyCalled, &quot;Super constructor may only be called once&quot;)           \\012  T(UnsupportedSuper, &quot;Unsupported reference to 'super'&quot;)                      \\012 /* RangeError */                                                             \\012  T(BigIntDivZero, &quot;Division by zero&quot;)                                         \\012  T(BigIntNegativeExponent, &quot;Exponent must be positive&quot;)                       \\012  T(BigIntTooBig, &quot;Maximum BigInt size exceeded&quot;)                              \\012  T(DateRange, &quot;Provided date is not in valid range.&quot;)                         \\012  T(ExpectedLocation,                                                          \\012 &quot;Expected letters optionally connected with underscores or hyphens for &quot;   \\012 &quot;a location, got %&quot;)                                                       \\012  T(InvalidArrayBufferLength, &quot;Invalid array buffer length&quot;)                   \\012  T(ArrayBufferAllocationFailed, &quot;Array buffer allocation failed&quot;)             \\012  T(InvalidArrayLength, &quot;Invalid array length&quot;)                                \\012  T(InvalidAtomicAccessIndex, &quot;Invalid atomic access index&quot;)                   \\012  T(InvalidCodePoint, &quot;Invalid code point %&quot;)                                  \\012  T(InvalidCountValue, &quot;Invalid count value&quot;)                                  \\012  T(InvalidCurrencyCode, &quot;Invalid currency code: %&quot;)                           \\012  T(InvalidDataViewAccessorOffset,                                             \\012 &quot;Offset is outside the bounds of the DataView&quot;)                            \\012  T(InvalidDataViewLength, &quot;Invalid DataView length %&quot;)                        \\012  T(InvalidOffset, &quot;Start offset % is outside the bounds of the buffer&quot;)       \\012  T(InvalidHint, &quot;Invalid hint: %&quot;)                                            \\012  T(InvalidIndex, &quot;Invalid value: not (convertible to) a safe integer&quot;)        \\012  T(InvalidLanguageTag, &quot;Invalid language tag: %&quot;)                             \\012  T(InvalidWeakMapKey, &quot;Invalid value used as weak map key&quot;)                   \\012  T(InvalidWeakSetValue, &quot;Invalid value used in weak set&quot;)                     \\012  T(InvalidStringLength, &quot;Invalid string length&quot;)                              \\012  T(InvalidTimeValue, &quot;Invalid time value&quot;)                                    \\012  T(InvalidTimeZone, &quot;Invalid time zone specified: %&quot;)                         \\012  T(InvalidTypedArrayAlignment, &quot;% of % should be a multiple of %&quot;)            \\012  T(InvalidTypedArrayIndex, &quot;Invalid typed array index&quot;)                       \\012  T(InvalidTypedArrayLength, &quot;Invalid typed array length: %&quot;)                  \\012  T(LetInLexicalBinding, &quot;let is disallowed as a lexically bound name&quot;)        \\012  T(LocaleMatcher, &quot;Illegal value for localeMatcher:%&quot;)                        \\012  T(NormalizationForm, &quot;The normalization form should be one of %.&quot;)           \\012  T(ZeroDigitNumericSeparator,                                                 \\012 &quot;Numeric separator can not be used after leading 0.&quot;)                      \\012  T(NumberFormatRange, &quot;% argument must be between 0 and 100&quot;)                 \\012  T(TrailingNumericSeparator,                                                  \\012 &quot;Numeric separators are not allowed at the end of numeric literals&quot;)       \\012  T(ContinuousNumericSeparator,                                                \\012 &quot;Only one underscore is allowed as numeric separator&quot;)                     \\012  T(PropertyValueOutOfRange, &quot;% value is out of range.&quot;)                       \\012  T(StackOverflow, &quot;Maximum call stack size exceeded&quot;)                         \\012  T(ToPrecisionFormatRange,                                                    \\012 &quot;toPrecision() argument must be between 1 and 100&quot;)                        \\012  T(ToRadixFormatRange, &quot;toString() radix argument must be between 2 and 36&quot;)  \\012  T(TypedArraySetOffsetOutOfBounds, &quot;offset is out of bounds&quot;)                 \\012  T(TypedArraySetSourceTooLarge, &quot;Source is too large&quot;)                        \\012  T(ValueOutOfRange, &quot;Value % out of range for % options property %&quot;)          \\012 /* SyntaxError */                                                            \\012  T(AmbiguousExport,                                                           \\012 &quot;The requested module '%' contains conflicting star exports for name '%'&quot;) \\012  T(BadGetterArity, &quot;Getter must not have any formal parameters.&quot;)             \\012  T(BadSetterArity, &quot;Setter must have exactly one formal parameter.&quot;)          \\012  T(BigIntInvalidString, &quot;Invalid BigInt string&quot;)                              \\012  T(ConstructorIsAccessor, &quot;Class constructor may not be an accessor&quot;)         \\012  T(ConstructorIsGenerator, &quot;Class constructor may not be a generator&quot;)        \\012  T(ConstructorIsAsync, &quot;Class constructor may not be an async method&quot;)        \\012  T(DerivedConstructorReturnedNonObject,                                       \\012 &quot;Derived constructors may only return object or undefined&quot;)                \\012  T(DuplicateConstructor, &quot;A class may only have one constructor&quot;)             \\012  T(DuplicateExport, &quot;Duplicate export of '%'&quot;)                                \\012  T(DuplicateProto,                                                            \\012 &quot;Duplicate __proto__ fields are not allowed in object literals&quot;)           \\012  T(ForInOfLoopInitializer,                                                    \\012 &quot;% loop variable declaration may not have an initializer.&quot;)                \\012  T(ForInOfLoopMultiBindings,                                                  \\012 &quot;Invalid left-hand side in % loop: Must have a single binding.&quot;)           \\012  T(GeneratorInSingleStatementContext,                                         \\012 &quot;Generators can only be declared at the top level or inside a block.&quot;)     \\012  T(AsyncFunctionInSingleStatementContext,                                     \\012 &quot;Async functions can only be declared at the top level or inside a &quot;       \\012 &quot;block.&quot;)                                                                  \\012  T(IllegalBreak, &quot;Illegal break statement&quot;)                                   \\012  T(NoIterationStatement,                                                      \\012 &quot;Illegal continue statement: no surrounding iteration statement&quot;)          \\012  T(IllegalContinue,                                                           \\012 &quot;Illegal continue statement: '%' does not denote an iteration statement&quot;)  \\012  T(IllegalLanguageModeDirective,                                              \\012 &quot;Illegal '%' directive in function with non-simple parameter list&quot;)        \\012  T(IllegalReturn, &quot;Illegal return statement&quot;)                                 \\012  T(IntrinsicWithSpread, &quot;Intrinsic calls do not support spread arguments&quot;)    \\012  T(InvalidRestBindingPattern,                                                 \\012 &quot;`...` must be followed by an identifier in declaration contexts&quot;)         \\012  T(InvalidRestAssignmentPattern,                                              \\012 &quot;`...` must be followed by an assignable reference in assignment &quot;         \\012 &quot;contexts&quot;)                                                                \\012  T(InvalidEscapedReservedWord, &quot;Keyword must not contain escaped characters&quot;) \\012  T(InvalidEscapedMetaProperty, &quot;'%' must not contain escaped characters&quot;)     \\012  T(InvalidLhsInAssignment, &quot;Invalid left-hand side in assignment&quot;)            \\012  T(InvalidCoverInitializedName, &quot;Invalid shorthand property initializer&quot;)     \\012  T(InvalidDestructuringTarget, &quot;Invalid destructuring assignment target&quot;)     \\012  T(InvalidLhsInFor, &quot;Invalid left-hand side in for-loop&quot;)                     \\012  T(InvalidLhsInPostfixOp,                                                     \\012 &quot;Invalid left-hand side expression in postfix operation&quot;)                  \\012  T(InvalidLhsInPrefixOp,                                                      \\012 &quot;Invalid left-hand side expression in prefix operation&quot;)                   \\012  T(InvalidRegExpFlags, &quot;Invalid flags supplied to RegExp constructor '%'&quot;)    \\012  T(InvalidOrUnexpectedToken, &quot;Invalid or unexpected token&quot;)                   \\012  T(InvalidPrivateFieldAccess, &quot;Invalid private field '%'&quot;)                    \\012  T(JsonParseUnexpectedEOS, &quot;Unexpected end of JSON input&quot;)                    \\012  T(JsonParseUnexpectedToken, &quot;Unexpected token % in JSON at position %&quot;)      \\012  T(JsonParseUnexpectedTokenNumber, &quot;Unexpected number in JSON at position %&quot;) \\012  T(JsonParseUnexpectedTokenString, &quot;Unexpected string in JSON at position %&quot;) \\012  T(LabelRedeclaration, &quot;Label '%' has already been declared&quot;)                 \\012  T(LabelledFunctionDeclaration,                                               \\012 &quot;Labelled function declaration not allowed as the body of a control flow &quot; \\012 &quot;structure&quot;)                                                               \\012  T(MalformedArrowFunParamList, &quot;Malformed arrow function parameter list&quot;)     \\012  T(MalformedRegExp, &quot;Invalid regular expression: /%/: %&quot;)                     \\012  T(MalformedRegExpFlags, &quot;Invalid regular expression flags&quot;)                  \\012  T(ModuleExportUndefined, &quot;Export '%' is not defined in module&quot;)              \\012  T(HtmlCommentInModule, &quot;HTML comments are not allowed in modules&quot;)           \\012  T(MultipleDefaultsInSwitch,                                                  \\012 &quot;More than one default clause in switch statement&quot;)                        \\012  T(NewlineAfterThrow, &quot;Illegal newline after throw&quot;)                          \\012  T(NoCatchOrFinally, &quot;Missing catch or finally after try&quot;)                    \\012  T(NotIsvar, &quot;builtin %%IS_VAR: not a variable&quot;)                              \\012  T(ParamAfterRest, &quot;Rest parameter must be last formal parameter&quot;)            \\012  T(FlattenPastSafeLength,                                                     \\012 &quot;Flattening % elements on an array-like of length % &quot;                      \\012 &quot;is disallowed, as the total surpasses 2**53-1&quot;)                           \\012  T(PushPastSafeLength,                                                        \\012 &quot;Pushing % elements on an array-like of length % &quot;                         \\012 &quot;is disallowed, as the total surpasses 2**53-1&quot;)                           \\012  T(ElementAfterRest, &quot;Rest element must be last element&quot;)                     \\012  T(BadSetterRestParameter,                                                    \\012 &quot;Setter function argument must not be a rest parameter&quot;)                   \\012  T(ParamDupe, &quot;Duplicate parameter name not allowed in this context&quot;)         \\012  T(ParenthesisInArgString, &quot;Function arg string contains parenthesis&quot;)        \\012  T(ArgStringTerminatesParametersEarly,                                        \\012 &quot;Arg string terminates parameters early&quot;)                                  \\012  T(UnexpectedEndOfArgString, &quot;Unexpected end of arg string&quot;)                  \\012  T(RestDefaultInitializer,                                                    \\012 &quot;Rest parameter may not have a default initializer&quot;)                       \\012  T(RuntimeWrongNumArgs, &quot;Runtime function given wrong number of arguments&quot;)   \\012  T(SuperNotCalled,                                                            \\012 &quot;Must call super constructor in derived class before accessing 'this' or &quot; \\012 &quot;returning from derived constructor&quot;)                                      \\012  T(SingleFunctionLiteral, &quot;Single function literal required&quot;)                 \\012  T(SloppyFunction,                                                            \\012 &quot;In non-strict mode code, functions can only be declared at top level, &quot;   \\012 &quot;inside a block, or as the body of an if statement.&quot;)                      \\012  T(SpeciesNotConstructor,                                                     \\012 &quot;object.constructor[Symbol.species] is not a constructor&quot;)                 \\012  T(StrictDelete, &quot;Delete of an unqualified identifier in strict mode.&quot;)       \\012  T(StrictEvalArguments, &quot;Unexpected eval or arguments in strict mode&quot;)        \\012  T(StrictFunction,                                                            \\012 &quot;In strict mode code, functions can only be declared at top level or &quot;     \\012 &quot;inside a block.&quot;)                                                         \\012  T(StrictOctalLiteral, &quot;Octal literals are not allowed in strict mode.&quot;)      \\012  T(StrictDecimalWithLeadingZero,                                              \\012 &quot;Decimals with leading zeros are not allowed in strict mode.&quot;)             \\012  T(StrictOctalEscape,                                                         \\012 &quot;Octal escape sequences are not allowed in strict mode.&quot;)                  \\012  T(StrictWith, &quot;Strict mode code may not include a with statement&quot;)           \\012  T(TemplateOctalLiteral,                                                      \\012 &quot;Octal escape sequences are not allowed in template strings.&quot;)             \\012  T(ThisFormalParameter, &quot;'this' is not a valid formal parameter name&quot;)        \\012  T(AwaitBindingIdentifier,                                                    \\012 &quot;'await' is not a valid identifier name in an async function&quot;)             \\012  T(AwaitExpressionFormalParameter,                                            \\012 &quot;Illegal await-expression in formal parameters of async function&quot;)         \\012  T(TooManyArguments,                                                          \\012 &quot;Too many arguments in function call (only 65535 allowed)&quot;)                \\012  T(TooManyParameters,                                                         \\012 &quot;Too many parameters in function definition (only 65535 allowed)&quot;)         \\012  T(TooManySpreads,                                                            \\012 &quot;Literal containing too many nested spreads (up to 65534 allowed)&quot;)        \\012  T(TooManyVariables, &quot;Too many variables declared (only 4194303 allowed)&quot;)    \\012  T(TooManyElementsInPromiseAll, &quot;Too many elements passed to Promise.all&quot;)    \\012  T(TypedArrayTooShort,                                                        \\012 &quot;Derived TypedArray constructor created an array which was too small&quot;)     \\012  T(UnexpectedEOS, &quot;Unexpected end of input&quot;)                                  \\012  T(UnexpectedReserved, &quot;Unexpected reserved word&quot;)                            \\012  T(UnexpectedStrictReserved, &quot;Unexpected strict mode reserved word&quot;)          \\012  T(UnexpectedSuper, &quot;'super' keyword unexpected here&quot;)                        \\012  T(UnexpectedNewTarget, &quot;new.target expression is not allowed here&quot;)          \\012  T(UnexpectedTemplateString, &quot;Unexpected template string&quot;)                    \\012  T(UnexpectedToken, &quot;Unexpected token %&quot;)                                     \\012  T(UnexpectedTokenIdentifier, &quot;Unexpected identifier&quot;)                        \\012  T(UnexpectedTokenNumber, &quot;Unexpected number&quot;)                                \\012  T(UnexpectedTokenString, &quot;Unexpected string&quot;)                                \\012  T(UnexpectedTokenRegExp, &quot;Unexpected regular expression&quot;)                    \\012  T(UnexpectedLexicalDeclaration,                                              \\012 &quot;Lexical declaration cannot appear in a single-statement context&quot;)         \\012  T(UnknownLabel, &quot;Undefined label '%'&quot;)                                       \\012  T(UnresolvableExport,                                                        \\012 &quot;The requested module '%' does not provide an export named '%'&quot;)           \\012  T(UnterminatedArgList, &quot;missing ) after argument list&quot;)                      \\012  T(UnterminatedRegExp, &quot;Invalid regular expression: missing /&quot;)               \\012  T(UnterminatedTemplate, &quot;Unterminated template literal&quot;)                     \\012  T(UnterminatedTemplateExpr, &quot;Missing } in template expression&quot;)              \\012  T(FoundNonCallableHasInstance, &quot;Found non-callable @@hasInstance&quot;)           \\012  T(InvalidHexEscapeSequence, &quot;Invalid hexadecimal escape sequence&quot;)           \\012  T(InvalidUnicodeEscapeSequence, &quot;Invalid Unicode escape sequence&quot;)           \\012  T(UndefinedUnicodeCodePoint, &quot;Undefined Unicode code-point&quot;)                 \\012  T(YieldInParameter, &quot;Yield expression not allowed in formal parameter&quot;)      \\012 /* EvalError */                                                              \\012  T(CodeGenFromStrings, &quot;%&quot;)                                                   \\012  T(NoSideEffectDebugEvaluate, &quot;Possible side-effect in debug-evaluate&quot;)       \\012 /* URIError */                                                               \\012  T(URIMalformed, &quot;URI malformed&quot;)                                             \\012 /* Wasm errors (currently Error) */                                          \\012  T(WasmTrapUnreachable, &quot;unreachable&quot;)                                        \\012  T(WasmTrapMemOutOfBounds, &quot;memory access out of bounds&quot;)                     \\012  T(WasmTrapUnalignedAccess, &quot;operation does not support unaligned accesses&quot;)  \\012  T(WasmTrapDivByZero, &quot;divide by zero&quot;)                                       \\012  T(WasmTrapDivUnrepresentable, &quot;divide result unrepresentable&quot;)               \\012  T(WasmTrapRemByZero, &quot;remainder by zero&quot;)                                    \\012  T(WasmTrapFloatUnrepresentable, &quot;float unrepresentable in integer range&quot;)    \\012  T(WasmTrapFuncInvalid, &quot;invalid index into function table&quot;)                  \\012  T(WasmTrapFuncSigMismatch, &quot;function signature mismatch&quot;)                    \\012  T(WasmTrapTypeError, &quot;wasm function signature contains illegal type&quot;)        \\012  T(WasmExceptionError, &quot;wasm exception&quot;)                                      \\012 /* Asm.js validation related */                                              \\012  T(AsmJsInvalid, &quot;Invalid asm.js: %&quot;)                                         \\012  T(AsmJsCompiled, &quot;Converted asm.js to WebAssembly: %&quot;)                       \\012  T(AsmJsInstantiated, &quot;Instantiated asm.js: %&quot;)                               \\012  T(AsmJsLinkingFailed, &quot;Linking failure in asm.js: %&quot;)                        \\012 /* DataCloneError messages */                                                \\012  T(DataCloneError, &quot;% could not be cloned.&quot;)                                  \\012  T(DataCloneErrorOutOfMemory, &quot;Data cannot be cloned, out of memory.&quot;)        \\012  T(DataCloneErrorNeuteredArrayBuffer,                                         \\012 &quot;An ArrayBuffer is neutered and could not be cloned.&quot;)                     \\012  T(DataCloneErrorSharedArrayBufferTransferred,                                \\012 &quot;A SharedArrayBuffer could not be cloned. SharedArrayBuffer must not be &quot;  \\012 &quot;transferred.&quot;)                                                            \\012  T(DataCloneDeserializationError, &quot;Unable to deserialize cloned data.&quot;)       \\012  T(DataCloneDeserializationVersionError,                                      \\012 &quot;Unable to deserialize cloned data due to invalid or unsupported &quot;         \\012 &quot;version.&quot;)                                                                \\012 /* Builtins-Trace Errors */                                                  \\012  T(TraceEventCategoryError, &quot;Trace event category must be a string.&quot;)         \\012  T(TraceEventNameError, &quot;Trace event name must be a string.&quot;)                 \\012  T(TraceEventNameLengthError,                                                 \\012 &quot;Trace event name must not be an empty string.&quot;)                           \\012  T(TraceEventPhaseError, &quot;Trace event phase must be a number.&quot;)               \\012  T(TraceEventIDError, &quot;Trace event id must be a number.&quot;)\012\012class MessageTemplate {\012 public:\012 enum Template {\012#define TEMPLATE(NAME, STRING) k##NAME,\012    MESSAGE_TEMPLATES(TEMPLATE)\012#undef TEMPLATE\012        kLastMessage\012 };\012\012 static const char* TemplateString(int template_index);\012\012 static MaybeHandle&lt;String&gt; FormatMessage(Isolate* isolate, int template_index,\012 Handle&lt;String&gt; arg0,\012 Handle&lt;String&gt; arg1,\012 Handle&lt;String&gt; arg2);\012\012 static Handle&lt;String&gt; FormatMessage(Isolate* isolate, int template_index,\012 Handle&lt;Object&gt; arg);\012};\012\012\012// A message handler is a convenience interface for accessing the list\012// of message listeners registered in an environment\012class MessageHandler {\012 public:\012 // Returns a message object for the API to use.\012 static Handle&lt;JSMessageObject&gt; MakeMessageObject(\012 Isolate* isolate, MessageTemplate::Template type,\012 const MessageLocation* location, Handle&lt;Object&gt; argument,\012 Handle&lt;FixedArray&gt; stack_frames);\012\012 // Report a formatted message (needs JS allocation).\012 static void ReportMessage(Isolate* isolate, const MessageLocation* loc,\012 Handle&lt;JSMessageObject&gt; message);\012\012 static void DefaultMessageReport(Isolate* isolate, const MessageLocation* loc,\012 Handle&lt;Object&gt; message_obj);\012 static Handle&lt;String&gt; GetMessage(Isolate* isolate, Handle&lt;Object&gt; data);\012 static std::unique_ptr&lt;char[]&gt; GetLocalizedMessage(Isolate* isolate,\012 Handle&lt;Object&gt; data);\012\012 private:\012 static void ReportMessageNoExceptions(Isolate* isolate,\012 const MessageLocation* loc,\012 Handle&lt;Object&gt; message_obj,\012                                        v8::Local&lt;v8::Value&gt; api_exception_obj);\012};\012\012\012} // namespace internal\012})<SUB>17</SUB>> ]
 "5" [label = <(METHOD,&lt;global&gt;)<SUB>1</SUB>> ]
 "8" [label = <(METHOD_RETURN,ANY)<SUB>1</SUB>> ]
   "7" -> "8" 
diff -bur /home/mrt3acher/thesis-implementation/.avuln-workdir/code/CVE-2021-0396_1/secure/out/1-cfg.dot /home/mrt3acher/thesis-implementation/.avuln-workdir/code/CVE-2021-0396_1/vulnerable/out/1-cfg.dot
--- /home/mrt3acher/thesis-implementation/.avuln-workdir/code/CVE-2021-0396_1/secure/out/1-cfg.dot	2023-06-07 19:36:12.327380748 +0330
+++ /home/mrt3acher/thesis-implementation/.avuln-workdir/code/CVE-2021-0396_1/vulnerable/out/1-cfg.dot	2023-06-07 19:36:15.797380509 +0330
@@ -1,5 +1,5 @@
 digraph "&lt;global&gt;" {  
-"14" [label = <(UNKNOWN,namespace v8 {\012namespace internal {\012\012enum FunctionNameValidity {\012  kFunctionNameIsStrictReserved,\012  kSkipFunctionNameCheck,\012  kFunctionNameValidityUnknown\012};\012\012enum AllowLabelledFunctionStatement {\012  kAllowLabelledFunctionStatement,\012  kDisallowLabelledFunctionStatement,\012};\012\012enum class ParseFunctionFlags {\012  kIsNormal = 0,\012  kIsGenerator = 1,\012  kIsAsync = 2,\012  kIsDefault = 4\012};\012\012static inline ParseFunctionFlags operator|(ParseFunctionFlags lhs,\012 ParseFunctionFlags rhs) {\012 typedef unsigned char T;\012 return static_cast&lt;ParseFunctionFlags&gt;(static_cast&lt;T&gt;(lhs) |\012 static_cast&lt;T&gt;(rhs));\012}\012\012static inline ParseFunctionFlags&amp; operator|=(ParseFunctionFlags&amp; lhs,\012 const ParseFunctionFlags&amp; rhs) {\012  lhs = lhs | rhs;\012 return lhs;\012}\012\012static inline bool operator&amp;(ParseFunctionFlags bitfield,\012 ParseFunctionFlags mask) {\012 typedef unsigned char T;\012 return static_cast&lt;T&gt;(bitfield) &amp; static_cast&lt;T&gt;(mask);\012}\012\012struct FormalParametersBase {\012 explicit FormalParametersBase(DeclarationScope* scope) : scope(scope) {}\012\012 int num_parameters() const {\012 // Don't include the rest parameter into the function's formal parameter\012 // count (esp. the SharedFunctionInfo::internal_formal_parameter_count,\012 // which says whether we need to create an arguments adaptor frame).\012 return arity - has_rest;\012 }\012\012 void UpdateArityAndFunctionLength(bool is_optional, bool is_rest) {\012 if (!is_optional &amp;&amp; !is_rest &amp;&amp; function_length == arity) {\012 ++function_length;\012 }\012 ++arity;\012 }\012\012 DeclarationScope* scope;\012 bool has_rest = false;\012 bool is_simple = true;\012 int function_length = 0;\012 int arity = 0;\012};\012\012// Stack-allocated scope to collect source ranges from the parser.\012class SourceRangeScope final {\012 public:\012 enum PositionKind {\012    POSITION_BEG,\012    POSITION_END,\012    PEEK_POSITION_BEG,\012    PEEK_POSITION_END,\012 };\012\012 SourceRangeScope(Scanner* scanner, SourceRange* range,\012 PositionKind pre_kind = PEEK_POSITION_BEG,\012 PositionKind post_kind = POSITION_END)\012 : scanner_(scanner), range_(range), post_kind_(post_kind) {\012    range_-&gt;start = GetPosition(pre_kind);\012    DCHECK_NE(range_-&gt;start, kNoSourcePosition);\012 }\012\012 ~SourceRangeScope() { Finalize(); }\012\012 const SourceRange&amp; Finalize() {\012 if (is_finalized_) return *range_;\012    is_finalized_ = true;\012    range_-&gt;end = GetPosition(post_kind_);\012    DCHECK_NE(range_-&gt;end, kNoSourcePosition);\012 return *range_;\012 }\012\012 private:\012 int32_t GetPosition(PositionKind kind) {\012 switch (kind) {\012 case POSITION_BEG:\012 return scanner_-&gt;location().beg_pos;\012 case POSITION_END:\012 return scanner_-&gt;location().end_pos;\012 case PEEK_POSITION_BEG:\012 return scanner_-&gt;peek_location().beg_pos;\012 case PEEK_POSITION_END:\012 return scanner_-&gt;peek_location().end_pos;\012 default:\012        UNREACHABLE();\012 }\012 }\012\012 Scanner* scanner_;\012 SourceRange* range_;\012 PositionKind post_kind_;\012 bool is_finalized_ = false;\012\012  DISALLOW_IMPLICIT_CONSTRUCTORS(SourceRangeScope);\012};\012\012// ----------------------------------------------------------------------------\012// The CHECK_OK macro is a convenient macro to enforce error\012// handling for functions that may fail (by returning !*ok).\012//\012// CAUTION: This macro appends extra statements after a call,\012// thus it must never be used where only a single statement\012// is correct (e.g. an if statement branch w/o braces)!\012\012#define CHECK_OK_CUSTOM(x, ...) ok);       \\012 if (!*ok) return impl()-&gt;x(__VA_ARGS__); \\012 ((void)0\012#define DUMMY ) // to make indentation work\012#undef DUMMY\012\012// Used in functions where the return type is ExpressionT.\012#define CHECK_OK CHECK_OK_CUSTOM(NullExpression)\012\012#define CHECK_OK_VOID ok); \\012 if (!*ok) return;        \\012 ((void)0\012#define DUMMY ) // to make indentation work\012#undef DUMMY\012\012// Common base class template shared between parser and pre-parser.\012// The Impl parameter is the actual class of the parser/pre-parser,\012// following the Curiously Recurring Template Pattern (CRTP).\012// The structure of the parser objects is roughly the following:\012//\012//   // A structure template containing type definitions, needed to\012//   // avoid a cyclic dependency.\012//   template &lt;typename Impl&gt;\012//   struct ParserTypes;\012//\012//   // The parser base object, which should just implement pure\012//   // parser behavior.  The Impl parameter is the actual derived\012//   // class (according to CRTP), which implements impure parser\012//   // behavior.\012//   template &lt;typename Impl&gt;\012//   class ParserBase { ... };\012//\012//   // And then, for each parser variant (e.g., parser, preparser, etc):\012//   class Parser;\012//\012//   template &lt;&gt;\012//   class ParserTypes&lt;Parser&gt; { ... };\012//\012//   class Parser : public ParserBase&lt;Parser&gt; { ... };\012//\012// The parser base object implements pure parsing, according to the\012// language grammar.  Different parser implementations may exhibit\012// different parser-driven behavior that is not considered as pure\012// parsing, e.g., early error detection and reporting, AST generation, etc.\012\012// The ParserTypes structure encapsulates the differences in the\012// types used in parsing methods.  E.g., Parser methods use Expression*\012// and PreParser methods use PreParserExpression.  For any given parser\012// implementation class Impl, it is expected to contain the following typedefs:\012//\012// template &lt;&gt;\012// struct ParserTypes&lt;Impl&gt; {\012//   // Synonyms for ParserBase&lt;Impl&gt; and Impl, respectively.\012//   typedef Base;\012//   typedef Impl;\012//   // Return types for traversing functions.\012//   typedef Identifier;\012//   typedef Expression;\012//   typedef FunctionLiteral;\012//   typedef ObjectLiteralProperty;\012//   typedef ClassLiteralProperty;\012//   typedef ExpressionList;\012//   typedef ObjectPropertyList;\012//   typedef ClassPropertyList;\012//   typedef FormalParameters;\012//   typedef Statement;\012//   typedef StatementList;\012//   typedef Block;\012//   typedef BreakableStatement;\012//   typedef ForStatement;\012//   typedef IterationStatement;\012//   // For constructing objects returned by the traversing functions.\012//   typedef Factory;\012//   // For other implementation-specific tasks.\012//   typedef Target;\012//   typedef TargetScope;\012// };\012\012template &lt;typename Impl&gt;\012struct ParserTypes;\012\012template &lt;typename Impl&gt;\012class ParserBase {\012 public:\012 // Shorten type names defined by ParserTypes&lt;Impl&gt;.\012 typedef ParserTypes&lt;Impl&gt; Types;\012 typedef typename Types::Identifier IdentifierT;\012 typedef typename Types::Expression ExpressionT;\012 typedef typename Types::FunctionLiteral FunctionLiteralT;\012 typedef typename Types::ObjectLiteralProperty ObjectLiteralPropertyT;\012 typedef typename Types::ClassLiteralProperty ClassLiteralPropertyT;\012 typedef typename Types::Suspend SuspendExpressionT;\012 typedef typename Types::RewritableExpression RewritableExpressionT;\012 typedef typename Types::ExpressionList ExpressionListT;\012 typedef typename Types::FormalParameters FormalParametersT;\012 typedef typename Types::Statement StatementT;\012 typedef typename Types::StatementList StatementListT;\012 typedef typename Types::Block BlockT;\012 typedef typename Types::ForStatement ForStatementT;\012 typedef typename v8::internal::ExpressionClassifier&lt;Types&gt;\012 ExpressionClassifier;\012\012 // All implementation-specific methods must be called through this.\012 Impl* impl() { return static_cast&lt;Impl*&gt;(this); }\012 const Impl* impl() const { return static_cast&lt;const Impl*&gt;(this); }\012\012 ParserBase(Zone* zone, Scanner* scanner, uintptr_t stack_limit,\012             v8::Extension* extension, AstValueFactory* ast_value_factory,\012 PendingCompilationErrorHandler* pending_error_handler,\012 RuntimeCallStats* runtime_call_stats, Logger* logger,\012 int script_id, bool parsing_module, bool parsing_on_main_thread)\012 : scope_(nullptr),\012        original_scope_(nullptr),\012        function_state_(nullptr),\012        extension_(extension),\012        fni_(nullptr),\012        ast_value_factory_(ast_value_factory),\012        ast_node_factory_(ast_value_factory, zone),\012        runtime_call_stats_(runtime_call_stats),\012        logger_(logger),\012        parsing_on_main_thread_(parsing_on_main_thread),\012        parsing_module_(parsing_module),\012        stack_limit_(stack_limit),\012        pending_error_handler_(pending_error_handler),\012        zone_(zone),\012        classifier_(nullptr),\012        scanner_(scanner),\012        default_eager_compile_hint_(FunctionLiteral::kShouldLazyCompile),\012        function_literal_id_(0),\012        script_id_(script_id),\012        allow_natives_(false),\012        allow_harmony_do_expressions_(false),\012        allow_harmony_public_fields_(false),\012        allow_harmony_static_fields_(false),\012        allow_harmony_dynamic_import_(false),\012        allow_harmony_import_meta_(false),\012        allow_harmony_private_fields_(false),\012        allow_eval_cache_(true) {}\012\012#define ALLOW_ACCESSORS(name)                           \\012 bool allow_##name() const { return allow_##name##_; } \\012 void set_allow_##name(bool allow) { allow_##name##_ = allow; }\012\012  ALLOW_ACCESSORS(natives);\012  ALLOW_ACCESSORS(harmony_do_expressions);\012  ALLOW_ACCESSORS(harmony_public_fields);\012  ALLOW_ACCESSORS(harmony_static_fields);\012  ALLOW_ACCESSORS(harmony_dynamic_import);\012  ALLOW_ACCESSORS(harmony_import_meta);\012  ALLOW_ACCESSORS(eval_cache);\012\012#undef ALLOW_ACCESSORS\012\012 bool allow_harmony_bigint() const {\012 return scanner()-&gt;allow_harmony_bigint();\012 }\012 void set_allow_harmony_bigint(bool allow) {\012    scanner()-&gt;set_allow_harmony_bigint(allow);\012 }\012 bool allow_harmony_numeric_separator() const {\012 return scanner()-&gt;allow_harmony_numeric_separator();\012 }\012 void set_allow_harmony_numeric_separator(bool allow) {\012    scanner()-&gt;set_allow_harmony_numeric_separator(allow);\012 }\012\012 bool allow_harmony_private_fields() const {\012 return scanner()-&gt;allow_harmony_private_fields();\012 }\012 void set_allow_harmony_private_fields(bool allow) {\012    scanner()-&gt;set_allow_harmony_private_fields(allow);\012 }\012\012 uintptr_t stack_limit() const { return stack_limit_; }\012\012 void set_stack_limit(uintptr_t stack_limit) { stack_limit_ = stack_limit; }\012\012 void set_default_eager_compile_hint(\012 FunctionLiteral::EagerCompileHint eager_compile_hint) {\012    default_eager_compile_hint_ = eager_compile_hint;\012 }\012\012 FunctionLiteral::EagerCompileHint default_eager_compile_hint() const {\012 return default_eager_compile_hint_;\012 }\012\012 int GetNextFunctionLiteralId() { return ++function_literal_id_; }\012 int GetLastFunctionLiteralId() const { return function_literal_id_; }\012\012 void SkipFunctionLiterals(int delta) { function_literal_id_ += delta; }\012\012 void ResetFunctionLiteralId() { function_literal_id_ = 0; }\012\012 // The Zone where the parsing outputs are stored.\012 Zone* main_zone() const { return ast_value_factory()-&gt;zone(); }\012\012 // The current Zone, which might be the main zone or a temporary Zone.\012 Zone* zone() const { return zone_; }\012\012 protected:\012 friend class v8::internal::ExpressionClassifier&lt;ParserTypes&lt;Impl&gt;&gt;;\012\012 enum AllowRestrictedIdentifiers {\012    kAllowRestrictedIdentifiers,\012    kDontAllowRestrictedIdentifiers\012 };\012\012 enum LazyParsingResult { kLazyParsingComplete, kLazyParsingAborted };\012\012 enum VariableDeclarationContext {\012    kStatementListItem,\012    kStatement,\012    kForStatement\012 };\012\012 class ClassLiteralChecker;\012 class ObjectLiteralChecker;\012\012 // ---------------------------------------------------------------------------\012 // BlockState and FunctionState implement the parser's scope stack.\012 // The parser's current scope is in scope_. BlockState and FunctionState\012 // constructors push on the scope stack and the destructors pop. They are also\012 // used to hold the parser's per-funcion state.\012 class BlockState BASE_EMBEDDED {\012 public:\012 BlockState(Scope** scope_stack, Scope* scope)\012 : scope_stack_(scope_stack), outer_scope_(*scope_stack) {\012 *scope_stack_ = scope;\012 }\012\012 BlockState(Zone* zone, Scope** scope_stack)\012 : BlockState(scope_stack,\012 new (zone) Scope(zone, *scope_stack, BLOCK_SCOPE)) {}\012\012 ~BlockState() { *scope_stack_ = outer_scope_; }\012\012 private:\012 Scope** const scope_stack_;\012 Scope* const outer_scope_;\012 };\012\012 class FunctionState final : public BlockState {\012 public:\012 FunctionState(FunctionState** function_state_stack, Scope** scope_stack,\012 DeclarationScope* scope);\012 ~FunctionState();\012\012 DeclarationScope* scope() const { return scope_-&gt;AsDeclarationScope(); }\012\012 void AddProperty() { expected_property_count_++; }\012 int expected_property_count() { return expected_property_count_; }\012\012 void DisableOptimization(BailoutReason reason) {\012      dont_optimize_reason_ = reason;\012 }\012 BailoutReason dont_optimize_reason() { return dont_optimize_reason_; }\012\012 void AddSuspend() { suspend_count_++; }\012 int suspend_count() const { return suspend_count_; }\012 bool CanSuspend() const { return suspend_count_ &gt; 0; }\012\012 FunctionKind kind() const { return scope()-&gt;function_kind(); }\012\012 void RewindDestructuringAssignments(int pos) {\012      destructuring_assignments_to_rewrite_.Rewind(pos);\012 }\012\012 void AdoptDestructuringAssignmentsFromParentState(int pos) {\012 const auto&amp; outer_assignments =\012          outer_function_state_-&gt;destructuring_assignments_to_rewrite_;\012      DCHECK_GE(outer_assignments.size(), pos);\012 auto it = outer_assignments.begin();\012      it.Advance(pos);\012 for (; it != outer_assignments.end(); ++it) {\012 auto expr = *it;\012        expr-&gt;set_scope(scope_);\012        destructuring_assignments_to_rewrite_.push_back(expr);\012 }\012      outer_function_state_-&gt;RewindDestructuringAssignments(pos);\012 }\012\012 const ZoneChunkList&lt;RewritableExpressionT&gt;&amp;\012    destructuring_assignments_to_rewrite() const {\012 return destructuring_assignments_to_rewrite_;\012 }\012\012 ZoneVector&lt;typename ExpressionClassifier::Error&gt;* GetReportedErrorList() {\012 return &amp;reported_errors_;\012 }\012\012 bool next_function_is_likely_called() const {\012 return next_function_is_likely_called_;\012 }\012\012 bool previous_function_was_likely_called() const {\012 return previous_function_was_likely_called_;\012 }\012\012 void set_next_function_is_likely_called() {\012      next_function_is_likely_called_ = true;\012 }\012\012 void RecordFunctionOrEvalCall() { contains_function_or_eval_ = true; }\012 bool contains_function_or_eval() const {\012 return contains_function_or_eval_;\012 }\012\012 class FunctionOrEvalRecordingScope {\012 public:\012 explicit FunctionOrEvalRecordingScope(FunctionState* state)\012 : state_(state) {\012        prev_value_ = state-&gt;contains_function_or_eval_;\012        state-&gt;contains_function_or_eval_ = false;\012 }\012 ~FunctionOrEvalRecordingScope() {\012 bool found = state_-&gt;contains_function_or_eval_;\012 if (!found) {\012          state_-&gt;contains_function_or_eval_ = prev_value_;\012 }\012 }\012\012 private:\012 FunctionState* state_;\012 bool prev_value_;\012 };\012\012 private:\012 void AddDestructuringAssignment(RewritableExpressionT expr) {\012      destructuring_assignments_to_rewrite_.push_back(expr);\012 }\012\012 // Properties count estimation.\012 int expected_property_count_;\012\012 // How many suspends are needed for this function.\012 int suspend_count_;\012\012 FunctionState** function_state_stack_;\012 FunctionState* outer_function_state_;\012 DeclarationScope* scope_;\012\012 ZoneChunkList&lt;RewritableExpressionT&gt; destructuring_assignments_to_rewrite_;\012\012 // We use a ZoneVector here because we need to do a lot of random access.\012 ZoneVector&lt;typename ExpressionClassifier::Error&gt; reported_errors_;\012\012 // A reason, if any, why this function should not be optimized.\012 BailoutReason dont_optimize_reason_;\012\012 // Record whether the next (=== immediately following) function literal is\012 // preceded by a parenthesis / exclamation mark. Also record the previous\012 // state.\012 // These are managed by the FunctionState constructor; the caller may only\012 // call set_next_function_is_likely_called.\012 bool next_function_is_likely_called_;\012 bool previous_function_was_likely_called_;\012\012 // Track if a function or eval occurs within this FunctionState\012 bool contains_function_or_eval_;\012\012 friend Impl;\012 };\012\012 struct DeclarationDescriptor {\012 enum Kind { NORMAL, PARAMETER, FOR_EACH };\012 Scope* scope;\012 VariableMode mode;\012 int declaration_pos;\012 int initialization_pos;\012 Kind declaration_kind;\012 };\012\012 struct DeclarationParsingResult {\012 struct Declaration {\012 Declaration(ExpressionT pattern, int initializer_position,\012 ExpressionT initializer)\012 : pattern(pattern),\012            initializer_position(initializer_position),\012            initializer(initializer) {}\012\012 ExpressionT pattern;\012 int initializer_position;\012 int value_beg_position = kNoSourcePosition;\012 ExpressionT initializer;\012 };\012\012 DeclarationParsingResult()\012 : first_initializer_loc(Scanner::Location::invalid()),\012          bindings_loc(Scanner::Location::invalid()) {}\012\012 DeclarationDescriptor descriptor;\012    std::vector&lt;Declaration&gt; declarations;\012 Scanner::Location first_initializer_loc;\012 Scanner::Location bindings_loc;\012 };\012\012 struct CatchInfo {\012 public:\012 explicit CatchInfo(ParserBase* parser)\012 : name(parser-&gt;impl()-&gt;NullIdentifier()),\012          pattern(parser-&gt;impl()-&gt;NullExpression()),\012          scope(nullptr),\012          init_block(parser-&gt;impl()-&gt;NullStatement()),\012          inner_block(parser-&gt;impl()-&gt;NullStatement()),\012          bound_names(1, parser-&gt;zone()) {}\012 IdentifierT name;\012 ExpressionT pattern;\012 Scope* scope;\012 BlockT init_block;\012 BlockT inner_block;\012 ZonePtrList&lt;const AstRawString&gt; bound_names;\012 };\012\012 struct ForInfo {\012 public:\012 explicit ForInfo(ParserBase* parser)\012 : bound_names(1, parser-&gt;zone()),\012          mode(ForEachStatement::ENUMERATE),\012          position(kNoSourcePosition),\012          parsing_result() {}\012 ZonePtrList&lt;const AstRawString&gt; bound_names;\012 ForEachStatement::VisitMode mode;\012 int position;\012 DeclarationParsingResult parsing_result;\012 };\012\012 struct ClassInfo {\012 public:\012 explicit ClassInfo(ParserBase* parser)\012 : variable(nullptr),\012 extends(parser-&gt;impl()-&gt;NullExpression()),\012          properties(parser-&gt;impl()-&gt;NewClassPropertyList(4)),\012          static_fields(parser-&gt;impl()-&gt;NewClassPropertyList(4)),\012          instance_fields(parser-&gt;impl()-&gt;NewClassPropertyList(4)),\012          constructor(parser-&gt;impl()-&gt;NullExpression()),\012          has_seen_constructor(false),\012          has_name_static_property(false),\012          has_static_computed_names(false),\012          has_static_class_fields(false),\012          has_instance_class_fields(false),\012          is_anonymous(false),\012          static_fields_scope(nullptr),\012          instance_fields_scope(nullptr),\012          computed_field_count(0) {}\012 Variable* variable;\012 ExpressionT extends;\012 typename Types::ClassPropertyList properties;\012 typename Types::ClassPropertyList static_fields;\012 typename Types::ClassPropertyList instance_fields;\012 FunctionLiteralT constructor;\012\012 bool has_seen_constructor;\012 bool has_name_static_property;\012 bool has_static_computed_names;\012 bool has_static_class_fields;\012 bool has_instance_class_fields;\012 bool is_anonymous;\012 DeclarationScope* static_fields_scope;\012 DeclarationScope* instance_fields_scope;\012 int computed_field_count;\012 };\012\012 const AstRawString* ClassFieldVariableName(AstValueFactory* ast_value_factory,\012 int index) {\012    std::string name = &quot;.class-field-&quot; + std::to_string(index);\012 return ast_value_factory-&gt;GetOneByteString(name.c_str());\012 }\012\012 DeclarationScope* NewScriptScope() const {\012 return new (zone()) DeclarationScope(zone(), ast_value_factory());\012 }\012\012 DeclarationScope* NewVarblockScope() const {\012 return new (zone()) DeclarationScope(zone(), scope(), BLOCK_SCOPE);\012 }\012\012 ModuleScope* NewModuleScope(DeclarationScope* parent) const {\012 return new (zone()) ModuleScope(parent, ast_value_factory());\012 }\012\012 DeclarationScope* NewEvalScope(Scope* parent) const {\012 return new (zone()) DeclarationScope(zone(), parent, EVAL_SCOPE);\012 }\012\012 Scope* NewScope(ScopeType scope_type) const {\012 return NewScopeWithParent(scope(), scope_type);\012 }\012\012 // This constructor should only be used when absolutely necessary. Most scopes\012 // should automatically use scope() as parent, and be fine with\012 // NewScope(ScopeType) above.\012 Scope* NewScopeWithParent(Scope* parent, ScopeType scope_type) const {\012 // Must always use the specific constructors for the blacklisted scope\012 // types.\012    DCHECK_NE(FUNCTION_SCOPE, scope_type);\012    DCHECK_NE(SCRIPT_SCOPE, scope_type);\012    DCHECK_NE(MODULE_SCOPE, scope_type);\012    DCHECK_NOT_NULL(parent);\012 return new (zone()) Scope(zone(), parent, scope_type);\012 }\012\012 // Creates a function scope that always allocates in zone(). The function\012 // scope itself is either allocated in zone() or in target_zone if one is\012 // passed in.\012 DeclarationScope* NewFunctionScope(FunctionKind kind,\012 Zone* target_zone = nullptr) const {\012    DCHECK(ast_value_factory());\012 if (target_zone == nullptr) target_zone = zone();\012 DeclarationScope* result = new (target_zone)\012 DeclarationScope(zone(), scope(), FUNCTION_SCOPE, kind);\012\012 // Record presence of an inner function scope\012    function_state_-&gt;RecordFunctionOrEvalCall();\012\012 // TODO(verwaest): Move into the DeclarationScope constructor.\012 if (!IsArrowFunction(kind)) {\012      result-&gt;DeclareDefaultFunctionVariables(ast_value_factory());\012 }\012 return result;\012 }\012\012  V8_INLINE DeclarationScope* GetDeclarationScope() const {\012 return scope()-&gt;GetDeclarationScope();\012 }\012  V8_INLINE DeclarationScope* GetClosureScope() const {\012 return scope()-&gt;GetClosureScope();\012 }\012\012 Scanner* scanner() const { return scanner_; }\012 AstValueFactory* ast_value_factory() const { return ast_value_factory_; }\012 int position() const { return scanner_-&gt;location().beg_pos; }\012 int peek_position() const { return scanner_-&gt;peek_location().beg_pos; }\012 bool stack_overflow() const {\012 return pending_error_handler()-&gt;stack_overflow();\012 }\012 void set_stack_overflow() { pending_error_handler()-&gt;set_stack_overflow(); }\012 int script_id() { return script_id_; }\012 void set_script_id(int id) { script_id_ = id; }\012\012  V8_INLINE Token::Value peek() {\012 if (stack_overflow()) return Token::ILLEGAL;\012 return scanner()-&gt;peek();\012 }\012\012 // Returns the position past the following semicolon (if it exists), and the\012 // position past the end of the current token otherwise.\012 int PositionAfterSemicolon() {\012 return (peek() == Token::SEMICOLON) ? scanner_-&gt;peek_location().end_pos\012 : scanner_-&gt;location().end_pos;\012 }\012\012  V8_INLINE Token::Value PeekAhead() {\012 if (stack_overflow()) return Token::ILLEGAL;\012 return scanner()-&gt;PeekAhead();\012 }\012\012  V8_INLINE Token::Value Next() {\012 if (stack_overflow()) return Token::ILLEGAL;\012 {\012 if (GetCurrentStackPosition() &lt; stack_limit_) {\012 // Any further calls to Next or peek will return the illegal token.\012 // The current call must return the next token, which might already\012 // have been peek'ed.\012        set_stack_overflow();\012 }\012 }\012 return scanner()-&gt;Next();\012 }\012\012 void Consume(Token::Value token) {\012 Token::Value next = Next();\012    USE(next);\012    USE(token);\012    DCHECK(next == token);\012 }\012\012 bool Check(Token::Value token) {\012 Token::Value next = peek();\012 if (next == token) {\012 Consume(next);\012 return true;\012 }\012 return false;\012 }\012\012 void Expect(Token::Value token, bool* ok) {\012 Token::Value next = Next();\012 if (next != token) {\012 ReportUnexpectedToken(next);\012 *ok = false;\012 }\012 }\012\012 void ExpectSemicolon(bool* ok) {\012 // Check for automatic semicolon insertion according to\012 // the rules given in ECMA-262, section 7.9, page 21.\012 Token::Value tok = peek();\012 if (tok == Token::SEMICOLON) {\012 Next();\012 return;\012 }\012 if (scanner()-&gt;HasLineTerminatorBeforeNext() || tok == Token::RBRACE ||\012        tok == Token::EOS) {\012 return;\012 }\012\012 Token::Value current = scanner()-&gt;current_token();\012 Scanner::Location current_location = scanner()-&gt;location();\012 Token::Value next = Next();\012\012 if (next == Token::SEMICOLON) {\012 return;\012 }\012\012 *ok = false;\012 if (current == Token::AWAIT &amp;&amp; !is_async_function()) {\012 ReportMessageAt(current_location,\012 MessageTemplate::kAwaitNotInAsyncFunction, kSyntaxError);\012 return;\012 }\012\012 ReportUnexpectedToken(next);\012 }\012\012 // Dummy functions, just useful as arguments to CHECK_OK_CUSTOM.\012 static void Void() {}\012 template &lt;typename T&gt;\012 static T Return(T result) {\012 return result;\012 }\012\012 bool is_any_identifier(Token::Value token) {\012 return token == Token::IDENTIFIER || token == Token::ENUM ||\012           token == Token::AWAIT || token == Token::ASYNC ||\012           token == Token::ESCAPED_STRICT_RESERVED_WORD ||\012           token == Token::FUTURE_STRICT_RESERVED_WORD || token == Token::LET ||\012           token == Token::STATIC || token == Token::YIELD;\012 }\012 bool peek_any_identifier() { return is_any_identifier(peek()); }\012\012 bool CheckContextualKeyword(Token::Value token) {\012 if (PeekContextualKeyword(token)) {\012 Consume(Token::IDENTIFIER);\012 return true;\012 }\012 return false;\012 }\012\012 bool PeekContextualKeyword(Token::Value token) {\012    DCHECK(Token::IsContextualKeyword(token));\012 return peek() == Token::IDENTIFIER &amp;&amp;\012           scanner()-&gt;next_contextual_token() == token;\012 }\012\012 void ExpectMetaProperty(Token::Value property_name, const char* full_name,\012 int pos, bool* ok);\012\012 void ExpectContextualKeyword(Token::Value token, bool* ok) {\012    DCHECK(Token::IsContextualKeyword(token));\012 Expect(Token::IDENTIFIER, CHECK_OK_CUSTOM(Void));\012 if (scanner()-&gt;current_contextual_token() != token) {\012 ReportUnexpectedToken(scanner()-&gt;current_token());\012 *ok = false;\012 }\012 }\012\012 bool CheckInOrOf(ForEachStatement::VisitMode* visit_mode) {\012 if (Check(Token::IN)) {\012 *visit_mode = ForEachStatement::ENUMERATE;\012 return true;\012 } else if (CheckContextualKeyword(Token::OF)) {\012 *visit_mode = ForEachStatement::ITERATE;\012 return true;\012 }\012 return false;\012 }\012\012 bool PeekInOrOf() {\012 return peek() == Token::IN || PeekContextualKeyword(Token::OF);\012 }\012\012 // Checks whether an octal literal was last seen between beg_pos and end_pos.\012 // Only called for strict mode strings.\012 void CheckStrictOctalLiteral(int beg_pos, int end_pos, bool* ok) {\012 Scanner::Location octal = scanner()-&gt;octal_position();\012 if (octal.IsValid() &amp;&amp; beg_pos &lt;= octal.beg_pos &amp;&amp;\012        octal.end_pos &lt;= end_pos) {\012 MessageTemplate::Template message = scanner()-&gt;octal_message();\012      DCHECK_NE(message, MessageTemplate::kNone);\012      impl()-&gt;ReportMessageAt(octal, message);\012      scanner()-&gt;clear_octal_position();\012 if (message == MessageTemplate::kStrictDecimalWithLeadingZero) {\012        impl()-&gt;CountUsage(v8::Isolate::kDecimalWithLeadingZeroInStrictMode);\012 }\012 *ok = false;\012 }\012 }\012\012 // Checks if an octal literal or an invalid hex or unicode escape sequence\012 // appears in the current template literal token. In the presence of such,\012 // either returns false or reports an error, depending on should_throw.\012 // Otherwise returns true.\012 inline bool CheckTemplateEscapes(bool should_throw, bool* ok) {\012    DCHECK(scanner()-&gt;current_token() == Token::TEMPLATE_SPAN ||\012           scanner()-&gt;current_token() == Token::TEMPLATE_TAIL);\012 if (!scanner()-&gt;has_invalid_template_escape()) {\012 return true;\012 }\012\012 // Handle error case(s)\012 if (should_throw) {\012      impl()-&gt;ReportMessageAt(scanner()-&gt;invalid_template_escape_location(),\012                              scanner()-&gt;invalid_template_escape_message());\012 *ok = false;\012 }\012 return false;\012 }\012\012 void CheckDestructuringElement(ExpressionT element, int beg_pos, int end_pos);\012\012 // Checking the name of a function literal. This has to be done after parsing\012 // the function, since the function can declare itself strict.\012 void CheckFunctionName(LanguageMode language_mode, IdentifierT function_name,\012 FunctionNameValidity function_name_validity,\012 const Scanner::Location&amp; function_name_loc, bool* ok) {\012 if (impl()-&gt;IsNull(function_name)) return;\012 if (function_name_validity == kSkipFunctionNameCheck) return;\012 // The function name needs to be checked in strict mode.\012 if (is_sloppy(language_mode)) return;\012\012 if (impl()-&gt;IsEvalOrArguments(function_name)) {\012      impl()-&gt;ReportMessageAt(function_name_loc,\012 MessageTemplate::kStrictEvalArguments);\012 *ok = false;\012 return;\012 }\012 if (function_name_validity == kFunctionNameIsStrictReserved) {\012      impl()-&gt;ReportMessageAt(function_name_loc,\012 MessageTemplate::kUnexpectedStrictReserved);\012 *ok = false;\012 return;\012 }\012 }\012\012 // Determine precedence of given token.\012 static int Precedence(Token::Value token, bool accept_IN) {\012 if (token == Token::IN &amp;&amp; !accept_IN)\012 return 0; // 0 precedence will terminate binary expression parsing\012 return Token::Precedence(token);\012 }\012\012 typename Types::Factory* factory() { return &amp;ast_node_factory_; }\012\012 DeclarationScope* GetReceiverScope() const {\012 return scope()-&gt;GetReceiverScope();\012 }\012 LanguageMode language_mode() { return scope()-&gt;language_mode(); }\012 void RaiseLanguageMode(LanguageMode mode) {\012 LanguageMode old = scope()-&gt;language_mode();\012    impl()-&gt;SetLanguageMode(scope(), old &gt; mode ? old : mode);\012 }\012 bool is_generator() const {\012 return IsGeneratorFunction(function_state_-&gt;kind());\012 }\012 bool is_async_function() const {\012 return IsAsyncFunction(function_state_-&gt;kind());\012 }\012 bool is_async_generator() const {\012 return IsAsyncGeneratorFunction(function_state_-&gt;kind());\012 }\012 bool is_resumable() const {\012 return IsResumableFunction(function_state_-&gt;kind());\012 }\012\012 const PendingCompilationErrorHandler* pending_error_handler() const {\012 return pending_error_handler_;\012 }\012 PendingCompilationErrorHandler* pending_error_handler() {\012 return pending_error_handler_;\012 }\012\012 // Report syntax errors.\012 void ReportMessage(MessageTemplate::Template message) {\012 Scanner::Location source_location = scanner()-&gt;location();\012    impl()-&gt;ReportMessageAt(source_location, message,\012 static_cast&lt;const char*&gt;(nullptr), kSyntaxError);\012 }\012\012 template &lt;typename T&gt;\012 void ReportMessage(MessageTemplate::Template message, T arg,\012 ParseErrorType error_type = kSyntaxError) {\012 Scanner::Location source_location = scanner()-&gt;location();\012    impl()-&gt;ReportMessageAt(source_location, message, arg, error_type);\012 }\012\012 void ReportMessageAt(Scanner::Location location,\012 MessageTemplate::Template message,\012 ParseErrorType error_type) {\012    impl()-&gt;ReportMessageAt(location, message,\012 static_cast&lt;const char*&gt;(nullptr), error_type);\012 }\012\012 void GetUnexpectedTokenMessage(\012 Token::Value token, MessageTemplate::Template* message,\012 Scanner::Location* location, const char** arg,\012 MessageTemplate::Template default_ = MessageTemplate::kUnexpectedToken);\012\012 void ReportUnexpectedToken(Token::Value token);\012 void ReportUnexpectedTokenAt(\012 Scanner::Location location, Token::Value token,\012 MessageTemplate::Template message = MessageTemplate::kUnexpectedToken);\012\012 void ReportClassifierError(\012 const typename ExpressionClassifier::Error&amp; error) {\012    impl()-&gt;ReportMessageAt(error.location, error.message, error.arg);\012 }\012\012 void ValidateExpression(bool* ok) {\012 if (!classifier()-&gt;is_valid_expression()) {\012 ReportClassifierError(classifier()-&gt;expression_error());\012 *ok = false;\012 }\012 }\012\012 void ValidateFormalParameterInitializer(bool* ok) {\012 if (!classifier()-&gt;is_valid_formal_parameter_initializer()) {\012 ReportClassifierError(classifier()-&gt;formal_parameter_initializer_error());\012 *ok = false;\012 }\012 }\012\012 void ValidateBindingPattern(bool* ok) {\012 if (!classifier()-&gt;is_valid_binding_pattern()) {\012 ReportClassifierError(classifier()-&gt;binding_pattern_error());\012 *ok = false;\012 }\012 }\012\012 void ValidateAssignmentPattern(bool* ok) {\012 if (!classifier()-&gt;is_valid_assignment_pattern()) {\012 ReportClassifierError(classifier()-&gt;assignment_pattern_error());\012 *ok = false;\012 }\012 }\012\012 void ValidateFormalParameters(LanguageMode language_mode,\012 bool allow_duplicates, bool* ok) {\012 if (!allow_duplicates &amp;&amp;\012 !classifier()-&gt;is_valid_formal_parameter_list_without_duplicates()) {\012 ReportClassifierError(classifier()-&gt;duplicate_formal_parameter_error());\012 *ok = false;\012 } else if (is_strict(language_mode) &amp;&amp;\012 !classifier()-&gt;is_valid_strict_mode_formal_parameters()) {\012 ReportClassifierError(classifier()-&gt;strict_mode_formal_parameter_error());\012 *ok = false;\012 }\012 }\012\012 bool IsValidArrowFormalParametersStart(Token::Value token) {\012 return is_any_identifier(token) || token == Token::LPAREN;\012 }\012\012 void ValidateArrowFormalParameters(ExpressionT expr,\012 bool parenthesized_formals, bool is_async,\012 bool* ok) {\012 if (classifier()-&gt;is_valid_binding_pattern()) {\012 // A simple arrow formal parameter: IDENTIFIER =&gt; BODY.\012 if (!impl()-&gt;IsIdentifier(expr)) {\012        impl()-&gt;ReportMessageAt(scanner()-&gt;location(),\012 MessageTemplate::kUnexpectedToken,\012 Token::String(scanner()-&gt;current_token()));\012 *ok = false;\012 }\012 } else if (!classifier()-&gt;is_valid_arrow_formal_parameters()) {\012 // If after parsing the expr, we see an error but the expression is\012 // neither a valid binding pattern nor a valid parenthesized formal\012 // parameter list, show the &quot;arrow formal parameters&quot; error if the formals\012 // started with a parenthesis, and the binding pattern error otherwise.\012 const typename ExpressionClassifier::Error&amp; error =\012          parenthesized_formals ? classifier()-&gt;arrow_formal_parameters_error()\012 : classifier()-&gt;binding_pattern_error();\012 ReportClassifierError(error);\012 *ok = false;\012 }\012 if (is_async &amp;&amp; !classifier()-&gt;is_valid_async_arrow_formal_parameters()) {\012 const typename ExpressionClassifier::Error&amp; error =\012          classifier()-&gt;async_arrow_formal_parameters_error();\012 ReportClassifierError(error);\012 *ok = false;\012 }\012 }\012\012 void ValidateLetPattern(bool* ok) {\012 if (!classifier()-&gt;is_valid_let_pattern()) {\012 ReportClassifierError(classifier()-&gt;let_pattern_error());\012 *ok = false;\012 }\012 }\012\012 void BindingPatternUnexpectedToken() {\012 MessageTemplate::Template message = MessageTemplate::kUnexpectedToken;\012 const char* arg;\012 Scanner::Location location = scanner()-&gt;peek_location();\012 GetUnexpectedTokenMessage(peek(), &amp;message, &amp;location, &amp;arg);\012    classifier()-&gt;RecordBindingPatternError(location, message, arg);\012 }\012\012 void ArrowFormalParametersUnexpectedToken() {\012 MessageTemplate::Template message = MessageTemplate::kUnexpectedToken;\012 const char* arg;\012 Scanner::Location location = scanner()-&gt;peek_location();\012 GetUnexpectedTokenMessage(peek(), &amp;message, &amp;location, &amp;arg);\012    classifier()-&gt;RecordArrowFormalParametersError(location, message, arg);\012 }\012\012 // Recursive descent functions.\012 // All ParseXXX functions take as the last argument an *ok parameter\012 // which is set to false if parsing failed; it is unchanged otherwise.\012 // By making the 'exception handling' explicit, we are forced to check\012 // for failure at the call sites. The family of CHECK_OK* macros can\012 // be useful for this.\012\012 // Parses an identifier that is valid for the current scope, in particular it\012 // fails on strict mode future reserved keywords in a strict scope. If\012 // allow_eval_or_arguments is kAllowEvalOrArguments, we allow &quot;eval&quot; or\012 // &quot;arguments&quot; as identifier even in strict mode (this is needed in cases like\012 // &quot;var foo = eval;&quot;).\012 IdentifierT ParseIdentifier(AllowRestrictedIdentifiers, bool* ok);\012 IdentifierT ParseAndClassifyIdentifier(bool* ok);\012 // Parses an identifier or a strict mode future reserved word, and indicate\012 // whether it is strict mode future reserved. Allows passing in function_kind\012 // for the case of parsing the identifier in a function expression, where the\012 // relevant &quot;function_kind&quot; bit is of the function being parsed, not the\012 // containing function.\012 IdentifierT ParseIdentifierOrStrictReservedWord(FunctionKind function_kind,\012 bool* is_strict_reserved,\012 bool* is_await, bool* ok);\012 IdentifierT ParseIdentifierOrStrictReservedWord(bool* is_strict_reserved,\012 bool* is_await, bool* ok) {\012 return ParseIdentifierOrStrictReservedWord(\012        function_state_-&gt;kind(), is_strict_reserved, is_await, ok);\012 }\012\012  V8_INLINE IdentifierT ParseIdentifierName(bool* ok);\012\012 ExpressionT ParseIdentifierNameOrPrivateName(bool* ok);\012\012 ExpressionT ParseRegExpLiteral(bool* ok);\012\012 ExpressionT ParsePrimaryExpression(bool* is_async, bool* ok);\012 ExpressionT ParsePrimaryExpression(bool* ok) {\012 bool is_async;\012 return ParsePrimaryExpression(&amp;is_async, ok);\012 }\012\012 // Use when parsing an expression that is known to not be a pattern or part\012 // of a pattern.\012  V8_INLINE ExpressionT ParseExpression(bool accept_IN, bool* ok);\012\012 // This method does not wrap the parsing of the expression inside a\012 // new expression classifier; it uses the top-level classifier instead.\012 // It should be used whenever we're parsing something with the &quot;cover&quot;\012 // grammar that recognizes both patterns and non-patterns (which roughly\012 // corresponds to what's inside the parentheses generated by the symbol\012 // &quot;CoverParenthesizedExpressionAndArrowParameterList&quot; in the ES 2017\012 // specification).\012 ExpressionT ParseExpressionCoverGrammar(bool accept_IN, bool* ok);\012\012 ExpressionT ParseArrayLiteral(bool* ok);\012\012 enum class PropertyKind {\012    kAccessorProperty,\012    kValueProperty,\012    kShorthandProperty,\012    kMethodProperty,\012    kClassField,\012    kSpreadProperty,\012    kNotSet\012 };\012\012 bool SetPropertyKindFromToken(Token::Value token, PropertyKind* kind);\012 ExpressionT ParsePropertyName(IdentifierT* name, PropertyKind* kind,\012 bool* is_generator, bool* is_get, bool* is_set,\012 bool* is_async, bool* is_computed_name,\012 bool* ok);\012 ExpressionT ParseObjectLiteral(bool* ok);\012 ClassLiteralPropertyT ParseClassPropertyDefinition(\012 ClassLiteralChecker* checker, ClassInfo* class_info,\012 IdentifierT* property_name, bool has_extends, bool* is_computed_name,\012 ClassLiteralProperty::Kind* property_kind, bool* is_static, bool* ok);\012 ExpressionT ParseClassFieldInitializer(ClassInfo* class_info, bool is_static,\012 bool* ok);\012 ObjectLiteralPropertyT ParseObjectPropertyDefinition(\012 ObjectLiteralChecker* checker, bool* is_computed_name,\012 bool* is_rest_property, bool* ok);\012 ExpressionListT ParseArguments(Scanner::Location* first_spread_pos,\012 bool maybe_arrow,\012 bool* is_simple_parameter_list, bool* ok);\012 ExpressionListT ParseArguments(Scanner::Location* first_spread_pos,\012 bool* ok) {\012 return ParseArguments(first_spread_pos, false, nullptr, ok);\012 }\012\012 ExpressionT ParseAssignmentExpression(bool accept_IN, bool* ok);\012 ExpressionT ParseYieldExpression(bool accept_IN, bool* ok);\012  V8_INLINE ExpressionT ParseConditionalExpression(bool accept_IN, bool* ok);\012 ExpressionT ParseBinaryExpression(int prec, bool accept_IN, bool* ok);\012 ExpressionT ParseUnaryExpression(bool* ok);\012  V8_INLINE ExpressionT ParsePostfixExpression(bool* ok);\012  V8_INLINE ExpressionT ParseLeftHandSideExpression(bool* ok);\012 ExpressionT ParseMemberWithNewPrefixesExpression(bool* is_async, bool* ok);\012  V8_INLINE ExpressionT ParseMemberExpression(bool* is_async, bool* ok);\012  V8_INLINE ExpressionT ParseMemberExpressionContinuation(\012 ExpressionT expression, bool* is_async, bool* ok);\012\012 // `rewritable_length`: length of the destructuring_assignments_to_rewrite()\012 // queue in the parent function state, prior to parsing of formal parameters.\012 // If the arrow function is lazy, any items added during formal parameter\012 // parsing are removed from the queue.\012 ExpressionT ParseArrowFunctionLiteral(bool accept_IN,\012 const FormalParametersT&amp; parameters,\012 int rewritable_length, bool* ok);\012 void ParseSingleExpressionFunctionBody(StatementListT body, bool is_async,\012 bool accept_IN, bool* ok);\012 void ParseAsyncFunctionBody(Scope* scope, StatementListT body, bool* ok);\012 ExpressionT ParseAsyncFunctionLiteral(bool* ok);\012 ExpressionT ParseClassLiteral(IdentifierT name,\012 Scanner::Location class_name_location,\012 bool name_is_strict_reserved,\012 int class_token_pos, bool* ok);\012 ExpressionT ParseTemplateLiteral(ExpressionT tag, int start, bool tagged,\012 bool* ok);\012 ExpressionT ParseSuperExpression(bool is_new, bool* ok);\012 ExpressionT ParseImportExpressions(bool* ok);\012 ExpressionT ParseNewTargetExpression(bool* ok);\012\012  V8_INLINE void ParseFormalParameter(FormalParametersT* parameters, bool* ok);\012 void ParseFormalParameterList(FormalParametersT* parameters, bool* ok);\012 void CheckArityRestrictions(int param_count, FunctionKind function_type,\012 bool has_rest, int formals_start_pos,\012 int formals_end_pos, bool* ok);\012\012 BlockT ParseVariableDeclarations(VariableDeclarationContext var_context,\012 DeclarationParsingResult* parsing_result,\012 ZonePtrList&lt;const AstRawString&gt;* names,\012 bool* ok);\012 StatementT ParseAsyncFunctionDeclaration(\012 ZonePtrList&lt;const AstRawString&gt;* names, bool default_export, bool* ok);\012 StatementT ParseFunctionDeclaration(bool* ok);\012 StatementT ParseHoistableDeclaration(ZonePtrList&lt;const AstRawString&gt;* names,\012 bool default_export, bool* ok);\012 StatementT ParseHoistableDeclaration(int pos, ParseFunctionFlags flags,\012 ZonePtrList&lt;const AstRawString&gt;* names,\012 bool default_export, bool* ok);\012 StatementT ParseClassDeclaration(ZonePtrList&lt;const AstRawString&gt;* names,\012 bool default_export, bool* ok);\012 StatementT ParseNativeDeclaration(bool* ok);\012\012 // Consumes the ending }.\012 void ParseFunctionBody(StatementListT result, IdentifierT function_name,\012 int pos, const FormalParametersT&amp; parameters,\012 FunctionKind kind,\012 FunctionLiteral::FunctionType function_type, bool* ok);\012\012 // Under some circumstances, we allow preparsing to abort if the preparsed\012 // function is &quot;long and trivial&quot;, and fully parse instead. Our current\012 // definition of &quot;long and trivial&quot; is:\012 // - over kLazyParseTrialLimit statements\012 // - all starting with an identifier (i.e., no if, for, while, etc.)\012 static const int kLazyParseTrialLimit = 200;\012\012 // TODO(nikolaos, marja): The first argument should not really be passed\012 // by value. The method is expected to add the parsed statements to the\012 // list. This works because in the case of the parser, StatementListT is\012 // a pointer whereas the preparser does not really modify the body.\012  V8_INLINE void ParseStatementList(StatementListT body, Token::Value end_token,\012 bool* ok) {\012 LazyParsingResult result = ParseStatementList(body, end_token, false, ok);\012    USE(result);\012    DCHECK_EQ(result, kLazyParsingComplete);\012 }\012  V8_INLINE LazyParsingResult ParseStatementList(StatementListT body,\012 Token::Value end_token,\012 bool may_abort, bool* ok);\012 StatementT ParseStatementListItem(bool* ok);\012\012 StatementT ParseStatement(ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels,\012 bool* ok) {\012 return ParseStatement(labels, own_labels,\012                          kDisallowLabelledFunctionStatement, ok);\012 }\012 StatementT ParseStatement(ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels,\012 AllowLabelledFunctionStatement allow_function,\012 bool* ok);\012 BlockT ParseBlock(ZonePtrList&lt;const AstRawString&gt;* labels, bool* ok);\012\012 // Parse a SubStatement in strict mode, or with an extra block scope in\012 // sloppy mode to handle\012 // ES#sec-functiondeclarations-in-ifstatement-statement-clauses\012 StatementT ParseScopedStatement(ZonePtrList&lt;const AstRawString&gt;* labels,\012 bool* ok);\012\012 StatementT ParseVariableStatement(VariableDeclarationContext var_context,\012 ZonePtrList&lt;const AstRawString&gt;* names,\012 bool* ok);\012\012 // Magical syntax support.\012 ExpressionT ParseV8Intrinsic(bool* ok);\012\012 ExpressionT ParseDoExpression(bool* ok);\012\012 StatementT ParseDebuggerStatement(bool* ok);\012\012 StatementT ParseExpressionOrLabelledStatement(\012 ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels,\012 AllowLabelledFunctionStatement allow_function, bool* ok);\012 StatementT ParseIfStatement(ZonePtrList&lt;const AstRawString&gt;* labels,\012 bool* ok);\012 StatementT ParseContinueStatement(bool* ok);\012 StatementT ParseBreakStatement(ZonePtrList&lt;const AstRawString&gt;* labels,\012 bool* ok);\012 StatementT ParseReturnStatement(bool* ok);\012 StatementT ParseWithStatement(ZonePtrList&lt;const AstRawString&gt;* labels,\012 bool* ok);\012 StatementT ParseDoWhileStatement(ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels,\012 bool* ok);\012 StatementT ParseWhileStatement(ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels,\012 bool* ok);\012 StatementT ParseThrowStatement(bool* ok);\012 StatementT ParseSwitchStatement(ZonePtrList&lt;const AstRawString&gt;* labels,\012 bool* ok);\012  V8_INLINE StatementT ParseTryStatement(bool* ok);\012 StatementT ParseForStatement(ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels,\012 bool* ok);\012 StatementT ParseForEachStatementWithDeclarations(\012 int stmt_pos, ForInfo* for_info, ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels, Scope* inner_block_scope,\012 bool* ok);\012 StatementT ParseForEachStatementWithoutDeclarations(\012 int stmt_pos, ExpressionT expression, int lhs_beg_pos, int lhs_end_pos,\012 ForInfo* for_info, ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels, bool* ok);\012\012 // Parse a C-style for loop: 'for (&lt;init&gt;; &lt;cond&gt;; &lt;next&gt;) { ... }'\012 // &quot;for (&lt;init&gt;;&quot; is assumed to have been parser already.\012 ForStatementT ParseStandardForLoop(\012 int stmt_pos, ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels, ExpressionT* cond,\012 StatementT* next, StatementT* body, bool* ok);\012 // Same as the above, but handles those cases where &lt;init&gt; is a\012 // lexical variable declaration.\012 StatementT ParseStandardForLoopWithLexicalDeclarations(\012 int stmt_pos, StatementT init, ForInfo* for_info,\012 ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels, bool* ok);\012 StatementT ParseForAwaitStatement(ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels,\012 bool* ok);\012\012 bool IsNextLetKeyword();\012 bool IsTrivialExpression();\012\012 // Checks if the expression is a valid reference expression (e.g., on the\012 // left-hand side of assignments). Although ruled out by ECMA as early errors,\012 // we allow calls for web compatibility and rewrite them to a runtime throw.\012 ExpressionT CheckAndRewriteReferenceExpression(\012 ExpressionT expression, int beg_pos, int end_pos,\012 MessageTemplate::Template message, bool* ok);\012 ExpressionT CheckAndRewriteReferenceExpression(\012 ExpressionT expression, int beg_pos, int end_pos,\012 MessageTemplate::Template message, ParseErrorType type, bool* ok);\012\012 bool IsValidReferenceExpression(ExpressionT expression);\012\012 bool IsAssignableIdentifier(ExpressionT expression) {\012 if (!impl()-&gt;IsIdentifier(expression)) return false;\012 if (is_strict(language_mode()) &amp;&amp;\012        impl()-&gt;IsEvalOrArguments(impl()-&gt;AsIdentifier(expression))) {\012 return false;\012 }\012 return true;\012 }\012\012 bool IsValidPattern(ExpressionT expression) {\012 return expression-&gt;IsObjectLiteral() || expression-&gt;IsArrayLiteral();\012 }\012\012 // Due to hoisting, the value of a 'var'-declared variable may actually change\012 // even if the code contains only the &quot;initial&quot; assignment, namely when that\012 // assignment occurs inside a loop.  For example:\012 //\012 //   let i = 10;\012 //   do { var x = i } while (i--):\012 //\012 // As a simple and very conservative approximation of this, we explicitly mark\012 // as maybe-assigned any non-lexical variable whose initializing &quot;declaration&quot;\012 // does not syntactically occur in the function scope.  (In the example above,\012 // it occurs in a block scope.)\012 //\012 // Note that non-lexical variables include temporaries, which may also get\012 // assigned inside a loop due to the various rewritings that the parser\012 // performs.\012 //\012 // This also handles marking of loop variables in for-in and for-of loops,\012 // as determined by declaration_kind.\012 //\012 static void MarkLoopVariableAsAssigned(\012 Scope* scope, Variable* var,\012 typename DeclarationDescriptor::Kind declaration_kind);\012\012 FunctionKind FunctionKindForImpl(bool is_method, bool is_generator,\012 bool is_async) {\012 static const FunctionKind kFunctionKinds[][2][2] = {\012 {\012 // is_method=false\012 {// is_generator=false\012 FunctionKind::kNormalFunction, FunctionKind::kAsyncFunction},\012 {// is_generator=true\012 FunctionKind::kGeneratorFunction,\012 FunctionKind::kAsyncGeneratorFunction},\012 },\012 {\012 // is_method=true\012 {// is_generator=false\012 FunctionKind::kConciseMethod, FunctionKind::kAsyncConciseMethod},\012 {// is_generator=true\012 FunctionKind::kConciseGeneratorMethod,\012 FunctionKind::kAsyncConciseGeneratorMethod},\012 }};\012 return kFunctionKinds[is_method][is_generator][is_async];\012 }\012\012 inline FunctionKind FunctionKindFor(bool is_generator, bool is_async) {\012 const bool kIsMethod = false;\012 return FunctionKindForImpl(kIsMethod, is_generator, is_async);\012 }\012\012 inline FunctionKind MethodKindFor(bool is_generator, bool is_async) {\012 const bool kIsMethod = true;\012 return FunctionKindForImpl(kIsMethod, is_generator, is_async);\012 }\012\012 // Keep track of eval() calls since they disable all local variable\012 // optimizations. This checks if expression is an eval call, and if yes,\012 // forwards the information to scope.\012 Call::PossiblyEval CheckPossibleEvalCall(ExpressionT expression,\012 Scope* scope) {\012 if (impl()-&gt;IsIdentifier(expression) &amp;&amp;\012        impl()-&gt;IsEval(impl()-&gt;AsIdentifier(expression))) {\012      scope-&gt;RecordInnerScopeEvalCall();\012      function_state_-&gt;RecordFunctionOrEvalCall();\012 if (is_sloppy(scope-&gt;language_mode())) {\012 // For sloppy scopes we also have to record the call at function level,\012 // in case it includes declarations that will be hoisted.\012        scope-&gt;GetDeclarationScope()-&gt;RecordEvalCall();\012 }\012\012 // This call is only necessary to track evals that may be\012 // inside arrow function parameter lists. In that case,\012 // Scope::Snapshot::Reparent will move this bit down into\012 // the arrow function's scope.\012      scope-&gt;RecordEvalCall();\012\012 return Call::IS_POSSIBLY_EVAL;\012 }\012 return Call::NOT_EVAL;\012 }\012\012 // Convenience method which determines the type of return statement to emit\012 // depending on the current function type.\012 inline StatementT BuildReturnStatement(ExpressionT expr, int pos,\012 int end_pos = kNoSourcePosition) {\012 if (impl()-&gt;IsNull(expr)) {\012      expr = factory()-&gt;NewUndefinedLiteral(kNoSourcePosition);\012 } else if (is_async_generator()) {\012 // In async generators, if there is an explicit operand to the return\012 // statement, await the operand.\012      expr = factory()-&gt;NewAwait(expr, kNoSourcePosition);\012      function_state_-&gt;AddSuspend();\012 }\012 if (is_async_function()) {\012 return factory()-&gt;NewAsyncReturnStatement(expr, pos, end_pos);\012 }\012 return factory()-&gt;NewReturnStatement(expr, pos, end_pos);\012 }\012\012 // Validation per ES6 object literals.\012 class ObjectLiteralChecker {\012 public:\012 explicit ObjectLiteralChecker(ParserBase* parser)\012 : parser_(parser), has_seen_proto_(false) {}\012\012 void CheckDuplicateProto(Token::Value property);\012\012 private:\012 bool IsProto() const {\012 return this-&gt;scanner()-&gt;CurrentMatchesContextualEscaped(\012 Token::PROTO_UNDERSCORED);\012 }\012\012 ParserBase* parser() const { return parser_; }\012 Scanner* scanner() const { return parser_-&gt;scanner(); }\012\012 ParserBase* parser_;\012 bool has_seen_proto_;\012 };\012\012 // Validation per ES6 class literals.\012 class ClassLiteralChecker {\012 public:\012 explicit ClassLiteralChecker(ParserBase* parser)\012 : parser_(parser), has_seen_constructor_(false) {}\012\012 void CheckClassMethodName(Token::Value property, PropertyKind type,\012 bool is_generator, bool is_async, bool is_static,\012 bool* ok);\012 void CheckClassFieldName(bool is_static, bool* ok);\012\012 private:\012 bool IsConstructor() {\012 return this-&gt;scanner()-&gt;CurrentMatchesContextualEscaped(\012 Token::CONSTRUCTOR);\012 }\012 bool IsPrivateConstructor() {\012 return this-&gt;scanner()-&gt;CurrentMatchesContextualEscaped(\012 Token::PRIVATE_CONSTRUCTOR);\012 }\012 bool IsPrototype() {\012 return this-&gt;scanner()-&gt;CurrentMatchesContextualEscaped(Token::PROTOTYPE);\012 }\012\012 ParserBase* parser() const { return parser_; }\012 Scanner* scanner() const { return parser_-&gt;scanner(); }\012\012 ParserBase* parser_;\012 bool has_seen_constructor_;\012 };\012\012 ModuleDescriptor* module() const {\012 return scope()-&gt;AsModuleScope()-&gt;module();\012 }\012 Scope* scope() const { return scope_; }\012\012 // Stack of expression classifiers.\012 // The top of the stack is always pointed to by classifier().\012  V8_INLINE ExpressionClassifier* classifier() const {\012    DCHECK_NOT_NULL(classifier_);\012 return classifier_;\012 }\012\012 // Accumulates the classifier that is on top of the stack (inner) to\012 // the one that is right below (outer) and pops the inner.\012  V8_INLINE void Accumulate(unsigned productions) {\012    DCHECK_NOT_NULL(classifier_);\012 ExpressionClassifier* previous = classifier_-&gt;previous();\012    DCHECK_NOT_NULL(previous);\012    previous-&gt;Accumulate(classifier_, productions);\012    classifier_ = previous;\012 }\012\012  V8_INLINE void AccumulateNonBindingPatternErrors() {\012 this-&gt;Accumulate(ExpressionClassifier::AllProductions &amp;\012 ~(ExpressionClassifier::BindingPatternProduction |\012 ExpressionClassifier::LetPatternProduction));\012 }\012\012 // Pops and discards the classifier that is on top of the stack\012 // without accumulating.\012  V8_INLINE void DiscardExpressionClassifier() {\012    DCHECK_NOT_NULL(classifier_);\012    classifier_-&gt;Discard();\012    classifier_ = classifier_-&gt;previous();\012 }\012\012 // Accumulate errors that can be arbitrarily deep in an expression.\012 // These correspond to the ECMAScript spec's 'Contains' operation\012 // on productions. This includes:\012 //\012 // - YieldExpression is disallowed in arrow parameters in a generator.\012 // - AwaitExpression is disallowed in arrow parameters in an async function.\012 // - AwaitExpression is disallowed in async arrow parameters.\012 //\012  V8_INLINE void AccumulateFormalParameterContainmentErrors() {\012 Accumulate(ExpressionClassifier::FormalParameterInitializerProduction |\012 ExpressionClassifier::AsyncArrowFormalParametersProduction);\012 }\012\012 // Parser base's protected field members.\012\012 Scope* scope_; // Scope stack.\012 Scope* original_scope_; // The top scope for the current parsing item.\012 FunctionState* function_state_; // Function state stack.\012  v8::Extension* extension_;\012 FuncNameInferrer* fni_;\012 AstValueFactory* ast_value_factory_; // Not owned.\012 typename Types::Factory ast_node_factory_;\012 RuntimeCallStats* runtime_call_stats_;\012 internal::Logger* logger_;\012 bool parsing_on_main_thread_;\012 const bool parsing_module_;\012 uintptr_t stack_limit_;\012 PendingCompilationErrorHandler* pending_error_handler_;\012\012 // Parser base's private field members.\012\012 private:\012 Zone* zone_;\012 ExpressionClassifier* classifier_;\012\012 Scanner* scanner_;\012\012 FunctionLiteral::EagerCompileHint default_eager_compile_hint_;\012\012 int function_literal_id_;\012 int script_id_;\012\012 bool allow_natives_;\012 bool allow_harmony_do_expressions_;\012 bool allow_harmony_public_fields_;\012 bool allow_harmony_static_fields_;\012 bool allow_harmony_dynamic_import_;\012 bool allow_harmony_import_meta_;\012 bool allow_harmony_private_fields_;\012 bool allow_eval_cache_;\012\012 friend class DiscardableZoneScope;\012};\012\012template &lt;typename Impl&gt;\012ParserBase&lt;Impl&gt;::FunctionState::FunctionState(\012 FunctionState** function_state_stack, Scope** scope_stack,\012 DeclarationScope* scope)\012 : BlockState(scope_stack, scope),\012      expected_property_count_(0),\012      suspend_count_(0),\012      function_state_stack_(function_state_stack),\012      outer_function_state_(*function_state_stack),\012      scope_(scope),\012      destructuring_assignments_to_rewrite_(scope-&gt;zone()),\012      reported_errors_(scope_-&gt;zone()),\012      dont_optimize_reason_(BailoutReason::kNoReason),\012      next_function_is_likely_called_(false),\012      previous_function_was_likely_called_(false),\012      contains_function_or_eval_(false) {\012 *function_state_stack = this;\012  reported_errors_.reserve(16);\012 if (outer_function_state_) {\012    outer_function_state_-&gt;previous_function_was_likely_called_ =\012        outer_function_state_-&gt;next_function_is_likely_called_;\012    outer_function_state_-&gt;next_function_is_likely_called_ = false;\012 }\012}\012\012template &lt;typename Impl&gt;\012ParserBase&lt;Impl&gt;::FunctionState::~FunctionState() {\012 *function_state_stack_ = outer_function_state_;\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::GetUnexpectedTokenMessage(\012 Token::Value token, MessageTemplate::Template* message,\012 Scanner::Location* location, const char** arg,\012 MessageTemplate::Template default_) {\012 *arg = nullptr;\012 switch (token) {\012 case Token::EOS:\012 *message = MessageTemplate::kUnexpectedEOS;\012 break;\012 case Token::SMI:\012 case Token::NUMBER:\012 case Token::BIGINT:\012 *message = MessageTemplate::kUnexpectedTokenNumber;\012 break;\012 case Token::STRING:\012 *message = MessageTemplate::kUnexpectedTokenString;\012 break;\012 case Token::PRIVATE_NAME:\012 case Token::IDENTIFIER:\012 *message = MessageTemplate::kUnexpectedTokenIdentifier;\012 break;\012 case Token::AWAIT:\012 case Token::ENUM:\012 *message = MessageTemplate::kUnexpectedReserved;\012 break;\012 case Token::LET:\012 case Token::STATIC:\012 case Token::YIELD:\012 case Token::FUTURE_STRICT_RESERVED_WORD:\012 *message = is_strict(language_mode())\012 ? MessageTemplate::kUnexpectedStrictReserved\012 : MessageTemplate::kUnexpectedTokenIdentifier;\012 break;\012 case Token::TEMPLATE_SPAN:\012 case Token::TEMPLATE_TAIL:\012 *message = MessageTemplate::kUnexpectedTemplateString;\012 break;\012 case Token::ESCAPED_STRICT_RESERVED_WORD:\012 case Token::ESCAPED_KEYWORD:\012 *message = MessageTemplate::kInvalidEscapedReservedWord;\012 break;\012 case Token::ILLEGAL:\012 if (scanner()-&gt;has_error()) {\012 *message = scanner()-&gt;error();\012 *location = scanner()-&gt;error_location();\012 } else {\012 *message = MessageTemplate::kInvalidOrUnexpectedToken;\012 }\012 break;\012 case Token::REGEXP_LITERAL:\012 *message = MessageTemplate::kUnexpectedTokenRegExp;\012 break;\012 default:\012 const char* name = Token::String(token);\012      DCHECK_NOT_NULL(name);\012 *arg = name;\012 break;\012 }\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::ReportUnexpectedToken(Token::Value token) {\012 return ReportUnexpectedTokenAt(scanner_-&gt;location(), token);\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::ReportUnexpectedTokenAt(\012 Scanner::Location source_location, Token::Value token,\012 MessageTemplate::Template message) {\012 const char* arg;\012 GetUnexpectedTokenMessage(token, &amp;message, &amp;source_location, &amp;arg);\012  impl()-&gt;ReportMessageAt(source_location, message, arg);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::IdentifierT ParserBase&lt;Impl&gt;::ParseIdentifier(\012 AllowRestrictedIdentifiers allow_restricted_identifiers, bool* ok) {\012 ExpressionClassifier classifier(this);\012 auto result = ParseAndClassifyIdentifier(CHECK_OK_CUSTOM(NullIdentifier));\012\012 if (allow_restricted_identifiers == kDontAllowRestrictedIdentifiers) {\012 ValidateAssignmentPattern(CHECK_OK_CUSTOM(NullIdentifier));\012 ValidateBindingPattern(CHECK_OK_CUSTOM(NullIdentifier));\012 }\012\012 return result;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::IdentifierT\012ParserBase&lt;Impl&gt;::ParseAndClassifyIdentifier(bool* ok) {\012 Token::Value next = Next();\012 if (next == Token::IDENTIFIER || next == Token::ASYNC ||\012 (next == Token::AWAIT &amp;&amp; !parsing_module_ &amp;&amp; !is_async_function())) {\012 IdentifierT name = impl()-&gt;GetSymbol();\012\012 if (impl()-&gt;IsArguments(name) &amp;&amp; scope()-&gt;ShouldBanArguments()) {\012 ReportMessage(MessageTemplate::kArgumentsDisallowedInInitializer);\012 *ok = false;\012 return impl()-&gt;NullIdentifier();\012 }\012\012 // When this function is used to read a formal parameter, we don't always\012 // know whether the function is going to be strict or sloppy.  Indeed for\012 // arrow functions we don't always know that the identifier we are reading\012 // is actually a formal parameter.  Therefore besides the errors that we\012 // must detect because we know we're in strict mode, we also record any\012 // error that we might make in the future once we know the language mode.\012 if (impl()-&gt;IsEvalOrArguments(name)) {\012      classifier()-&gt;RecordStrictModeFormalParameterError(\012          scanner()-&gt;location(), MessageTemplate::kStrictEvalArguments);\012 if (is_strict(language_mode())) {\012        classifier()-&gt;RecordBindingPatternError(\012            scanner()-&gt;location(), MessageTemplate::kStrictEvalArguments);\012 }\012 } else if (next == Token::AWAIT) {\012      classifier()-&gt;RecordAsyncArrowFormalParametersError(\012          scanner()-&gt;location(), MessageTemplate::kAwaitBindingIdentifier);\012 }\012\012 if (classifier()-&gt;duplicate_finder() != nullptr &amp;&amp;\012        scanner()-&gt;IsDuplicateSymbol(classifier()-&gt;duplicate_finder(),\012                                     ast_value_factory())) {\012      classifier()-&gt;RecordDuplicateFormalParameterError(scanner()-&gt;location());\012 }\012 return name;\012 } else if (is_sloppy(language_mode()) &amp;&amp;\012 (next == Token::FUTURE_STRICT_RESERVED_WORD ||\012 next == Token::ESCAPED_STRICT_RESERVED_WORD ||\012 next == Token::LET || next == Token::STATIC ||\012 (next == Token::YIELD &amp;&amp; !is_generator()))) {\012    classifier()-&gt;RecordStrictModeFormalParameterError(\012        scanner()-&gt;location(), MessageTemplate::kUnexpectedStrictReserved);\012 if (next == Token::ESCAPED_STRICT_RESERVED_WORD &amp;&amp;\012        is_strict(language_mode())) {\012 ReportUnexpectedToken(next);\012 *ok = false;\012 return impl()-&gt;NullIdentifier();\012 }\012 if (scanner()-&gt;IsLet()) {\012      classifier()-&gt;RecordLetPatternError(\012          scanner()-&gt;location(), MessageTemplate::kLetInLexicalBinding);\012 }\012 return impl()-&gt;GetSymbol();\012 } else {\012 ReportUnexpectedToken(next);\012 *ok = false;\012 return impl()-&gt;NullIdentifier();\012 }\012}\012\012template &lt;class Impl&gt;\012typename ParserBase&lt;Impl&gt;::IdentifierT\012ParserBase&lt;Impl&gt;::ParseIdentifierOrStrictReservedWord(\012 FunctionKind function_kind, bool* is_strict_reserved, bool* is_await,\012 bool* ok) {\012 Token::Value next = Next();\012 if (next == Token::IDENTIFIER || (next == Token::AWAIT &amp;&amp; !parsing_module_ &amp;&amp;\012 !IsAsyncFunction(function_kind)) ||\012 next == Token::ASYNC) {\012 *is_strict_reserved = false;\012 *is_await = next == Token::AWAIT;\012 } else if (next == Token::ESCAPED_STRICT_RESERVED_WORD ||\012 next == Token::FUTURE_STRICT_RESERVED_WORD || next == Token::LET ||\012 next == Token::STATIC ||\012 (next == Token::YIELD &amp;&amp; !IsGeneratorFunction(function_kind))) {\012 *is_strict_reserved = true;\012 } else {\012 ReportUnexpectedToken(next);\012 *ok = false;\012 return impl()-&gt;NullIdentifier();\012 }\012\012 return impl()-&gt;GetSymbol();\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::IdentifierT ParserBase&lt;Impl&gt;::ParseIdentifierName(\012 bool* ok) {\012 Token::Value next = Next();\012 if (next != Token::IDENTIFIER &amp;&amp; next != Token::ASYNC &amp;&amp;\012 next != Token::ENUM &amp;&amp; next != Token::AWAIT &amp;&amp; next != Token::LET &amp;&amp;\012 next != Token::STATIC &amp;&amp; next != Token::YIELD &amp;&amp;\012 next != Token::FUTURE_STRICT_RESERVED_WORD &amp;&amp;\012 next != Token::ESCAPED_KEYWORD &amp;&amp;\012 next != Token::ESCAPED_STRICT_RESERVED_WORD &amp;&amp; !Token::IsKeyword(next)) {\012 ReportUnexpectedToken(next);\012 *ok = false;\012 return impl()-&gt;NullIdentifier();\012 }\012\012 return impl()-&gt;GetSymbol();\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT\012ParserBase&lt;Impl&gt;::ParseIdentifierNameOrPrivateName(bool* ok) {\012 int pos = position();\012 IdentifierT name;\012 ExpressionT key;\012 if (allow_harmony_private_fields() &amp;&amp; peek() == Token::PRIVATE_NAME) {\012 Consume(Token::PRIVATE_NAME);\012    name = impl()-&gt;GetSymbol();\012 auto key_proxy =\012        impl()-&gt;ExpressionFromIdentifier(name, pos, InferName::kNo);\012    key_proxy-&gt;set_is_private_field();\012    key = key_proxy;\012 } else {\012    name = ParseIdentifierName(CHECK_OK);\012    key = factory()-&gt;NewStringLiteral(name, pos);\012 }\012  impl()-&gt;PushLiteralName(name);\012 return key;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParseRegExpLiteral(\012 bool* ok) {\012 int pos = peek_position();\012 if (!scanner()-&gt;ScanRegExpPattern()) {\012 Next();\012 ReportMessage(MessageTemplate::kUnterminatedRegExp);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012\012 IdentifierT js_pattern = impl()-&gt;GetNextSymbol();\012 Maybe&lt;RegExp::Flags&gt; flags = scanner()-&gt;ScanRegExpFlags();\012 if (flags.IsNothing()) {\012 Next();\012 ReportMessage(MessageTemplate::kMalformedRegExpFlags);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012 int js_flags = flags.FromJust();\012 Next();\012 return factory()-&gt;NewRegExpLiteral(js_pattern, js_flags, pos);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParsePrimaryExpression(\012 bool* is_async, bool* ok) {\012 // PrimaryExpression ::\012 //   'this'\012 //   'null'\012 //   'true'\012 //   'false'\012 //   Identifier\012 //   Number\012 //   String\012 //   ArrayLiteral\012 //   ObjectLiteral\012 //   RegExpLiteral\012 //   ClassLiteral\012 //   '(' Expression ')'\012 //   TemplateLiteral\012 //   do Block\012 //   AsyncFunctionLiteral\012\012 int beg_pos = peek_position();\012 switch (peek()) {\012 case Token::THIS: {\012 BindingPatternUnexpectedToken();\012 Consume(Token::THIS);\012 return impl()-&gt;ThisExpression(beg_pos);\012 }\012\012 case Token::NULL_LITERAL:\012 case Token::TRUE_LITERAL:\012 case Token::FALSE_LITERAL:\012 case Token::SMI:\012 case Token::NUMBER:\012 case Token::BIGINT:\012 BindingPatternUnexpectedToken();\012 return impl()-&gt;ExpressionFromLiteral(Next(), beg_pos);\012\012 case Token::ASYNC:\012 if (!scanner()-&gt;HasLineTerminatorAfterNext() &amp;&amp;\012 PeekAhead() == Token::FUNCTION) {\012 BindingPatternUnexpectedToken();\012 Consume(Token::ASYNC);\012 return ParseAsyncFunctionLiteral(CHECK_OK);\012 }\012 // CoverCallExpressionAndAsyncArrowHead\012 *is_async = true;\012      V8_FALLTHROUGH;\012 case Token::IDENTIFIER:\012 case Token::LET:\012 case Token::STATIC:\012 case Token::YIELD:\012 case Token::AWAIT:\012 case Token::ESCAPED_STRICT_RESERVED_WORD:\012 case Token::FUTURE_STRICT_RESERVED_WORD: {\012 // Using eval or arguments in this context is OK even in strict mode.\012 IdentifierT name = ParseAndClassifyIdentifier(CHECK_OK);\012 return impl()-&gt;ExpressionFromIdentifier(name, beg_pos);\012 }\012\012 case Token::STRING: {\012 BindingPatternUnexpectedToken();\012 Consume(Token::STRING);\012 return impl()-&gt;ExpressionFromString(beg_pos);\012 }\012\012 case Token::ASSIGN_DIV:\012 case Token::DIV:\012      classifier()-&gt;RecordBindingPatternError(\012          scanner()-&gt;peek_location(), MessageTemplate::kUnexpectedTokenRegExp);\012 return ParseRegExpLiteral(ok);\012\012 case Token::LBRACK:\012 return ParseArrayLiteral(ok);\012\012 case Token::LBRACE:\012 return ParseObjectLiteral(ok);\012\012 case Token::LPAREN: {\012 // Arrow function formal parameters are either a single identifier or a\012 // list of BindingPattern productions enclosed in parentheses.\012 // Parentheses are not valid on the LHS of a BindingPattern, so we use the\012 // is_valid_binding_pattern() check to detect multiple levels of\012 // parenthesization.\012 bool pattern_error = !classifier()-&gt;is_valid_binding_pattern();\012      classifier()-&gt;RecordPatternError(scanner()-&gt;peek_location(),\012 MessageTemplate::kUnexpectedToken,\012 Token::String(Token::LPAREN));\012 if (pattern_error) ArrowFormalParametersUnexpectedToken();\012 Consume(Token::LPAREN);\012 if (Check(Token::RPAREN)) {\012 // ()=&gt;x.  The continuation that looks for the =&gt; is in\012 // ParseAssignmentExpression.\012        classifier()-&gt;RecordExpressionError(scanner()-&gt;location(),\012 MessageTemplate::kUnexpectedToken,\012 Token::String(Token::RPAREN));\012 return factory()-&gt;NewEmptyParentheses(beg_pos);\012 }\012 // Heuristically try to detect immediately called functions before\012 // seeing the call parentheses.\012 if (peek() == Token::FUNCTION ||\012 (peek() == Token::ASYNC &amp;&amp; PeekAhead() == Token::FUNCTION)) {\012        function_state_-&gt;set_next_function_is_likely_called();\012 }\012 ExpressionT expr = ParseExpressionCoverGrammar(true, CHECK_OK);\012 Expect(Token::RPAREN, CHECK_OK);\012 return expr;\012 }\012\012 case Token::CLASS: {\012 BindingPatternUnexpectedToken();\012 Consume(Token::CLASS);\012 int class_token_pos = position();\012 IdentifierT name = impl()-&gt;NullIdentifier();\012 bool is_strict_reserved_name = false;\012 Scanner::Location class_name_location = Scanner::Location::invalid();\012 if (peek_any_identifier()) {\012 bool is_await = false;\012        name = ParseIdentifierOrStrictReservedWord(&amp;is_strict_reserved_name,\012 &amp;is_await, CHECK_OK);\012        class_name_location = scanner()-&gt;location();\012 if (is_await) {\012          classifier()-&gt;RecordAsyncArrowFormalParametersError(\012              scanner()-&gt;location(), MessageTemplate::kAwaitBindingIdentifier);\012 }\012 }\012 return ParseClassLiteral(name, class_name_location,\012                               is_strict_reserved_name, class_token_pos, ok);\012 }\012\012 case Token::TEMPLATE_SPAN:\012 case Token::TEMPLATE_TAIL:\012 BindingPatternUnexpectedToken();\012 return ParseTemplateLiteral(impl()-&gt;NullExpression(), beg_pos, false, ok);\012\012 case Token::MOD:\012 if (allow_natives() || extension_ != nullptr) {\012 BindingPatternUnexpectedToken();\012 return ParseV8Intrinsic(ok);\012 }\012 break;\012\012 case Token::DO:\012 if (allow_harmony_do_expressions()) {\012 BindingPatternUnexpectedToken();\012 return ParseDoExpression(ok);\012 }\012 break;\012\012 default:\012 break;\012 }\012\012 ReportUnexpectedToken(Next());\012 *ok = false;\012 return impl()-&gt;NullExpression();\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParseExpression(\012 bool accept_IN, bool* ok) {\012 ExpressionClassifier classifier(this);\012 ExpressionT result = ParseExpressionCoverGrammar(accept_IN, CHECK_OK);\012 ValidateExpression(CHECK_OK);\012 return result;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT\012ParserBase&lt;Impl&gt;::ParseExpressionCoverGrammar(bool accept_IN, bool* ok) {\012 // Expression ::\012 //   AssignmentExpression\012 //   Expression ',' AssignmentExpression\012\012 ExpressionT result = impl()-&gt;NullExpression();\012 while (true) {\012 int comma_pos = position();\012 ExpressionClassifier binding_classifier(this);\012 ExpressionT right;\012 if (Check(Token::ELLIPSIS)) {\012 // 'x, y, ...z' in CoverParenthesizedExpressionAndArrowParameterList only\012 // as the formal parameters of'(x, y, ...z) =&gt; foo', and is not itself a\012 // valid expression.\012      classifier()-&gt;RecordExpressionError(scanner()-&gt;location(),\012 MessageTemplate::kUnexpectedToken,\012 Token::String(Token::ELLIPSIS));\012 int ellipsis_pos = position();\012 int pattern_pos = peek_position();\012 ExpressionT pattern = ParsePrimaryExpression(CHECK_OK);\012 if (peek() == Token::ASSIGN) {\012 ReportMessage(MessageTemplate::kRestDefaultInitializer);\012 *ok = false;\012 return result;\012 }\012 ValidateBindingPattern(CHECK_OK);\012      right = factory()-&gt;NewSpread(pattern, ellipsis_pos, pattern_pos);\012 } else {\012      right = ParseAssignmentExpression(accept_IN, CHECK_OK);\012 }\012 // No need to accumulate binding pattern-related errors, since\012 // an Expression can't be a binding pattern anyway.\012 AccumulateNonBindingPatternErrors();\012 if (!impl()-&gt;IsIdentifier(right)) classifier()-&gt;RecordNonSimpleParameter();\012 if (impl()-&gt;IsNull(result)) {\012 // First time through the loop.\012      result = right;\012 } else if (impl()-&gt;CollapseNaryExpression(&amp;result, right, Token::COMMA,\012                                              comma_pos,\012 SourceRange::Empty())) {\012 // Do nothing, &quot;result&quot; is already updated.\012 } else {\012      result =\012          factory()-&gt;NewBinaryOperation(Token::COMMA, result, right, comma_pos);\012 }\012\012 if (!Check(Token::COMMA)) break;\012\012 if (right-&gt;IsSpread()) {\012      classifier()-&gt;RecordArrowFormalParametersError(\012          scanner()-&gt;location(), MessageTemplate::kParamAfterRest);\012 }\012\012 if (peek() == Token::RPAREN &amp;&amp; PeekAhead() == Token::ARROW) {\012 // a trailing comma is allowed at the end of an arrow parameter list\012 break;\012 }\012\012 // Pass on the 'set_next_function_is_likely_called' flag if we have\012 // several function literals separated by comma.\012 if (peek() == Token::FUNCTION &amp;&amp;\012        function_state_-&gt;previous_function_was_likely_called()) {\012      function_state_-&gt;set_next_function_is_likely_called();\012 }\012 }\012\012 return result;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParseArrayLiteral(\012 bool* ok) {\012 // ArrayLiteral ::\012 //   '[' Expression? (',' Expression?)* ']'\012\012 int pos = peek_position();\012 ExpressionListT values = impl()-&gt;NewExpressionList(4);\012 int first_spread_index = -1;\012 Expect(Token::LBRACK, CHECK_OK);\012 while (peek() != Token::RBRACK) {\012 ExpressionT elem;\012 if (peek() == Token::COMMA) {\012      elem = factory()-&gt;NewTheHoleLiteral();\012 } else if (peek() == Token::ELLIPSIS) {\012 int start_pos = peek_position();\012 Consume(Token::ELLIPSIS);\012 int expr_pos = peek_position();\012 ExpressionT argument = ParseAssignmentExpression(true, CHECK_OK);\012      elem = factory()-&gt;NewSpread(argument, start_pos, expr_pos);\012\012 if (first_spread_index &lt; 0) {\012        first_spread_index = values-&gt;length();\012 }\012\012 if (argument-&gt;IsAssignment()) {\012        classifier()-&gt;RecordPatternError(\012 Scanner::Location(start_pos, scanner()-&gt;location().end_pos),\012 MessageTemplate::kInvalidDestructuringTarget);\012 } else {\012 CheckDestructuringElement(argument, start_pos,\012                                  scanner()-&gt;location().end_pos);\012 }\012\012 if (peek() == Token::COMMA) {\012        classifier()-&gt;RecordPatternError(\012 Scanner::Location(start_pos, scanner()-&gt;location().end_pos),\012 MessageTemplate::kElementAfterRest);\012 }\012 } else {\012 int beg_pos = peek_position();\012      elem = ParseAssignmentExpression(true, CHECK_OK);\012 CheckDestructuringElement(elem, beg_pos, scanner()-&gt;location().end_pos);\012 }\012    values-&gt;Add(elem, zone_);\012 if (peek() != Token::RBRACK) {\012 Expect(Token::COMMA, CHECK_OK);\012 }\012 }\012 Expect(Token::RBRACK, CHECK_OK);\012\012 return factory()-&gt;NewArrayLiteral(values, first_spread_index, pos);\012}\012\012template &lt;class Impl&gt;\012bool ParserBase&lt;Impl&gt;::SetPropertyKindFromToken(Token::Value token,\012 PropertyKind* kind) {\012 // This returns true, setting the property kind, iff the given token is one\012 // which must occur after a property name, indicating that the previous token\012 // was in fact a name and not a modifier (like the &quot;get&quot; in &quot;get x&quot;).\012 switch (token) {\012 case Token::COLON:\012 *kind = PropertyKind::kValueProperty;\012 return true;\012 case Token::COMMA:\012 case Token::RBRACE:\012 case Token::ASSIGN:\012 *kind = PropertyKind::kShorthandProperty;\012 return true;\012 case Token::LPAREN:\012 *kind = PropertyKind::kMethodProperty;\012 return true;\012 case Token::MUL:\012 case Token::SEMICOLON:\012 *kind = PropertyKind::kClassField;\012 return true;\012 case Token::PRIVATE_NAME:\012 *kind = PropertyKind::kClassField;\012 return true;\012 default:\012 break;\012 }\012 return false;\012}\012\012template &lt;class Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParsePropertyName(\012 IdentifierT* name, PropertyKind* kind, bool* is_generator, bool* is_get,\012 bool* is_set, bool* is_async, bool* is_computed_name, bool* ok) {\012  DCHECK_EQ(*kind, PropertyKind::kNotSet);\012  DCHECK(!*is_generator);\012  DCHECK(!*is_get);\012  DCHECK(!*is_set);\012  DCHECK(!*is_async);\012  DCHECK(!*is_computed_name);\012\012 *is_generator = Check(Token::MUL);\012 if (*is_generator) {\012 *kind = PropertyKind::kMethodProperty;\012 }\012\012 Token::Value token = peek();\012 int pos = peek_position();\012\012 if (!*is_generator &amp;&amp; token == Token::ASYNC &amp;&amp;\012 !scanner()-&gt;HasLineTerminatorAfterNext()) {\012 Consume(Token::ASYNC);\012    token = peek();\012 if (token == Token::MUL &amp;&amp; !scanner()-&gt;HasLineTerminatorBeforeNext()) {\012 Consume(Token::MUL);\012      token = peek();\012 *is_generator = true;\012 } else if (SetPropertyKindFromToken(token, kind)) {\012 *name = impl()-&gt;GetSymbol(); // TODO(bakkot) specialize on 'async'\012      impl()-&gt;PushLiteralName(*name);\012 return factory()-&gt;NewStringLiteral(*name, pos);\012 }\012 *kind = PropertyKind::kMethodProperty;\012 *is_async = true;\012    pos = peek_position();\012 }\012\012 if (token == Token::IDENTIFIER &amp;&amp; !*is_generator &amp;&amp; !*is_async) {\012 // This is checking for 'get' and 'set' in particular.\012 Consume(Token::IDENTIFIER);\012    token = peek();\012 if (SetPropertyKindFromToken(token, kind) ||\012 !scanner()-&gt;IsGetOrSet(is_get, is_set)) {\012 *name = impl()-&gt;GetSymbol();\012      impl()-&gt;PushLiteralName(*name);\012 return factory()-&gt;NewStringLiteral(*name, pos);\012 }\012 *kind = PropertyKind::kAccessorProperty;\012    pos = peek_position();\012 }\012\012 // For non computed property names we normalize the name a bit:\012 //\012 //   &quot;12&quot; -&gt; 12\012 //   12.3 -&gt; &quot;12.3&quot;\012 //   12.30 -&gt; &quot;12.3&quot;\012 //   identifier -&gt; &quot;identifier&quot;\012 //\012 // This is important because we use the property name as a key in a hash\012 // table when we compute constant properties.\012 ExpressionT expression = impl()-&gt;NullExpression();\012 switch (token) {\012 case Token::STRING:\012 Consume(Token::STRING);\012 *name = impl()-&gt;GetSymbol();\012 break;\012\012 case Token::SMI:\012 Consume(Token::SMI);\012 *name = impl()-&gt;GetNumberAsSymbol();\012 break;\012\012 case Token::NUMBER:\012 Consume(Token::NUMBER);\012 *name = impl()-&gt;GetNumberAsSymbol();\012 break;\012\012 case Token::LBRACK: {\012 *name = impl()-&gt;NullIdentifier();\012 *is_computed_name = true;\012 Consume(Token::LBRACK);\012 ExpressionClassifier computed_name_classifier(this);\012      expression = ParseAssignmentExpression(true, CHECK_OK);\012 ValidateExpression(CHECK_OK);\012 AccumulateFormalParameterContainmentErrors();\012 Expect(Token::RBRACK, CHECK_OK);\012 break;\012 }\012\012 case Token::ELLIPSIS:\012 if (!*is_generator &amp;&amp; !*is_async &amp;&amp; !*is_get &amp;&amp; !*is_set) {\012 *name = impl()-&gt;NullIdentifier();\012 Consume(Token::ELLIPSIS);\012        expression = ParseAssignmentExpression(true, CHECK_OK);\012 *kind = PropertyKind::kSpreadProperty;\012\012 if (!impl()-&gt;IsIdentifier(expression)) {\012          classifier()-&gt;RecordBindingPatternError(\012              scanner()-&gt;location(),\012 MessageTemplate::kInvalidRestBindingPattern);\012 }\012\012 if (!expression-&gt;IsValidReferenceExpression()) {\012          classifier()-&gt;RecordAssignmentPatternError(\012              scanner()-&gt;location(),\012 MessageTemplate::kInvalidRestAssignmentPattern);\012 }\012\012 if (peek() != Token::RBRACE) {\012          classifier()-&gt;RecordPatternError(scanner()-&gt;location(),\012 MessageTemplate::kElementAfterRest);\012 }\012 return expression;\012 }\012      V8_FALLTHROUGH;\012\012 default:\012 *name = ParseIdentifierName(CHECK_OK);\012 break;\012 }\012\012 if (*kind == PropertyKind::kNotSet) {\012 SetPropertyKindFromToken(peek(), kind);\012 }\012\012 if (*is_computed_name) {\012 return expression;\012 }\012\012  impl()-&gt;PushLiteralName(*name);\012\012 uint32_t index;\012 return impl()-&gt;IsArrayIndex(*name, &amp;index)\012 ? factory()-&gt;NewNumberLiteral(index, pos)\012 : factory()-&gt;NewStringLiteral(*name, pos);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ClassLiteralPropertyT\012ParserBase&lt;Impl&gt;::ParseClassPropertyDefinition(\012 ClassLiteralChecker* checker, ClassInfo* class_info, IdentifierT* name,\012 bool has_extends, bool* is_computed_name,\012 ClassLiteralProperty::Kind* property_kind, bool* is_static, bool* ok) {\012  DCHECK_NOT_NULL(class_info);\012 bool is_get = false;\012 bool is_set = false;\012 bool is_generator = false;\012 bool is_async = false;\012 *is_static = false;\012 *property_kind = ClassLiteralProperty::METHOD;\012 PropertyKind kind = PropertyKind::kNotSet;\012\012 Token::Value name_token = peek();\012  DCHECK_IMPLIES(name_token == Token::PRIVATE_NAME,\012                 allow_harmony_private_fields());\012\012 int name_token_position = scanner()-&gt;peek_location().beg_pos;\012 *name = impl()-&gt;NullIdentifier();\012 ExpressionT name_expression;\012 if (name_token == Token::STATIC) {\012 Consume(Token::STATIC);\012    name_token_position = scanner()-&gt;peek_location().beg_pos;\012 if (peek() == Token::LPAREN) {\012      kind = PropertyKind::kMethodProperty;\012 *name = impl()-&gt;GetSymbol(); // TODO(bakkot) specialize on 'static'\012      name_expression = factory()-&gt;NewStringLiteral(*name, position());\012 } else if (peek() == Token::ASSIGN || peek() == Token::SEMICOLON ||\012               peek() == Token::RBRACE) {\012 *name = impl()-&gt;GetSymbol(); // TODO(bakkot) specialize on 'static'\012      name_expression = factory()-&gt;NewStringLiteral(*name, position());\012 } else if (peek() == Token::PRIVATE_NAME) {\012      DCHECK(allow_harmony_private_fields());\012 // TODO(gsathya): Make a better error message for this.\012 ReportUnexpectedToken(Next());\012 *ok = false;\012 return impl()-&gt;NullLiteralProperty();\012 } else {\012 *is_static = true;\012      name_expression = ParsePropertyName(name, &amp;kind, &amp;is_generator, &amp;is_get,\012 &amp;is_set, &amp;is_async, is_computed_name,\012                                          CHECK_OK_CUSTOM(NullLiteralProperty));\012 }\012 } else if (name_token == Token::PRIVATE_NAME) {\012 Consume(Token::PRIVATE_NAME);\012 *name = impl()-&gt;GetSymbol();\012    name_expression = factory()-&gt;NewStringLiteral(*name, position());\012 } else {\012    name_expression = ParsePropertyName(name, &amp;kind, &amp;is_generator, &amp;is_get,\012 &amp;is_set, &amp;is_async, is_computed_name,\012                                        CHECK_OK_CUSTOM(NullLiteralProperty));\012 }\012\012 if (!class_info-&gt;has_name_static_property &amp;&amp; *is_static &amp;&amp;\012      impl()-&gt;IsName(*name)) {\012    class_info-&gt;has_name_static_property = true;\012 }\012\012 switch (kind) {\012 case PropertyKind::kClassField:\012 case PropertyKind::kNotSet: // This case is a name followed by a name or\012 // other property. Here we have to assume\012 // that's an uninitialized field followed by a\012 // linebreak followed by a property, with ASI\012 // adding the semicolon. If not, there will be\012 // a syntax error after parsing the first name\012 // as an uninitialized field.\012 case PropertyKind::kShorthandProperty:\012 case PropertyKind::kValueProperty:\012 if (allow_harmony_public_fields() || allow_harmony_private_fields()) {\012 *property_kind = name_token == Token::PRIVATE_NAME\012 ? ClassLiteralProperty::PRIVATE_FIELD\012 : ClassLiteralProperty::PUBLIC_FIELD;\012 if (*is_static &amp;&amp; !allow_harmony_static_fields()) {\012 ReportUnexpectedToken(Next());\012 *ok = false;\012 return impl()-&gt;NullLiteralProperty();\012 }\012 if (!*is_computed_name) {\012          checker-&gt;CheckClassFieldName(*is_static,\012                                       CHECK_OK_CUSTOM(NullLiteralProperty));\012 }\012 ExpressionT initializer = ParseClassFieldInitializer(\012            class_info, *is_static, CHECK_OK_CUSTOM(NullLiteralProperty));\012 ExpectSemicolon(CHECK_OK_CUSTOM(NullLiteralProperty));\012 ClassLiteralPropertyT result = factory()-&gt;NewClassLiteralProperty(\012            name_expression, initializer, *property_kind, *is_static,\012 *is_computed_name);\012        impl()-&gt;SetFunctionNameFromPropertyName(result, *name);\012 return result;\012\012 } else {\012 ReportUnexpectedToken(Next());\012 *ok = false;\012 return impl()-&gt;NullLiteralProperty();\012 }\012\012 case PropertyKind::kMethodProperty: {\012      DCHECK(!is_get &amp;&amp; !is_set);\012\012 // MethodDefinition\012 //    PropertyName '(' StrictFormalParameters ')' '{' FunctionBody '}'\012 //    '*' PropertyName '(' StrictFormalParameters ')' '{' FunctionBody '}'\012 //    async PropertyName '(' StrictFormalParameters ')'\012 //        '{' FunctionBody '}'\012 //    async '*' PropertyName '(' StrictFormalParameters ')'\012 //        '{' FunctionBody '}'\012\012 if (!*is_computed_name) {\012        checker-&gt;CheckClassMethodName(name_token, PropertyKind::kMethodProperty,\012                                      is_generator, is_async, *is_static,\012                                      CHECK_OK_CUSTOM(NullLiteralProperty));\012 }\012\012 FunctionKind kind = MethodKindFor(is_generator, is_async);\012\012 if (!*is_static &amp;&amp; impl()-&gt;IsConstructor(*name)) {\012        class_info-&gt;has_seen_constructor = true;\012        kind = has_extends ? FunctionKind::kDerivedConstructor\012 : FunctionKind::kBaseConstructor;\012 }\012\012 ExpressionT value = impl()-&gt;ParseFunctionLiteral(\012 *name, scanner()-&gt;location(), kSkipFunctionNameCheck, kind,\012          FLAG_harmony_function_tostring ? name_token_position\012 : kNoSourcePosition,\012 FunctionLiteral::kAccessorOrMethod, language_mode(), nullptr,\012          CHECK_OK_CUSTOM(NullLiteralProperty));\012\012 *property_kind = ClassLiteralProperty::METHOD;\012 ClassLiteralPropertyT result = factory()-&gt;NewClassLiteralProperty(\012          name_expression, value, *property_kind, *is_static,\012 *is_computed_name);\012      impl()-&gt;SetFunctionNameFromPropertyName(result, *name);\012 return result;\012 }\012\012 case PropertyKind::kAccessorProperty: {\012      DCHECK((is_get || is_set) &amp;&amp; !is_generator &amp;&amp; !is_async);\012\012 if (!*is_computed_name) {\012        checker-&gt;CheckClassMethodName(\012            name_token, PropertyKind::kAccessorProperty, false, false,\012 *is_static, CHECK_OK_CUSTOM(NullLiteralProperty));\012 // Make sure the name expression is a string since we need a Name for\012 // Runtime_DefineAccessorPropertyUnchecked and since we can determine\012 // this statically we can skip the extra runtime check.\012        name_expression =\012            factory()-&gt;NewStringLiteral(*name, name_expression-&gt;position());\012 }\012\012 FunctionKind kind = is_get ? FunctionKind::kGetterFunction\012 : FunctionKind::kSetterFunction;\012\012 FunctionLiteralT value = impl()-&gt;ParseFunctionLiteral(\012 *name, scanner()-&gt;location(), kSkipFunctionNameCheck, kind,\012          FLAG_harmony_function_tostring ? name_token_position\012 : kNoSourcePosition,\012 FunctionLiteral::kAccessorOrMethod, language_mode(), nullptr,\012          CHECK_OK_CUSTOM(NullLiteralProperty));\012\012 *property_kind =\012          is_get ? ClassLiteralProperty::GETTER : ClassLiteralProperty::SETTER;\012 ClassLiteralPropertyT result = factory()-&gt;NewClassLiteralProperty(\012          name_expression, value, *property_kind, *is_static,\012 *is_computed_name);\012 const AstRawString* prefix =\012          is_get ? ast_value_factory()-&gt;get_space_string()\012 : ast_value_factory()-&gt;set_space_string();\012      impl()-&gt;SetFunctionNameFromPropertyName(result, *name, prefix);\012 return result;\012 }\012 case PropertyKind::kSpreadProperty:\012 ReportUnexpectedTokenAt(\012 Scanner::Location(name_token_position, name_expression-&gt;position()),\012          name_token);\012 *ok = false;\012 return impl()-&gt;NullLiteralProperty();\012 }\012  UNREACHABLE();\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT\012ParserBase&lt;Impl&gt;::ParseClassFieldInitializer(ClassInfo* class_info,\012 bool is_static, bool* ok) {\012 DeclarationScope* initializer_scope = is_static\012 ? class_info-&gt;static_fields_scope\012 : class_info-&gt;instance_fields_scope;\012\012 if (initializer_scope == nullptr) {\012    initializer_scope =\012 NewFunctionScope(FunctionKind::kClassFieldsInitializerFunction);\012 // TODO(gsathya): Make scopes be non contiguous.\012    initializer_scope-&gt;set_start_position(scanner()-&gt;location().end_pos);\012    initializer_scope-&gt;SetLanguageMode(LanguageMode::kStrict);\012 }\012\012 ExpressionT initializer;\012 if (Check(Token::ASSIGN)) {\012 FunctionState initializer_state(&amp;function_state_, &amp;scope_,\012                                    initializer_scope);\012 ExpressionClassifier expression_classifier(this);\012\012    initializer =\012 ParseAssignmentExpression(true, CHECK_OK_CUSTOM(NullExpression));\012 ValidateExpression(CHECK_OK_CUSTOM(NullExpression));\012 } else {\012    initializer = factory()-&gt;NewUndefinedLiteral(kNoSourcePosition);\012 }\012\012  initializer_scope-&gt;set_end_position(scanner()-&gt;location().end_pos);\012 if (is_static) {\012    class_info-&gt;static_fields_scope = initializer_scope;\012    class_info-&gt;has_static_class_fields = true;\012 } else {\012    class_info-&gt;instance_fields_scope = initializer_scope;\012    class_info-&gt;has_instance_class_fields = true;\012 }\012\012 return initializer;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ObjectLiteralPropertyT\012ParserBase&lt;Impl&gt;::ParseObjectPropertyDefinition(ObjectLiteralChecker* checker,\012 bool* is_computed_name,\012 bool* is_rest_property,\012 bool* ok) {\012 bool is_get = false;\012 bool is_set = false;\012 bool is_generator = false;\012 bool is_async = false;\012 PropertyKind kind = PropertyKind::kNotSet;\012\012 IdentifierT name = impl()-&gt;NullIdentifier();\012 Token::Value name_token = peek();\012 int next_beg_pos = scanner()-&gt;peek_location().beg_pos;\012 int next_end_pos = scanner()-&gt;peek_location().end_pos;\012\012 ExpressionT name_expression = ParsePropertyName(\012 &amp;name, &amp;kind, &amp;is_generator, &amp;is_get, &amp;is_set, &amp;is_async,\012      is_computed_name, CHECK_OK_CUSTOM(NullLiteralProperty));\012\012 switch (kind) {\012 case PropertyKind::kSpreadProperty:\012      DCHECK(!is_get &amp;&amp; !is_set &amp;&amp; !is_generator &amp;&amp; !is_async &amp;&amp;\012 !*is_computed_name);\012      DCHECK(name_token == Token::ELLIPSIS);\012\012 *is_computed_name = true;\012 *is_rest_property = true;\012\012 return factory()-&gt;NewObjectLiteralProperty(\012          factory()-&gt;NewTheHoleLiteral(), name_expression,\012 ObjectLiteralProperty::SPREAD, true);\012\012 case PropertyKind::kValueProperty: {\012      DCHECK(!is_get &amp;&amp; !is_set &amp;&amp; !is_generator &amp;&amp; !is_async);\012\012 if (!*is_computed_name) {\012        checker-&gt;CheckDuplicateProto(name_token);\012 }\012 Consume(Token::COLON);\012 int beg_pos = peek_position();\012 ExpressionT value =\012 ParseAssignmentExpression(true, CHECK_OK_CUSTOM(NullLiteralProperty));\012 CheckDestructuringElement(value, beg_pos, scanner()-&gt;location().end_pos);\012\012 ObjectLiteralPropertyT result = factory()-&gt;NewObjectLiteralProperty(\012          name_expression, value, *is_computed_name);\012      impl()-&gt;SetFunctionNameFromPropertyName(result, name);\012 return result;\012 }\012\012 case PropertyKind::kShorthandProperty: {\012 // PropertyDefinition\012 //    IdentifierReference\012 //    CoverInitializedName\012 //\012 // CoverInitializedName\012 //    IdentifierReference Initializer?\012      DCHECK(!is_get &amp;&amp; !is_set &amp;&amp; !is_generator &amp;&amp; !is_async);\012\012 if (!Token::IsIdentifier(name_token, language_mode(),\012 this-&gt;is_generator(),\012                               parsing_module_ || is_async_function())) {\012 ReportUnexpectedToken(Next());\012 *ok = false;\012 return impl()-&gt;NullLiteralProperty();\012 }\012\012      DCHECK(!*is_computed_name);\012\012 if (classifier()-&gt;duplicate_finder() != nullptr &amp;&amp;\012          scanner()-&gt;IsDuplicateSymbol(classifier()-&gt;duplicate_finder(),\012                                       ast_value_factory())) {\012        classifier()-&gt;RecordDuplicateFormalParameterError(\012            scanner()-&gt;location());\012 }\012\012 if (impl()-&gt;IsEvalOrArguments(name) &amp;&amp; is_strict(language_mode())) {\012        classifier()-&gt;RecordBindingPatternError(\012            scanner()-&gt;location(), MessageTemplate::kStrictEvalArguments);\012 }\012\012 if (name_token == Token::LET) {\012        classifier()-&gt;RecordLetPatternError(\012            scanner()-&gt;location(), MessageTemplate::kLetInLexicalBinding);\012 }\012 if (name_token == Token::AWAIT) {\012        DCHECK(!is_async_function());\012        classifier()-&gt;RecordAsyncArrowFormalParametersError(\012 Scanner::Location(next_beg_pos, next_end_pos),\012 MessageTemplate::kAwaitBindingIdentifier);\012 }\012 ExpressionT lhs = impl()-&gt;ExpressionFromIdentifier(name, next_beg_pos);\012 CheckDestructuringElement(lhs, next_beg_pos, next_end_pos);\012\012 ExpressionT value;\012 if (peek() == Token::ASSIGN) {\012 Consume(Token::ASSIGN);\012 ExpressionClassifier rhs_classifier(this);\012 ExpressionT rhs = ParseAssignmentExpression(\012 true, CHECK_OK_CUSTOM(NullLiteralProperty));\012 ValidateExpression(CHECK_OK_CUSTOM(NullLiteralProperty));\012 AccumulateFormalParameterContainmentErrors();\012        value = factory()-&gt;NewAssignment(Token::ASSIGN, lhs, rhs,\012                                         kNoSourcePosition);\012        classifier()-&gt;RecordExpressionError(\012 Scanner::Location(next_beg_pos, scanner()-&gt;location().end_pos),\012 MessageTemplate::kInvalidCoverInitializedName);\012\012        impl()-&gt;SetFunctionNameFromIdentifierRef(rhs, lhs);\012 } else {\012        value = lhs;\012 }\012\012 ObjectLiteralPropertyT result = factory()-&gt;NewObjectLiteralProperty(\012          name_expression, value, ObjectLiteralProperty::COMPUTED, false);\012      impl()-&gt;SetFunctionNameFromPropertyName(result, name);\012 return result;\012 }\012\012 case PropertyKind::kMethodProperty: {\012      DCHECK(!is_get &amp;&amp; !is_set);\012\012 // MethodDefinition\012 //    PropertyName '(' StrictFormalParameters ')' '{' FunctionBody '}'\012 //    '*' PropertyName '(' StrictFormalParameters ')' '{' FunctionBody '}'\012\012      classifier()-&gt;RecordPatternError(\012 Scanner::Location(next_beg_pos, scanner()-&gt;location().end_pos),\012 MessageTemplate::kInvalidDestructuringTarget);\012\012 FunctionKind kind = MethodKindFor(is_generator, is_async);\012\012 ExpressionT value = impl()-&gt;ParseFunctionLiteral(\012          name, scanner()-&gt;location(), kSkipFunctionNameCheck, kind,\012          FLAG_harmony_function_tostring ? next_beg_pos : kNoSourcePosition,\012 FunctionLiteral::kAccessorOrMethod, language_mode(), nullptr,\012          CHECK_OK_CUSTOM(NullLiteralProperty));\012\012 ObjectLiteralPropertyT result = factory()-&gt;NewObjectLiteralProperty(\012          name_expression, value, ObjectLiteralProperty::COMPUTED,\012 *is_computed_name);\012      impl()-&gt;SetFunctionNameFromPropertyName(result, name);\012 return result;\012 }\012\012 case PropertyKind::kAccessorProperty: {\012      DCHECK((is_get || is_set) &amp;&amp; !(is_set &amp;&amp; is_get) &amp;&amp; !is_generator &amp;&amp;\012 !is_async);\012\012      classifier()-&gt;RecordPatternError(\012 Scanner::Location(next_beg_pos, scanner()-&gt;location().end_pos),\012 MessageTemplate::kInvalidDestructuringTarget);\012\012 if (!*is_computed_name) {\012 // Make sure the name expression is a string since we need a Name for\012 // Runtime_DefineAccessorPropertyUnchecked and since we can determine\012 // this statically we can skip the extra runtime check.\012        name_expression =\012            factory()-&gt;NewStringLiteral(name, name_expression-&gt;position());\012 }\012\012 FunctionKind kind = is_get ? FunctionKind::kGetterFunction\012 : FunctionKind::kSetterFunction;\012\012 FunctionLiteralT value = impl()-&gt;ParseFunctionLiteral(\012          name, scanner()-&gt;location(), kSkipFunctionNameCheck, kind,\012          FLAG_harmony_function_tostring ? next_beg_pos : kNoSourcePosition,\012 FunctionLiteral::kAccessorOrMethod, language_mode(), nullptr,\012          CHECK_OK_CUSTOM(NullLiteralProperty));\012\012 ObjectLiteralPropertyT result = factory()-&gt;NewObjectLiteralProperty(\012          name_expression, value,\012          is_get ? ObjectLiteralProperty::GETTER\012 : ObjectLiteralProperty::SETTER,\012 *is_computed_name);\012 const AstRawString* prefix =\012          is_get ? ast_value_factory()-&gt;get_space_string()\012 : ast_value_factory()-&gt;set_space_string();\012      impl()-&gt;SetFunctionNameFromPropertyName(result, name, prefix);\012 return result;\012 }\012\012 case PropertyKind::kClassField:\012 case PropertyKind::kNotSet:\012 ReportUnexpectedToken(Next());\012 *ok = false;\012 return impl()-&gt;NullLiteralProperty();\012 }\012  UNREACHABLE();\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParseObjectLiteral(\012 bool* ok) {\012 // ObjectLiteral ::\012 // '{' (PropertyDefinition (',' PropertyDefinition)* ','? )? '}'\012\012 int pos = peek_position();\012 typename Types::ObjectPropertyList properties =\012      impl()-&gt;NewObjectPropertyList(4);\012 int number_of_boilerplate_properties = 0;\012\012 bool has_computed_names = false;\012 bool has_rest_property = false;\012 ObjectLiteralChecker checker(this);\012\012 Expect(Token::LBRACE, CHECK_OK);\012\012 while (peek() != Token::RBRACE) {\012 FuncNameInferrer::State fni_state(fni_);\012\012 bool is_computed_name = false;\012 bool is_rest_property = false;\012 ObjectLiteralPropertyT property = ParseObjectPropertyDefinition(\012 &amp;checker, &amp;is_computed_name, &amp;is_rest_property, CHECK_OK);\012\012 if (is_computed_name) {\012      has_computed_names = true;\012 }\012\012 if (is_rest_property) {\012      has_rest_property = true;\012 }\012\012 if (impl()-&gt;IsBoilerplateProperty(property) &amp;&amp; !has_computed_names) {\012 // Count CONSTANT or COMPUTED properties to maintain the enumeration\012 // order.\012      number_of_boilerplate_properties++;\012 }\012\012    properties-&gt;Add(property, zone());\012\012 if (peek() != Token::RBRACE) {\012 // Need {} because of the CHECK_OK macro.\012 Expect(Token::COMMA, CHECK_OK);\012 }\012\012 if (fni_ != nullptr) fni_-&gt;Infer();\012 }\012 Expect(Token::RBRACE, CHECK_OK);\012\012 // In pattern rewriter, we rewrite rest property to call out to a\012 // runtime function passing all the other properties as arguments to\012 // this runtime function. Here, we make sure that the number of\012 // properties is less than number of arguments allowed for a runtime\012 // call.\012 if (has_rest_property &amp;&amp; properties-&gt;length() &gt; Code::kMaxArguments) {\012 this-&gt;classifier()-&gt;RecordPatternError(Scanner::Location(pos, position()),\012 MessageTemplate::kTooManyArguments);\012 }\012\012 return impl()-&gt;InitializeObjectLiteral(factory()-&gt;NewObjectLiteral(\012      properties, number_of_boilerplate_properties, pos, has_rest_property));\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionListT ParserBase&lt;Impl&gt;::ParseArguments(\012 Scanner::Location* first_spread_arg_loc, bool maybe_arrow,\012 bool* is_simple_parameter_list, bool* ok) {\012 // Arguments ::\012 //   '(' (AssignmentExpression)*[','] ')'\012\012 Scanner::Location spread_arg = Scanner::Location::invalid();\012 ExpressionListT result = impl()-&gt;NewExpressionList(4);\012 Expect(Token::LPAREN, CHECK_OK_CUSTOM(NullExpressionList));\012 bool done = (peek() == Token::RPAREN);\012 while (!done) {\012 int start_pos = peek_position();\012 bool is_spread = Check(Token::ELLIPSIS);\012 int expr_pos = peek_position();\012\012 ExpressionT argument =\012 ParseAssignmentExpression(true, CHECK_OK_CUSTOM(NullExpressionList));\012 if (!impl()-&gt;IsIdentifier(argument) &amp;&amp;\012        is_simple_parameter_list != nullptr) {\012 *is_simple_parameter_list = false;\012 }\012 if (!maybe_arrow) {\012 ValidateExpression(CHECK_OK_CUSTOM(NullExpressionList));\012 }\012 if (is_spread) {\012 if (is_simple_parameter_list != nullptr) {\012 *is_simple_parameter_list = false;\012 }\012 if (!spread_arg.IsValid()) {\012        spread_arg.beg_pos = start_pos;\012        spread_arg.end_pos = peek_position();\012 }\012 if (argument-&gt;IsAssignment()) {\012        classifier()-&gt;RecordAsyncArrowFormalParametersError(\012            scanner()-&gt;location(), MessageTemplate::kRestDefaultInitializer);\012 }\012      argument = factory()-&gt;NewSpread(argument, start_pos, expr_pos);\012 }\012    result-&gt;Add(argument, zone_);\012\012 if (result-&gt;length() &gt; Code::kMaxArguments) {\012 ReportMessage(MessageTemplate::kTooManyArguments);\012 *ok = false;\012 return impl()-&gt;NullExpressionList();\012 }\012 done = (peek() != Token::COMMA);\012 if (!done) {\012 Next();\012 if (argument-&gt;IsSpread()) {\012        classifier()-&gt;RecordAsyncArrowFormalParametersError(\012            scanner()-&gt;location(), MessageTemplate::kParamAfterRest);\012 }\012 if (peek() == Token::RPAREN) {\012 // allow trailing comma\012 done = true;\012 }\012 }\012 }\012 Scanner::Location location = scanner_-&gt;location();\012 if (Token::RPAREN != Next()) {\012    impl()-&gt;ReportMessageAt(location, MessageTemplate::kUnterminatedArgList);\012 *ok = false;\012 return impl()-&gt;NullExpressionList();\012 }\012 *first_spread_arg_loc = spread_arg;\012\012 if (!maybe_arrow || peek() != Token::ARROW) {\012 if (maybe_arrow) {\012 ValidateExpression(CHECK_OK_CUSTOM(NullExpressionList));\012 }\012 }\012\012 return result;\012}\012\012// Precedence = 2\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT\012ParserBase&lt;Impl&gt;::ParseAssignmentExpression(bool accept_IN, bool* ok) {\012 // AssignmentExpression ::\012 //   ConditionalExpression\012 //   ArrowFunction\012 //   YieldExpression\012 //   LeftHandSideExpression AssignmentOperator AssignmentExpression\012 int lhs_beg_pos = peek_position();\012\012 if (peek() == Token::YIELD &amp;&amp; is_generator()) {\012 return ParseYieldExpression(accept_IN, ok);\012 }\012\012 FuncNameInferrer::State fni_state(fni_);\012 ExpressionClassifier arrow_formals_classifier(\012 this, classifier()-&gt;duplicate_finder());\012\012 Scope::Snapshot scope_snapshot(scope());\012 int rewritable_length = static_cast&lt;int&gt;(\012      function_state_-&gt;destructuring_assignments_to_rewrite().size());\012\012 bool is_async = peek() == Token::ASYNC &amp;&amp;\012 !scanner()-&gt;HasLineTerminatorAfterNext() &amp;&amp;\012 IsValidArrowFormalParametersStart(PeekAhead());\012\012 bool parenthesized_formals = peek() == Token::LPAREN;\012 if (!is_async &amp;&amp; !parenthesized_formals) {\012 ArrowFormalParametersUnexpectedToken();\012 }\012\012 // Parse a simple, faster sub-grammar (primary expression) if it's evident\012 // that we have only a trivial expression to parse.\012 ExpressionT expression;\012 if (IsTrivialExpression()) {\012    expression = ParsePrimaryExpression(&amp;is_async, CHECK_OK);\012 } else {\012    expression = ParseConditionalExpression(accept_IN, CHECK_OK);\012 }\012\012 if (is_async &amp;&amp; impl()-&gt;IsIdentifier(expression) &amp;&amp; peek_any_identifier() &amp;&amp;\012 PeekAhead() == Token::ARROW) {\012 // async Identifier =&gt; AsyncConciseBody\012 IdentifierT name = ParseAndClassifyIdentifier(CHECK_OK);\012    expression =\012        impl()-&gt;ExpressionFromIdentifier(name, position(), InferName::kNo);\012 if (fni_) {\012 // Remove `async` keyword from inferred name stack.\012      fni_-&gt;RemoveAsyncKeywordFromEnd();\012 }\012 }\012\012 if (peek() == Token::ARROW) {\012 Scanner::Location arrow_loc = scanner()-&gt;peek_location();\012 ValidateArrowFormalParameters(expression, parenthesized_formals, is_async,\012                                  CHECK_OK);\012 // This reads strangely, but is correct: it checks whether any\012 // sub-expression of the parameter list failed to be a valid formal\012 // parameter initializer. Since YieldExpressions are banned anywhere\012 // in an arrow parameter list, this is correct.\012 // TODO(adamk): Rename &quot;FormalParameterInitializerError&quot; to refer to\012 // &quot;YieldExpression&quot;, which is its only use.\012 ValidateFormalParameterInitializer(ok);\012\012 Scanner::Location loc(lhs_beg_pos, scanner()-&gt;location().end_pos);\012 DeclarationScope* scope =\012 NewFunctionScope(is_async ? FunctionKind::kAsyncArrowFunction\012 : FunctionKind::kArrowFunction);\012\012 // Because the arrow's parameters were parsed in the outer scope,\012 // we need to fix up the scope chain appropriately.\012    scope_snapshot.Reparent(scope);\012\012 FormalParametersT parameters(scope);\012 if (!classifier()-&gt;is_simple_parameter_list()) {\012      scope-&gt;SetHasNonSimpleParameters();\012      parameters.is_simple = false;\012 }\012\012    scope-&gt;set_start_position(lhs_beg_pos);\012 Scanner::Location duplicate_loc = Scanner::Location::invalid();\012    impl()-&gt;DeclareArrowFunctionFormalParameters(&amp;parameters, expression, loc,\012 &amp;duplicate_loc, CHECK_OK);\012 if (duplicate_loc.IsValid()) {\012      classifier()-&gt;RecordDuplicateFormalParameterError(duplicate_loc);\012 }\012    expression = ParseArrowFunctionLiteral(accept_IN, parameters,\012                                           rewritable_length, CHECK_OK);\012 Accumulate(ExpressionClassifier::AsyncArrowFormalParametersProduction);\012    classifier()-&gt;RecordPatternError(arrow_loc,\012 MessageTemplate::kUnexpectedToken,\012 Token::String(Token::ARROW));\012\012 if (fni_ != nullptr) fni_-&gt;Infer();\012\012 return expression;\012 }\012\012 // &quot;expression&quot; was not itself an arrow function parameter list, but it might\012 // form part of one.  Propagate speculative formal parameter error locations\012 // (including those for binding patterns, since formal parameters can\012 // themselves contain binding patterns).\012 unsigned productions = ExpressionClassifier::AllProductions &amp;\012 ~ExpressionClassifier::ArrowFormalParametersProduction;\012\012 // Parenthesized identifiers and property references are allowed as part\012 // of a larger assignment pattern, even though parenthesized patterns\012 // themselves are not allowed, e.g., &quot;[(x)] = []&quot;. Only accumulate\012 // assignment pattern errors if the parsed expression is more complex.\012 if (IsValidReferenceExpression(expression)) {\012    productions &amp;= ~ExpressionClassifier::AssignmentPatternProduction;\012 }\012\012 const bool is_destructuring_assignment =\012 IsValidPattern(expression) &amp;&amp; peek() == Token::ASSIGN;\012 if (is_destructuring_assignment) {\012 // This is definitely not an expression so don't accumulate\012 // expression-related errors.\012    productions &amp;= ~ExpressionClassifier::ExpressionProduction;\012 }\012\012 Accumulate(productions);\012 if (!Token::IsAssignmentOp(peek())) return expression;\012\012 if (is_destructuring_assignment) {\012 ValidateAssignmentPattern(CHECK_OK);\012 } else {\012    expression = CheckAndRewriteReferenceExpression(\012        expression, lhs_beg_pos, scanner()-&gt;location().end_pos,\012 MessageTemplate::kInvalidLhsInAssignment, CHECK_OK);\012 }\012\012  impl()-&gt;MarkExpressionAsAssigned(expression);\012\012 Token::Value op = Next(); // Get assignment operator.\012 if (op != Token::ASSIGN) {\012    classifier()-&gt;RecordPatternError(scanner()-&gt;location(),\012 MessageTemplate::kUnexpectedToken,\012 Token::String(op));\012 }\012 int pos = position();\012\012 ExpressionClassifier rhs_classifier(this);\012\012 ExpressionT right = ParseAssignmentExpression(accept_IN, CHECK_OK);\012 ValidateExpression(CHECK_OK);\012 AccumulateFormalParameterContainmentErrors();\012\012 // We try to estimate the set of properties set by constructors. We define a\012 // new property whenever there is an assignment to a property of 'this'. We\012 // should probably only add properties if we haven't seen them\012 // before. Otherwise we'll probably overestimate the number of properties.\012 if (op == Token::ASSIGN &amp;&amp; impl()-&gt;IsThisProperty(expression)) {\012    function_state_-&gt;AddProperty();\012 }\012\012  impl()-&gt;CheckAssigningFunctionLiteralToProperty(expression, right);\012\012 if (fni_ != nullptr) {\012 // Check if the right hand side is a call to avoid inferring a\012 // name if we're dealing with &quot;a = function(){...}();&quot;-like\012 // expression.\012 if (op == Token::ASSIGN &amp;&amp; !right-&gt;IsCall() &amp;&amp; !right-&gt;IsCallNew()) {\012      fni_-&gt;Infer();\012 } else {\012      fni_-&gt;RemoveLastFunction();\012 }\012 }\012\012 if (op == Token::ASSIGN) {\012    impl()-&gt;SetFunctionNameFromIdentifierRef(right, expression);\012 }\012\012  DCHECK_NE(op, Token::INIT);\012 ExpressionT result = factory()-&gt;NewAssignment(op, expression, right, pos);\012\012 if (is_destructuring_assignment) {\012    DCHECK_NE(op, Token::ASSIGN_EXP);\012 auto rewritable = factory()-&gt;NewRewritableExpression(result, scope());\012    impl()-&gt;QueueDestructuringAssignmentForRewriting(rewritable);\012    result = rewritable;\012 }\012\012 return result;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParseYieldExpression(\012 bool accept_IN, bool* ok) {\012 // YieldExpression ::\012 //   'yield' ([no line terminator] '*'? AssignmentExpression)?\012 int pos = peek_position();\012  classifier()-&gt;RecordPatternError(\012      scanner()-&gt;peek_location(), MessageTemplate::kInvalidDestructuringTarget);\012  classifier()-&gt;RecordFormalParameterInitializerError(\012      scanner()-&gt;peek_location(), MessageTemplate::kYieldInParameter);\012 Expect(Token::YIELD, CHECK_OK);\012 // The following initialization is necessary.\012 ExpressionT expression = impl()-&gt;NullExpression();\012 bool delegating = false; // yield*\012 if (!scanner()-&gt;HasLineTerminatorBeforeNext()) {\012 if (Check(Token::MUL)) delegating = true;\012 switch (peek()) {\012 case Token::EOS:\012 case Token::SEMICOLON:\012 case Token::RBRACE:\012 case Token::RBRACK:\012 case Token::RPAREN:\012 case Token::COLON:\012 case Token::COMMA:\012 case Token::IN:\012 // The above set of tokens is the complete set of tokens that can appear\012 // after an AssignmentExpression, and none of them can start an\012 // AssignmentExpression.  This allows us to avoid looking for an RHS for\012 // a regular yield, given only one look-ahead token.\012 if (!delegating) break;\012 // Delegating yields require an RHS; fall through.\012        V8_FALLTHROUGH;\012 default:\012        expression = ParseAssignmentExpression(accept_IN, CHECK_OK);\012 ValidateExpression(CHECK_OK);\012 break;\012 }\012 }\012\012 if (delegating) {\012 ExpressionT yieldstar = factory()-&gt;NewYieldStar(expression, pos);\012    impl()-&gt;RecordSuspendSourceRange(yieldstar, PositionAfterSemicolon());\012    function_state_-&gt;AddSuspend();\012 if (IsAsyncGeneratorFunction(function_state_-&gt;kind())) {\012 // iterator_close and delegated_iterator_output suspend ids.\012      function_state_-&gt;AddSuspend();\012      function_state_-&gt;AddSuspend();\012 }\012 return yieldstar;\012 }\012\012 // Hackily disambiguate o from o.next and o [Symbol.iterator]().\012 // TODO(verwaest): Come up with a better solution.\012 ExpressionT yield =\012      factory()-&gt;NewYield(expression, pos, Suspend::kOnExceptionThrow);\012  impl()-&gt;RecordSuspendSourceRange(yield, PositionAfterSemicolon());\012  function_state_-&gt;AddSuspend();\012 return yield;\012}\012\012// Precedence = 3\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT\012ParserBase&lt;Impl&gt;::ParseConditionalExpression(bool accept_IN,\012 bool* ok) {\012 // ConditionalExpression ::\012 //   LogicalOrExpression\012 //   LogicalOrExpression '?' AssignmentExpression ':' AssignmentExpression\012\012 SourceRange then_range, else_range;\012 int pos = peek_position();\012 // We start using the binary expression parser for prec &gt;= 4 only!\012 ExpressionT expression = ParseBinaryExpression(4, accept_IN, CHECK_OK);\012 if (peek() != Token::CONDITIONAL) return expression;\012 ValidateExpression(CHECK_OK);\012 BindingPatternUnexpectedToken();\012 ArrowFormalParametersUnexpectedToken();\012\012 ExpressionT left;\012 {\012 SourceRangeScope range_scope(scanner(), &amp;then_range);\012 Consume(Token::CONDITIONAL);\012 ExpressionClassifier classifier(this);\012 // In parsing the first assignment expression in conditional\012 // expressions we always accept the 'in' keyword; see ECMA-262,\012 // section 11.12, page 58.\012    left = ParseAssignmentExpression(true, CHECK_OK);\012 AccumulateNonBindingPatternErrors();\012 }\012 ValidateExpression(CHECK_OK);\012 ExpressionT right;\012 {\012 SourceRangeScope range_scope(scanner(), &amp;else_range);\012 Expect(Token::COLON, CHECK_OK);\012 ExpressionClassifier classifier(this);\012    right = ParseAssignmentExpression(accept_IN, CHECK_OK);\012 AccumulateNonBindingPatternErrors();\012 }\012 ValidateExpression(CHECK_OK);\012 ExpressionT expr = factory()-&gt;NewConditional(expression, left, right, pos);\012  impl()-&gt;RecordConditionalSourceRange(expr, then_range, else_range);\012 return expr;\012}\012\012\012// Precedence &gt;= 4\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParseBinaryExpression(\012 int prec, bool accept_IN, bool* ok) {\012  DCHECK_GE(prec, 4);\012 SourceRange right_range;\012 ExpressionT x = ParseUnaryExpression(CHECK_OK);\012 for (int prec1 = Precedence(peek(), accept_IN); prec1 &gt;= prec; prec1--) {\012 // prec1 &gt;= 4\012 while (Precedence(peek(), accept_IN) == prec1) {\012 ValidateExpression(CHECK_OK);\012 BindingPatternUnexpectedToken();\012 ArrowFormalParametersUnexpectedToken();\012\012 SourceRangeScope right_range_scope(scanner(), &amp;right_range);\012 Token::Value op = Next();\012 int pos = position();\012\012 const bool is_right_associative = op == Token::EXP;\012 const int next_prec = is_right_associative ? prec1 : prec1 + 1;\012 ExpressionT y = ParseBinaryExpression(next_prec, accept_IN, CHECK_OK);\012      right_range_scope.Finalize();\012 ValidateExpression(CHECK_OK);\012\012 if (impl()-&gt;ShortcutNumericLiteralBinaryExpression(&amp;x, y, op, pos)) {\012 continue;\012 }\012\012 // For now we distinguish between comparisons and other binary\012 // operations.  (We could combine the two and get rid of this\012 // code and AST node eventually.)\012 if (Token::IsCompareOp(op)) {\012 // We have a comparison.\012 Token::Value cmp = op;\012 switch (op) {\012 case Token::NE: cmp = Token::EQ; break;\012 case Token::NE_STRICT: cmp = Token::EQ_STRICT; break;\012 default: break;\012 }\012        x = factory()-&gt;NewCompareOperation(cmp, x, y, pos);\012 if (cmp != op) {\012 // The comparison was negated - add a NOT.\012          x = factory()-&gt;NewUnaryOperation(Token::NOT, x, pos);\012 }\012 } else if (impl()-&gt;CollapseNaryExpression(&amp;x, y, op, pos, right_range)) {\012 continue;\012 } else {\012 // We have a &quot;normal&quot; binary operation.\012        x = factory()-&gt;NewBinaryOperation(op, x, y, pos);\012 if (op == Token::OR || op == Token::AND) {\012          impl()-&gt;RecordBinaryOperationSourceRange(x, right_range);\012 }\012 }\012 }\012 }\012 return x;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParseUnaryExpression(\012 bool* ok) {\012 // UnaryExpression ::\012 //   PostfixExpression\012 //   'delete' UnaryExpression\012 //   'void' UnaryExpression\012 //   'typeof' UnaryExpression\012 //   '++' UnaryExpression\012 //   '--' UnaryExpression\012 //   '+' UnaryExpression\012 //   '-' UnaryExpression\012 //   '~' UnaryExpression\012 //   '!' UnaryExpression\012 //   [+Await] AwaitExpression[?Yield]\012\012 Token::Value op = peek();\012 if (Token::IsUnaryOp(op)) {\012 BindingPatternUnexpectedToken();\012 ArrowFormalParametersUnexpectedToken();\012\012    op = Next();\012 int pos = position();\012\012 // Assume &quot;! function ...&quot; indicates the function is likely to be called.\012 if (op == Token::NOT &amp;&amp; peek() == Token::FUNCTION) {\012      function_state_-&gt;set_next_function_is_likely_called();\012 }\012\012 ExpressionT expression = ParseUnaryExpression(CHECK_OK);\012 ValidateExpression(CHECK_OK);\012\012 if (op == Token::DELETE) {\012 if (impl()-&gt;IsIdentifier(expression) &amp;&amp; is_strict(language_mode())) {\012 // &quot;delete identifier&quot; is a syntax error in strict mode.\012 ReportMessage(MessageTemplate::kStrictDelete);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012\012 if (impl()-&gt;IsPropertyWithPrivateFieldKey(expression)) {\012 ReportMessage(MessageTemplate::kDeletePrivateField);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012 }\012\012 if (peek() == Token::EXP) {\012 ReportUnexpectedToken(Next());\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012\012 // Allow the parser's implementation to rewrite the expression.\012 return impl()-&gt;BuildUnaryExpression(expression, op, pos);\012 } else if (Token::IsCountOp(op)) {\012 BindingPatternUnexpectedToken();\012 ArrowFormalParametersUnexpectedToken();\012    op = Next();\012 int beg_pos = peek_position();\012 ExpressionT expression = ParseUnaryExpression(CHECK_OK);\012    expression = CheckAndRewriteReferenceExpression(\012        expression, beg_pos, scanner()-&gt;location().end_pos,\012 MessageTemplate::kInvalidLhsInPrefixOp, CHECK_OK);\012    impl()-&gt;MarkExpressionAsAssigned(expression);\012 ValidateExpression(CHECK_OK);\012\012 return factory()-&gt;NewCountOperation(op,\012 true /* prefix */,\012                                        expression,\012                                        position());\012\012 } else if (is_async_function() &amp;&amp; peek() == Token::AWAIT) {\012    classifier()-&gt;RecordFormalParameterInitializerError(\012        scanner()-&gt;peek_location(),\012 MessageTemplate::kAwaitExpressionFormalParameter);\012 int await_pos = peek_position();\012 Consume(Token::AWAIT);\012\012 ExpressionT value = ParseUnaryExpression(CHECK_OK);\012\012    classifier()-&gt;RecordBindingPatternError(\012 Scanner::Location(await_pos, scanner()-&gt;location().end_pos),\012 MessageTemplate::kInvalidDestructuringTarget);\012\012 ExpressionT expr = factory()-&gt;NewAwait(value, await_pos);\012    function_state_-&gt;AddSuspend();\012    impl()-&gt;RecordSuspendSourceRange(expr, PositionAfterSemicolon());\012 return expr;\012 } else {\012 return ParsePostfixExpression(ok);\012 }\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParsePostfixExpression(\012 bool* ok) {\012 // PostfixExpression ::\012 //   LeftHandSideExpression ('++' | '--')?\012\012 int lhs_beg_pos = peek_position();\012 ExpressionT expression = ParseLeftHandSideExpression(CHECK_OK);\012 if (!scanner()-&gt;HasLineTerminatorBeforeNext() &amp;&amp; Token::IsCountOp(peek())) {\012 BindingPatternUnexpectedToken();\012 ArrowFormalParametersUnexpectedToken();\012\012    expression = CheckAndRewriteReferenceExpression(\012        expression, lhs_beg_pos, scanner()-&gt;location().end_pos,\012 MessageTemplate::kInvalidLhsInPostfixOp, CHECK_OK);\012    impl()-&gt;MarkExpressionAsAssigned(expression);\012 ValidateExpression(CHECK_OK);\012\012 Token::Value next = Next();\012    expression =\012        factory()-&gt;NewCountOperation(next,\012 false /* postfix */,\012                                     expression,\012                                     position());\012 }\012 return expression;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT\012ParserBase&lt;Impl&gt;::ParseLeftHandSideExpression(bool* ok) {\012 // LeftHandSideExpression ::\012 //   (NewExpression | MemberExpression) ...\012\012 bool is_async = false;\012 ExpressionT result =\012 ParseMemberWithNewPrefixesExpression(&amp;is_async, CHECK_OK);\012\012 while (true) {\012 switch (peek()) {\012 case Token::LBRACK: {\012 ValidateExpression(CHECK_OK);\012 BindingPatternUnexpectedToken();\012 ArrowFormalParametersUnexpectedToken();\012 Consume(Token::LBRACK);\012 int pos = position();\012 ExpressionT index = ParseExpressionCoverGrammar(true, CHECK_OK);\012 ValidateExpression(CHECK_OK);\012        result = factory()-&gt;NewProperty(result, index, pos);\012 Expect(Token::RBRACK, CHECK_OK);\012 break;\012 }\012\012 case Token::LPAREN: {\012 int pos;\012 ValidateExpression(CHECK_OK);\012 BindingPatternUnexpectedToken();\012 if (scanner()-&gt;current_token() == Token::IDENTIFIER ||\012            scanner()-&gt;current_token() == Token::SUPER ||\012            scanner()-&gt;current_token() == Token::ASYNC) {\012 // For call of an identifier we want to report position of\012 // the identifier as position of the call in the stack trace.\012          pos = position();\012 } else {\012 // For other kinds of calls we record position of the parenthesis as\012 // position of the call. Note that this is extremely important for\012 // expressions of the form function(){...}() for which call position\012 // should not point to the closing brace otherwise it will intersect\012 // with positions recorded for function literal and confuse debugger.\012          pos = peek_position();\012 // Also the trailing parenthesis are a hint that the function will\012 // be called immediately. If we happen to have parsed a preceding\012 // function literal eagerly, we can also compile it eagerly.\012 if (result-&gt;IsFunctionLiteral()) {\012            result-&gt;AsFunctionLiteral()-&gt;SetShouldEagerCompile();\012            result-&gt;AsFunctionLiteral()-&gt;mark_as_iife();\012 }\012 }\012 Scanner::Location spread_pos;\012 ExpressionListT args;\012 if (V8_UNLIKELY(is_async &amp;&amp; impl()-&gt;IsIdentifier(result))) {\012 ExpressionClassifier async_classifier(this);\012 bool is_simple_parameter_list = true;\012          args = ParseArguments(&amp;spread_pos, true, &amp;is_simple_parameter_list,\012                                CHECK_OK);\012 if (peek() == Token::ARROW) {\012 if (fni_) {\012              fni_-&gt;RemoveAsyncKeywordFromEnd();\012 }\012 ValidateBindingPattern(CHECK_OK);\012 ValidateFormalParameterInitializer(CHECK_OK);\012 if (!classifier()-&gt;is_valid_async_arrow_formal_parameters()) {\012 ReportClassifierError(\012                  classifier()-&gt;async_arrow_formal_parameters_error());\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012 if (args-&gt;length()) {\012 // async ( Arguments ) =&gt; ...\012 if (!is_simple_parameter_list) {\012                async_classifier.previous()-&gt;RecordNonSimpleParameter();\012 }\012 return impl()-&gt;ExpressionListToExpression(args);\012 }\012 // async () =&gt; ...\012 return factory()-&gt;NewEmptyParentheses(pos);\012 } else {\012 AccumulateFormalParameterContainmentErrors();\012 }\012 } else {\012          args = ParseArguments(&amp;spread_pos, CHECK_OK);\012 }\012\012 ArrowFormalParametersUnexpectedToken();\012\012 // Keep track of eval() calls since they disable all local variable\012 // optimizations.\012 // The calls that need special treatment are the\012 // direct eval calls. These calls are all of the form eval(...), with\012 // no explicit receiver.\012 // These calls are marked as potentially direct eval calls. Whether\012 // they are actually direct calls to eval is determined at run time.\012 Call::PossiblyEval is_possibly_eval =\012 CheckPossibleEvalCall(result, scope());\012\012 if (spread_pos.IsValid()) {\012          result = impl()-&gt;SpreadCall(result, args, pos, is_possibly_eval);\012 } else {\012          result = factory()-&gt;NewCall(result, args, pos, is_possibly_eval);\012 }\012\012 if (fni_ != nullptr) fni_-&gt;RemoveLastFunction();\012 break;\012 }\012\012 case Token::PERIOD: {\012 ValidateExpression(CHECK_OK);\012 BindingPatternUnexpectedToken();\012 ArrowFormalParametersUnexpectedToken();\012 Consume(Token::PERIOD);\012 int pos = position();\012 ExpressionT key = ParseIdentifierNameOrPrivateName(CHECK_OK);\012        result = factory()-&gt;NewProperty(result, key, pos);\012 break;\012 }\012\012 case Token::TEMPLATE_SPAN:\012 case Token::TEMPLATE_TAIL: {\012 ValidateExpression(CHECK_OK);\012 BindingPatternUnexpectedToken();\012 ArrowFormalParametersUnexpectedToken();\012        result = ParseTemplateLiteral(result, position(), true, CHECK_OK);\012 break;\012 }\012\012 default:\012 return result;\012 }\012 }\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT\012ParserBase&lt;Impl&gt;::ParseMemberWithNewPrefixesExpression(bool* is_async,\012 bool* ok) {\012 // NewExpression ::\012 //   ('new')+ MemberExpression\012 //\012 // NewTarget ::\012 //   'new' '.' 'target'\012\012 // The grammar for new expressions is pretty warped. We can have several 'new'\012 // keywords following each other, and then a MemberExpression. When we see '('\012 // after the MemberExpression, it's associated with the rightmost unassociated\012 // 'new' to create a NewExpression with arguments. However, a NewExpression\012 // can also occur without arguments.\012\012 // Examples of new expression:\012 // new foo.bar().baz means (new (foo.bar)()).baz\012 // new foo()() means (new foo())()\012 // new new foo()() means (new (new foo())())\012 // new new foo means new (new foo)\012 // new new foo() means new (new foo())\012 // new new foo().bar().baz means (new (new foo()).bar()).baz\012\012 if (peek() == Token::NEW) {\012 BindingPatternUnexpectedToken();\012 ArrowFormalParametersUnexpectedToken();\012 Consume(Token::NEW);\012 int new_pos = position();\012 ExpressionT result;\012 if (peek() == Token::SUPER) {\012 const bool is_new = true;\012      result = ParseSuperExpression(is_new, CHECK_OK);\012 } else if (allow_harmony_dynamic_import() &amp;&amp; peek() == Token::IMPORT &amp;&amp;\012 (!allow_harmony_import_meta() || PeekAhead() == Token::LPAREN)) {\012      impl()-&gt;ReportMessageAt(scanner()-&gt;peek_location(),\012 MessageTemplate::kImportCallNotNewExpression);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 } else if (peek() == Token::PERIOD) {\012 *is_async = false;\012      result = ParseNewTargetExpression(CHECK_OK);\012 return ParseMemberExpressionContinuation(result, is_async, CHECK_OK);\012 } else {\012      result = ParseMemberWithNewPrefixesExpression(is_async, CHECK_OK);\012 }\012 ValidateExpression(CHECK_OK);\012 if (peek() == Token::LPAREN) {\012 // NewExpression with arguments.\012 Scanner::Location spread_pos;\012 ExpressionListT args = ParseArguments(&amp;spread_pos, CHECK_OK);\012\012 if (spread_pos.IsValid()) {\012        result = impl()-&gt;SpreadCallNew(result, args, new_pos);\012 } else {\012        result = factory()-&gt;NewCallNew(result, args, new_pos);\012 }\012 // The expression can still continue with . or [ after the arguments.\012      result = ParseMemberExpressionContinuation(result, is_async, CHECK_OK);\012 return result;\012 }\012 // NewExpression without arguments.\012 return factory()-&gt;NewCallNew(result, impl()-&gt;NewExpressionList(0), new_pos);\012 }\012 // No 'new' or 'super' keyword.\012 return ParseMemberExpression(is_async, ok);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParseMemberExpression(\012 bool* is_async, bool* ok) {\012 // MemberExpression ::\012 //   (PrimaryExpression | FunctionLiteral | ClassLiteral)\012 //     ('[' Expression ']' | '.' Identifier | Arguments | TemplateLiteral)*\012 //\012 // CallExpression ::\012 //   (SuperCall | ImportCall)\012 //     ('[' Expression ']' | '.' Identifier | Arguments | TemplateLiteral)*\012 //\012 // The '[' Expression ']' and '.' Identifier parts are parsed by\012 // ParseMemberExpressionContinuation, and the Arguments part is parsed by the\012 // caller.\012\012 // Parse the initial primary or function expression.\012 ExpressionT result;\012 if (peek() == Token::FUNCTION) {\012 BindingPatternUnexpectedToken();\012 ArrowFormalParametersUnexpectedToken();\012\012 Consume(Token::FUNCTION);\012 int function_token_position = position();\012\012 FunctionKind function_kind = Check(Token::MUL)\012 ? FunctionKind::kGeneratorFunction\012 : FunctionKind::kNormalFunction;\012 IdentifierT name = impl()-&gt;NullIdentifier();\012 bool is_strict_reserved_name = false;\012 Scanner::Location function_name_location = Scanner::Location::invalid();\012 FunctionLiteral::FunctionType function_type =\012 FunctionLiteral::kAnonymousExpression;\012 if (impl()-&gt;ParsingDynamicFunctionDeclaration()) {\012 // We don't want dynamic functions to actually declare their name\012 // &quot;anonymous&quot;. We just want that name in the toString().\012 if (stack_overflow()) {\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012 Consume(Token::IDENTIFIER);\012      DCHECK(scanner()-&gt;CurrentMatchesContextual(Token::ANONYMOUS));\012 } else if (peek_any_identifier()) {\012 bool is_await = false;\012      name = ParseIdentifierOrStrictReservedWord(\012          function_kind, &amp;is_strict_reserved_name, &amp;is_await, CHECK_OK);\012      function_name_location = scanner()-&gt;location();\012      function_type = FunctionLiteral::kNamedExpression;\012 }\012    result = impl()-&gt;ParseFunctionLiteral(\012        name, function_name_location,\012        is_strict_reserved_name ? kFunctionNameIsStrictReserved\012 : kFunctionNameValidityUnknown,\012        function_kind, function_token_position, function_type, language_mode(),\012 nullptr, CHECK_OK);\012 } else if (peek() == Token::SUPER) {\012 const bool is_new = false;\012    result = ParseSuperExpression(is_new, CHECK_OK);\012 } else if (allow_harmony_dynamic_import() &amp;&amp; peek() == Token::IMPORT) {\012    result = ParseImportExpressions(CHECK_OK);\012 } else {\012    result = ParsePrimaryExpression(is_async, CHECK_OK);\012 }\012\012  result = ParseMemberExpressionContinuation(result, is_async, CHECK_OK);\012 return result;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParseImportExpressions(\012 bool* ok) {\012  DCHECK(allow_harmony_dynamic_import());\012\012  classifier()-&gt;RecordPatternError(scanner()-&gt;peek_location(),\012 MessageTemplate::kUnexpectedToken,\012 Token::String(Token::IMPORT));\012\012 Consume(Token::IMPORT);\012 int pos = position();\012 if (allow_harmony_import_meta() &amp;&amp; peek() == Token::PERIOD) {\012 ExpectMetaProperty(Token::META, &quot;import.meta&quot;, pos, CHECK_OK);\012 if (!parsing_module_) {\012      impl()-&gt;ReportMessageAt(scanner()-&gt;location(),\012 MessageTemplate::kImportMetaOutsideModule);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012\012 return impl()-&gt;ImportMetaExpression(pos);\012 }\012 Expect(Token::LPAREN, CHECK_OK);\012 if (peek() == Token::RPAREN) {\012    impl()-&gt;ReportMessageAt(scanner()-&gt;location(),\012 MessageTemplate::kImportMissingSpecifier);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012 ExpressionT arg = ParseAssignmentExpression(true, CHECK_OK);\012 Expect(Token::RPAREN, CHECK_OK);\012 return factory()-&gt;NewImportCallExpression(arg, pos);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParseSuperExpression(\012 bool is_new, bool* ok) {\012 Expect(Token::SUPER, CHECK_OK);\012 int pos = position();\012\012 DeclarationScope* scope = GetReceiverScope();\012 FunctionKind kind = scope-&gt;function_kind();\012 if (IsConciseMethod(kind) || IsAccessorFunction(kind) ||\012 IsClassConstructor(kind)) {\012 if (peek() == Token::PERIOD || peek() == Token::LBRACK) {\012      scope-&gt;RecordSuperPropertyUsage();\012 return impl()-&gt;NewSuperPropertyReference(pos);\012 }\012 // new super() is never allowed.\012 // super() is only allowed in derived constructor\012 if (!is_new &amp;&amp; peek() == Token::LPAREN &amp;&amp; IsDerivedConstructor(kind)) {\012 // TODO(rossberg): This might not be the correct FunctionState for the\012 // method here.\012 return impl()-&gt;NewSuperCallReference(pos);\012 }\012 }\012\012  impl()-&gt;ReportMessageAt(scanner()-&gt;location(),\012 MessageTemplate::kUnexpectedSuper);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::ExpectMetaProperty(Token::Value property_name,\012 const char* full_name, int pos,\012 bool* ok) {\012 Consume(Token::PERIOD);\012 ExpectContextualKeyword(property_name, CHECK_OK_CUSTOM(Void));\012 if (scanner()-&gt;literal_contains_escapes()) {\012    impl()-&gt;ReportMessageAt(\012 Scanner::Location(pos, scanner()-&gt;location().end_pos),\012 MessageTemplate::kInvalidEscapedMetaProperty, full_name);\012 *ok = false;\012 }\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT\012ParserBase&lt;Impl&gt;::ParseNewTargetExpression(bool* ok) {\012 int pos = position();\012 ExpectMetaProperty(Token::TARGET, &quot;new.target&quot;, pos, CHECK_OK);\012\012  classifier()-&gt;RecordAssignmentPatternError(\012 Scanner::Location(pos, scanner()-&gt;location().end_pos),\012 MessageTemplate::kInvalidDestructuringTarget);\012\012 if (!GetReceiverScope()-&gt;is_function_scope()) {\012    impl()-&gt;ReportMessageAt(scanner()-&gt;location(),\012 MessageTemplate::kUnexpectedNewTarget);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012\012 return impl()-&gt;NewTargetExpression(pos);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT\012ParserBase&lt;Impl&gt;::ParseMemberExpressionContinuation(ExpressionT expression,\012 bool* is_async, bool* ok) {\012 // Parses this part of MemberExpression:\012 // ('[' Expression ']' | '.' Identifier | TemplateLiteral)*\012 while (true) {\012 switch (peek()) {\012 case Token::LBRACK: {\012 *is_async = false;\012 ValidateExpression(CHECK_OK);\012 BindingPatternUnexpectedToken();\012 ArrowFormalParametersUnexpectedToken();\012\012 Consume(Token::LBRACK);\012 int pos = position();\012 ExpressionT index = ParseExpressionCoverGrammar(true, CHECK_OK);\012 ValidateExpression(CHECK_OK);\012        expression = factory()-&gt;NewProperty(expression, index, pos);\012        impl()-&gt;PushPropertyName(index);\012 Expect(Token::RBRACK, CHECK_OK);\012 break;\012 }\012 case Token::PERIOD: {\012 *is_async = false;\012 ValidateExpression(CHECK_OK);\012 BindingPatternUnexpectedToken();\012 ArrowFormalParametersUnexpectedToken();\012\012 Consume(Token::PERIOD);\012 int pos = peek_position();\012 ExpressionT key = ParseIdentifierNameOrPrivateName(CHECK_OK);\012        expression = factory()-&gt;NewProperty(expression, key, pos);\012 break;\012 }\012 case Token::TEMPLATE_SPAN:\012 case Token::TEMPLATE_TAIL: {\012 *is_async = false;\012 ValidateExpression(CHECK_OK);\012 BindingPatternUnexpectedToken();\012 ArrowFormalParametersUnexpectedToken();\012 int pos;\012 if (scanner()-&gt;current_token() == Token::IDENTIFIER) {\012          pos = position();\012 } else {\012          pos = peek_position();\012 if (expression-&gt;IsFunctionLiteral()) {\012 // If the tag function looks like an IIFE, set_parenthesized() to\012 // force eager compilation.\012            expression-&gt;AsFunctionLiteral()-&gt;SetShouldEagerCompile();\012 }\012 }\012        expression = ParseTemplateLiteral(expression, pos, true, CHECK_OK);\012 break;\012 }\012 case Token::ILLEGAL: {\012 ReportUnexpectedTokenAt(scanner()-&gt;peek_location(), Token::ILLEGAL);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012 default:\012 return expression;\012 }\012 }\012  DCHECK(false);\012 return impl()-&gt;NullExpression();\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::ParseFormalParameter(FormalParametersT* parameters,\012 bool* ok) {\012 // FormalParameter[Yield,GeneratorParameter] :\012 //   BindingElement[?Yield, ?GeneratorParameter]\012 bool is_rest = parameters-&gt;has_rest;\012\012 FuncNameInferrer::State fni_state(fni_);\012 ExpressionT pattern = ParsePrimaryExpression(CHECK_OK_CUSTOM(Void));\012 ValidateBindingPattern(CHECK_OK_CUSTOM(Void));\012\012 if (!impl()-&gt;IsIdentifier(pattern)) {\012    parameters-&gt;is_simple = false;\012 ValidateFormalParameterInitializer(CHECK_OK_CUSTOM(Void));\012    classifier()-&gt;RecordNonSimpleParameter();\012 }\012\012 ExpressionT initializer = impl()-&gt;NullExpression();\012 if (Check(Token::ASSIGN)) {\012 if (is_rest) {\012 ReportMessage(MessageTemplate::kRestDefaultInitializer);\012 *ok = false;\012 return;\012 }\012 ExpressionClassifier init_classifier(this);\012    initializer = ParseAssignmentExpression(true, CHECK_OK_CUSTOM(Void));\012 ValidateExpression(CHECK_OK_CUSTOM(Void));\012 ValidateFormalParameterInitializer(CHECK_OK_CUSTOM(Void));\012    parameters-&gt;is_simple = false;\012 DiscardExpressionClassifier();\012    classifier()-&gt;RecordNonSimpleParameter();\012\012    impl()-&gt;SetFunctionNameFromIdentifierRef(initializer, pattern);\012 }\012\012  impl()-&gt;AddFormalParameter(parameters, pattern, initializer,\012                             scanner()-&gt;location().end_pos, is_rest);\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::ParseFormalParameterList(FormalParametersT* parameters,\012 bool* ok) {\012 // FormalParameters[Yield] :\012 //   [empty]\012 //   FunctionRestParameter[?Yield]\012 //   FormalParameterList[?Yield]\012 //   FormalParameterList[?Yield] ,\012 //   FormalParameterList[?Yield] , FunctionRestParameter[?Yield]\012 //\012 // FormalParameterList[Yield] :\012 //   FormalParameter[?Yield]\012 //   FormalParameterList[?Yield] , FormalParameter[?Yield]\012\012  DCHECK_EQ(0, parameters-&gt;arity);\012\012 if (peek() != Token::RPAREN) {\012 while (true) {\012 // Add one since we're going to be adding a parameter.\012 if (parameters-&gt;arity + 1 &gt; Code::kMaxArguments) {\012 ReportMessage(MessageTemplate::kTooManyParameters);\012 *ok = false;\012 return;\012 }\012      parameters-&gt;has_rest = Check(Token::ELLIPSIS);\012 ParseFormalParameter(parameters, CHECK_OK_CUSTOM(Void));\012\012 if (parameters-&gt;has_rest) {\012        parameters-&gt;is_simple = false;\012        classifier()-&gt;RecordNonSimpleParameter();\012 if (peek() == Token::COMMA) {\012          impl()-&gt;ReportMessageAt(scanner()-&gt;peek_location(),\012 MessageTemplate::kParamAfterRest);\012 *ok = false;\012 return;\012 }\012 break;\012 }\012 if (!Check(Token::COMMA)) break;\012 if (peek() == Token::RPAREN) {\012 // allow the trailing comma\012 break;\012 }\012 }\012 }\012\012  impl()-&gt;DeclareFormalParameters(parameters-&gt;scope, parameters-&gt;params,\012                                  parameters-&gt;is_simple);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::BlockT ParserBase&lt;Impl&gt;::ParseVariableDeclarations(\012 VariableDeclarationContext var_context,\012 DeclarationParsingResult* parsing_result,\012 ZonePtrList&lt;const AstRawString&gt;* names, bool* ok) {\012 // VariableDeclarations ::\012 //   ('var' | 'const' | 'let') (Identifier ('=' AssignmentExpression)?)+[',']\012 //\012 // ES6:\012 // FIXME(marja, nikolaos): Add an up-to-date comment about ES6 variable\012 // declaration syntax.\012\012  DCHECK_NOT_NULL(parsing_result);\012  parsing_result-&gt;descriptor.declaration_kind = DeclarationDescriptor::NORMAL;\012  parsing_result-&gt;descriptor.declaration_pos = peek_position();\012  parsing_result-&gt;descriptor.initialization_pos = peek_position();\012\012 BlockT init_block = impl()-&gt;NullStatement();\012 if (var_context != kForStatement) {\012    init_block = factory()-&gt;NewBlock(1, true);\012 }\012\012 switch (peek()) {\012 case Token::VAR:\012      parsing_result-&gt;descriptor.mode = VariableMode::kVar;\012 Consume(Token::VAR);\012 break;\012 case Token::CONST:\012 Consume(Token::CONST);\012      DCHECK_NE(var_context, kStatement);\012      parsing_result-&gt;descriptor.mode = VariableMode::kConst;\012 break;\012 case Token::LET:\012 Consume(Token::LET);\012      DCHECK_NE(var_context, kStatement);\012      parsing_result-&gt;descriptor.mode = VariableMode::kLet;\012 break;\012 default:\012      UNREACHABLE(); // by current callers\012 break;\012 }\012\012  parsing_result-&gt;descriptor.scope = scope();\012\012 int bindings_start = peek_position();\012 do {\012 // Parse binding pattern.\012 FuncNameInferrer::State fni_state(fni_);\012\012 ExpressionT pattern = impl()-&gt;NullExpression();\012 int decl_pos = peek_position();\012 {\012 ExpressionClassifier pattern_classifier(this);\012      pattern = ParsePrimaryExpression(CHECK_OK_CUSTOM(NullStatement));\012\012 ValidateBindingPattern(CHECK_OK_CUSTOM(NullStatement));\012 if (IsLexicalVariableMode(parsing_result-&gt;descriptor.mode)) {\012 ValidateLetPattern(CHECK_OK_CUSTOM(NullStatement));\012 }\012 }\012\012 Scanner::Location variable_loc = scanner()-&gt;location();\012 bool single_name = impl()-&gt;IsIdentifier(pattern);\012\012 if (single_name) {\012      impl()-&gt;PushVariableName(impl()-&gt;AsIdentifier(pattern));\012 }\012\012 ExpressionT value = impl()-&gt;NullExpression();\012 int initializer_position = kNoSourcePosition;\012 int value_beg_position = kNoSourcePosition;\012 if (Check(Token::ASSIGN)) {\012      value_beg_position = peek_position();\012\012 ExpressionClassifier classifier(this);\012      value = ParseAssignmentExpression(var_context != kForStatement,\012                                        CHECK_OK_CUSTOM(NullStatement));\012 ValidateExpression(CHECK_OK_CUSTOM(NullStatement));\012      variable_loc.end_pos = scanner()-&gt;location().end_pos;\012\012 if (!parsing_result-&gt;first_initializer_loc.IsValid()) {\012        parsing_result-&gt;first_initializer_loc = variable_loc;\012 }\012\012 // Don't infer if it is &quot;a = function(){...}();&quot;-like expression.\012 if (single_name &amp;&amp; fni_ != nullptr) {\012 if (!value-&gt;IsCall() &amp;&amp; !value-&gt;IsCallNew()) {\012          fni_-&gt;Infer();\012 } else {\012          fni_-&gt;RemoveLastFunction();\012 }\012 }\012\012      impl()-&gt;SetFunctionNameFromIdentifierRef(value, pattern);\012\012 // End position of the initializer is after the assignment expression.\012      initializer_position = scanner()-&gt;location().end_pos;\012 } else {\012 if (var_context != kForStatement || !PeekInOrOf()) {\012 // ES6 'const' and binding patterns require initializers.\012 if (parsing_result-&gt;descriptor.mode == VariableMode::kConst ||\012 !impl()-&gt;IsIdentifier(pattern)) {\012          impl()-&gt;ReportMessageAt(\012 Scanner::Location(decl_pos, scanner()-&gt;location().end_pos),\012 MessageTemplate::kDeclarationMissingInitializer,\012 !impl()-&gt;IsIdentifier(pattern) ? &quot;destructuring&quot; : &quot;const&quot;);\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 }\012 // 'let x' initializes 'x' to undefined.\012 if (parsing_result-&gt;descriptor.mode == VariableMode::kLet) {\012          value = factory()-&gt;NewUndefinedLiteral(position());\012 }\012 }\012\012 // End position of the initializer is after the variable.\012      initializer_position = position();\012 }\012\012 typename DeclarationParsingResult::Declaration decl(\012        pattern, initializer_position, value);\012    decl.value_beg_position = value_beg_position;\012 if (var_context == kForStatement) {\012 // Save the declaration for further handling in ParseForStatement.\012      parsing_result-&gt;declarations.push_back(decl);\012 } else {\012 // Immediately declare the variable otherwise. This avoids O(N^2)\012 // behavior (where N is the number of variables in a single\012 // declaration) in the PatternRewriter having to do with removing\012 // and adding VariableProxies to the Scope (see bug 4699).\012      impl()-&gt;DeclareAndInitializeVariables(\012          init_block, &amp;parsing_result-&gt;descriptor, &amp;decl, names,\012          CHECK_OK_CUSTOM(NullStatement));\012 }\012 } while (Check(Token::COMMA));\012\012  parsing_result-&gt;bindings_loc =\012 Scanner::Location(bindings_start, scanner()-&gt;location().end_pos);\012\012  DCHECK(*ok);\012 return init_block;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT\012ParserBase&lt;Impl&gt;::ParseFunctionDeclaration(bool* ok) {\012 Consume(Token::FUNCTION);\012 int pos = position();\012 ParseFunctionFlags flags = ParseFunctionFlags::kIsNormal;\012 if (Check(Token::MUL)) {\012    impl()-&gt;ReportMessageAt(\012        scanner()-&gt;location(),\012 MessageTemplate::kGeneratorInSingleStatementContext);\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 }\012 return ParseHoistableDeclaration(pos, flags, nullptr, false, ok);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT\012ParserBase&lt;Impl&gt;::ParseHoistableDeclaration(\012 ZonePtrList&lt;const AstRawString&gt;* names, bool default_export, bool* ok) {\012 Expect(Token::FUNCTION, CHECK_OK_CUSTOM(NullStatement));\012 int pos = position();\012 ParseFunctionFlags flags = ParseFunctionFlags::kIsNormal;\012 if (Check(Token::MUL)) {\012    flags |= ParseFunctionFlags::kIsGenerator;\012 }\012 return ParseHoistableDeclaration(pos, flags, names, default_export, ok);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT\012ParserBase&lt;Impl&gt;::ParseHoistableDeclaration(\012 int pos, ParseFunctionFlags flags, ZonePtrList&lt;const AstRawString&gt;* names,\012 bool default_export, bool* ok) {\012 // FunctionDeclaration ::\012 //   'function' Identifier '(' FormalParameters ')' '{' FunctionBody '}'\012 //   'function' '(' FormalParameters ')' '{' FunctionBody '}'\012 // GeneratorDeclaration ::\012 //   'function' '*' Identifier '(' FormalParameters ')' '{' FunctionBody '}'\012 //   'function' '*' '(' FormalParameters ')' '{' FunctionBody '}'\012 //\012 // The anonymous forms are allowed iff [default_export] is true.\012 //\012 // 'function' and '*' (if present) have been consumed by the caller.\012\012 bool is_generator = flags &amp; ParseFunctionFlags::kIsGenerator;\012 const bool is_async = flags &amp; ParseFunctionFlags::kIsAsync;\012  DCHECK(!is_generator || !is_async);\012\012 if (is_async &amp;&amp; Check(Token::MUL)) {\012 // Async generator\012    is_generator = true;\012 }\012\012 IdentifierT name;\012 FunctionNameValidity name_validity;\012 IdentifierT variable_name;\012 if (default_export &amp;&amp; peek() == Token::LPAREN) {\012    impl()-&gt;GetDefaultStrings(&amp;name, &amp;variable_name);\012    name_validity = kSkipFunctionNameCheck;\012 } else {\012 bool is_strict_reserved;\012 bool is_await = false;\012    name = ParseIdentifierOrStrictReservedWord(&amp;is_strict_reserved, &amp;is_await,\012                                               CHECK_OK_CUSTOM(NullStatement));\012    name_validity = is_strict_reserved ? kFunctionNameIsStrictReserved\012 : kFunctionNameValidityUnknown;\012    variable_name = name;\012 }\012\012 FuncNameInferrer::State fni_state(fni_);\012  impl()-&gt;PushEnclosingName(name);\012\012 FunctionKind kind = FunctionKindFor(is_generator, is_async);\012\012 FunctionLiteralT function = impl()-&gt;ParseFunctionLiteral(\012      name, scanner()-&gt;location(), name_validity, kind, pos,\012 FunctionLiteral::kDeclaration, language_mode(), nullptr,\012      CHECK_OK_CUSTOM(NullStatement));\012\012 // In ES6, a function behaves as a lexical binding, except in\012 // a script scope, or the initial scope of eval or another function.\012 VariableMode mode =\012 (!scope()-&gt;is_declaration_scope() || scope()-&gt;is_module_scope())\012 ? VariableMode::kLet\012 : VariableMode::kVar;\012 // Async functions don't undergo sloppy mode block scoped hoisting, and don't\012 // allow duplicates in a block. Both are represented by the\012 // sloppy_block_function_map. Don't add them to the map for async functions.\012 // Generators are also supposed to be prohibited; currently doing this behind\012 // a flag and UseCounting violations to assess web compatibility.\012 bool is_sloppy_block_function = is_sloppy(language_mode()) &amp;&amp;\012 !scope()-&gt;is_declaration_scope() &amp;&amp;\012 !is_async &amp;&amp; !is_generator;\012\012 return impl()-&gt;DeclareFunction(variable_name, function, mode, pos,\012                                 is_sloppy_block_function, names, ok);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseClassDeclaration(\012 ZonePtrList&lt;const AstRawString&gt;* names, bool default_export, bool* ok) {\012 // ClassDeclaration ::\012 //   'class' Identifier ('extends' LeftHandExpression)? '{' ClassBody '}'\012 //   'class' ('extends' LeftHandExpression)? '{' ClassBody '}'\012 //\012 // The anonymous form is allowed iff [default_export] is true.\012 //\012 // 'class' is expected to be consumed by the caller.\012 //\012 // A ClassDeclaration\012 //\012 //   class C { ... }\012 //\012 // has the same semantics as:\012 //\012 //   let C = class C { ... };\012 //\012 // so rewrite it as such.\012\012 int class_token_pos = position();\012 IdentifierT name = impl()-&gt;NullIdentifier();\012 bool is_strict_reserved = false;\012 IdentifierT variable_name = impl()-&gt;NullIdentifier();\012 if (default_export &amp;&amp; (peek() == Token::EXTENDS || peek() == Token::LBRACE)) {\012    impl()-&gt;GetDefaultStrings(&amp;name, &amp;variable_name);\012 } else {\012 bool is_await = false;\012    name = ParseIdentifierOrStrictReservedWord(&amp;is_strict_reserved, &amp;is_await,\012                                               CHECK_OK_CUSTOM(NullStatement));\012    variable_name = name;\012 }\012\012 ExpressionClassifier no_classifier(this);\012 ExpressionT value =\012 ParseClassLiteral(name, scanner()-&gt;location(), is_strict_reserved,\012                        class_token_pos, CHECK_OK_CUSTOM(NullStatement));\012 int end_pos = position();\012 return impl()-&gt;DeclareClass(variable_name, value, names, class_token_pos,\012                              end_pos, ok);\012}\012\012// Language extension which is only enabled for source files loaded\012// through the API's extension mechanism.  A native function\012// declaration is resolved by looking up the function through a\012// callback provided by the extension.\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseNativeDeclaration(\012 bool* ok) {\012  function_state_-&gt;DisableOptimization(BailoutReason::kNativeFunctionLiteral);\012\012 int pos = peek_position();\012 Expect(Token::FUNCTION, CHECK_OK_CUSTOM(NullStatement));\012 // Allow &quot;eval&quot; or &quot;arguments&quot; for backward compatibility.\012 IdentifierT name = ParseIdentifier(kAllowRestrictedIdentifiers,\012                                     CHECK_OK_CUSTOM(NullStatement));\012 Expect(Token::LPAREN, CHECK_OK_CUSTOM(NullStatement));\012 if (peek() != Token::RPAREN) {\012 do {\012 ParseIdentifier(kAllowRestrictedIdentifiers,\012                      CHECK_OK_CUSTOM(NullStatement));\012 } while (Check(Token::COMMA));\012 }\012 Expect(Token::RPAREN, CHECK_OK_CUSTOM(NullStatement));\012 Expect(Token::SEMICOLON, CHECK_OK_CUSTOM(NullStatement));\012 return impl()-&gt;DeclareNative(name, pos, ok);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT\012ParserBase&lt;Impl&gt;::ParseAsyncFunctionDeclaration(\012 ZonePtrList&lt;const AstRawString&gt;* names, bool default_export, bool* ok) {\012 // AsyncFunctionDeclaration ::\012 //   async [no LineTerminator here] function BindingIdentifier[Await]\012 //       ( FormalParameters[Await] ) { AsyncFunctionBody }\012  DCHECK_EQ(scanner()-&gt;current_token(), Token::ASYNC);\012 int pos = position();\012 if (scanner()-&gt;HasLineTerminatorBeforeNext()) {\012 *ok = false;\012    impl()-&gt;ReportUnexpectedToken(scanner()-&gt;current_token());\012 return impl()-&gt;NullStatement();\012 }\012 Expect(Token::FUNCTION, CHECK_OK_CUSTOM(NullStatement));\012 ParseFunctionFlags flags = ParseFunctionFlags::kIsAsync;\012 return ParseHoistableDeclaration(pos, flags, names, default_export, ok);\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::ParseFunctionBody(\012 typename ParserBase&lt;Impl&gt;::StatementListT result, IdentifierT function_name,\012 int pos, const FormalParametersT&amp; parameters, FunctionKind kind,\012 FunctionLiteral::FunctionType function_type, bool* ok) {\012 DeclarationScope* function_scope = scope()-&gt;AsDeclarationScope();\012 DeclarationScope* inner_scope = function_scope;\012 BlockT inner_block = impl()-&gt;NullStatement();\012\012 StatementListT body = result;\012 if (!parameters.is_simple) {\012    inner_scope = NewVarblockScope();\012    inner_scope-&gt;set_start_position(scanner()-&gt;location().beg_pos);\012    inner_block = factory()-&gt;NewBlock(8, true);\012    inner_block-&gt;set_scope(inner_scope);\012    body = inner_block-&gt;statements();\012 }\012\012 // If we are parsing the source as if it is wrapped in a function, the source\012 // ends without a closing brace.\012 Token::Value closing_token =\012      function_type == FunctionLiteral::kWrapped ? Token::EOS : Token::RBRACE;\012\012 {\012 BlockState block_state(&amp;scope_, inner_scope);\012\012 if (IsResumableFunction(kind)) impl()-&gt;PrepareGeneratorVariables();\012\012 if (IsAsyncGeneratorFunction(kind)) {\012      impl()-&gt;ParseAndRewriteAsyncGeneratorFunctionBody(pos, kind, body, ok);\012 } else if (IsGeneratorFunction(kind)) {\012      impl()-&gt;ParseAndRewriteGeneratorFunctionBody(pos, kind, body, ok);\012 } else if (IsAsyncFunction(kind)) {\012 ParseAsyncFunctionBody(inner_scope, body, CHECK_OK_VOID);\012 } else {\012 ParseStatementList(body, closing_token, CHECK_OK_VOID);\012 }\012\012 if (IsDerivedConstructor(kind)) {\012      body-&gt;Add(factory()-&gt;NewReturnStatement(impl()-&gt;ThisExpression(),\012                                              kNoSourcePosition),\012                zone());\012 }\012 }\012\012 Expect(closing_token, CHECK_OK_VOID);\012  scope()-&gt;set_end_position(scanner()-&gt;location().end_pos);\012\012 if (!parameters.is_simple) {\012    DCHECK_NOT_NULL(inner_scope);\012    DCHECK_EQ(function_scope, scope());\012    DCHECK_EQ(function_scope, inner_scope-&gt;outer_scope());\012    impl()-&gt;SetLanguageMode(function_scope, inner_scope-&gt;language_mode());\012 BlockT init_block =\012        impl()-&gt;BuildParameterInitializationBlock(parameters, CHECK_OK_VOID);\012\012 if (is_sloppy(inner_scope-&gt;language_mode())) {\012      impl()-&gt;InsertSloppyBlockFunctionVarBindings(inner_scope);\012 }\012\012 // TODO(littledan): Merge the two rejection blocks into one\012 if (IsAsyncFunction(kind) &amp;&amp; !IsAsyncGeneratorFunction(kind)) {\012      init_block = impl()-&gt;BuildRejectPromiseOnException(init_block);\012 }\012\012    inner_scope-&gt;set_end_position(scanner()-&gt;location().end_pos);\012 if (inner_scope-&gt;FinalizeBlockScope() != nullptr) {\012      impl()-&gt;CheckConflictingVarDeclarations(inner_scope, CHECK_OK_VOID);\012      impl()-&gt;InsertShadowingVarBindingInitializers(inner_block);\012 } else {\012      inner_block-&gt;set_scope(nullptr);\012 }\012    inner_scope = nullptr;\012\012    result-&gt;Add(init_block, zone());\012    result-&gt;Add(inner_block, zone());\012 } else {\012    DCHECK_EQ(inner_scope, function_scope);\012 if (is_sloppy(function_scope-&gt;language_mode())) {\012      impl()-&gt;InsertSloppyBlockFunctionVarBindings(function_scope);\012 }\012 }\012\012 if (!IsArrowFunction(kind)) {\012 // Declare arguments after parsing the function since lexical 'arguments'\012 // masks the arguments object. Declare arguments before declaring the\012 // function var since the arguments object masks 'function arguments'.\012    function_scope-&gt;DeclareArguments(ast_value_factory());\012 }\012\012  impl()-&gt;DeclareFunctionNameVar(function_name, function_type, function_scope);\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::CheckArityRestrictions(int param_count,\012 FunctionKind function_kind,\012 bool has_rest,\012 int formals_start_pos,\012 int formals_end_pos, bool* ok) {\012 if (IsGetterFunction(function_kind)) {\012 if (param_count != 0) {\012      impl()-&gt;ReportMessageAt(\012 Scanner::Location(formals_start_pos, formals_end_pos),\012 MessageTemplate::kBadGetterArity);\012 *ok = false;\012 }\012 } else if (IsSetterFunction(function_kind)) {\012 if (param_count != 1) {\012      impl()-&gt;ReportMessageAt(\012 Scanner::Location(formals_start_pos, formals_end_pos),\012 MessageTemplate::kBadSetterArity);\012 *ok = false;\012 }\012 if (has_rest) {\012      impl()-&gt;ReportMessageAt(\012 Scanner::Location(formals_start_pos, formals_end_pos),\012 MessageTemplate::kBadSetterRestParameter);\012 *ok = false;\012 }\012 }\012}\012\012template &lt;typename Impl&gt;\012bool ParserBase&lt;Impl&gt;::IsNextLetKeyword() {\012  DCHECK(peek() == Token::LET);\012 Token::Value next_next = PeekAhead();\012 switch (next_next) {\012 case Token::LBRACE:\012 case Token::LBRACK:\012 case Token::IDENTIFIER:\012 case Token::STATIC:\012 case Token::LET: // `let let;` is disallowed by static semantics, but the\012 // token must be first interpreted as a keyword in order\012 // for those semantics to apply. This ensures that ASI is\012 // not honored when a LineTerminator separates the\012 // tokens.\012 case Token::YIELD:\012 case Token::AWAIT:\012 case Token::ASYNC:\012 return true;\012 case Token::FUTURE_STRICT_RESERVED_WORD:\012 return is_sloppy(language_mode());\012 default:\012 return false;\012 }\012}\012\012template &lt;typename Impl&gt;\012bool ParserBase&lt;Impl&gt;::IsTrivialExpression() {\012 Token::Value peek_token = peek();\012 if (peek_token == Token::SMI || peek_token == Token::NUMBER ||\012      peek_token == Token::BIGINT || peek_token == Token::NULL_LITERAL ||\012      peek_token == Token::TRUE_LITERAL || peek_token == Token::FALSE_LITERAL ||\012      peek_token == Token::STRING || peek_token == Token::IDENTIFIER ||\012      peek_token == Token::THIS) {\012 // PeekAhead() is expensive &amp; may not always be called, so we only call it\012 // after checking peek().\012 Token::Value peek_ahead = PeekAhead();\012 if (peek_ahead == Token::COMMA || peek_ahead == Token::RPAREN ||\012        peek_ahead == Token::SEMICOLON || peek_ahead == Token::RBRACK) {\012 return true;\012 }\012 }\012 return false;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT\012ParserBase&lt;Impl&gt;::ParseArrowFunctionLiteral(\012 bool accept_IN, const FormalParametersT&amp; formal_parameters,\012 int rewritable_length, bool* ok) {\012 const RuntimeCallCounterId counters[2][2] = {\012 {RuntimeCallCounterId::kParseBackgroundArrowFunctionLiteral,\012 RuntimeCallCounterId::kParseArrowFunctionLiteral},\012 {RuntimeCallCounterId::kPreParseBackgroundArrowFunctionLiteral,\012 RuntimeCallCounterId::kPreParseArrowFunctionLiteral}};\012 RuntimeCallTimerScope runtime_timer(\012      runtime_call_stats_,\012      counters[Impl::IsPreParser()][parsing_on_main_thread_]);\012 base::ElapsedTimer timer;\012 if (V8_UNLIKELY(FLAG_log_function_events)) timer.Start();\012\012 if (peek() == Token::ARROW &amp;&amp; scanner_-&gt;HasLineTerminatorBeforeNext()) {\012 // ASI inserts `;` after arrow parameters if a line terminator is found.\012 // `=&gt; ...` is never a valid expression, so report as syntax error.\012 // If next token is not `=&gt;`, it's a syntax error anyways.\012 ReportUnexpectedTokenAt(scanner_-&gt;peek_location(), Token::ARROW);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012\012 StatementListT body = impl()-&gt;NullStatementList();\012 int expected_property_count = -1;\012 int suspend_count = 0;\012 int function_literal_id = GetNextFunctionLiteralId();\012\012 FunctionKind kind = formal_parameters.scope-&gt;function_kind();\012 FunctionLiteral::EagerCompileHint eager_compile_hint =\012      default_eager_compile_hint_;\012 bool can_preparse = impl()-&gt;parse_lazily() &amp;&amp;\012                      eager_compile_hint == FunctionLiteral::kShouldLazyCompile;\012 // TODO(marja): consider lazy-parsing inner arrow functions too. is_this\012 // handling in Scope::ResolveVariable needs to change.\012 bool is_lazy_top_level_function =\012      can_preparse &amp;&amp; impl()-&gt;AllowsLazyParsingWithoutUnresolvedVariables();\012 bool has_braces = true;\012 ProducedPreParsedScopeData* produced_preparsed_scope_data = nullptr;\012 {\012 FunctionState function_state(&amp;function_state_, &amp;scope_,\012                                 formal_parameters.scope);\012\012 // Move any queued destructuring assignments which appeared\012 // in this function's parameter list into its own function_state.\012    function_state.AdoptDestructuringAssignmentsFromParentState(\012        rewritable_length);\012\012 Expect(Token::ARROW, CHECK_OK);\012\012 if (peek() == Token::LBRACE) {\012 // Multiple statement body\012      DCHECK_EQ(scope(), formal_parameters.scope);\012 if (is_lazy_top_level_function) {\012 // FIXME(marja): Arrow function parameters will be parsed even if the\012 // body is preparsed; move relevant parts of parameter handling to\012 // simulate consistent parameter handling.\012\012 // For arrow functions, we don't need to retrieve data about function\012 // parameters.\012 int dummy_num_parameters = -1;\012        DCHECK_NE(kind &amp; FunctionKind::kArrowFunction, 0);\012 LazyParsingResult result = impl()-&gt;SkipFunction(\012 nullptr, kind, FunctionLiteral::kAnonymousExpression,\012            formal_parameters.scope, &amp;dummy_num_parameters,\012 &amp;produced_preparsed_scope_data, false, false, CHECK_OK);\012        DCHECK_NE(result, kLazyParsingAborted);\012        DCHECK_NULL(produced_preparsed_scope_data);\012        USE(result);\012        formal_parameters.scope-&gt;ResetAfterPreparsing(ast_value_factory_,\012 false);\012 // Discard any queued destructuring assignments which appeared\012 // in this function's parameter list, and which were adopted\012 // into this function state, above.\012        function_state.RewindDestructuringAssignments(0);\012 } else {\012 Consume(Token::LBRACE);\012        body = impl()-&gt;NewStatementList(8);\012 ParseFunctionBody(body, impl()-&gt;NullIdentifier(), kNoSourcePosition,\012                          formal_parameters, kind,\012 FunctionLiteral::kAnonymousExpression, CHECK_OK);\012        expected_property_count = function_state.expected_property_count();\012 }\012 } else {\012 // Single-expression body\012      has_braces = false;\012 const bool is_async = IsAsyncFunction(kind);\012      body = impl()-&gt;NewStatementList(1);\012      impl()-&gt;AddParameterInitializationBlock(formal_parameters, body, is_async,\012                                              CHECK_OK);\012 ParseSingleExpressionFunctionBody(body, is_async, accept_IN, CHECK_OK);\012      expected_property_count = function_state.expected_property_count();\012 }\012\012    formal_parameters.scope-&gt;set_end_position(scanner()-&gt;location().end_pos);\012\012 // Arrow function formal parameters are parsed as StrictFormalParameterList,\012 // which is not the same as &quot;parameters of a strict function&quot;; it only means\012 // that duplicates are not allowed.  Of course, the arrow function may\012 // itself be strict as well.\012 const bool allow_duplicate_parameters = false;\012 ValidateFormalParameters(language_mode(), allow_duplicate_parameters,\012                             CHECK_OK);\012\012 // Validate strict mode.\012 if (is_strict(language_mode())) {\012 CheckStrictOctalLiteral(formal_parameters.scope-&gt;start_position(),\012                              scanner()-&gt;location().end_pos, CHECK_OK);\012 }\012    impl()-&gt;CheckConflictingVarDeclarations(formal_parameters.scope, CHECK_OK);\012\012    impl()-&gt;RewriteDestructuringAssignments();\012    suspend_count = function_state.suspend_count();\012 }\012\012 FunctionLiteralT function_literal = factory()-&gt;NewFunctionLiteral(\012      impl()-&gt;EmptyIdentifierString(), formal_parameters.scope, body,\012      expected_property_count, formal_parameters.num_parameters(),\012      formal_parameters.function_length,\012 FunctionLiteral::kNoDuplicateParameters,\012 FunctionLiteral::kAnonymousExpression, eager_compile_hint,\012      formal_parameters.scope-&gt;start_position(), has_braces,\012      function_literal_id, produced_preparsed_scope_data);\012\012  function_literal-&gt;set_suspend_count(suspend_count);\012  function_literal-&gt;set_function_token_position(\012      formal_parameters.scope-&gt;start_position());\012\012  impl()-&gt;AddFunctionForNameInference(function_literal);\012\012 if (V8_UNLIKELY((FLAG_log_function_events))) {\012 Scope* scope = formal_parameters.scope;\012 double ms = timer.Elapsed().InMillisecondsF();\012 const char* event_name =\012        is_lazy_top_level_function ? &quot;preparse-no-resolution&quot; : &quot;parse&quot;;\012 const char* name = &quot;arrow function&quot;;\012    logger_-&gt;FunctionEvent(event_name, script_id(), ms, scope-&gt;start_position(),\012                           scope-&gt;end_position(), name, strlen(name));\012 }\012\012 return function_literal;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParseClassLiteral(\012 IdentifierT name, Scanner::Location class_name_location,\012 bool name_is_strict_reserved, int class_token_pos, bool* ok) {\012 bool is_anonymous = impl()-&gt;IsNull(name);\012\012 // All parts of a ClassDeclaration and ClassExpression are strict code.\012 if (!is_anonymous) {\012 if (name_is_strict_reserved) {\012      impl()-&gt;ReportMessageAt(class_name_location,\012 MessageTemplate::kUnexpectedStrictReserved);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012 if (impl()-&gt;IsEvalOrArguments(name)) {\012      impl()-&gt;ReportMessageAt(class_name_location,\012 MessageTemplate::kStrictEvalArguments);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012 }\012\012 Scope* block_scope = NewScope(BLOCK_SCOPE);\012 BlockState block_state(&amp;scope_, block_scope);\012 RaiseLanguageMode(LanguageMode::kStrict);\012\012 ClassInfo class_info(this);\012  class_info.is_anonymous = is_anonymous;\012  impl()-&gt;DeclareClassVariable(name, &amp;class_info, class_token_pos, CHECK_OK);\012\012  scope()-&gt;set_start_position(scanner()-&gt;location().end_pos);\012 if (Check(Token::EXTENDS)) {\012 FuncNameInferrer::State fni_state(fni_);\012 ExpressionClassifier extends_classifier(this);\012    class_info.extends = ParseLeftHandSideExpression(CHECK_OK);\012 ValidateExpression(CHECK_OK);\012 AccumulateFormalParameterContainmentErrors();\012 }\012\012 ClassLiteralChecker checker(this);\012\012 Expect(Token::LBRACE, CHECK_OK);\012\012 const bool has_extends = !impl()-&gt;IsNull(class_info.extends);\012 while (peek() != Token::RBRACE) {\012 if (Check(Token::SEMICOLON)) continue;\012 FuncNameInferrer::State fni_state(fni_);\012 bool is_computed_name = false; // Classes do not care about computed\012 // property names here.\012 bool is_static;\012 ClassLiteralProperty::Kind property_kind;\012 ExpressionClassifier property_classifier(this);\012 IdentifierT property_name;\012 // If we haven't seen the constructor yet, it potentially is the next\012 // property.\012 bool is_constructor = !class_info.has_seen_constructor;\012 ClassLiteralPropertyT property = ParseClassPropertyDefinition(\012 &amp;checker, &amp;class_info, &amp;property_name, has_extends, &amp;is_computed_name,\012 &amp;property_kind, &amp;is_static, CHECK_OK);\012 if (!class_info.has_static_computed_names &amp;&amp; is_static &amp;&amp;\012        is_computed_name) {\012      class_info.has_static_computed_names = true;\012 }\012 if (is_computed_name &amp;&amp;\012        property_kind == ClassLiteralProperty::PUBLIC_FIELD) {\012      class_info.computed_field_count++;\012 }\012    is_constructor &amp;= class_info.has_seen_constructor;\012 ValidateExpression(CHECK_OK);\012 AccumulateFormalParameterContainmentErrors();\012\012    impl()-&gt;DeclareClassProperty(name, property, property_name, property_kind,\012                                 is_static, is_constructor, is_computed_name,\012 &amp;class_info, CHECK_OK);\012    impl()-&gt;InferFunctionName();\012 }\012\012 Expect(Token::RBRACE, CHECK_OK);\012 int end_pos = scanner()-&gt;location().end_pos;\012  block_scope-&gt;set_end_position(end_pos);\012 return impl()-&gt;RewriteClassLiteral(block_scope, name, &amp;class_info,\012                                     class_token_pos, end_pos, ok);\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::ParseSingleExpressionFunctionBody(StatementListT body,\012 bool is_async,\012 bool accept_IN,\012 bool* ok) {\012 if (is_async) impl()-&gt;PrepareGeneratorVariables();\012\012 ExpressionClassifier classifier(this);\012 ExpressionT expression = ParseAssignmentExpression(accept_IN, CHECK_OK_VOID);\012 ValidateExpression(CHECK_OK_VOID);\012\012 if (is_async) {\012 BlockT block = factory()-&gt;NewBlock(1, true);\012    impl()-&gt;RewriteAsyncFunctionBody(body, block, expression, CHECK_OK_VOID);\012 } else {\012    body-&gt;Add(BuildReturnStatement(expression, expression-&gt;position()), zone());\012 }\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::ParseAsyncFunctionBody(Scope* scope, StatementListT body,\012 bool* ok) {\012 BlockT block = factory()-&gt;NewBlock(8, true);\012\012 ParseStatementList(block-&gt;statements(), Token::RBRACE, CHECK_OK_VOID);\012  impl()-&gt;RewriteAsyncFunctionBody(\012      body, block, factory()-&gt;NewUndefinedLiteral(kNoSourcePosition),\012      CHECK_OK_VOID);\012  scope-&gt;set_end_position(scanner()-&gt;location().end_pos);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT\012ParserBase&lt;Impl&gt;::ParseAsyncFunctionLiteral(bool* ok) {\012 // AsyncFunctionLiteral ::\012 //   async [no LineTerminator here] function ( FormalParameters[Await] )\012 //       { AsyncFunctionBody }\012 //\012 //   async [no LineTerminator here] function BindingIdentifier[Await]\012 //       ( FormalParameters[Await] ) { AsyncFunctionBody }\012  DCHECK_EQ(scanner()-&gt;current_token(), Token::ASYNC);\012 int pos = position();\012 Expect(Token::FUNCTION, CHECK_OK);\012 bool is_strict_reserved = false;\012 IdentifierT name = impl()-&gt;NullIdentifier();\012 FunctionLiteral::FunctionType type = FunctionLiteral::kAnonymousExpression;\012\012 bool is_generator = Check(Token::MUL);\012 const bool kIsAsync = true;\012 const FunctionKind kind = FunctionKindFor(is_generator, kIsAsync);\012\012 if (impl()-&gt;ParsingDynamicFunctionDeclaration()) {\012 // We don't want dynamic functions to actually declare their name\012 // &quot;anonymous&quot;. We just want that name in the toString().\012 if (stack_overflow()) {\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012 Consume(Token::IDENTIFIER);\012    DCHECK(scanner()-&gt;CurrentMatchesContextual(Token::ANONYMOUS));\012 } else if (peek_any_identifier()) {\012    type = FunctionLiteral::kNamedExpression;\012 bool is_await = false;\012    name = ParseIdentifierOrStrictReservedWord(kind, &amp;is_strict_reserved,\012 &amp;is_await, CHECK_OK);\012 // If the function name is &quot;await&quot;, ParseIdentifierOrStrictReservedWord\012 // recognized the error.\012    DCHECK(!is_await);\012 }\012 return impl()-&gt;ParseFunctionLiteral(\012      name, scanner()-&gt;location(),\012      is_strict_reserved ? kFunctionNameIsStrictReserved\012 : kFunctionNameValidityUnknown,\012      kind, pos, type, language_mode(), nullptr, CHECK_OK);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParseTemplateLiteral(\012 ExpressionT tag, int start, bool tagged, bool* ok) {\012 // A TemplateLiteral is made up of 0 or more TEMPLATE_SPAN tokens (literal\012 // text followed by a substitution expression), finalized by a single\012 // TEMPLATE_TAIL.\012 //\012 // In terms of draft language, TEMPLATE_SPAN may be either the TemplateHead or\012 // TemplateMiddle productions, while TEMPLATE_TAIL is either TemplateTail, or\012 // NoSubstitutionTemplate.\012 //\012 // When parsing a TemplateLiteral, we must have scanned either an initial\012 // TEMPLATE_SPAN, or a TEMPLATE_TAIL.\012  DCHECK(peek() == Token::TEMPLATE_SPAN || peek() == Token::TEMPLATE_TAIL);\012\012 if (tagged) {\012 // TaggedTemplate expressions prevent the eval compilation cache from being\012 // used. This flag is only used if an eval is being parsed.\012    set_allow_eval_cache(false);\012 }\012\012 bool forbid_illegal_escapes = !tagged;\012\012 // If we reach a TEMPLATE_TAIL first, we are parsing a NoSubstitutionTemplate.\012 // In this case we may simply consume the token and build a template with a\012 // single TEMPLATE_SPAN and no expressions.\012 if (peek() == Token::TEMPLATE_TAIL) {\012 Consume(Token::TEMPLATE_TAIL);\012 int pos = position();\012 typename Impl::TemplateLiteralState ts = impl()-&gt;OpenTemplateLiteral(pos);\012 bool is_valid = CheckTemplateEscapes(forbid_illegal_escapes, CHECK_OK);\012    impl()-&gt;AddTemplateSpan(&amp;ts, is_valid, true);\012 return impl()-&gt;CloseTemplateLiteral(&amp;ts, start, tag);\012 }\012\012 Consume(Token::TEMPLATE_SPAN);\012 int pos = position();\012 typename Impl::TemplateLiteralState ts = impl()-&gt;OpenTemplateLiteral(pos);\012 bool is_valid = CheckTemplateEscapes(forbid_illegal_escapes, CHECK_OK);\012  impl()-&gt;AddTemplateSpan(&amp;ts, is_valid, false);\012 Token::Value next;\012\012 // If we open with a TEMPLATE_SPAN, we must scan the subsequent expression,\012 // and repeat if the following token is a TEMPLATE_SPAN as well (in this\012 // case, representing a TemplateMiddle).\012\012 do {\012 next = peek();\012 if (next == Token::EOS) {\012      impl()-&gt;ReportMessageAt(Scanner::Location(start, peek_position()),\012 MessageTemplate::kUnterminatedTemplate);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 } else if (next == Token::ILLEGAL) {\012      impl()-&gt;ReportMessageAt(\012 Scanner::Location(position() + 1, peek_position()),\012 MessageTemplate::kUnexpectedToken, &quot;ILLEGAL&quot;, kSyntaxError);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012\012 int expr_pos = peek_position();\012 ExpressionT expression = ParseExpressionCoverGrammar(true, CHECK_OK);\012 ValidateExpression(CHECK_OK);\012    impl()-&gt;AddTemplateExpression(&amp;ts, expression);\012\012 if (peek() != Token::RBRACE) {\012      impl()-&gt;ReportMessageAt(Scanner::Location(expr_pos, peek_position()),\012 MessageTemplate::kUnterminatedTemplateExpr);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012\012 // If we didn't die parsing that expression, our next token should be a\012 // TEMPLATE_SPAN or TEMPLATE_TAIL.\012 next = scanner()-&gt;ScanTemplateContinuation();\012 Next();\012    pos = position();\012\012 if (next == Token::EOS) {\012      impl()-&gt;ReportMessageAt(Scanner::Location(start, pos),\012 MessageTemplate::kUnterminatedTemplate);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 } else if (next == Token::ILLEGAL) {\012      impl()-&gt;ReportMessageAt(\012 Scanner::Location(position() + 1, peek_position()),\012 MessageTemplate::kUnexpectedToken, &quot;ILLEGAL&quot;, kSyntaxError);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012\012 bool is_valid = CheckTemplateEscapes(forbid_illegal_escapes, CHECK_OK);\012    impl()-&gt;AddTemplateSpan(&amp;ts, is_valid, next == Token::TEMPLATE_TAIL);\012 } while (next == Token::TEMPLATE_SPAN);\012\012  DCHECK_EQ(next, Token::TEMPLATE_TAIL);\012 // Once we've reached a TEMPLATE_TAIL, we can close the TemplateLiteral.\012 return impl()-&gt;CloseTemplateLiteral(&amp;ts, start, tag);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT\012ParserBase&lt;Impl&gt;::CheckAndRewriteReferenceExpression(\012 ExpressionT expression, int beg_pos, int end_pos,\012 MessageTemplate::Template message, bool* ok) {\012 return CheckAndRewriteReferenceExpression(expression, beg_pos, end_pos,\012                                            message, kReferenceError, ok);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT\012ParserBase&lt;Impl&gt;::CheckAndRewriteReferenceExpression(\012 ExpressionT expression, int beg_pos, int end_pos,\012 MessageTemplate::Template message, ParseErrorType type, bool* ok) {\012 if (impl()-&gt;IsIdentifier(expression) &amp;&amp; is_strict(language_mode()) &amp;&amp;\012      impl()-&gt;IsEvalOrArguments(impl()-&gt;AsIdentifier(expression))) {\012 ReportMessageAt(Scanner::Location(beg_pos, end_pos),\012 MessageTemplate::kStrictEvalArguments, kSyntaxError);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012 if (expression-&gt;IsValidReferenceExpression()) {\012 return expression;\012 }\012 if (expression-&gt;IsCall() &amp;&amp; !expression-&gt;AsCall()-&gt;is_tagged_template()) {\012 // If it is a call, make it a runtime error for legacy web compatibility.\012 // Bug: https://bugs.chromium.org/p/v8/issues/detail?id=4480\012 // Rewrite `expr' to `expr[throw ReferenceError]'.\012    impl()-&gt;CountUsage(\012        is_strict(language_mode())\012 ? v8::Isolate::kAssigmentExpressionLHSIsCallInStrict\012 : v8::Isolate::kAssigmentExpressionLHSIsCallInSloppy);\012 ExpressionT error = impl()-&gt;NewThrowReferenceError(message, beg_pos);\012 return factory()-&gt;NewProperty(expression, error, beg_pos);\012 }\012 ReportMessageAt(Scanner::Location(beg_pos, end_pos), message, type);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012}\012\012template &lt;typename Impl&gt;\012bool ParserBase&lt;Impl&gt;::IsValidReferenceExpression(ExpressionT expression) {\012 return IsAssignableIdentifier(expression) || expression-&gt;IsProperty();\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::CheckDestructuringElement(ExpressionT expression,\012 int begin, int end) {\012 if (!IsValidPattern(expression) &amp;&amp; !expression-&gt;IsAssignment() &amp;&amp;\012 !IsValidReferenceExpression(expression)) {\012    classifier()-&gt;RecordAssignmentPatternError(\012 Scanner::Location(begin, end),\012 MessageTemplate::kInvalidDestructuringTarget);\012 }\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParseV8Intrinsic(\012 bool* ok) {\012 // CallRuntime ::\012 //   '%' Identifier Arguments\012\012 int pos = peek_position();\012 Expect(Token::MOD, CHECK_OK);\012 // Allow &quot;eval&quot; or &quot;arguments&quot; for backward compatibility.\012 IdentifierT name = ParseIdentifier(kAllowRestrictedIdentifiers, CHECK_OK);\012 Scanner::Location spread_pos;\012 ExpressionClassifier classifier(this);\012 ExpressionListT args = ParseArguments(&amp;spread_pos, CHECK_OK);\012\012 if (spread_pos.IsValid()) {\012 *ok = false;\012 ReportMessageAt(spread_pos, MessageTemplate::kIntrinsicWithSpread,\012                    kSyntaxError);\012 return impl()-&gt;NullExpression();\012 }\012\012 return impl()-&gt;NewV8Intrinsic(name, args, pos, ok);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParseDoExpression(\012 bool* ok) {\012 // AssignmentExpression ::\012 //     do '{' StatementList '}'\012\012 int pos = peek_position();\012 Expect(Token::DO, CHECK_OK);\012 BlockT block = ParseBlock(nullptr, CHECK_OK);\012 return impl()-&gt;RewriteDoExpression(block, pos, ok);\012}\012\012// Redefinition of CHECK_OK for parsing statements.\012#undef CHECK_OK\012#define CHECK_OK CHECK_OK_CUSTOM(NullStatement)\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::LazyParsingResult\012ParserBase&lt;Impl&gt;::ParseStatementList(StatementListT body,\012 Token::Value end_token, bool may_abort,\012 bool* ok) {\012 // StatementList ::\012 //   (StatementListItem)* &lt;end_token&gt;\012\012 // Allocate a target stack to use for this set of source\012 // elements. This way, all scripts and functions get their own\012 // target stack thus avoiding illegal breaks and continues across\012 // functions.\012 typename Types::TargetScope target_scope(this);\012 int count_statements = 0;\012\012  DCHECK(!impl()-&gt;IsNull(body));\012 bool directive_prologue = true; // Parsing directive prologue.\012\012 while (peek() != end_token) {\012 if (directive_prologue &amp;&amp; peek() != Token::STRING) {\012      directive_prologue = false;\012 }\012\012 bool starts_with_identifier = peek() == Token::IDENTIFIER;\012 Scanner::Location token_loc = scanner()-&gt;peek_location();\012 StatementT stat =\012 ParseStatementListItem(CHECK_OK_CUSTOM(Return, kLazyParsingComplete));\012\012 if (impl()-&gt;IsNull(stat) || stat-&gt;IsEmptyStatement()) {\012      directive_prologue = false; // End of directive prologue.\012 continue;\012 }\012\012 if (directive_prologue) {\012 // The length of the token is used to distinguish between strings literals\012 // that evaluate equal to directives but contain either escape sequences\012 // (e.g., &quot;use \x73trict&quot;) or line continuations (e.g., &quot;use \(newline)\012 // strict&quot;).\012 if (impl()-&gt;IsUseStrictDirective(stat) &amp;&amp;\012          token_loc.end_pos - token_loc.beg_pos == sizeof(&quot;use strict&quot;) + 1) {\012 // Directive &quot;use strict&quot; (ES5 14.1).\012 RaiseLanguageMode(LanguageMode::kStrict);\012 if (!scope()-&gt;HasSimpleParameters()) {\012 // TC39 deemed &quot;use strict&quot; directives to be an error when occurring\012 // in the body of a function with non-simple parameter list, on\012 // 29/7/2015. https://goo.gl/ueA7Ln\012          impl()-&gt;ReportMessageAt(\012              token_loc, MessageTemplate::kIllegalLanguageModeDirective,\012 &quot;use strict&quot;);\012 *ok = false;\012 return kLazyParsingComplete;\012 }\012 } else if (impl()-&gt;IsUseAsmDirective(stat) &amp;&amp;\012                 token_loc.end_pos - token_loc.beg_pos ==\012 sizeof(&quot;use asm&quot;) + 1) {\012 // Directive &quot;use asm&quot;.\012        impl()-&gt;SetAsmModule();\012 } else if (impl()-&gt;IsStringLiteral(stat)) {\012 // Possibly an unknown directive.\012 // Should not change mode, but will increment usage counters\012 // as appropriate. Ditto usages below.\012 RaiseLanguageMode(LanguageMode::kSloppy);\012 } else {\012 // End of the directive prologue.\012        directive_prologue = false;\012 RaiseLanguageMode(LanguageMode::kSloppy);\012 }\012 } else {\012 RaiseLanguageMode(LanguageMode::kSloppy);\012 }\012\012 // If we're allowed to abort, we will do so when we see a &quot;long and\012 // trivial&quot; function. Our current definition of &quot;long and trivial&quot; is:\012 // - over kLazyParseTrialLimit statements\012 // - all starting with an identifier (i.e., no if, for, while, etc.)\012 if (may_abort) {\012 if (!starts_with_identifier) {\012        may_abort = false;\012 } else if (++count_statements &gt; kLazyParseTrialLimit) {\012 return kLazyParsingAborted;\012 }\012 }\012\012    body-&gt;Add(stat, zone());\012 }\012 return kLazyParsingComplete;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseStatementListItem(\012 bool* ok) {\012 // ECMA 262 6th Edition\012 // StatementListItem[Yield, Return] :\012 //   Statement[?Yield, ?Return]\012 //   Declaration[?Yield]\012 //\012 // Declaration[Yield] :\012 //   HoistableDeclaration[?Yield]\012 //   ClassDeclaration[?Yield]\012 //   LexicalDeclaration[In, ?Yield]\012 //\012 // HoistableDeclaration[Yield, Default] :\012 //   FunctionDeclaration[?Yield, ?Default]\012 //   GeneratorDeclaration[?Yield, ?Default]\012 //\012 // LexicalDeclaration[In, Yield] :\012 //   LetOrConst BindingList[?In, ?Yield] ;\012\012 switch (peek()) {\012 case Token::FUNCTION:\012 return ParseHoistableDeclaration(nullptr, false, ok);\012 case Token::CLASS:\012 Consume(Token::CLASS);\012 return ParseClassDeclaration(nullptr, false, ok);\012 case Token::VAR:\012 case Token::CONST:\012 return ParseVariableStatement(kStatementListItem, nullptr, ok);\012 case Token::LET:\012 if (IsNextLetKeyword()) {\012 return ParseVariableStatement(kStatementListItem, nullptr, ok);\012 }\012 break;\012 case Token::ASYNC:\012 if (PeekAhead() == Token::FUNCTION &amp;&amp;\012 !scanner()-&gt;HasLineTerminatorAfterNext()) {\012 Consume(Token::ASYNC);\012 return ParseAsyncFunctionDeclaration(nullptr, false, ok);\012 }\012 break;\012 default:\012 break;\012 }\012 return ParseStatement(nullptr, nullptr, kAllowLabelledFunctionStatement, ok);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseStatement(\012 ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels,\012 AllowLabelledFunctionStatement allow_function, bool* ok) {\012 // Statement ::\012 //   Block\012 //   VariableStatement\012 //   EmptyStatement\012 //   ExpressionStatement\012 //   IfStatement\012 //   IterationStatement\012 //   ContinueStatement\012 //   BreakStatement\012 //   ReturnStatement\012 //   WithStatement\012 //   LabelledStatement\012 //   SwitchStatement\012 //   ThrowStatement\012 //   TryStatement\012 //   DebuggerStatement\012\012 // {own_labels} is always a subset of {labels}.\012  DCHECK_IMPLIES(labels == nullptr, own_labels == nullptr);\012\012 // Note: Since labels can only be used by 'break' and 'continue'\012 // statements, which themselves are only valid within blocks,\012 // iterations or 'switch' statements (i.e., BreakableStatements),\012 // labels can be simply ignored in all other cases; except for\012 // trivial labeled break statements 'label: break label' which is\012 // parsed into an empty statement.\012 switch (peek()) {\012 case Token::LBRACE:\012 return ParseBlock(labels, ok);\012 case Token::SEMICOLON:\012 Next();\012 return factory()-&gt;NewEmptyStatement(kNoSourcePosition);\012 case Token::IF:\012 return ParseIfStatement(labels, ok);\012 case Token::DO:\012 return ParseDoWhileStatement(labels, own_labels, ok);\012 case Token::WHILE:\012 return ParseWhileStatement(labels, own_labels, ok);\012 case Token::FOR:\012 if (V8_UNLIKELY(is_async_function() &amp;&amp; PeekAhead() == Token::AWAIT)) {\012 return ParseForAwaitStatement(labels, own_labels, ok);\012 }\012 return ParseForStatement(labels, own_labels, ok);\012 case Token::CONTINUE:\012 return ParseContinueStatement(ok);\012 case Token::BREAK:\012 return ParseBreakStatement(labels, ok);\012 case Token::RETURN:\012 return ParseReturnStatement(ok);\012 case Token::THROW:\012 return ParseThrowStatement(ok);\012 case Token::TRY: {\012 // It is somewhat complicated to have labels on try-statements.\012 // When breaking out of a try-finally statement, one must take\012 // great care not to treat it as a fall-through. It is much easier\012 // just to wrap the entire try-statement in a statement block and\012 // put the labels there.\012 if (labels == nullptr) return ParseTryStatement(ok);\012 BlockT result = factory()-&gt;NewBlock(1, false, labels);\012 typename Types::Target target(this, result);\012 StatementT statement = ParseTryStatement(CHECK_OK);\012      result-&gt;statements()-&gt;Add(statement, zone());\012 return result;\012 }\012 case Token::WITH:\012 return ParseWithStatement(labels, ok);\012 case Token::SWITCH:\012 return ParseSwitchStatement(labels, ok);\012 case Token::FUNCTION:\012 // FunctionDeclaration only allowed as a StatementListItem, not in\012 // an arbitrary Statement position. Exceptions such as\012 // ES#sec-functiondeclarations-in-ifstatement-statement-clauses\012 // are handled by calling ParseScopedStatement rather than\012 // ParseStatement directly.\012      impl()-&gt;ReportMessageAt(scanner()-&gt;peek_location(),\012                              is_strict(language_mode())\012 ? MessageTemplate::kStrictFunction\012 : MessageTemplate::kSloppyFunction);\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 case Token::DEBUGGER:\012 return ParseDebuggerStatement(ok);\012 case Token::VAR:\012 return ParseVariableStatement(kStatement, nullptr, ok);\012 case Token::ASYNC:\012 if (!scanner()-&gt;HasLineTerminatorAfterNext() &amp;&amp;\012 PeekAhead() == Token::FUNCTION) {\012        impl()-&gt;ReportMessageAt(\012            scanner()-&gt;peek_location(),\012 MessageTemplate::kAsyncFunctionInSingleStatementContext);\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 }\012      V8_FALLTHROUGH;\012 default:\012 return ParseExpressionOrLabelledStatement(labels, own_labels,\012                                                allow_function, ok);\012 }\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::BlockT ParserBase&lt;Impl&gt;::ParseBlock(\012 ZonePtrList&lt;const AstRawString&gt;* labels, bool* ok) {\012 // Block ::\012 //   '{' StatementList '}'\012\012 // Construct block expecting 16 statements.\012 BlockT body = factory()-&gt;NewBlock(16, false, labels);\012\012 // Parse the statements and collect escaping labels.\012 Expect(Token::LBRACE, CHECK_OK_CUSTOM(NullStatement));\012 {\012 BlockState block_state(zone(), &amp;scope_);\012    scope()-&gt;set_start_position(scanner()-&gt;location().beg_pos);\012 typename Types::Target target(this, body);\012\012 while (peek() != Token::RBRACE) {\012 StatementT stat = ParseStatementListItem(CHECK_OK_CUSTOM(NullStatement));\012 if (!impl()-&gt;IsNull(stat) &amp;&amp; !stat-&gt;IsEmptyStatement()) {\012        body-&gt;statements()-&gt;Add(stat, zone());\012 }\012 }\012\012 Expect(Token::RBRACE, CHECK_OK_CUSTOM(NullStatement));\012 int end_pos = scanner()-&gt;location().end_pos;\012    scope()-&gt;set_end_position(end_pos);\012    impl()-&gt;RecordBlockSourceRange(body, end_pos);\012    body-&gt;set_scope(scope()-&gt;FinalizeBlockScope());\012 }\012 return body;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseScopedStatement(\012 ZonePtrList&lt;const AstRawString&gt;* labels, bool* ok) {\012 if (is_strict(language_mode()) || peek() != Token::FUNCTION) {\012 return ParseStatement(labels, nullptr, ok);\012 } else {\012 // Make a block around the statement for a lexical binding\012 // is introduced by a FunctionDeclaration.\012 BlockState block_state(zone(), &amp;scope_);\012    scope()-&gt;set_start_position(scanner()-&gt;location().beg_pos);\012 BlockT block = factory()-&gt;NewBlock(1, false);\012 StatementT body = ParseFunctionDeclaration(CHECK_OK);\012    block-&gt;statements()-&gt;Add(body, zone());\012    scope()-&gt;set_end_position(scanner()-&gt;location().end_pos);\012    block-&gt;set_scope(scope()-&gt;FinalizeBlockScope());\012 return block;\012 }\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseVariableStatement(\012 VariableDeclarationContext var_context,\012 ZonePtrList&lt;const AstRawString&gt;* names, bool* ok) {\012 // VariableStatement ::\012 //   VariableDeclarations ';'\012\012 // The scope of a var declared variable anywhere inside a function\012 // is the entire function (ECMA-262, 3rd, 10.1.3, and 12.2). Thus we can\012 // transform a source-level var declaration into a (Function) Scope\012 // declaration, and rewrite the source-level initialization into an assignment\012 // statement. We use a block to collect multiple assignments.\012 //\012 // We mark the block as initializer block because we don't want the\012 // rewriter to add a '.result' assignment to such a block (to get compliant\012 // behavior for code such as print(eval('var x = 7')), and for cosmetic\012 // reasons when pretty-printing. Also, unless an assignment (initialization)\012 // is inside an initializer block, it is ignored.\012\012 DeclarationParsingResult parsing_result;\012 StatementT result =\012 ParseVariableDeclarations(var_context, &amp;parsing_result, names, CHECK_OK);\012 ExpectSemicolon(CHECK_OK);\012 return result;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseDebuggerStatement(\012 bool* ok) {\012 // In ECMA-262 'debugger' is defined as a reserved keyword. In some browser\012 // contexts this is used as a statement which invokes the debugger as i a\012 // break point is present.\012 // DebuggerStatement ::\012 //   'debugger' ';'\012\012 int pos = peek_position();\012 Expect(Token::DEBUGGER, CHECK_OK);\012 ExpectSemicolon(CHECK_OK);\012 return factory()-&gt;NewDebuggerStatement(pos);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT\012ParserBase&lt;Impl&gt;::ParseExpressionOrLabelledStatement(\012 ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels,\012 AllowLabelledFunctionStatement allow_function, bool* ok) {\012 // ExpressionStatement | LabelledStatement ::\012 //   Expression ';'\012 //   Identifier ':' Statement\012 //\012 // ExpressionStatement[Yield] :\012 //   [lookahead notin {{, function, class, let [}] Expression[In, ?Yield] ;\012\012 int pos = peek_position();\012\012 switch (peek()) {\012 case Token::FUNCTION:\012 case Token::LBRACE:\012      UNREACHABLE(); // Always handled by the callers.\012 case Token::CLASS:\012 ReportUnexpectedToken(Next());\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 case Token::LET: {\012 Token::Value next_next = PeekAhead();\012 // &quot;let&quot; followed by either &quot;[&quot;, &quot;{&quot; or an identifier means a lexical\012 // declaration, which should not appear here.\012 // However, ASI may insert a line break before an identifier or a brace.\012 if (next_next != Token::LBRACK &amp;&amp;\012 ((next_next != Token::LBRACE &amp;&amp; next_next != Token::IDENTIFIER) ||\012           scanner_-&gt;HasLineTerminatorAfterNext())) {\012 break;\012 }\012      impl()-&gt;ReportMessageAt(scanner()-&gt;peek_location(),\012 MessageTemplate::kUnexpectedLexicalDeclaration);\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 }\012 default:\012 break;\012 }\012\012 bool starts_with_identifier = peek_any_identifier();\012 ExpressionT expr = ParseExpression(true, CHECK_OK);\012 if (peek() == Token::COLON &amp;&amp; starts_with_identifier &amp;&amp;\012      impl()-&gt;IsIdentifier(expr)) {\012 // The whole expression was a single identifier, and not, e.g.,\012 // something starting with an identifier or a parenthesized identifier.\012    impl()-&gt;DeclareLabel(&amp;labels, &amp;own_labels,\012                         impl()-&gt;AsIdentifierExpression(expr), CHECK_OK);\012 Consume(Token::COLON);\012 // ES#sec-labelled-function-declarations Labelled Function Declarations\012 if (peek() == Token::FUNCTION &amp;&amp; is_sloppy(language_mode()) &amp;&amp;\012        allow_function == kAllowLabelledFunctionStatement) {\012 return ParseFunctionDeclaration(ok);\012 }\012 return ParseStatement(labels, own_labels, allow_function, ok);\012 }\012\012 // If we have an extension, we allow a native function declaration.\012 // A native function declaration starts with &quot;native function&quot; with\012 // no line-terminator between the two words.\012 if (extension_ != nullptr &amp;&amp; peek() == Token::FUNCTION &amp;&amp;\012 !scanner()-&gt;HasLineTerminatorBeforeNext() &amp;&amp; impl()-&gt;IsNative(expr) &amp;&amp;\012 !scanner()-&gt;literal_contains_escapes()) {\012 return ParseNativeDeclaration(ok);\012 }\012\012 // Parsed expression statement, followed by semicolon.\012 ExpectSemicolon(CHECK_OK);\012 return factory()-&gt;NewExpressionStatement(expr, pos);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseIfStatement(\012 ZonePtrList&lt;const AstRawString&gt;* labels, bool* ok) {\012 // IfStatement ::\012 //   'if' '(' Expression ')' Statement ('else' Statement)?\012\012 int pos = peek_position();\012 Expect(Token::IF, CHECK_OK);\012 Expect(Token::LPAREN, CHECK_OK);\012 ExpressionT condition = ParseExpression(true, CHECK_OK);\012 Expect(Token::RPAREN, CHECK_OK);\012\012 SourceRange then_range, else_range;\012 StatementT then_statement = impl()-&gt;NullStatement();\012 {\012 SourceRangeScope range_scope(scanner(), &amp;then_range);\012    then_statement = ParseScopedStatement(labels, CHECK_OK);\012 }\012\012 StatementT else_statement = impl()-&gt;NullStatement();\012 if (Check(Token::ELSE)) {\012    else_range = SourceRange::ContinuationOf(then_range);\012    else_statement = ParseScopedStatement(labels, CHECK_OK);\012    else_range.end = scanner_-&gt;location().end_pos;\012 } else {\012    else_statement = factory()-&gt;NewEmptyStatement(kNoSourcePosition);\012 }\012 StatementT stmt =\012      factory()-&gt;NewIfStatement(condition, then_statement, else_statement, pos);\012  impl()-&gt;RecordIfStatementSourceRange(stmt, then_range, else_range);\012 return stmt;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseContinueStatement(\012 bool* ok) {\012 // ContinueStatement ::\012 //   'continue' Identifier? ';'\012\012 int pos = peek_position();\012 Expect(Token::CONTINUE, CHECK_OK);\012 IdentifierT label = impl()-&gt;NullIdentifier();\012 Token::Value tok = peek();\012 if (!scanner()-&gt;HasLineTerminatorBeforeNext() &amp;&amp; tok != Token::SEMICOLON &amp;&amp;\012      tok != Token::RBRACE &amp;&amp; tok != Token::EOS) {\012 // ECMA allows &quot;eval&quot; or &quot;arguments&quot; as labels even in strict mode.\012    label = ParseIdentifier(kAllowRestrictedIdentifiers, CHECK_OK);\012 }\012 typename Types::IterationStatement target =\012      impl()-&gt;LookupContinueTarget(label, CHECK_OK);\012 if (impl()-&gt;IsNull(target)) {\012 // Illegal continue statement.\012 MessageTemplate::Template message = MessageTemplate::kIllegalContinue;\012 typename Types::BreakableStatement breakable_target =\012        impl()-&gt;LookupBreakTarget(label, CHECK_OK);\012 if (impl()-&gt;IsNull(label)) {\012      message = MessageTemplate::kNoIterationStatement;\012 } else if (impl()-&gt;IsNull(breakable_target)) {\012      message = MessageTemplate::kUnknownLabel;\012 }\012 ReportMessage(message, label);\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 }\012 ExpectSemicolon(CHECK_OK);\012 StatementT stmt = factory()-&gt;NewContinueStatement(target, pos);\012  impl()-&gt;RecordJumpStatementSourceRange(stmt, scanner_-&gt;location().end_pos);\012 return stmt;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseBreakStatement(\012 ZonePtrList&lt;const AstRawString&gt;* labels, bool* ok) {\012 // BreakStatement ::\012 //   'break' Identifier? ';'\012\012 int pos = peek_position();\012 Expect(Token::BREAK, CHECK_OK);\012 IdentifierT label = impl()-&gt;NullIdentifier();\012 Token::Value tok = peek();\012 if (!scanner()-&gt;HasLineTerminatorBeforeNext() &amp;&amp; tok != Token::SEMICOLON &amp;&amp;\012      tok != Token::RBRACE &amp;&amp; tok != Token::EOS) {\012 // ECMA allows &quot;eval&quot; or &quot;arguments&quot; as labels even in strict mode.\012    label = ParseIdentifier(kAllowRestrictedIdentifiers, CHECK_OK);\012 }\012 // Parse labeled break statements that target themselves into\012 // empty statements, e.g. 'l1: l2: l3: break l2;'\012 if (!impl()-&gt;IsNull(label) &amp;&amp; impl()-&gt;ContainsLabel(labels, label)) {\012 ExpectSemicolon(CHECK_OK);\012 return factory()-&gt;NewEmptyStatement(pos);\012 }\012 typename Types::BreakableStatement target =\012      impl()-&gt;LookupBreakTarget(label, CHECK_OK);\012 if (impl()-&gt;IsNull(target)) {\012 // Illegal break statement.\012 MessageTemplate::Template message = MessageTemplate::kIllegalBreak;\012 if (!impl()-&gt;IsNull(label)) {\012      message = MessageTemplate::kUnknownLabel;\012 }\012 ReportMessage(message, label);\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 }\012 ExpectSemicolon(CHECK_OK);\012 StatementT stmt = factory()-&gt;NewBreakStatement(target, pos);\012  impl()-&gt;RecordJumpStatementSourceRange(stmt, scanner_-&gt;location().end_pos);\012 return stmt;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseReturnStatement(\012 bool* ok) {\012 // ReturnStatement ::\012 //   'return' [no line terminator] Expression? ';'\012\012 // Consume the return token. It is necessary to do that before\012 // reporting any errors on it, because of the way errors are\012 // reported (underlining).\012 Expect(Token::RETURN, CHECK_OK);\012 Scanner::Location loc = scanner()-&gt;location();\012\012 switch (GetDeclarationScope()-&gt;scope_type()) {\012 case SCRIPT_SCOPE:\012 case EVAL_SCOPE:\012 case MODULE_SCOPE:\012      impl()-&gt;ReportMessageAt(loc, MessageTemplate::kIllegalReturn);\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 default:\012 break;\012 }\012\012 Token::Value tok = peek();\012 ExpressionT return_value = impl()-&gt;NullExpression();\012 if (scanner()-&gt;HasLineTerminatorBeforeNext() || tok == Token::SEMICOLON ||\012      tok == Token::RBRACE || tok == Token::EOS) {\012 if (IsDerivedConstructor(function_state_-&gt;kind())) {\012      return_value = impl()-&gt;ThisExpression(loc.beg_pos);\012 }\012 } else {\012    return_value = ParseExpression(true, CHECK_OK);\012 }\012 ExpectSemicolon(CHECK_OK);\012  return_value = impl()-&gt;RewriteReturn(return_value, loc.beg_pos);\012 int continuation_pos = scanner_-&gt;location().end_pos;\012 StatementT stmt =\012 BuildReturnStatement(return_value, loc.beg_pos, continuation_pos);\012  impl()-&gt;RecordJumpStatementSourceRange(stmt, scanner_-&gt;location().end_pos);\012 return stmt;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseWithStatement(\012 ZonePtrList&lt;const AstRawString&gt;* labels, bool* ok) {\012 // WithStatement ::\012 //   'with' '(' Expression ')' Statement\012\012 Expect(Token::WITH, CHECK_OK);\012 int pos = position();\012\012 if (is_strict(language_mode())) {\012 ReportMessage(MessageTemplate::kStrictWith);\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 }\012\012 Expect(Token::LPAREN, CHECK_OK);\012 ExpressionT expr = ParseExpression(true, CHECK_OK);\012 Expect(Token::RPAREN, CHECK_OK);\012\012 Scope* with_scope = NewScope(WITH_SCOPE);\012 StatementT body = impl()-&gt;NullStatement();\012 {\012 BlockState block_state(&amp;scope_, with_scope);\012    with_scope-&gt;set_start_position(scanner()-&gt;peek_location().beg_pos);\012    body = ParseStatement(labels, nullptr, CHECK_OK);\012    with_scope-&gt;set_end_position(scanner()-&gt;location().end_pos);\012 }\012 return factory()-&gt;NewWithStatement(with_scope, expr, body, pos);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseDoWhileStatement(\012 ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels, bool* ok) {\012 // DoStatement ::\012 //   'do' Statement 'while' '(' Expression ')' ';'\012\012 auto loop =\012      factory()-&gt;NewDoWhileStatement(labels, own_labels, peek_position());\012 typename Types::Target target(this, loop);\012\012 SourceRange body_range;\012 StatementT body = impl()-&gt;NullStatement();\012\012 Expect(Token::DO, CHECK_OK);\012 {\012 SourceRangeScope range_scope(scanner(), &amp;body_range);\012    body = ParseStatement(nullptr, nullptr, CHECK_OK);\012 }\012 Expect(Token::WHILE, CHECK_OK);\012 Expect(Token::LPAREN, CHECK_OK);\012\012 ExpressionT cond = ParseExpression(true, CHECK_OK);\012 Expect(Token::RPAREN, CHECK_OK);\012\012 // Allow do-statements to be terminated with and without\012 // semi-colons. This allows code such as 'do;while(0)return' to\012 // parse, which would not be the case if we had used the\012 // ExpectSemicolon() functionality here.\012 Check(Token::SEMICOLON);\012\012  loop-&gt;Initialize(cond, body);\012  impl()-&gt;RecordIterationStatementSourceRange(loop, body_range);\012\012 return loop;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseWhileStatement(\012 ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels, bool* ok) {\012 // WhileStatement ::\012 //   'while' '(' Expression ')' Statement\012\012 auto loop = factory()-&gt;NewWhileStatement(labels, own_labels, peek_position());\012 typename Types::Target target(this, loop);\012\012 SourceRange body_range;\012 StatementT body = impl()-&gt;NullStatement();\012\012 Expect(Token::WHILE, CHECK_OK);\012 Expect(Token::LPAREN, CHECK_OK);\012 ExpressionT cond = ParseExpression(true, CHECK_OK);\012 Expect(Token::RPAREN, CHECK_OK);\012 {\012 SourceRangeScope range_scope(scanner(), &amp;body_range);\012    body = ParseStatement(nullptr, nullptr, CHECK_OK);\012 }\012\012  loop-&gt;Initialize(cond, body);\012  impl()-&gt;RecordIterationStatementSourceRange(loop, body_range);\012\012 return loop;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseThrowStatement(\012 bool* ok) {\012 // ThrowStatement ::\012 //   'throw' Expression ';'\012\012 Expect(Token::THROW, CHECK_OK);\012 int pos = position();\012 if (scanner()-&gt;HasLineTerminatorBeforeNext()) {\012 ReportMessage(MessageTemplate::kNewlineAfterThrow);\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 }\012 ExpressionT exception = ParseExpression(true, CHECK_OK);\012 ExpectSemicolon(CHECK_OK);\012\012 StatementT stmt = impl()-&gt;NewThrowStatement(exception, pos);\012  impl()-&gt;RecordThrowSourceRange(stmt, scanner_-&gt;location().end_pos);\012\012 return stmt;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseSwitchStatement(\012 ZonePtrList&lt;const AstRawString&gt;* labels, bool* ok) {\012 // SwitchStatement ::\012 //   'switch' '(' Expression ')' '{' CaseClause* '}'\012 // CaseClause ::\012 //   'case' Expression ':' StatementList\012 //   'default' ':' StatementList\012\012 int switch_pos = peek_position();\012\012 Expect(Token::SWITCH, CHECK_OK);\012 Expect(Token::LPAREN, CHECK_OK);\012 ExpressionT tag = ParseExpression(true, CHECK_OK);\012 Expect(Token::RPAREN, CHECK_OK);\012\012 auto switch_statement =\012      factory()-&gt;NewSwitchStatement(labels, tag, switch_pos);\012\012 {\012 BlockState cases_block_state(zone(), &amp;scope_);\012    scope()-&gt;set_start_position(switch_pos);\012    scope()-&gt;SetNonlinear();\012 typename Types::Target target(this, switch_statement);\012\012 bool default_seen = false;\012 Expect(Token::LBRACE, CHECK_OK);\012 while (peek() != Token::RBRACE) {\012 // An empty label indicates the default case.\012 ExpressionT label = impl()-&gt;NullExpression();\012 SourceRange clause_range;\012 SourceRangeScope range_scope(scanner(), &amp;clause_range);\012 if (Check(Token::CASE)) {\012        label = ParseExpression(true, CHECK_OK);\012 } else {\012 Expect(Token::DEFAULT, CHECK_OK);\012 if (default_seen) {\012 ReportMessage(MessageTemplate::kMultipleDefaultsInSwitch);\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 }\012        default_seen = true;\012 }\012 Expect(Token::COLON, CHECK_OK);\012 StatementListT statements = impl()-&gt;NewStatementList(5);\012 while (peek() != Token::CASE &amp;&amp; peek() != Token::DEFAULT &amp;&amp;\012             peek() != Token::RBRACE) {\012 StatementT stat = ParseStatementListItem(CHECK_OK);\012        statements-&gt;Add(stat, zone());\012 }\012 auto clause = factory()-&gt;NewCaseClause(label, statements);\012      impl()-&gt;RecordCaseClauseSourceRange(clause, range_scope.Finalize());\012      switch_statement-&gt;cases()-&gt;Add(clause, zone());\012 }\012 Expect(Token::RBRACE, CHECK_OK);\012\012 int end_position = scanner()-&gt;location().end_pos;\012    scope()-&gt;set_end_position(end_position);\012    impl()-&gt;RecordSwitchStatementSourceRange(switch_statement, end_position);\012 Scope* switch_scope = scope()-&gt;FinalizeBlockScope();\012 if (switch_scope != nullptr) {\012 return impl()-&gt;RewriteSwitchStatement(switch_statement, switch_scope);\012 }\012 return switch_statement;\012 }\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseTryStatement(\012 bool* ok) {\012 // TryStatement ::\012 //   'try' Block Catch\012 //   'try' Block Finally\012 //   'try' Block Catch Finally\012 //\012 // Catch ::\012 //   'catch' '(' Identifier ')' Block\012 //\012 // Finally ::\012 //   'finally' Block\012\012 Expect(Token::TRY, CHECK_OK);\012 int pos = position();\012\012 BlockT try_block = ParseBlock(nullptr, CHECK_OK);\012\012 CatchInfo catch_info(this);\012\012 if (peek() != Token::CATCH &amp;&amp; peek() != Token::FINALLY) {\012 ReportMessage(MessageTemplate::kNoCatchOrFinally);\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 }\012\012 SourceRange catch_range, finally_range;\012\012 BlockT catch_block = impl()-&gt;NullStatement();\012 {\012 SourceRangeScope catch_range_scope(scanner(), &amp;catch_range);\012 if (Check(Token::CATCH)) {\012 bool has_binding;\012      has_binding = Check(Token::LPAREN);\012\012 if (has_binding) {\012        catch_info.scope = NewScope(CATCH_SCOPE);\012        catch_info.scope-&gt;set_start_position(scanner()-&gt;location().beg_pos);\012\012 {\012 BlockState catch_block_state(&amp;scope_, catch_info.scope);\012\012          catch_block = factory()-&gt;NewBlock(16, false);\012\012 // Create a block scope to hold any lexical declarations created\012 // as part of destructuring the catch parameter.\012 {\012 BlockState catch_variable_block_state(zone(), &amp;scope_);\012            scope()-&gt;set_start_position(scanner()-&gt;location().beg_pos);\012\012 // This does not simply call ParsePrimaryExpression to avoid\012 // ExpressionFromIdentifier from being called in the first\012 // branch, which would introduce an unresolved symbol and mess\012 // with arrow function names.\012 if (peek_any_identifier()) {\012              catch_info.name =\012 ParseIdentifier(kDontAllowRestrictedIdentifiers, CHECK_OK);\012 } else {\012 ExpressionClassifier pattern_classifier(this);\012              catch_info.pattern = ParsePrimaryExpression(CHECK_OK);\012 ValidateBindingPattern(CHECK_OK);\012 }\012\012 Expect(Token::RPAREN, CHECK_OK);\012            impl()-&gt;RewriteCatchPattern(&amp;catch_info, CHECK_OK);\012 if (!impl()-&gt;IsNull(catch_info.init_block)) {\012              catch_block-&gt;statements()-&gt;Add(catch_info.init_block, zone());\012 }\012\012            catch_info.inner_block = ParseBlock(nullptr, CHECK_OK);\012            catch_block-&gt;statements()-&gt;Add(catch_info.inner_block, zone());\012            impl()-&gt;ValidateCatchBlock(catch_info, CHECK_OK);\012            scope()-&gt;set_end_position(scanner()-&gt;location().end_pos);\012            catch_block-&gt;set_scope(scope()-&gt;FinalizeBlockScope());\012 }\012 }\012\012        catch_info.scope-&gt;set_end_position(scanner()-&gt;location().end_pos);\012 } else {\012        catch_block = ParseBlock(nullptr, CHECK_OK);\012 }\012 }\012 }\012\012 BlockT finally_block = impl()-&gt;NullStatement();\012  DCHECK(peek() == Token::FINALLY || !impl()-&gt;IsNull(catch_block));\012 {\012 SourceRangeScope range_scope(scanner(), &amp;finally_range);\012 if (Check(Token::FINALLY)) {\012      finally_block = ParseBlock(nullptr, CHECK_OK);\012 }\012 }\012\012 return impl()-&gt;RewriteTryStatement(try_block, catch_block, catch_range,\012                                     finally_block, finally_range, catch_info,\012                                     pos);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseForStatement(\012 ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels, bool* ok) {\012 // Either a standard for loop\012 //   for (&lt;init&gt;; &lt;cond&gt;; &lt;next&gt;) { ... }\012 // or a for-each loop\012 //   for (&lt;each&gt; of|in &lt;iterable&gt;) { ... }\012 //\012 // We parse a declaration/expression after the 'for (' and then read the first\012 // expression/declaration before we know if this is a for or a for-each.\012\012 int stmt_pos = peek_position();\012 ForInfo for_info(this);\012\012 Expect(Token::FOR, CHECK_OK);\012 Expect(Token::LPAREN, CHECK_OK);\012\012 if (peek() == Token::CONST || (peek() == Token::LET &amp;&amp; IsNextLetKeyword())) {\012 // The initializer contains lexical declarations,\012 // so create an in-between scope.\012 BlockState for_state(zone(), &amp;scope_);\012    scope()-&gt;set_start_position(scanner()-&gt;location().beg_pos);\012\012 // Also record whether inner functions or evals are found inside\012 // this loop, as this information is used to simplify the desugaring\012 // if none are found.\012 typename FunctionState::FunctionOrEvalRecordingScope recording_scope(\012        function_state_);\012\012 // Create an inner block scope which will be the parent scope of scopes\012 // possibly created by ParseVariableDeclarations.\012 Scope* inner_block_scope = NewScope(BLOCK_SCOPE);\012 {\012 BlockState inner_state(&amp;scope_, inner_block_scope);\012 ParseVariableDeclarations(kForStatement, &amp;for_info.parsing_result,\012 nullptr, CHECK_OK);\012 }\012    DCHECK(IsLexicalVariableMode(for_info.parsing_result.descriptor.mode));\012    for_info.position = scanner()-&gt;location().beg_pos;\012\012 if (CheckInOrOf(&amp;for_info.mode)) {\012      scope()-&gt;set_is_hidden();\012 return ParseForEachStatementWithDeclarations(\012          stmt_pos, &amp;for_info, labels, own_labels, inner_block_scope, ok);\012 }\012\012 Expect(Token::SEMICOLON, CHECK_OK);\012\012 StatementT init = impl()-&gt;BuildInitializationBlock(\012 &amp;for_info.parsing_result, &amp;for_info.bound_names, CHECK_OK);\012\012 Scope* finalized = inner_block_scope-&gt;FinalizeBlockScope();\012 // No variable declarations will have been created in inner_block_scope.\012    DCHECK_NULL(finalized);\012    USE(finalized);\012 return ParseStandardForLoopWithLexicalDeclarations(\012        stmt_pos, init, &amp;for_info, labels, own_labels, ok);\012 }\012\012 StatementT init = impl()-&gt;NullStatement();\012 if (peek() == Token::VAR) {\012 ParseVariableDeclarations(kForStatement, &amp;for_info.parsing_result, nullptr,\012                              CHECK_OK);\012    DCHECK_EQ(for_info.parsing_result.descriptor.mode, VariableMode::kVar);\012    for_info.position = scanner()-&gt;location().beg_pos;\012\012 if (CheckInOrOf(&amp;for_info.mode)) {\012 return ParseForEachStatementWithDeclarations(stmt_pos, &amp;for_info, labels,\012                                                   own_labels, nullptr, ok);\012 }\012\012    init = impl()-&gt;BuildInitializationBlock(&amp;for_info.parsing_result, nullptr,\012                                            CHECK_OK);\012 } else if (peek() != Token::SEMICOLON) {\012 // The initializer does not contain declarations.\012 int lhs_beg_pos = peek_position();\012 ExpressionClassifier classifier(this);\012 ExpressionT expression = ParseExpressionCoverGrammar(false, CHECK_OK);\012 int lhs_end_pos = scanner()-&gt;location().end_pos;\012\012 bool is_for_each = CheckInOrOf(&amp;for_info.mode);\012 bool is_destructuring = is_for_each &amp;&amp; (expression-&gt;IsArrayLiteral() ||\012                                            expression-&gt;IsObjectLiteral());\012\012 if (is_destructuring) {\012 ValidateAssignmentPattern(CHECK_OK);\012 } else {\012 ValidateExpression(CHECK_OK);\012 }\012\012 if (is_for_each) {\012 return ParseForEachStatementWithoutDeclarations(\012          stmt_pos, expression, lhs_beg_pos, lhs_end_pos, &amp;for_info, labels,\012          own_labels, ok);\012 }\012 // Initializer is just an expression.\012    init = factory()-&gt;NewExpressionStatement(expression, lhs_beg_pos);\012 }\012\012 Expect(Token::SEMICOLON, CHECK_OK);\012\012 // Standard 'for' loop, we have parsed the initializer at this point.\012 ExpressionT cond = impl()-&gt;NullExpression();\012 StatementT next = impl()-&gt;NullStatement();\012 StatementT body = impl()-&gt;NullStatement();\012 ForStatementT loop = ParseStandardForLoop(stmt_pos, labels, own_labels, &amp;cond,\012 &amp;next, &amp;body, CHECK_OK);\012  loop-&gt;Initialize(init, cond, next, body);\012 return loop;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT\012ParserBase&lt;Impl&gt;::ParseForEachStatementWithDeclarations(\012 int stmt_pos, ForInfo* for_info, ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels, Scope* inner_block_scope,\012 bool* ok) {\012 // Just one declaration followed by in/of.\012 if (for_info-&gt;parsing_result.declarations.size() != 1) {\012    impl()-&gt;ReportMessageAt(for_info-&gt;parsing_result.bindings_loc,\012 MessageTemplate::kForInOfLoopMultiBindings,\012 ForEachStatement::VisitModeString(for_info-&gt;mode));\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 }\012 if (for_info-&gt;parsing_result.first_initializer_loc.IsValid() &amp;&amp;\012 (is_strict(language_mode()) ||\012       for_info-&gt;mode == ForEachStatement::ITERATE ||\012 IsLexicalVariableMode(for_info-&gt;parsing_result.descriptor.mode) ||\012 !impl()-&gt;IsIdentifier(\012           for_info-&gt;parsing_result.declarations[0].pattern))) {\012    impl()-&gt;ReportMessageAt(for_info-&gt;parsing_result.first_initializer_loc,\012 MessageTemplate::kForInOfLoopInitializer,\012 ForEachStatement::VisitModeString(for_info-&gt;mode));\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 }\012\012 // Reset the declaration_kind to ensure proper processing during declaration.\012  for_info-&gt;parsing_result.descriptor.declaration_kind =\012 DeclarationDescriptor::FOR_EACH;\012\012 BlockT init_block = impl()-&gt;RewriteForVarInLegacy(*for_info);\012\012 auto loop = factory()-&gt;NewForEachStatement(for_info-&gt;mode, labels, own_labels,\012                                             stmt_pos);\012 typename Types::Target target(this, loop);\012\012 ExpressionT enumerable = impl()-&gt;NullExpression();\012 if (for_info-&gt;mode == ForEachStatement::ITERATE) {\012 ExpressionClassifier classifier(this);\012    enumerable = ParseAssignmentExpression(true, CHECK_OK);\012 ValidateExpression(CHECK_OK);\012 } else {\012    enumerable = ParseExpression(true, CHECK_OK);\012 }\012\012 Expect(Token::RPAREN, CHECK_OK);\012\012 Scope* for_scope = nullptr;\012 if (inner_block_scope != nullptr) {\012    for_scope = inner_block_scope-&gt;outer_scope();\012    DCHECK(for_scope == scope());\012    inner_block_scope-&gt;set_start_position(scanner()-&gt;location().beg_pos);\012 }\012\012 ExpressionT each_variable = impl()-&gt;NullExpression();\012 BlockT body_block = impl()-&gt;NullStatement();\012 {\012 BlockState block_state(\012 &amp;scope_, inner_block_scope != nullptr ? inner_block_scope : scope_);\012\012 SourceRange body_range;\012 SourceRangeScope range_scope(scanner(), &amp;body_range);\012\012 StatementT body = ParseStatement(nullptr, nullptr, CHECK_OK);\012    impl()-&gt;RecordIterationStatementSourceRange(loop, range_scope.Finalize());\012\012    impl()-&gt;DesugarBindingInForEachStatement(for_info, &amp;body_block,\012 &amp;each_variable, CHECK_OK);\012    body_block-&gt;statements()-&gt;Add(body, zone());\012\012 if (inner_block_scope != nullptr) {\012      inner_block_scope-&gt;set_end_position(scanner()-&gt;location().end_pos);\012      body_block-&gt;set_scope(inner_block_scope-&gt;FinalizeBlockScope());\012 }\012 }\012\012 StatementT final_loop = impl()-&gt;InitializeForEachStatement(\012      loop, each_variable, enumerable, body_block);\012\012  init_block = impl()-&gt;CreateForEachStatementTDZ(init_block, *for_info, ok);\012\012 if (for_scope != nullptr) {\012    for_scope-&gt;set_end_position(scanner()-&gt;location().end_pos);\012    for_scope = for_scope-&gt;FinalizeBlockScope();\012 }\012\012 // Parsed for-in loop w/ variable declarations.\012 if (!impl()-&gt;IsNull(init_block)) {\012    init_block-&gt;statements()-&gt;Add(final_loop, zone());\012    init_block-&gt;set_scope(for_scope);\012 return init_block;\012 }\012\012  DCHECK_NULL(for_scope);\012 return final_loop;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT\012ParserBase&lt;Impl&gt;::ParseForEachStatementWithoutDeclarations(\012 int stmt_pos, ExpressionT expression, int lhs_beg_pos, int lhs_end_pos,\012 ForInfo* for_info, ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels, bool* ok) {\012 // Initializer is reference followed by in/of.\012 if (!expression-&gt;IsArrayLiteral() &amp;&amp; !expression-&gt;IsObjectLiteral()) {\012    expression = CheckAndRewriteReferenceExpression(\012        expression, lhs_beg_pos, lhs_end_pos, MessageTemplate::kInvalidLhsInFor,\012        kSyntaxError, CHECK_OK);\012 }\012\012 auto loop = factory()-&gt;NewForEachStatement(for_info-&gt;mode, labels, own_labels,\012                                             stmt_pos);\012 typename Types::Target target(this, loop);\012\012 ExpressionT enumerable = impl()-&gt;NullExpression();\012 if (for_info-&gt;mode == ForEachStatement::ITERATE) {\012 ExpressionClassifier classifier(this);\012    enumerable = ParseAssignmentExpression(true, CHECK_OK);\012 ValidateExpression(CHECK_OK);\012 } else {\012    enumerable = ParseExpression(true, CHECK_OK);\012 }\012\012 Expect(Token::RPAREN, CHECK_OK);\012\012 StatementT body = impl()-&gt;NullStatement();\012 {\012 SourceRange body_range;\012 SourceRangeScope range_scope(scanner(), &amp;body_range);\012\012    body = ParseStatement(nullptr, nullptr, CHECK_OK);\012    impl()-&gt;RecordIterationStatementSourceRange(loop, range_scope.Finalize());\012 }\012 return impl()-&gt;InitializeForEachStatement(loop, expression, enumerable, body);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT\012ParserBase&lt;Impl&gt;::ParseStandardForLoopWithLexicalDeclarations(\012 int stmt_pos, StatementT init, ForInfo* for_info,\012 ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels, bool* ok) {\012 // The condition and the next statement of the for loop must be parsed\012 // in a new scope.\012 Scope* inner_scope = NewScope(BLOCK_SCOPE);\012 ForStatementT loop = impl()-&gt;NullStatement();\012 ExpressionT cond = impl()-&gt;NullExpression();\012 StatementT next = impl()-&gt;NullStatement();\012 StatementT body = impl()-&gt;NullStatement();\012 {\012 BlockState block_state(&amp;scope_, inner_scope);\012    scope()-&gt;set_start_position(scanner()-&gt;location().beg_pos);\012    loop = ParseStandardForLoop(stmt_pos, labels, own_labels, &amp;cond, &amp;next,\012 &amp;body, CHECK_OK);\012    scope()-&gt;set_end_position(scanner()-&gt;location().end_pos);\012 }\012\012  scope()-&gt;set_end_position(scanner()-&gt;location().end_pos);\012 if (for_info-&gt;bound_names.length() &gt; 0 &amp;&amp;\012      function_state_-&gt;contains_function_or_eval()) {\012    scope()-&gt;set_is_hidden();\012 return impl()-&gt;DesugarLexicalBindingsInForStatement(\012        loop, init, cond, next, body, inner_scope, *for_info, ok);\012 } else {\012    inner_scope = inner_scope-&gt;FinalizeBlockScope();\012    DCHECK_NULL(inner_scope);\012    USE(inner_scope);\012 }\012\012 Scope* for_scope = scope()-&gt;FinalizeBlockScope();\012 if (for_scope != nullptr) {\012 // Rewrite a for statement of the form\012 //   for (const x = i; c; n) b\012 //\012 // into\012 //\012 //   {\012 //     const x = i;\012 //     for (; c; n) b\012 //   }\012 //\012    DCHECK(!impl()-&gt;IsNull(init));\012 BlockT block = factory()-&gt;NewBlock(2, false);\012    block-&gt;statements()-&gt;Add(init, zone());\012    block-&gt;statements()-&gt;Add(loop, zone());\012    block-&gt;set_scope(for_scope);\012    loop-&gt;Initialize(impl()-&gt;NullStatement(), cond, next, body);\012 return block;\012 }\012\012  loop-&gt;Initialize(init, cond, next, body);\012 return loop;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ForStatementT ParserBase&lt;Impl&gt;::ParseStandardForLoop(\012 int stmt_pos, ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels, ExpressionT* cond,\012 StatementT* next, StatementT* body, bool* ok) {\012 ForStatementT loop = factory()-&gt;NewForStatement(labels, own_labels, stmt_pos);\012 typename Types::Target target(this, loop);\012\012 if (peek() != Token::SEMICOLON) {\012 *cond = ParseExpression(true, CHECK_OK);\012 }\012 Expect(Token::SEMICOLON, CHECK_OK);\012\012 if (peek() != Token::RPAREN) {\012 ExpressionT exp = ParseExpression(true, CHECK_OK);\012 *next = factory()-&gt;NewExpressionStatement(exp, exp-&gt;position());\012 }\012 Expect(Token::RPAREN, CHECK_OK);\012\012 SourceRange body_range;\012 {\012 SourceRangeScope range_scope(scanner(), &amp;body_range);\012 *body = ParseStatement(nullptr, nullptr, CHECK_OK);\012 }\012  impl()-&gt;RecordIterationStatementSourceRange(loop, body_range);\012\012 return loop;\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::MarkLoopVariableAsAssigned(\012 Scope* scope, Variable* var,\012 typename DeclarationDescriptor::Kind declaration_kind) {\012 if (!IsLexicalVariableMode(var-&gt;mode()) &amp;&amp;\012 (!scope-&gt;is_function_scope() ||\012       declaration_kind == DeclarationDescriptor::FOR_EACH)) {\012 var-&gt;set_maybe_assigned();\012 }\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseForAwaitStatement(\012 ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels, bool* ok) {\012 // for await '(' ForDeclaration of AssignmentExpression ')'\012  DCHECK(is_async_function());\012\012 int stmt_pos = peek_position();\012\012 ForInfo for_info(this);\012  for_info.mode = ForEachStatement::ITERATE;\012\012 // Create an in-between scope for let-bound iteration variables.\012 BlockState for_state(zone(), &amp;scope_);\012 Expect(Token::FOR, CHECK_OK);\012 Expect(Token::AWAIT, CHECK_OK);\012 Expect(Token::LPAREN, CHECK_OK);\012  scope()-&gt;set_start_position(scanner()-&gt;location().beg_pos);\012  scope()-&gt;set_is_hidden();\012\012 auto loop = factory()-&gt;NewForOfStatement(labels, own_labels, stmt_pos);\012 typename Types::Target target(this, loop);\012\012 ExpressionT each_variable = impl()-&gt;NullExpression();\012\012 bool has_declarations = false;\012 Scope* inner_block_scope = NewScope(BLOCK_SCOPE);\012\012 if (peek() == Token::VAR || peek() == Token::CONST ||\012 (peek() == Token::LET &amp;&amp; IsNextLetKeyword())) {\012 // The initializer contains declarations\012 // 'for' 'await' '(' ForDeclaration 'of' AssignmentExpression ')'\012 //     Statement\012 // 'for' 'await' '(' 'var' ForBinding 'of' AssignmentExpression ')'\012 //     Statement\012    has_declarations = true;\012\012 {\012 BlockState inner_state(&amp;scope_, inner_block_scope);\012 ParseVariableDeclarations(kForStatement, &amp;for_info.parsing_result,\012 nullptr, CHECK_OK);\012 }\012    for_info.position = scanner()-&gt;location().beg_pos;\012\012 // Only a single declaration is allowed in for-await-of loops\012 if (for_info.parsing_result.declarations.size() != 1) {\012      impl()-&gt;ReportMessageAt(for_info.parsing_result.bindings_loc,\012 MessageTemplate::kForInOfLoopMultiBindings,\012 &quot;for-await-of&quot;);\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 }\012\012 // for-await-of's declarations do not permit initializers.\012 if (for_info.parsing_result.first_initializer_loc.IsValid()) {\012      impl()-&gt;ReportMessageAt(for_info.parsing_result.first_initializer_loc,\012 MessageTemplate::kForInOfLoopInitializer,\012 &quot;for-await-of&quot;);\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 }\012 } else {\012 // The initializer does not contain declarations.\012 // 'for' 'await' '(' LeftHandSideExpression 'of' AssignmentExpression ')'\012 //     Statement\012 int lhs_beg_pos = peek_position();\012 BlockState inner_state(&amp;scope_, inner_block_scope);\012 ExpressionClassifier classifier(this);\012 ExpressionT lhs = each_variable = ParseLeftHandSideExpression(CHECK_OK);\012 int lhs_end_pos = scanner()-&gt;location().end_pos;\012\012 if (lhs-&gt;IsArrayLiteral() || lhs-&gt;IsObjectLiteral()) {\012 ValidateAssignmentPattern(CHECK_OK);\012 } else {\012 ValidateExpression(CHECK_OK);\012      each_variable = CheckAndRewriteReferenceExpression(\012          lhs, lhs_beg_pos, lhs_end_pos, MessageTemplate::kInvalidLhsInFor,\012          kSyntaxError, CHECK_OK);\012 }\012 }\012\012 ExpectContextualKeyword(Token::OF, CHECK_OK);\012 int each_keyword_pos = scanner()-&gt;location().beg_pos;\012\012 const bool kAllowIn = true;\012 ExpressionT iterable = impl()-&gt;NullExpression();\012\012 {\012 ExpressionClassifier classifier(this);\012    iterable = ParseAssignmentExpression(kAllowIn, CHECK_OK);\012 ValidateExpression(CHECK_OK);\012 }\012\012 Expect(Token::RPAREN, CHECK_OK);\012\012 StatementT body = impl()-&gt;NullStatement();\012 {\012 BlockState block_state(&amp;scope_, inner_block_scope);\012    scope()-&gt;set_start_position(scanner()-&gt;location().beg_pos);\012\012 SourceRange body_range;\012 SourceRangeScope range_scope(scanner(), &amp;body_range);\012\012    body = ParseStatement(nullptr, nullptr, CHECK_OK);\012    scope()-&gt;set_end_position(scanner()-&gt;location().end_pos);\012    impl()-&gt;RecordIterationStatementSourceRange(loop, range_scope.Finalize());\012\012 if (has_declarations) {\012 BlockT body_block = impl()-&gt;NullStatement();\012      impl()-&gt;DesugarBindingInForEachStatement(&amp;for_info, &amp;body_block,\012 &amp;each_variable, CHECK_OK);\012      body_block-&gt;statements()-&gt;Add(body, zone());\012      body_block-&gt;set_scope(scope()-&gt;FinalizeBlockScope());\012      body = body_block;\012 } else {\012 Scope* block_scope = scope()-&gt;FinalizeBlockScope();\012      DCHECK_NULL(block_scope);\012      USE(block_scope);\012 }\012 }\012 const bool finalize = true;\012 StatementT final_loop = impl()-&gt;InitializeForOfStatement(\012      loop, each_variable, iterable, body, finalize, IteratorType::kAsync,\012      each_keyword_pos);\012\012 if (!has_declarations) {\012 Scope* for_scope = scope()-&gt;FinalizeBlockScope();\012    DCHECK_NULL(for_scope);\012    USE(for_scope);\012 return final_loop;\012 }\012\012 BlockT init_block =\012      impl()-&gt;CreateForEachStatementTDZ(impl()-&gt;NullStatement(), for_info, ok);\012\012  scope()-&gt;set_end_position(scanner()-&gt;location().end_pos);\012 Scope* for_scope = scope()-&gt;FinalizeBlockScope();\012 // Parsed for-in loop w/ variable declarations.\012 if (!impl()-&gt;IsNull(init_block)) {\012    init_block-&gt;statements()-&gt;Add(final_loop, zone());\012    init_block-&gt;set_scope(for_scope);\012 return init_block;\012 }\012  DCHECK_NULL(for_scope);\012 return final_loop;\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::ObjectLiteralChecker::CheckDuplicateProto(\012 Token::Value property) {\012 if (property == Token::SMI || property == Token::NUMBER) return;\012\012 if (IsProto()) {\012 if (has_seen_proto_) {\012 this-&gt;parser()-&gt;classifier()-&gt;RecordExpressionError(\012 this-&gt;scanner()-&gt;location(), MessageTemplate::kDuplicateProto);\012 return;\012 }\012    has_seen_proto_ = true;\012 }\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::ClassLiteralChecker::CheckClassMethodName(\012 Token::Value property, PropertyKind type, bool is_generator, bool is_async,\012 bool is_static, bool* ok) {\012  DCHECK(type == PropertyKind::kMethodProperty ||\012         type == PropertyKind::kAccessorProperty);\012\012 if (property == Token::SMI || property == Token::NUMBER) return;\012\012 if (is_static) {\012 if (IsPrototype()) {\012 this-&gt;parser()-&gt;ReportMessage(MessageTemplate::kStaticPrototype);\012 *ok = false;\012 return;\012 }\012 } else if (IsConstructor()) {\012 if (is_generator || is_async || type == PropertyKind::kAccessorProperty) {\012 MessageTemplate::Template msg =\012          is_generator ? MessageTemplate::kConstructorIsGenerator\012 : is_async ? MessageTemplate::kConstructorIsAsync\012 : MessageTemplate::kConstructorIsAccessor;\012 this-&gt;parser()-&gt;ReportMessage(msg);\012 *ok = false;\012 return;\012 }\012 if (has_seen_constructor_) {\012 this-&gt;parser()-&gt;ReportMessage(MessageTemplate::kDuplicateConstructor);\012 *ok = false;\012 return;\012 }\012    has_seen_constructor_ = true;\012 return;\012 }\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::ClassLiteralChecker::CheckClassFieldName(bool is_static,\012 bool* ok) {\012 if (is_static &amp;&amp; IsPrototype()) {\012 this-&gt;parser()-&gt;ReportMessage(MessageTemplate::kStaticPrototype);\012 *ok = false;\012 return;\012 }\012\012 if (IsConstructor() || IsPrivateConstructor()) {\012 this-&gt;parser()-&gt;ReportMessage(MessageTemplate::kConstructorClassField);\012 *ok = false;\012 return;\012 }\012}\012\012#undef CHECK_OK\012#undef CHECK_OK_CUSTOM\012#undef CHECK_OK_VOID\012\012} // namespace internal\012},namespace v8 {\012namespace internal {\012\012enum FunctionNameValidity {\012  kFunctionNameIsStrictReserved,\012  kSkipFunctionNameCheck,\012  kFunctionNameValidityUnknown\012};\012\012enum AllowLabelledFunctionStatement {\012  kAllowLabelledFunctionStatement,\012  kDisallowLabelledFunctionStatement,\012};\012\012enum class ParseFunctionFlags {\012  kIsNormal = 0,\012  kIsGenerator = 1,\012  kIsAsync = 2,\012  kIsDefault = 4\012};\012\012static inline ParseFunctionFlags operator|(ParseFunctionFlags lhs,\012 ParseFunctionFlags rhs) {\012 typedef unsigned char T;\012 return static_cast&lt;ParseFunctionFlags&gt;(static_cast&lt;T&gt;(lhs) |\012 static_cast&lt;T&gt;(rhs));\012}\012\012static inline ParseFunctionFlags&amp; operator|=(ParseFunctionFlags&amp; lhs,\012 const ParseFunctionFlags&amp; rhs) {\012  lhs = lhs | rhs;\012 return lhs;\012}\012\012static inline bool operator&amp;(ParseFunctionFlags bitfield,\012 ParseFunctionFlags mask) {\012 typedef unsigned char T;\012 return static_cast&lt;T&gt;(bitfield) &amp; static_cast&lt;T&gt;(mask);\012}\012\012struct FormalParametersBase {\012 explicit FormalParametersBase(DeclarationScope* scope) : scope(scope) {}\012\012 int num_parameters() const {\012 // Don't include the rest parameter into the function's formal parameter\012 // count (esp. the SharedFunctionInfo::internal_formal_parameter_count,\012 // which says whether we need to create an arguments adaptor frame).\012 return arity - has_rest;\012 }\012\012 void UpdateArityAndFunctionLength(bool is_optional, bool is_rest) {\012 if (!is_optional &amp;&amp; !is_rest &amp;&amp; function_length == arity) {\012 ++function_length;\012 }\012 ++arity;\012 }\012\012 DeclarationScope* scope;\012 bool has_rest = false;\012 bool is_simple = true;\012 int function_length = 0;\012 int arity = 0;\012};\012\012// Stack-allocated scope to collect source ranges from the parser.\012class SourceRangeScope final {\012 public:\012 enum PositionKind {\012    POSITION_BEG,\012    POSITION_END,\012    PEEK_POSITION_BEG,\012    PEEK_POSITION_END,\012 };\012\012 SourceRangeScope(Scanner* scanner, SourceRange* range,\012 PositionKind pre_kind = PEEK_POSITION_BEG,\012 PositionKind post_kind = POSITION_END)\012 : scanner_(scanner), range_(range), post_kind_(post_kind) {\012    range_-&gt;start = GetPosition(pre_kind);\012    DCHECK_NE(range_-&gt;start, kNoSourcePosition);\012 }\012\012 ~SourceRangeScope() { Finalize(); }\012\012 const SourceRange&amp; Finalize() {\012 if (is_finalized_) return *range_;\012    is_finalized_ = true;\012    range_-&gt;end = GetPosition(post_kind_);\012    DCHECK_NE(range_-&gt;end, kNoSourcePosition);\012 return *range_;\012 }\012\012 private:\012 int32_t GetPosition(PositionKind kind) {\012 switch (kind) {\012 case POSITION_BEG:\012 return scanner_-&gt;location().beg_pos;\012 case POSITION_END:\012 return scanner_-&gt;location().end_pos;\012 case PEEK_POSITION_BEG:\012 return scanner_-&gt;peek_location().beg_pos;\012 case PEEK_POSITION_END:\012 return scanner_-&gt;peek_location().end_pos;\012 default:\012        UNREACHABLE();\012 }\012 }\012\012 Scanner* scanner_;\012 SourceRange* range_;\012 PositionKind post_kind_;\012 bool is_finalized_ = false;\012\012  DISALLOW_IMPLICIT_CONSTRUCTORS(SourceRangeScope);\012};\012\012// ----------------------------------------------------------------------------\012// The CHECK_OK macro is a convenient macro to enforce error\012// handling for functions that may fail (by returning !*ok).\012//\012// CAUTION: This macro appends extra statements after a call,\012// thus it must never be used where only a single statement\012// is correct (e.g. an if statement branch w/o braces)!\012\012#define CHECK_OK_CUSTOM(x, ...) ok);       \\012 if (!*ok) return impl()-&gt;x(__VA_ARGS__); \\012 ((void)0\012#define DUMMY ) // to make indentation work\012#undef DUMMY\012\012// Used in functions where the return type is ExpressionT.\012#define CHECK_OK CHECK_OK_CUSTOM(NullExpression)\012\012#define CHECK_OK_VOID ok); \\012 if (!*ok) return;        \\012 ((void)0\012#define DUMMY ) // to make indentation work\012#undef DUMMY\012\012// Common base class template shared between parser and pre-parser.\012// The Impl parameter is the actual class of the parser/pre-parser,\012// following the Curiously Recurring Template Pattern (CRTP).\012// The structure of the parser objects is roughly the following:\012//\012//   // A structure template containing type definitions, needed to\012//   // avoid a cyclic dependency.\012//   template &lt;typename Impl&gt;\012//   struct ParserTypes;\012//\012//   // The parser base object, which should just implement pure\012//   // parser behavior.  The Impl parameter is the actual derived\012//   // class (according to CRTP), which implements impure parser\012//   // behavior.\012//   template &lt;typename Impl&gt;\012//   class ParserBase { ... };\012//\012//   // And then, for each parser variant (e.g., parser, preparser, etc):\012//   class Parser;\012//\012//   template &lt;&gt;\012//   class ParserTypes&lt;Parser&gt; { ... };\012//\012//   class Parser : public ParserBase&lt;Parser&gt; { ... };\012//\012// The parser base object implements pure parsing, according to the\012// language grammar.  Different parser implementations may exhibit\012// different parser-driven behavior that is not considered as pure\012// parsing, e.g., early error detection and reporting, AST generation, etc.\012\012// The ParserTypes structure encapsulates the differences in the\012// types used in parsing methods.  E.g., Parser methods use Expression*\012// and PreParser methods use PreParserExpression.  For any given parser\012// implementation class Impl, it is expected to contain the following typedefs:\012//\012// template &lt;&gt;\012// struct ParserTypes&lt;Impl&gt; {\012//   // Synonyms for ParserBase&lt;Impl&gt; and Impl, respectively.\012//   typedef Base;\012//   typedef Impl;\012//   // Return types for traversing functions.\012//   typedef Identifier;\012//   typedef Expression;\012//   typedef FunctionLiteral;\012//   typedef ObjectLiteralProperty;\012//   typedef ClassLiteralProperty;\012//   typedef ExpressionList;\012//   typedef ObjectPropertyList;\012//   typedef ClassPropertyList;\012//   typedef FormalParameters;\012//   typedef Statement;\012//   typedef StatementList;\012//   typedef Block;\012//   typedef BreakableStatement;\012//   typedef ForStatement;\012//   typedef IterationStatement;\012//   // For constructing objects returned by the traversing functions.\012//   typedef Factory;\012//   // For other implementation-specific tasks.\012//   typedef Target;\012//   typedef TargetScope;\012// };\012\012template &lt;typename Impl&gt;\012struct ParserTypes;\012\012template &lt;typename Impl&gt;\012class ParserBase {\012 public:\012 // Shorten type names defined by ParserTypes&lt;Impl&gt;.\012 typedef ParserTypes&lt;Impl&gt; Types;\012 typedef typename Types::Identifier IdentifierT;\012 typedef typename Types::Expression ExpressionT;\012 typedef typename Types::FunctionLiteral FunctionLiteralT;\012 typedef typename Types::ObjectLiteralProperty ObjectLiteralPropertyT;\012 typedef typename Types::ClassLiteralProperty ClassLiteralPropertyT;\012 typedef typename Types::Suspend SuspendExpressionT;\012 typedef typename Types::RewritableExpression RewritableExpressionT;\012 typedef typename Types::ExpressionList ExpressionListT;\012 typedef typename Types::FormalParameters FormalParametersT;\012 typedef typename Types::Statement StatementT;\012 typedef typename Types::StatementList StatementListT;\012 typedef typename Types::Block BlockT;\012 typedef typename Types::ForStatement ForStatementT;\012 typedef typename v8::internal::ExpressionClassifier&lt;Types&gt;\012 ExpressionClassifier;\012\012 // All implementation-specific methods must be called through this.\012 Impl* impl() { return static_cast&lt;Impl*&gt;(this); }\012 const Impl* impl() const { return static_cast&lt;const Impl*&gt;(this); }\012\012 ParserBase(Zone* zone, Scanner* scanner, uintptr_t stack_limit,\012             v8::Extension* extension, AstValueFactory* ast_value_factory,\012 PendingCompilationErrorHandler* pending_error_handler,\012 RuntimeCallStats* runtime_call_stats, Logger* logger,\012 int script_id, bool parsing_module, bool parsing_on_main_thread)\012 : scope_(nullptr),\012        original_scope_(nullptr),\012        function_state_(nullptr),\012        extension_(extension),\012        fni_(nullptr),\012        ast_value_factory_(ast_value_factory),\012        ast_node_factory_(ast_value_factory, zone),\012        runtime_call_stats_(runtime_call_stats),\012        logger_(logger),\012        parsing_on_main_thread_(parsing_on_main_thread),\012        parsing_module_(parsing_module),\012        stack_limit_(stack_limit),\012        pending_error_handler_(pending_error_handler),\012        zone_(zone),\012        classifier_(nullptr),\012        scanner_(scanner),\012        default_eager_compile_hint_(FunctionLiteral::kShouldLazyCompile),\012        function_literal_id_(0),\012        script_id_(script_id),\012        allow_natives_(false),\012        allow_harmony_do_expressions_(false),\012        allow_harmony_public_fields_(false),\012        allow_harmony_static_fields_(false),\012        allow_harmony_dynamic_import_(false),\012        allow_harmony_import_meta_(false),\012        allow_harmony_private_fields_(false),\012        allow_eval_cache_(true) {}\012\012#define ALLOW_ACCESSORS(name)                           \\012 bool allow_##name() const { return allow_##name##_; } \\012 void set_allow_##name(bool allow) { allow_##name##_ = allow; }\012\012  ALLOW_ACCESSORS(natives);\012  ALLOW_ACCESSORS(harmony_do_expressions);\012  ALLOW_ACCESSORS(harmony_public_fields);\012  ALLOW_ACCESSORS(harmony_static_fields);\012  ALLOW_ACCESSORS(harmony_dynamic_import);\012  ALLOW_ACCESSORS(harmony_import_meta);\012  ALLOW_ACCESSORS(eval_cache);\012\012#undef ALLOW_ACCESSORS\012\012 bool allow_harmony_bigint() const {\012 return scanner()-&gt;allow_harmony_bigint();\012 }\012 void set_allow_harmony_bigint(bool allow) {\012    scanner()-&gt;set_allow_harmony_bigint(allow);\012 }\012 bool allow_harmony_numeric_separator() const {\012 return scanner()-&gt;allow_harmony_numeric_separator();\012 }\012 void set_allow_harmony_numeric_separator(bool allow) {\012    scanner()-&gt;set_allow_harmony_numeric_separator(allow);\012 }\012\012 bool allow_harmony_private_fields() const {\012 return scanner()-&gt;allow_harmony_private_fields();\012 }\012 void set_allow_harmony_private_fields(bool allow) {\012    scanner()-&gt;set_allow_harmony_private_fields(allow);\012 }\012\012 uintptr_t stack_limit() const { return stack_limit_; }\012\012 void set_stack_limit(uintptr_t stack_limit) { stack_limit_ = stack_limit; }\012\012 void set_default_eager_compile_hint(\012 FunctionLiteral::EagerCompileHint eager_compile_hint) {\012    default_eager_compile_hint_ = eager_compile_hint;\012 }\012\012 FunctionLiteral::EagerCompileHint default_eager_compile_hint() const {\012 return default_eager_compile_hint_;\012 }\012\012 int GetNextFunctionLiteralId() { return ++function_literal_id_; }\012 int GetLastFunctionLiteralId() const { return function_literal_id_; }\012\012 void SkipFunctionLiterals(int delta) { function_literal_id_ += delta; }\012\012 void ResetFunctionLiteralId() { function_literal_id_ = 0; }\012\012 // The Zone where the parsing outputs are stored.\012 Zone* main_zone() const { return ast_value_factory()-&gt;zone(); }\012\012 // The current Zone, which might be the main zone or a temporary Zone.\012 Zone* zone() const { return zone_; }\012\012 protected:\012 friend class v8::internal::ExpressionClassifier&lt;ParserTypes&lt;Impl&gt;&gt;;\012\012 enum AllowRestrictedIdentifiers {\012    kAllowRestrictedIdentifiers,\012    kDontAllowRestrictedIdentifiers\012 };\012\012 enum LazyParsingResult { kLazyParsingComplete, kLazyParsingAborted };\012\012 enum VariableDeclarationContext {\012    kStatementListItem,\012    kStatement,\012    kForStatement\012 };\012\012 class ClassLiteralChecker;\012 class ObjectLiteralChecker;\012\012 // ---------------------------------------------------------------------------\012 // BlockState and FunctionState implement the parser's scope stack.\012 // The parser's current scope is in scope_. BlockState and FunctionState\012 // constructors push on the scope stack and the destructors pop. They are also\012 // used to hold the parser's per-funcion state.\012 class BlockState BASE_EMBEDDED {\012 public:\012 BlockState(Scope** scope_stack, Scope* scope)\012 : scope_stack_(scope_stack), outer_scope_(*scope_stack) {\012 *scope_stack_ = scope;\012 }\012\012 BlockState(Zone* zone, Scope** scope_stack)\012 : BlockState(scope_stack,\012 new (zone) Scope(zone, *scope_stack, BLOCK_SCOPE)) {}\012\012 ~BlockState() { *scope_stack_ = outer_scope_; }\012\012 private:\012 Scope** const scope_stack_;\012 Scope* const outer_scope_;\012 };\012\012 class FunctionState final : public BlockState {\012 public:\012 FunctionState(FunctionState** function_state_stack, Scope** scope_stack,\012 DeclarationScope* scope);\012 ~FunctionState();\012\012 DeclarationScope* scope() const { return scope_-&gt;AsDeclarationScope(); }\012\012 void AddProperty() { expected_property_count_++; }\012 int expected_property_count() { return expected_property_count_; }\012\012 void DisableOptimization(BailoutReason reason) {\012      dont_optimize_reason_ = reason;\012 }\012 BailoutReason dont_optimize_reason() { return dont_optimize_reason_; }\012\012 void AddSuspend() { suspend_count_++; }\012 int suspend_count() const { return suspend_count_; }\012 bool CanSuspend() const { return suspend_count_ &gt; 0; }\012\012 FunctionKind kind() const { return scope()-&gt;function_kind(); }\012\012 void RewindDestructuringAssignments(int pos) {\012      destructuring_assignments_to_rewrite_.Rewind(pos);\012 }\012\012 void AdoptDestructuringAssignmentsFromParentState(int pos) {\012 const auto&amp; outer_assignments =\012          outer_function_state_-&gt;destructuring_assignments_to_rewrite_;\012      DCHECK_GE(outer_assignments.size(), pos);\012 auto it = outer_assignments.begin();\012      it.Advance(pos);\012 for (; it != outer_assignments.end(); ++it) {\012 auto expr = *it;\012        expr-&gt;set_scope(scope_);\012        destructuring_assignments_to_rewrite_.push_back(expr);\012 }\012      outer_function_state_-&gt;RewindDestructuringAssignments(pos);\012 }\012\012 const ZoneChunkList&lt;RewritableExpressionT&gt;&amp;\012    destructuring_assignments_to_rewrite() const {\012 return destructuring_assignments_to_rewrite_;\012 }\012\012 ZoneVector&lt;typename ExpressionClassifier::Error&gt;* GetReportedErrorList() {\012 return &amp;reported_errors_;\012 }\012\012 bool next_function_is_likely_called() const {\012 return next_function_is_likely_called_;\012 }\012\012 bool previous_function_was_likely_called() const {\012 return previous_function_was_likely_called_;\012 }\012\012 void set_next_function_is_likely_called() {\012      next_function_is_likely_called_ = true;\012 }\012\012 void RecordFunctionOrEvalCall() { contains_function_or_eval_ = true; }\012 bool contains_function_or_eval() const {\012 return contains_function_or_eval_;\012 }\012\012 class FunctionOrEvalRecordingScope {\012 public:\012 explicit FunctionOrEvalRecordingScope(FunctionState* state)\012 : state_(state) {\012        prev_value_ = state-&gt;contains_function_or_eval_;\012        state-&gt;contains_function_or_eval_ = false;\012 }\012 ~FunctionOrEvalRecordingScope() {\012 bool found = state_-&gt;contains_function_or_eval_;\012 if (!found) {\012          state_-&gt;contains_function_or_eval_ = prev_value_;\012 }\012 }\012\012 private:\012 FunctionState* state_;\012 bool prev_value_;\012 };\012\012 private:\012 void AddDestructuringAssignment(RewritableExpressionT expr) {\012      destructuring_assignments_to_rewrite_.push_back(expr);\012 }\012\012 // Properties count estimation.\012 int expected_property_count_;\012\012 // How many suspends are needed for this function.\012 int suspend_count_;\012\012 FunctionState** function_state_stack_;\012 FunctionState* outer_function_state_;\012 DeclarationScope* scope_;\012\012 ZoneChunkList&lt;RewritableExpressionT&gt; destructuring_assignments_to_rewrite_;\012\012 // We use a ZoneVector here because we need to do a lot of random access.\012 ZoneVector&lt;typename ExpressionClassifier::Error&gt; reported_errors_;\012\012 // A reason, if any, why this function should not be optimized.\012 BailoutReason dont_optimize_reason_;\012\012 // Record whether the next (=== immediately following) function literal is\012 // preceded by a parenthesis / exclamation mark. Also record the previous\012 // state.\012 // These are managed by the FunctionState constructor; the caller may only\012 // call set_next_function_is_likely_called.\012 bool next_function_is_likely_called_;\012 bool previous_function_was_likely_called_;\012\012 // Track if a function or eval occurs within this FunctionState\012 bool contains_function_or_eval_;\012\012 friend Impl;\012 };\012\012 struct DeclarationDescriptor {\012 enum Kind { NORMAL, PARAMETER, FOR_EACH };\012 Scope* scope;\012 VariableMode mode;\012 int declaration_pos;\012 int initialization_pos;\012 Kind declaration_kind;\012 };\012\012 struct DeclarationParsingResult {\012 struct Declaration {\012 Declaration(ExpressionT pattern, int initializer_position,\012 ExpressionT initializer)\012 : pattern(pattern),\012            initializer_position(initializer_position),\012            initializer(initializer) {}\012\012 ExpressionT pattern;\012 int initializer_position;\012 int value_beg_position = kNoSourcePosition;\012 ExpressionT initializer;\012 };\012\012 DeclarationParsingResult()\012 : first_initializer_loc(Scanner::Location::invalid()),\012          bindings_loc(Scanner::Location::invalid()) {}\012\012 DeclarationDescriptor descriptor;\012    std::vector&lt;Declaration&gt; declarations;\012 Scanner::Location first_initializer_loc;\012 Scanner::Location bindings_loc;\012 };\012\012 struct CatchInfo {\012 public:\012 explicit CatchInfo(ParserBase* parser)\012 : name(parser-&gt;impl()-&gt;NullIdentifier()),\012          pattern(parser-&gt;impl()-&gt;NullExpression()),\012          scope(nullptr),\012          init_block(parser-&gt;impl()-&gt;NullStatement()),\012          inner_block(parser-&gt;impl()-&gt;NullStatement()),\012          bound_names(1, parser-&gt;zone()) {}\012 IdentifierT name;\012 ExpressionT pattern;\012 Scope* scope;\012 BlockT init_block;\012 BlockT inner_block;\012 ZonePtrList&lt;const AstRawString&gt; bound_names;\012 };\012\012 struct ForInfo {\012 public:\012 explicit ForInfo(ParserBase* parser)\012 : bound_names(1, parser-&gt;zone()),\012          mode(ForEachStatement::ENUMERATE),\012          position(kNoSourcePosition),\012          parsing_result() {}\012 ZonePtrList&lt;const AstRawString&gt; bound_names;\012 ForEachStatement::VisitMode mode;\012 int position;\012 DeclarationParsingResult parsing_result;\012 };\012\012 struct ClassInfo {\012 public:\012 explicit ClassInfo(ParserBase* parser)\012 : variable(nullptr),\012 extends(parser-&gt;impl()-&gt;NullExpression()),\012          properties(parser-&gt;impl()-&gt;NewClassPropertyList(4)),\012          static_fields(parser-&gt;impl()-&gt;NewClassPropertyList(4)),\012          instance_fields(parser-&gt;impl()-&gt;NewClassPropertyList(4)),\012          constructor(parser-&gt;impl()-&gt;NullExpression()),\012          has_seen_constructor(false),\012          has_name_static_property(false),\012          has_static_computed_names(false),\012          has_static_class_fields(false),\012          has_instance_class_fields(false),\012          is_anonymous(false),\012          static_fields_scope(nullptr),\012          instance_fields_scope(nullptr),\012          computed_field_count(0) {}\012 Variable* variable;\012 ExpressionT extends;\012 typename Types::ClassPropertyList properties;\012 typename Types::ClassPropertyList static_fields;\012 typename Types::ClassPropertyList instance_fields;\012 FunctionLiteralT constructor;\012\012 bool has_seen_constructor;\012 bool has_name_static_property;\012 bool has_static_computed_names;\012 bool has_static_class_fields;\012 bool has_instance_class_fields;\012 bool is_anonymous;\012 DeclarationScope* static_fields_scope;\012 DeclarationScope* instance_fields_scope;\012 int computed_field_count;\012 };\012\012 const AstRawString* ClassFieldVariableName(AstValueFactory* ast_value_factory,\012 int index) {\012    std::string name = &quot;.class-field-&quot; + std::to_string(index);\012 return ast_value_factory-&gt;GetOneByteString(name.c_str());\012 }\012\012 DeclarationScope* NewScriptScope() const {\012 return new (zone()) DeclarationScope(zone(), ast_value_factory());\012 }\012\012 DeclarationScope* NewVarblockScope() const {\012 return new (zone()) DeclarationScope(zone(), scope(), BLOCK_SCOPE);\012 }\012\012 ModuleScope* NewModuleScope(DeclarationScope* parent) const {\012 return new (zone()) ModuleScope(parent, ast_value_factory());\012 }\012\012 DeclarationScope* NewEvalScope(Scope* parent) const {\012 return new (zone()) DeclarationScope(zone(), parent, EVAL_SCOPE);\012 }\012\012 Scope* NewScope(ScopeType scope_type) const {\012 return NewScopeWithParent(scope(), scope_type);\012 }\012\012 // This constructor should only be used when absolutely necessary. Most scopes\012 // should automatically use scope() as parent, and be fine with\012 // NewScope(ScopeType) above.\012 Scope* NewScopeWithParent(Scope* parent, ScopeType scope_type) const {\012 // Must always use the specific constructors for the blacklisted scope\012 // types.\012    DCHECK_NE(FUNCTION_SCOPE, scope_type);\012    DCHECK_NE(SCRIPT_SCOPE, scope_type);\012    DCHECK_NE(MODULE_SCOPE, scope_type);\012    DCHECK_NOT_NULL(parent);\012 return new (zone()) Scope(zone(), parent, scope_type);\012 }\012\012 // Creates a function scope that always allocates in zone(). The function\012 // scope itself is either allocated in zone() or in target_zone if one is\012 // passed in.\012 DeclarationScope* NewFunctionScope(FunctionKind kind,\012 Zone* target_zone = nullptr) const {\012    DCHECK(ast_value_factory());\012 if (target_zone == nullptr) target_zone = zone();\012 DeclarationScope* result = new (target_zone)\012 DeclarationScope(zone(), scope(), FUNCTION_SCOPE, kind);\012\012 // Record presence of an inner function scope\012    function_state_-&gt;RecordFunctionOrEvalCall();\012\012 // TODO(verwaest): Move into the DeclarationScope constructor.\012 if (!IsArrowFunction(kind)) {\012      result-&gt;DeclareDefaultFunctionVariables(ast_value_factory());\012 }\012 return result;\012 }\012\012  V8_INLINE DeclarationScope* GetDeclarationScope() const {\012 return scope()-&gt;GetDeclarationScope();\012 }\012  V8_INLINE DeclarationScope* GetClosureScope() const {\012 return scope()-&gt;GetClosureScope();\012 }\012\012 Scanner* scanner() const { return scanner_; }\012 AstValueFactory* ast_value_factory() const { return ast_value_factory_; }\012 int position() const { return scanner_-&gt;location().beg_pos; }\012 int peek_position() const { return scanner_-&gt;peek_location().beg_pos; }\012 bool stack_overflow() const {\012 return pending_error_handler()-&gt;stack_overflow();\012 }\012 void set_stack_overflow() { pending_error_handler()-&gt;set_stack_overflow(); }\012 int script_id() { return script_id_; }\012 void set_script_id(int id) { script_id_ = id; }\012\012  V8_INLINE Token::Value peek() {\012 if (stack_overflow()) return Token::ILLEGAL;\012 return scanner()-&gt;peek();\012 }\012\012 // Returns the position past the following semicolon (if it exists), and the\012 // position past the end of the current token otherwise.\012 int PositionAfterSemicolon() {\012 return (peek() == Token::SEMICOLON) ? scanner_-&gt;peek_location().end_pos\012 : scanner_-&gt;location().end_pos;\012 }\012\012  V8_INLINE Token::Value PeekAhead() {\012 if (stack_overflow()) return Token::ILLEGAL;\012 return scanner()-&gt;PeekAhead();\012 }\012\012  V8_INLINE Token::Value Next() {\012 if (stack_overflow()) return Token::ILLEGAL;\012 {\012 if (GetCurrentStackPosition() &lt; stack_limit_) {\012 // Any further calls to Next or peek will return the illegal token.\012 // The current call must return the next token, which might already\012 // have been peek'ed.\012        set_stack_overflow();\012 }\012 }\012 return scanner()-&gt;Next();\012 }\012\012 void Consume(Token::Value token) {\012 Token::Value next = Next();\012    USE(next);\012    USE(token);\012    DCHECK(next == token);\012 }\012\012 bool Check(Token::Value token) {\012 Token::Value next = peek();\012 if (next == token) {\012 Consume(next);\012 return true;\012 }\012 return false;\012 }\012\012 void Expect(Token::Value token, bool* ok) {\012 Token::Value next = Next();\012 if (next != token) {\012 ReportUnexpectedToken(next);\012 *ok = false;\012 }\012 }\012\012 void ExpectSemicolon(bool* ok) {\012 // Check for automatic semicolon insertion according to\012 // the rules given in ECMA-262, section 7.9, page 21.\012 Token::Value tok = peek();\012 if (tok == Token::SEMICOLON) {\012 Next();\012 return;\012 }\012 if (scanner()-&gt;HasLineTerminatorBeforeNext() || tok == Token::RBRACE ||\012        tok == Token::EOS) {\012 return;\012 }\012\012 Token::Value current = scanner()-&gt;current_token();\012 Scanner::Location current_location = scanner()-&gt;location();\012 Token::Value next = Next();\012\012 if (next == Token::SEMICOLON) {\012 return;\012 }\012\012 *ok = false;\012 if (current == Token::AWAIT &amp;&amp; !is_async_function()) {\012 ReportMessageAt(current_location,\012 MessageTemplate::kAwaitNotInAsyncFunction, kSyntaxError);\012 return;\012 }\012\012 ReportUnexpectedToken(next);\012 }\012\012 // Dummy functions, just useful as arguments to CHECK_OK_CUSTOM.\012 static void Void() {}\012 template &lt;typename T&gt;\012 static T Return(T result) {\012 return result;\012 }\012\012 bool is_any_identifier(Token::Value token) {\012 return token == Token::IDENTIFIER || token == Token::ENUM ||\012           token == Token::AWAIT || token == Token::ASYNC ||\012           token == Token::ESCAPED_STRICT_RESERVED_WORD ||\012           token == Token::FUTURE_STRICT_RESERVED_WORD || token == Token::LET ||\012           token == Token::STATIC || token == Token::YIELD;\012 }\012 bool peek_any_identifier() { return is_any_identifier(peek()); }\012\012 bool CheckContextualKeyword(Token::Value token) {\012 if (PeekContextualKeyword(token)) {\012 Consume(Token::IDENTIFIER);\012 return true;\012 }\012 return false;\012 }\012\012 bool PeekContextualKeyword(Token::Value token) {\012    DCHECK(Token::IsContextualKeyword(token));\012 return peek() == Token::IDENTIFIER &amp;&amp;\012           scanner()-&gt;next_contextual_token() == token;\012 }\012\012 void ExpectMetaProperty(Token::Value property_name, const char* full_name,\012 int pos, bool* ok);\012\012 void ExpectContextualKeyword(Token::Value token, bool* ok) {\012    DCHECK(Token::IsContextualKeyword(token));\012 Expect(Token::IDENTIFIER, CHECK_OK_CUSTOM(Void));\012 if (scanner()-&gt;current_contextual_token() != token) {\012 ReportUnexpectedToken(scanner()-&gt;current_token());\012 *ok = false;\012 }\012 }\012\012 bool CheckInOrOf(ForEachStatement::VisitMode* visit_mode) {\012 if (Check(Token::IN)) {\012 *visit_mode = ForEachStatement::ENUMERATE;\012 return true;\012 } else if (CheckContextualKeyword(Token::OF)) {\012 *visit_mode = ForEachStatement::ITERATE;\012 return true;\012 }\012 return false;\012 }\012\012 bool PeekInOrOf() {\012 return peek() == Token::IN || PeekContextualKeyword(Token::OF);\012 }\012\012 // Checks whether an octal literal was last seen between beg_pos and end_pos.\012 // Only called for strict mode strings.\012 void CheckStrictOctalLiteral(int beg_pos, int end_pos, bool* ok) {\012 Scanner::Location octal = scanner()-&gt;octal_position();\012 if (octal.IsValid() &amp;&amp; beg_pos &lt;= octal.beg_pos &amp;&amp;\012        octal.end_pos &lt;= end_pos) {\012 MessageTemplate::Template message = scanner()-&gt;octal_message();\012      DCHECK_NE(message, MessageTemplate::kNone);\012      impl()-&gt;ReportMessageAt(octal, message);\012      scanner()-&gt;clear_octal_position();\012 if (message == MessageTemplate::kStrictDecimalWithLeadingZero) {\012        impl()-&gt;CountUsage(v8::Isolate::kDecimalWithLeadingZeroInStrictMode);\012 }\012 *ok = false;\012 }\012 }\012\012 // Checks if an octal literal or an invalid hex or unicode escape sequence\012 // appears in the current template literal token. In the presence of such,\012 // either returns false or reports an error, depending on should_throw.\012 // Otherwise returns true.\012 inline bool CheckTemplateEscapes(bool should_throw, bool* ok) {\012    DCHECK(scanner()-&gt;current_token() == Token::TEMPLATE_SPAN ||\012           scanner()-&gt;current_token() == Token::TEMPLATE_TAIL);\012 if (!scanner()-&gt;has_invalid_template_escape()) {\012 return true;\012 }\012\012 // Handle error case(s)\012 if (should_throw) {\012      impl()-&gt;ReportMessageAt(scanner()-&gt;invalid_template_escape_location(),\012                              scanner()-&gt;invalid_template_escape_message());\012 *ok = false;\012 }\012 return false;\012 }\012\012 void CheckDestructuringElement(ExpressionT element, int beg_pos, int end_pos);\012\012 // Checking the name of a function literal. This has to be done after parsing\012 // the function, since the function can declare itself strict.\012 void CheckFunctionName(LanguageMode language_mode, IdentifierT function_name,\012 FunctionNameValidity function_name_validity,\012 const Scanner::Location&amp; function_name_loc, bool* ok) {\012 if (impl()-&gt;IsNull(function_name)) return;\012 if (function_name_validity == kSkipFunctionNameCheck) return;\012 // The function name needs to be checked in strict mode.\012 if (is_sloppy(language_mode)) return;\012\012 if (impl()-&gt;IsEvalOrArguments(function_name)) {\012      impl()-&gt;ReportMessageAt(function_name_loc,\012 MessageTemplate::kStrictEvalArguments);\012 *ok = false;\012 return;\012 }\012 if (function_name_validity == kFunctionNameIsStrictReserved) {\012      impl()-&gt;ReportMessageAt(function_name_loc,\012 MessageTemplate::kUnexpectedStrictReserved);\012 *ok = false;\012 return;\012 }\012 }\012\012 // Determine precedence of given token.\012 static int Precedence(Token::Value token, bool accept_IN) {\012 if (token == Token::IN &amp;&amp; !accept_IN)\012 return 0; // 0 precedence will terminate binary expression parsing\012 return Token::Precedence(token);\012 }\012\012 typename Types::Factory* factory() { return &amp;ast_node_factory_; }\012\012 DeclarationScope* GetReceiverScope() const {\012 return scope()-&gt;GetReceiverScope();\012 }\012 LanguageMode language_mode() { return scope()-&gt;language_mode(); }\012 void RaiseLanguageMode(LanguageMode mode) {\012 LanguageMode old = scope()-&gt;language_mode();\012    impl()-&gt;SetLanguageMode(scope(), old &gt; mode ? old : mode);\012 }\012 bool is_generator() const {\012 return IsGeneratorFunction(function_state_-&gt;kind());\012 }\012 bool is_async_function() const {\012 return IsAsyncFunction(function_state_-&gt;kind());\012 }\012 bool is_async_generator() const {\012 return IsAsyncGeneratorFunction(function_state_-&gt;kind());\012 }\012 bool is_resumable() const {\012 return IsResumableFunction(function_state_-&gt;kind());\012 }\012\012 const PendingCompilationErrorHandler* pending_error_handler() const {\012 return pending_error_handler_;\012 }\012 PendingCompilationErrorHandler* pending_error_handler() {\012 return pending_error_handler_;\012 }\012\012 // Report syntax errors.\012 void ReportMessage(MessageTemplate::Template message) {\012 Scanner::Location source_location = scanner()-&gt;location();\012    impl()-&gt;ReportMessageAt(source_location, message,\012 static_cast&lt;const char*&gt;(nullptr), kSyntaxError);\012 }\012\012 template &lt;typename T&gt;\012 void ReportMessage(MessageTemplate::Template message, T arg,\012 ParseErrorType error_type = kSyntaxError) {\012 Scanner::Location source_location = scanner()-&gt;location();\012    impl()-&gt;ReportMessageAt(source_location, message, arg, error_type);\012 }\012\012 void ReportMessageAt(Scanner::Location location,\012 MessageTemplate::Template message,\012 ParseErrorType error_type) {\012    impl()-&gt;ReportMessageAt(location, message,\012 static_cast&lt;const char*&gt;(nullptr), error_type);\012 }\012\012 void GetUnexpectedTokenMessage(\012 Token::Value token, MessageTemplate::Template* message,\012 Scanner::Location* location, const char** arg,\012 MessageTemplate::Template default_ = MessageTemplate::kUnexpectedToken);\012\012 void ReportUnexpectedToken(Token::Value token);\012 void ReportUnexpectedTokenAt(\012 Scanner::Location location, Token::Value token,\012 MessageTemplate::Template message = MessageTemplate::kUnexpectedToken);\012\012 void ReportClassifierError(\012 const typename ExpressionClassifier::Error&amp; error) {\012    impl()-&gt;ReportMessageAt(error.location, error.message, error.arg);\012 }\012\012 void ValidateExpression(bool* ok) {\012 if (!classifier()-&gt;is_valid_expression()) {\012 ReportClassifierError(classifier()-&gt;expression_error());\012 *ok = false;\012 }\012 }\012\012 void ValidateFormalParameterInitializer(bool* ok) {\012 if (!classifier()-&gt;is_valid_formal_parameter_initializer()) {\012 ReportClassifierError(classifier()-&gt;formal_parameter_initializer_error());\012 *ok = false;\012 }\012 }\012\012 void ValidateBindingPattern(bool* ok) {\012 if (!classifier()-&gt;is_valid_binding_pattern()) {\012 ReportClassifierError(classifier()-&gt;binding_pattern_error());\012 *ok = false;\012 }\012 }\012\012 void ValidateAssignmentPattern(bool* ok) {\012 if (!classifier()-&gt;is_valid_assignment_pattern()) {\012 ReportClassifierError(classifier()-&gt;assignment_pattern_error());\012 *ok = false;\012 }\012 }\012\012 void ValidateFormalParameters(LanguageMode language_mode,\012 bool allow_duplicates, bool* ok) {\012 if (!allow_duplicates &amp;&amp;\012 !classifier()-&gt;is_valid_formal_parameter_list_without_duplicates()) {\012 ReportClassifierError(classifier()-&gt;duplicate_formal_parameter_error());\012 *ok = false;\012 } else if (is_strict(language_mode) &amp;&amp;\012 !classifier()-&gt;is_valid_strict_mode_formal_parameters()) {\012 ReportClassifierError(classifier()-&gt;strict_mode_formal_parameter_error());\012 *ok = false;\012 }\012 }\012\012 bool IsValidArrowFormalParametersStart(Token::Value token) {\012 return is_any_identifier(token) || token == Token::LPAREN;\012 }\012\012 void ValidateArrowFormalParameters(ExpressionT expr,\012 bool parenthesized_formals, bool is_async,\012 bool* ok) {\012 if (classifier()-&gt;is_valid_binding_pattern()) {\012 // A simple arrow formal parameter: IDENTIFIER =&gt; BODY.\012 if (!impl()-&gt;IsIdentifier(expr)) {\012        impl()-&gt;ReportMessageAt(scanner()-&gt;location(),\012 MessageTemplate::kUnexpectedToken,\012 Token::String(scanner()-&gt;current_token()));\012 *ok = false;\012 }\012 } else if (!classifier()-&gt;is_valid_arrow_formal_parameters()) {\012 // If after parsing the expr, we see an error but the expression is\012 // neither a valid binding pattern nor a valid parenthesized formal\012 // parameter list, show the &quot;arrow formal parameters&quot; error if the formals\012 // started with a parenthesis, and the binding pattern error otherwise.\012 const typename ExpressionClassifier::Error&amp; error =\012          parenthesized_formals ? classifier()-&gt;arrow_formal_parameters_error()\012 : classifier()-&gt;binding_pattern_error();\012 ReportClassifierError(error);\012 *ok = false;\012 }\012 if (is_async &amp;&amp; !classifier()-&gt;is_valid_async_arrow_formal_parameters()) {\012 const typename ExpressionClassifier::Error&amp; error =\012          classifier()-&gt;async_arrow_formal_parameters_error();\012 ReportClassifierError(error);\012 *ok = false;\012 }\012 }\012\012 void ValidateLetPattern(bool* ok) {\012 if (!classifier()-&gt;is_valid_let_pattern()) {\012 ReportClassifierError(classifier()-&gt;let_pattern_error());\012 *ok = false;\012 }\012 }\012\012 void BindingPatternUnexpectedToken() {\012 MessageTemplate::Template message = MessageTemplate::kUnexpectedToken;\012 const char* arg;\012 Scanner::Location location = scanner()-&gt;peek_location();\012 GetUnexpectedTokenMessage(peek(), &amp;message, &amp;location, &amp;arg);\012    classifier()-&gt;RecordBindingPatternError(location, message, arg);\012 }\012\012 void ArrowFormalParametersUnexpectedToken() {\012 MessageTemplate::Template message = MessageTemplate::kUnexpectedToken;\012 const char* arg;\012 Scanner::Location location = scanner()-&gt;peek_location();\012 GetUnexpectedTokenMessage(peek(), &amp;message, &amp;location, &amp;arg);\012    classifier()-&gt;RecordArrowFormalParametersError(location, message, arg);\012 }\012\012 // Recursive descent functions.\012 // All ParseXXX functions take as the last argument an *ok parameter\012 // which is set to false if parsing failed; it is unchanged otherwise.\012 // By making the 'exception handling' explicit, we are forced to check\012 // for failure at the call sites. The family of CHECK_OK* macros can\012 // be useful for this.\012\012 // Parses an identifier that is valid for the current scope, in particular it\012 // fails on strict mode future reserved keywords in a strict scope. If\012 // allow_eval_or_arguments is kAllowEvalOrArguments, we allow &quot;eval&quot; or\012 // &quot;arguments&quot; as identifier even in strict mode (this is needed in cases like\012 // &quot;var foo = eval;&quot;).\012 IdentifierT ParseIdentifier(AllowRestrictedIdentifiers, bool* ok);\012 IdentifierT ParseAndClassifyIdentifier(bool* ok);\012 // Parses an identifier or a strict mode future reserved word, and indicate\012 // whether it is strict mode future reserved. Allows passing in function_kind\012 // for the case of parsing the identifier in a function expression, where the\012 // relevant &quot;function_kind&quot; bit is of the function being parsed, not the\012 // containing function.\012 IdentifierT ParseIdentifierOrStrictReservedWord(FunctionKind function_kind,\012 bool* is_strict_reserved,\012 bool* is_await, bool* ok);\012 IdentifierT ParseIdentifierOrStrictReservedWord(bool* is_strict_reserved,\012 bool* is_await, bool* ok) {\012 return ParseIdentifierOrStrictReservedWord(\012        function_state_-&gt;kind(), is_strict_reserved, is_await, ok);\012 }\012\012  V8_INLINE IdentifierT ParseIdentifierName(bool* ok);\012\012 ExpressionT ParseIdentifierNameOrPrivateName(bool* ok);\012\012 ExpressionT ParseRegExpLiteral(bool* ok);\012\012 ExpressionT ParsePrimaryExpression(bool* is_async, bool* ok);\012 ExpressionT ParsePrimaryExpression(bool* ok) {\012 bool is_async;\012 return ParsePrimaryExpression(&amp;is_async, ok);\012 }\012\012 // Use when parsing an expression that is known to not be a pattern or part\012 // of a pattern.\012  V8_INLINE ExpressionT ParseExpression(bool accept_IN, bool* ok);\012\012 // This method does not wrap the parsing of the expression inside a\012 // new expression classifier; it uses the top-level classifier instead.\012 // It should be used whenever we're parsing something with the &quot;cover&quot;\012 // grammar that recognizes both patterns and non-patterns (which roughly\012 // corresponds to what's inside the parentheses generated by the symbol\012 // &quot;CoverParenthesizedExpressionAndArrowParameterList&quot; in the ES 2017\012 // specification).\012 ExpressionT ParseExpressionCoverGrammar(bool accept_IN, bool* ok);\012\012 ExpressionT ParseArrayLiteral(bool* ok);\012\012 enum class PropertyKind {\012    kAccessorProperty,\012    kValueProperty,\012    kShorthandProperty,\012    kMethodProperty,\012    kClassField,\012    kSpreadProperty,\012    kNotSet\012 };\012\012 bool SetPropertyKindFromToken(Token::Value token, PropertyKind* kind);\012 ExpressionT ParsePropertyName(IdentifierT* name, PropertyKind* kind,\012 bool* is_generator, bool* is_get, bool* is_set,\012 bool* is_async, bool* is_computed_name,\012 bool* ok);\012 ExpressionT ParseObjectLiteral(bool* ok);\012 ClassLiteralPropertyT ParseClassPropertyDefinition(\012 ClassLiteralChecker* checker, ClassInfo* class_info,\012 IdentifierT* property_name, bool has_extends, bool* is_computed_name,\012 ClassLiteralProperty::Kind* property_kind, bool* is_static, bool* ok);\012 ExpressionT ParseClassFieldInitializer(ClassInfo* class_info, bool is_static,\012 bool* ok);\012 ObjectLiteralPropertyT ParseObjectPropertyDefinition(\012 ObjectLiteralChecker* checker, bool* is_computed_name,\012 bool* is_rest_property, bool* ok);\012 ExpressionListT ParseArguments(Scanner::Location* first_spread_pos,\012 bool maybe_arrow,\012 bool* is_simple_parameter_list, bool* ok);\012 ExpressionListT ParseArguments(Scanner::Location* first_spread_pos,\012 bool* ok) {\012 return ParseArguments(first_spread_pos, false, nullptr, ok);\012 }\012\012 ExpressionT ParseAssignmentExpression(bool accept_IN, bool* ok);\012 ExpressionT ParseYieldExpression(bool accept_IN, bool* ok);\012  V8_INLINE ExpressionT ParseConditionalExpression(bool accept_IN, bool* ok);\012 ExpressionT ParseBinaryExpression(int prec, bool accept_IN, bool* ok);\012 ExpressionT ParseUnaryExpression(bool* ok);\012  V8_INLINE ExpressionT ParsePostfixExpression(bool* ok);\012  V8_INLINE ExpressionT ParseLeftHandSideExpression(bool* ok);\012 ExpressionT ParseMemberWithNewPrefixesExpression(bool* is_async, bool* ok);\012  V8_INLINE ExpressionT ParseMemberExpression(bool* is_async, bool* ok);\012  V8_INLINE ExpressionT ParseMemberExpressionContinuation(\012 ExpressionT expression, bool* is_async, bool* ok);\012\012 // `rewritable_length`: length of the destructuring_assignments_to_rewrite()\012 // queue in the parent function state, prior to parsing of formal parameters.\012 // If the arrow function is lazy, any items added during formal parameter\012 // parsing are removed from the queue.\012 ExpressionT ParseArrowFunctionLiteral(bool accept_IN,\012 const FormalParametersT&amp; parameters,\012 int rewritable_length, bool* ok);\012 void ParseSingleExpressionFunctionBody(StatementListT body, bool is_async,\012 bool accept_IN, bool* ok);\012 void ParseAsyncFunctionBody(Scope* scope, StatementListT body, bool* ok);\012 ExpressionT ParseAsyncFunctionLiteral(bool* ok);\012 ExpressionT ParseClassLiteral(IdentifierT name,\012 Scanner::Location class_name_location,\012 bool name_is_strict_reserved,\012 int class_token_pos, bool* ok);\012 ExpressionT ParseTemplateLiteral(ExpressionT tag, int start, bool tagged,\012 bool* ok);\012 ExpressionT ParseSuperExpression(bool is_new, bool* ok);\012 ExpressionT ParseImportExpressions(bool* ok);\012 ExpressionT ParseNewTargetExpression(bool* ok);\012\012  V8_INLINE void ParseFormalParameter(FormalParametersT* parameters, bool* ok);\012 void ParseFormalParameterList(FormalParametersT* parameters, bool* ok);\012 void CheckArityRestrictions(int param_count, FunctionKind function_type,\012 bool has_rest, int formals_start_pos,\012 int formals_end_pos, bool* ok);\012\012 BlockT ParseVariableDeclarations(VariableDeclarationContext var_context,\012 DeclarationParsingResult* parsing_result,\012 ZonePtrList&lt;const AstRawString&gt;* names,\012 bool* ok);\012 StatementT ParseAsyncFunctionDeclaration(\012 ZonePtrList&lt;const AstRawString&gt;* names, bool default_export, bool* ok);\012 StatementT ParseFunctionDeclaration(bool* ok);\012 StatementT ParseHoistableDeclaration(ZonePtrList&lt;const AstRawString&gt;* names,\012 bool default_export, bool* ok);\012 StatementT ParseHoistableDeclaration(int pos, ParseFunctionFlags flags,\012 ZonePtrList&lt;const AstRawString&gt;* names,\012 bool default_export, bool* ok);\012 StatementT ParseClassDeclaration(ZonePtrList&lt;const AstRawString&gt;* names,\012 bool default_export, bool* ok);\012 StatementT ParseNativeDeclaration(bool* ok);\012\012 // Consumes the ending }.\012 void ParseFunctionBody(StatementListT result, IdentifierT function_name,\012 int pos, const FormalParametersT&amp; parameters,\012 FunctionKind kind,\012 FunctionLiteral::FunctionType function_type, bool* ok);\012\012 // Under some circumstances, we allow preparsing to abort if the preparsed\012 // function is &quot;long and trivial&quot;, and fully parse instead. Our current\012 // definition of &quot;long and trivial&quot; is:\012 // - over kLazyParseTrialLimit statements\012 // - all starting with an identifier (i.e., no if, for, while, etc.)\012 static const int kLazyParseTrialLimit = 200;\012\012 // TODO(nikolaos, marja): The first argument should not really be passed\012 // by value. The method is expected to add the parsed statements to the\012 // list. This works because in the case of the parser, StatementListT is\012 // a pointer whereas the preparser does not really modify the body.\012  V8_INLINE void ParseStatementList(StatementListT body, Token::Value end_token,\012 bool* ok) {\012 LazyParsingResult result = ParseStatementList(body, end_token, false, ok);\012    USE(result);\012    DCHECK_EQ(result, kLazyParsingComplete);\012 }\012  V8_INLINE LazyParsingResult ParseStatementList(StatementListT body,\012 Token::Value end_token,\012 bool may_abort, bool* ok);\012 StatementT ParseStatementListItem(bool* ok);\012\012 StatementT ParseStatement(ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels,\012 bool* ok) {\012 return ParseStatement(labels, own_labels,\012                          kDisallowLabelledFunctionStatement, ok);\012 }\012 StatementT ParseStatement(ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels,\012 AllowLabelledFunctionStatement allow_function,\012 bool* ok);\012 BlockT ParseBlock(ZonePtrList&lt;const AstRawString&gt;* labels, bool* ok);\012\012 // Parse a SubStatement in strict mode, or with an extra block scope in\012 // sloppy mode to handle\012 // ES#sec-functiondeclarations-in-ifstatement-statement-clauses\012 StatementT ParseScopedStatement(ZonePtrList&lt;const AstRawString&gt;* labels,\012 bool* ok);\012\012 StatementT ParseVariableStatement(VariableDeclarationContext var_context,\012 ZonePtrList&lt;const AstRawString&gt;* names,\012 bool* ok);\012\012 // Magical syntax support.\012 ExpressionT ParseV8Intrinsic(bool* ok);\012\012 ExpressionT ParseDoExpression(bool* ok);\012\012 StatementT ParseDebuggerStatement(bool* ok);\012\012 StatementT ParseExpressionOrLabelledStatement(\012 ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels,\012 AllowLabelledFunctionStatement allow_function, bool* ok);\012 StatementT ParseIfStatement(ZonePtrList&lt;const AstRawString&gt;* labels,\012 bool* ok);\012 StatementT ParseContinueStatement(bool* ok);\012 StatementT ParseBreakStatement(ZonePtrList&lt;const AstRawString&gt;* labels,\012 bool* ok);\012 StatementT ParseReturnStatement(bool* ok);\012 StatementT ParseWithStatement(ZonePtrList&lt;const AstRawString&gt;* labels,\012 bool* ok);\012 StatementT ParseDoWhileStatement(ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels,\012 bool* ok);\012 StatementT ParseWhileStatement(ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels,\012 bool* ok);\012 StatementT ParseThrowStatement(bool* ok);\012 StatementT ParseSwitchStatement(ZonePtrList&lt;const AstRawString&gt;* labels,\012 bool* ok);\012  V8_INLINE StatementT ParseTryStatement(bool* ok);\012 StatementT ParseForStatement(ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels,\012 bool* ok);\012 StatementT ParseForEachStatementWithDeclarations(\012 int stmt_pos, ForInfo* for_info, ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels, Scope* inner_block_scope,\012 bool* ok);\012 StatementT ParseForEachStatementWithoutDeclarations(\012 int stmt_pos, ExpressionT expression, int lhs_beg_pos, int lhs_end_pos,\012 ForInfo* for_info, ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels, bool* ok);\012\012 // Parse a C-style for loop: 'for (&lt;init&gt;; &lt;cond&gt;; &lt;next&gt;) { ... }'\012 // &quot;for (&lt;init&gt;;&quot; is assumed to have been parser already.\012 ForStatementT ParseStandardForLoop(\012 int stmt_pos, ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels, ExpressionT* cond,\012 StatementT* next, StatementT* body, bool* ok);\012 // Same as the above, but handles those cases where &lt;init&gt; is a\012 // lexical variable declaration.\012 StatementT ParseStandardForLoopWithLexicalDeclarations(\012 int stmt_pos, StatementT init, ForInfo* for_info,\012 ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels, bool* ok);\012 StatementT ParseForAwaitStatement(ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels,\012 bool* ok);\012\012 bool IsNextLetKeyword();\012 bool IsTrivialExpression();\012\012 // Checks if the expression is a valid reference expression (e.g., on the\012 // left-hand side of assignments). Although ruled out by ECMA as early errors,\012 // we allow calls for web compatibility and rewrite them to a runtime throw.\012 ExpressionT CheckAndRewriteReferenceExpression(\012 ExpressionT expression, int beg_pos, int end_pos,\012 MessageTemplate::Template message, bool* ok);\012 ExpressionT CheckAndRewriteReferenceExpression(\012 ExpressionT expression, int beg_pos, int end_pos,\012 MessageTemplate::Template message, ParseErrorType type, bool* ok);\012\012 bool IsValidReferenceExpression(ExpressionT expression);\012\012 bool IsAssignableIdentifier(ExpressionT expression) {\012 if (!impl()-&gt;IsIdentifier(expression)) return false;\012 if (is_strict(language_mode()) &amp;&amp;\012        impl()-&gt;IsEvalOrArguments(impl()-&gt;AsIdentifier(expression))) {\012 return false;\012 }\012 return true;\012 }\012\012 bool IsValidPattern(ExpressionT expression) {\012 return expression-&gt;IsObjectLiteral() || expression-&gt;IsArrayLiteral();\012 }\012\012 // Due to hoisting, the value of a 'var'-declared variable may actually change\012 // even if the code contains only the &quot;initial&quot; assignment, namely when that\012 // assignment occurs inside a loop.  For example:\012 //\012 //   let i = 10;\012 //   do { var x = i } while (i--):\012 //\012 // As a simple and very conservative approximation of this, we explicitly mark\012 // as maybe-assigned any non-lexical variable whose initializing &quot;declaration&quot;\012 // does not syntactically occur in the function scope.  (In the example above,\012 // it occurs in a block scope.)\012 //\012 // Note that non-lexical variables include temporaries, which may also get\012 // assigned inside a loop due to the various rewritings that the parser\012 // performs.\012 //\012 // This also handles marking of loop variables in for-in and for-of loops,\012 // as determined by declaration_kind.\012 //\012 static void MarkLoopVariableAsAssigned(\012 Scope* scope, Variable* var,\012 typename DeclarationDescriptor::Kind declaration_kind);\012\012 FunctionKind FunctionKindForImpl(bool is_method, bool is_generator,\012 bool is_async) {\012 static const FunctionKind kFunctionKinds[][2][2] = {\012 {\012 // is_method=false\012 {// is_generator=false\012 FunctionKind::kNormalFunction, FunctionKind::kAsyncFunction},\012 {// is_generator=true\012 FunctionKind::kGeneratorFunction,\012 FunctionKind::kAsyncGeneratorFunction},\012 },\012 {\012 // is_method=true\012 {// is_generator=false\012 FunctionKind::kConciseMethod, FunctionKind::kAsyncConciseMethod},\012 {// is_generator=true\012 FunctionKind::kConciseGeneratorMethod,\012 FunctionKind::kAsyncConciseGeneratorMethod},\012 }};\012 return kFunctionKinds[is_method][is_generator][is_async];\012 }\012\012 inline FunctionKind FunctionKindFor(bool is_generator, bool is_async) {\012 const bool kIsMethod = false;\012 return FunctionKindForImpl(kIsMethod, is_generator, is_async);\012 }\012\012 inline FunctionKind MethodKindFor(bool is_generator, bool is_async) {\012 const bool kIsMethod = true;\012 return FunctionKindForImpl(kIsMethod, is_generator, is_async);\012 }\012\012 // Keep track of eval() calls since they disable all local variable\012 // optimizations. This checks if expression is an eval call, and if yes,\012 // forwards the information to scope.\012 Call::PossiblyEval CheckPossibleEvalCall(ExpressionT expression,\012 Scope* scope) {\012 if (impl()-&gt;IsIdentifier(expression) &amp;&amp;\012        impl()-&gt;IsEval(impl()-&gt;AsIdentifier(expression))) {\012      scope-&gt;RecordInnerScopeEvalCall();\012      function_state_-&gt;RecordFunctionOrEvalCall();\012 if (is_sloppy(scope-&gt;language_mode())) {\012 // For sloppy scopes we also have to record the call at function level,\012 // in case it includes declarations that will be hoisted.\012        scope-&gt;GetDeclarationScope()-&gt;RecordEvalCall();\012 }\012\012 // This call is only necessary to track evals that may be\012 // inside arrow function parameter lists. In that case,\012 // Scope::Snapshot::Reparent will move this bit down into\012 // the arrow function's scope.\012      scope-&gt;RecordEvalCall();\012\012 return Call::IS_POSSIBLY_EVAL;\012 }\012 return Call::NOT_EVAL;\012 }\012\012 // Convenience method which determines the type of return statement to emit\012 // depending on the current function type.\012 inline StatementT BuildReturnStatement(ExpressionT expr, int pos,\012 int end_pos = kNoSourcePosition) {\012 if (impl()-&gt;IsNull(expr)) {\012      expr = factory()-&gt;NewUndefinedLiteral(kNoSourcePosition);\012 } else if (is_async_generator()) {\012 // In async generators, if there is an explicit operand to the return\012 // statement, await the operand.\012      expr = factory()-&gt;NewAwait(expr, kNoSourcePosition);\012      function_state_-&gt;AddSuspend();\012 }\012 if (is_async_function()) {\012 return factory()-&gt;NewAsyncReturnStatement(expr, pos, end_pos);\012 }\012 return factory()-&gt;NewReturnStatement(expr, pos, end_pos);\012 }\012\012 // Validation per ES6 object literals.\012 class ObjectLiteralChecker {\012 public:\012 explicit ObjectLiteralChecker(ParserBase* parser)\012 : parser_(parser), has_seen_proto_(false) {}\012\012 void CheckDuplicateProto(Token::Value property);\012\012 private:\012 bool IsProto() const {\012 return this-&gt;scanner()-&gt;CurrentMatchesContextualEscaped(\012 Token::PROTO_UNDERSCORED);\012 }\012\012 ParserBase* parser() const { return parser_; }\012 Scanner* scanner() const { return parser_-&gt;scanner(); }\012\012 ParserBase* parser_;\012 bool has_seen_proto_;\012 };\012\012 // Validation per ES6 class literals.\012 class ClassLiteralChecker {\012 public:\012 explicit ClassLiteralChecker(ParserBase* parser)\012 : parser_(parser), has_seen_constructor_(false) {}\012\012 void CheckClassMethodName(Token::Value property, PropertyKind type,\012 bool is_generator, bool is_async, bool is_static,\012 bool* ok);\012 void CheckClassFieldName(bool is_static, bool* ok);\012\012 private:\012 bool IsConstructor() {\012 return this-&gt;scanner()-&gt;CurrentMatchesContextualEscaped(\012 Token::CONSTRUCTOR);\012 }\012 bool IsPrivateConstructor() {\012 return this-&gt;scanner()-&gt;CurrentMatchesContextualEscaped(\012 Token::PRIVATE_CONSTRUCTOR);\012 }\012 bool IsPrototype() {\012 return this-&gt;scanner()-&gt;CurrentMatchesContextualEscaped(Token::PROTOTYPE);\012 }\012\012 ParserBase* parser() const { return parser_; }\012 Scanner* scanner() const { return parser_-&gt;scanner(); }\012\012 ParserBase* parser_;\012 bool has_seen_constructor_;\012 };\012\012 ModuleDescriptor* module() const {\012 return scope()-&gt;AsModuleScope()-&gt;module();\012 }\012 Scope* scope() const { return scope_; }\012\012 // Stack of expression classifiers.\012 // The top of the stack is always pointed to by classifier().\012  V8_INLINE ExpressionClassifier* classifier() const {\012    DCHECK_NOT_NULL(classifier_);\012 return classifier_;\012 }\012\012 // Accumulates the classifier that is on top of the stack (inner) to\012 // the one that is right below (outer) and pops the inner.\012  V8_INLINE void Accumulate(unsigned productions) {\012    DCHECK_NOT_NULL(classifier_);\012 ExpressionClassifier* previous = classifier_-&gt;previous();\012    DCHECK_NOT_NULL(previous);\012    previous-&gt;Accumulate(classifier_, productions);\012    classifier_ = previous;\012 }\012\012  V8_INLINE void AccumulateNonBindingPatternErrors() {\012 this-&gt;Accumulate(ExpressionClassifier::AllProductions &amp;\012 ~(ExpressionClassifier::BindingPatternProduction |\012 ExpressionClassifier::LetPatternProduction));\012 }\012\012 // Pops and discards the classifier that is on top of the stack\012 // without accumulating.\012  V8_INLINE void DiscardExpressionClassifier() {\012    DCHECK_NOT_NULL(classifier_);\012    classifier_-&gt;Discard();\012    classifier_ = classifier_-&gt;previous();\012 }\012\012 // Accumulate errors that can be arbitrarily deep in an expression.\012 // These correspond to the ECMAScript spec's 'Contains' operation\012 // on productions. This includes:\012 //\012 // - YieldExpression is disallowed in arrow parameters in a generator.\012 // - AwaitExpression is disallowed in arrow parameters in an async function.\012 // - AwaitExpression is disallowed in async arrow parameters.\012 //\012  V8_INLINE void AccumulateFormalParameterContainmentErrors() {\012 Accumulate(ExpressionClassifier::FormalParameterInitializerProduction |\012 ExpressionClassifier::AsyncArrowFormalParametersProduction);\012 }\012\012 // Parser base's protected field members.\012\012 Scope* scope_; // Scope stack.\012 Scope* original_scope_; // The top scope for the current parsing item.\012 FunctionState* function_state_; // Function state stack.\012  v8::Extension* extension_;\012 FuncNameInferrer* fni_;\012 AstValueFactory* ast_value_factory_; // Not owned.\012 typename Types::Factory ast_node_factory_;\012 RuntimeCallStats* runtime_call_stats_;\012 internal::Logger* logger_;\012 bool parsing_on_main_thread_;\012 const bool parsing_module_;\012 uintptr_t stack_limit_;\012 PendingCompilationErrorHandler* pending_error_handler_;\012\012 // Parser base's private field members.\012\012 private:\012 Zone* zone_;\012 ExpressionClassifier* classifier_;\012\012 Scanner* scanner_;\012\012 FunctionLiteral::EagerCompileHint default_eager_compile_hint_;\012\012 int function_literal_id_;\012 int script_id_;\012\012 bool allow_natives_;\012 bool allow_harmony_do_expressions_;\012 bool allow_harmony_public_fields_;\012 bool allow_harmony_static_fields_;\012 bool allow_harmony_dynamic_import_;\012 bool allow_harmony_import_meta_;\012 bool allow_harmony_private_fields_;\012 bool allow_eval_cache_;\012\012 friend class DiscardableZoneScope;\012};\012\012template &lt;typename Impl&gt;\012ParserBase&lt;Impl&gt;::FunctionState::FunctionState(\012 FunctionState** function_state_stack, Scope** scope_stack,\012 DeclarationScope* scope)\012 : BlockState(scope_stack, scope),\012      expected_property_count_(0),\012      suspend_count_(0),\012      function_state_stack_(function_state_stack),\012      outer_function_state_(*function_state_stack),\012      scope_(scope),\012      destructuring_assignments_to_rewrite_(scope-&gt;zone()),\012      reported_errors_(scope_-&gt;zone()),\012      dont_optimize_reason_(BailoutReason::kNoReason),\012      next_function_is_likely_called_(false),\012      previous_function_was_likely_called_(false),\012      contains_function_or_eval_(false) {\012 *function_state_stack = this;\012  reported_errors_.reserve(16);\012 if (outer_function_state_) {\012    outer_function_state_-&gt;previous_function_was_likely_called_ =\012        outer_function_state_-&gt;next_function_is_likely_called_;\012    outer_function_state_-&gt;next_function_is_likely_called_ = false;\012 }\012}\012\012template &lt;typename Impl&gt;\012ParserBase&lt;Impl&gt;::FunctionState::~FunctionState() {\012 *function_state_stack_ = outer_function_state_;\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::GetUnexpectedTokenMessage(\012 Token::Value token, MessageTemplate::Template* message,\012 Scanner::Location* location, const char** arg,\012 MessageTemplate::Template default_) {\012 *arg = nullptr;\012 switch (token) {\012 case Token::EOS:\012 *message = MessageTemplate::kUnexpectedEOS;\012 break;\012 case Token::SMI:\012 case Token::NUMBER:\012 case Token::BIGINT:\012 *message = MessageTemplate::kUnexpectedTokenNumber;\012 break;\012 case Token::STRING:\012 *message = MessageTemplate::kUnexpectedTokenString;\012 break;\012 case Token::PRIVATE_NAME:\012 case Token::IDENTIFIER:\012 *message = MessageTemplate::kUnexpectedTokenIdentifier;\012 break;\012 case Token::AWAIT:\012 case Token::ENUM:\012 *message = MessageTemplate::kUnexpectedReserved;\012 break;\012 case Token::LET:\012 case Token::STATIC:\012 case Token::YIELD:\012 case Token::FUTURE_STRICT_RESERVED_WORD:\012 *message = is_strict(language_mode())\012 ? MessageTemplate::kUnexpectedStrictReserved\012 : MessageTemplate::kUnexpectedTokenIdentifier;\012 break;\012 case Token::TEMPLATE_SPAN:\012 case Token::TEMPLATE_TAIL:\012 *message = MessageTemplate::kUnexpectedTemplateString;\012 break;\012 case Token::ESCAPED_STRICT_RESERVED_WORD:\012 case Token::ESCAPED_KEYWORD:\012 *message = MessageTemplate::kInvalidEscapedReservedWord;\012 break;\012 case Token::ILLEGAL:\012 if (scanner()-&gt;has_error()) {\012 *message = scanner()-&gt;error();\012 *location = scanner()-&gt;error_location();\012 } else {\012 *message = MessageTemplate::kInvalidOrUnexpectedToken;\012 }\012 break;\012 case Token::REGEXP_LITERAL:\012 *message = MessageTemplate::kUnexpectedTokenRegExp;\012 break;\012 default:\012 const char* name = Token::String(token);\012      DCHECK_NOT_NULL(name);\012 *arg = name;\012 break;\012 }\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::ReportUnexpectedToken(Token::Value token) {\012 return ReportUnexpectedTokenAt(scanner_-&gt;location(), token);\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::ReportUnexpectedTokenAt(\012 Scanner::Location source_location, Token::Value token,\012 MessageTemplate::Template message) {\012 const char* arg;\012 GetUnexpectedTokenMessage(token, &amp;message, &amp;source_location, &amp;arg);\012  impl()-&gt;ReportMessageAt(source_location, message, arg);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::IdentifierT ParserBase&lt;Impl&gt;::ParseIdentifier(\012 AllowRestrictedIdentifiers allow_restricted_identifiers, bool* ok) {\012 ExpressionClassifier classifier(this);\012 auto result = ParseAndClassifyIdentifier(CHECK_OK_CUSTOM(NullIdentifier));\012\012 if (allow_restricted_identifiers == kDontAllowRestrictedIdentifiers) {\012 ValidateAssignmentPattern(CHECK_OK_CUSTOM(NullIdentifier));\012 ValidateBindingPattern(CHECK_OK_CUSTOM(NullIdentifier));\012 }\012\012 return result;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::IdentifierT\012ParserBase&lt;Impl&gt;::ParseAndClassifyIdentifier(bool* ok) {\012 Token::Value next = Next();\012 if (next == Token::IDENTIFIER || next == Token::ASYNC ||\012 (next == Token::AWAIT &amp;&amp; !parsing_module_ &amp;&amp; !is_async_function())) {\012 IdentifierT name = impl()-&gt;GetSymbol();\012\012 if (impl()-&gt;IsArguments(name) &amp;&amp; scope()-&gt;ShouldBanArguments()) {\012 ReportMessage(MessageTemplate::kArgumentsDisallowedInInitializer);\012 *ok = false;\012 return impl()-&gt;NullIdentifier();\012 }\012\012 // When this function is used to read a formal parameter, we don't always\012 // know whether the function is going to be strict or sloppy.  Indeed for\012 // arrow functions we don't always know that the identifier we are reading\012 // is actually a formal parameter.  Therefore besides the errors that we\012 // must detect because we know we're in strict mode, we also record any\012 // error that we might make in the future once we know the language mode.\012 if (impl()-&gt;IsEvalOrArguments(name)) {\012      classifier()-&gt;RecordStrictModeFormalParameterError(\012          scanner()-&gt;location(), MessageTemplate::kStrictEvalArguments);\012 if (is_strict(language_mode())) {\012        classifier()-&gt;RecordBindingPatternError(\012            scanner()-&gt;location(), MessageTemplate::kStrictEvalArguments);\012 }\012 } else if (next == Token::AWAIT) {\012      classifier()-&gt;RecordAsyncArrowFormalParametersError(\012          scanner()-&gt;location(), MessageTemplate::kAwaitBindingIdentifier);\012 }\012\012 if (classifier()-&gt;duplicate_finder() != nullptr &amp;&amp;\012        scanner()-&gt;IsDuplicateSymbol(classifier()-&gt;duplicate_finder(),\012                                     ast_value_factory())) {\012      classifier()-&gt;RecordDuplicateFormalParameterError(scanner()-&gt;location());\012 }\012 return name;\012 } else if (is_sloppy(language_mode()) &amp;&amp;\012 (next == Token::FUTURE_STRICT_RESERVED_WORD ||\012 next == Token::ESCAPED_STRICT_RESERVED_WORD ||\012 next == Token::LET || next == Token::STATIC ||\012 (next == Token::YIELD &amp;&amp; !is_generator()))) {\012    classifier()-&gt;RecordStrictModeFormalParameterError(\012        scanner()-&gt;location(), MessageTemplate::kUnexpectedStrictReserved);\012 if (next == Token::ESCAPED_STRICT_RESERVED_WORD &amp;&amp;\012        is_strict(language_mode())) {\012 ReportUnexpectedToken(next);\012 *ok = false;\012 return impl()-&gt;NullIdentifier();\012 }\012 if (scanner()-&gt;IsLet()) {\012      classifier()-&gt;RecordLetPatternError(\012          scanner()-&gt;location(), MessageTemplate::kLetInLexicalBinding);\012 }\012 return impl()-&gt;GetSymbol();\012 } else {\012 ReportUnexpectedToken(next);\012 *ok = false;\012 return impl()-&gt;NullIdentifier();\012 }\012}\012\012template &lt;class Impl&gt;\012typename ParserBase&lt;Impl&gt;::IdentifierT\012ParserBase&lt;Impl&gt;::ParseIdentifierOrStrictReservedWord(\012 FunctionKind function_kind, bool* is_strict_reserved, bool* is_await,\012 bool* ok) {\012 Token::Value next = Next();\012 if (next == Token::IDENTIFIER || (next == Token::AWAIT &amp;&amp; !parsing_module_ &amp;&amp;\012 !IsAsyncFunction(function_kind)) ||\012 next == Token::ASYNC) {\012 *is_strict_reserved = false;\012 *is_await = next == Token::AWAIT;\012 } else if (next == Token::ESCAPED_STRICT_RESERVED_WORD ||\012 next == Token::FUTURE_STRICT_RESERVED_WORD || next == Token::LET ||\012 next == Token::STATIC ||\012 (next == Token::YIELD &amp;&amp; !IsGeneratorFunction(function_kind))) {\012 *is_strict_reserved = true;\012 } else {\012 ReportUnexpectedToken(next);\012 *ok = false;\012 return impl()-&gt;NullIdentifier();\012 }\012\012 return impl()-&gt;GetSymbol();\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::IdentifierT ParserBase&lt;Impl&gt;::ParseIdentifierName(\012 bool* ok) {\012 Token::Value next = Next();\012 if (next != Token::IDENTIFIER &amp;&amp; next != Token::ASYNC &amp;&amp;\012 next != Token::ENUM &amp;&amp; next != Token::AWAIT &amp;&amp; next != Token::LET &amp;&amp;\012 next != Token::STATIC &amp;&amp; next != Token::YIELD &amp;&amp;\012 next != Token::FUTURE_STRICT_RESERVED_WORD &amp;&amp;\012 next != Token::ESCAPED_KEYWORD &amp;&amp;\012 next != Token::ESCAPED_STRICT_RESERVED_WORD &amp;&amp; !Token::IsKeyword(next)) {\012 ReportUnexpectedToken(next);\012 *ok = false;\012 return impl()-&gt;NullIdentifier();\012 }\012\012 return impl()-&gt;GetSymbol();\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT\012ParserBase&lt;Impl&gt;::ParseIdentifierNameOrPrivateName(bool* ok) {\012 int pos = position();\012 IdentifierT name;\012 ExpressionT key;\012 if (allow_harmony_private_fields() &amp;&amp; peek() == Token::PRIVATE_NAME) {\012 Consume(Token::PRIVATE_NAME);\012    name = impl()-&gt;GetSymbol();\012 auto key_proxy =\012        impl()-&gt;ExpressionFromIdentifier(name, pos, InferName::kNo);\012    key_proxy-&gt;set_is_private_field();\012    key = key_proxy;\012 } else {\012    name = ParseIdentifierName(CHECK_OK);\012    key = factory()-&gt;NewStringLiteral(name, pos);\012 }\012  impl()-&gt;PushLiteralName(name);\012 return key;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParseRegExpLiteral(\012 bool* ok) {\012 int pos = peek_position();\012 if (!scanner()-&gt;ScanRegExpPattern()) {\012 Next();\012 ReportMessage(MessageTemplate::kUnterminatedRegExp);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012\012 IdentifierT js_pattern = impl()-&gt;GetNextSymbol();\012 Maybe&lt;RegExp::Flags&gt; flags = scanner()-&gt;ScanRegExpFlags();\012 if (flags.IsNothing()) {\012 Next();\012 ReportMessage(MessageTemplate::kMalformedRegExpFlags);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012 int js_flags = flags.FromJust();\012 Next();\012 return factory()-&gt;NewRegExpLiteral(js_pattern, js_flags, pos);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParsePrimaryExpression(\012 bool* is_async, bool* ok) {\012 // PrimaryExpression ::\012 //   'this'\012 //   'null'\012 //   'true'\012 //   'false'\012 //   Identifier\012 //   Number\012 //   String\012 //   ArrayLiteral\012 //   ObjectLiteral\012 //   RegExpLiteral\012 //   ClassLiteral\012 //   '(' Expression ')'\012 //   TemplateLiteral\012 //   do Block\012 //   AsyncFunctionLiteral\012\012 int beg_pos = peek_position();\012 switch (peek()) {\012 case Token::THIS: {\012 BindingPatternUnexpectedToken();\012 Consume(Token::THIS);\012 return impl()-&gt;ThisExpression(beg_pos);\012 }\012\012 case Token::NULL_LITERAL:\012 case Token::TRUE_LITERAL:\012 case Token::FALSE_LITERAL:\012 case Token::SMI:\012 case Token::NUMBER:\012 case Token::BIGINT:\012 BindingPatternUnexpectedToken();\012 return impl()-&gt;ExpressionFromLiteral(Next(), beg_pos);\012\012 case Token::ASYNC:\012 if (!scanner()-&gt;HasLineTerminatorAfterNext() &amp;&amp;\012 PeekAhead() == Token::FUNCTION) {\012 BindingPatternUnexpectedToken();\012 Consume(Token::ASYNC);\012 return ParseAsyncFunctionLiteral(CHECK_OK);\012 }\012 // CoverCallExpressionAndAsyncArrowHead\012 *is_async = true;\012      V8_FALLTHROUGH;\012 case Token::IDENTIFIER:\012 case Token::LET:\012 case Token::STATIC:\012 case Token::YIELD:\012 case Token::AWAIT:\012 case Token::ESCAPED_STRICT_RESERVED_WORD:\012 case Token::FUTURE_STRICT_RESERVED_WORD: {\012 // Using eval or arguments in this context is OK even in strict mode.\012 IdentifierT name = ParseAndClassifyIdentifier(CHECK_OK);\012 return impl()-&gt;ExpressionFromIdentifier(name, beg_pos);\012 }\012\012 case Token::STRING: {\012 BindingPatternUnexpectedToken();\012 Consume(Token::STRING);\012 return impl()-&gt;ExpressionFromString(beg_pos);\012 }\012\012 case Token::ASSIGN_DIV:\012 case Token::DIV:\012      classifier()-&gt;RecordBindingPatternError(\012          scanner()-&gt;peek_location(), MessageTemplate::kUnexpectedTokenRegExp);\012 return ParseRegExpLiteral(ok);\012\012 case Token::LBRACK:\012 return ParseArrayLiteral(ok);\012\012 case Token::LBRACE:\012 return ParseObjectLiteral(ok);\012\012 case Token::LPAREN: {\012 // Arrow function formal parameters are either a single identifier or a\012 // list of BindingPattern productions enclosed in parentheses.\012 // Parentheses are not valid on the LHS of a BindingPattern, so we use the\012 // is_valid_binding_pattern() check to detect multiple levels of\012 // parenthesization.\012 bool pattern_error = !classifier()-&gt;is_valid_binding_pattern();\012      classifier()-&gt;RecordPatternError(scanner()-&gt;peek_location(),\012 MessageTemplate::kUnexpectedToken,\012 Token::String(Token::LPAREN));\012 if (pattern_error) ArrowFormalParametersUnexpectedToken();\012 Consume(Token::LPAREN);\012 if (Check(Token::RPAREN)) {\012 // ()=&gt;x.  The continuation that looks for the =&gt; is in\012 // ParseAssignmentExpression.\012        classifier()-&gt;RecordExpressionError(scanner()-&gt;location(),\012 MessageTemplate::kUnexpectedToken,\012 Token::String(Token::RPAREN));\012 return factory()-&gt;NewEmptyParentheses(beg_pos);\012 }\012 // Heuristically try to detect immediately called functions before\012 // seeing the call parentheses.\012 if (peek() == Token::FUNCTION ||\012 (peek() == Token::ASYNC &amp;&amp; PeekAhead() == Token::FUNCTION)) {\012        function_state_-&gt;set_next_function_is_likely_called();\012 }\012 ExpressionT expr = ParseExpressionCoverGrammar(true, CHECK_OK);\012 Expect(Token::RPAREN, CHECK_OK);\012 return expr;\012 }\012\012 case Token::CLASS: {\012 BindingPatternUnexpectedToken();\012 Consume(Token::CLASS);\012 int class_token_pos = position();\012 IdentifierT name = impl()-&gt;NullIdentifier();\012 bool is_strict_reserved_name = false;\012 Scanner::Location class_name_location = Scanner::Location::invalid();\012 if (peek_any_identifier()) {\012 bool is_await = false;\012        name = ParseIdentifierOrStrictReservedWord(&amp;is_strict_reserved_name,\012 &amp;is_await, CHECK_OK);\012        class_name_location = scanner()-&gt;location();\012 if (is_await) {\012          classifier()-&gt;RecordAsyncArrowFormalParametersError(\012              scanner()-&gt;location(), MessageTemplate::kAwaitBindingIdentifier);\012 }\012 }\012 return ParseClassLiteral(name, class_name_location,\012                               is_strict_reserved_name, class_token_pos, ok);\012 }\012\012 case Token::TEMPLATE_SPAN:\012 case Token::TEMPLATE_TAIL:\012 BindingPatternUnexpectedToken();\012 return ParseTemplateLiteral(impl()-&gt;NullExpression(), beg_pos, false, ok);\012\012 case Token::MOD:\012 if (allow_natives() || extension_ != nullptr) {\012 BindingPatternUnexpectedToken();\012 return ParseV8Intrinsic(ok);\012 }\012 break;\012\012 case Token::DO:\012 if (allow_harmony_do_expressions()) {\012 BindingPatternUnexpectedToken();\012 return ParseDoExpression(ok);\012 }\012 break;\012\012 default:\012 break;\012 }\012\012 ReportUnexpectedToken(Next());\012 *ok = false;\012 return impl()-&gt;NullExpression();\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParseExpression(\012 bool accept_IN, bool* ok) {\012 ExpressionClassifier classifier(this);\012 ExpressionT result = ParseExpressionCoverGrammar(accept_IN, CHECK_OK);\012 ValidateExpression(CHECK_OK);\012 return result;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT\012ParserBase&lt;Impl&gt;::ParseExpressionCoverGrammar(bool accept_IN, bool* ok) {\012 // Expression ::\012 //   AssignmentExpression\012 //   Expression ',' AssignmentExpression\012\012 ExpressionT result = impl()-&gt;NullExpression();\012 while (true) {\012 int comma_pos = position();\012 ExpressionClassifier binding_classifier(this);\012 ExpressionT right;\012 if (Check(Token::ELLIPSIS)) {\012 // 'x, y, ...z' in CoverParenthesizedExpressionAndArrowParameterList only\012 // as the formal parameters of'(x, y, ...z) =&gt; foo', and is not itself a\012 // valid expression.\012      classifier()-&gt;RecordExpressionError(scanner()-&gt;location(),\012 MessageTemplate::kUnexpectedToken,\012 Token::String(Token::ELLIPSIS));\012 int ellipsis_pos = position();\012 int pattern_pos = peek_position();\012 ExpressionT pattern = ParsePrimaryExpression(CHECK_OK);\012 if (peek() == Token::ASSIGN) {\012 ReportMessage(MessageTemplate::kRestDefaultInitializer);\012 *ok = false;\012 return result;\012 }\012 ValidateBindingPattern(CHECK_OK);\012      right = factory()-&gt;NewSpread(pattern, ellipsis_pos, pattern_pos);\012 } else {\012      right = ParseAssignmentExpression(accept_IN, CHECK_OK);\012 }\012 // No need to accumulate binding pattern-related errors, since\012 // an Expression can't be a binding pattern anyway.\012 AccumulateNonBindingPatternErrors();\012 if (!impl()-&gt;IsIdentifier(right)) classifier()-&gt;RecordNonSimpleParameter();\012 if (impl()-&gt;IsNull(result)) {\012 // First time through the loop.\012      result = right;\012 } else if (impl()-&gt;CollapseNaryExpression(&amp;result, right, Token::COMMA,\012                                              comma_pos,\012 SourceRange::Empty())) {\012 // Do nothing, &quot;result&quot; is already updated.\012 } else {\012      result =\012          factory()-&gt;NewBinaryOperation(Token::COMMA, result, right, comma_pos);\012 }\012\012 if (!Check(Token::COMMA)) break;\012\012 if (right-&gt;IsSpread()) {\012      classifier()-&gt;RecordArrowFormalParametersError(\012          scanner()-&gt;location(), MessageTemplate::kParamAfterRest);\012 }\012\012 if (peek() == Token::RPAREN &amp;&amp; PeekAhead() == Token::ARROW) {\012 // a trailing comma is allowed at the end of an arrow parameter list\012 break;\012 }\012\012 // Pass on the 'set_next_function_is_likely_called' flag if we have\012 // several function literals separated by comma.\012 if (peek() == Token::FUNCTION &amp;&amp;\012        function_state_-&gt;previous_function_was_likely_called()) {\012      function_state_-&gt;set_next_function_is_likely_called();\012 }\012 }\012\012 return result;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParseArrayLiteral(\012 bool* ok) {\012 // ArrayLiteral ::\012 //   '[' Expression? (',' Expression?)* ']'\012\012 int pos = peek_position();\012 ExpressionListT values = impl()-&gt;NewExpressionList(4);\012 int first_spread_index = -1;\012 Expect(Token::LBRACK, CHECK_OK);\012 while (peek() != Token::RBRACK) {\012 ExpressionT elem;\012 if (peek() == Token::COMMA) {\012      elem = factory()-&gt;NewTheHoleLiteral();\012 } else if (peek() == Token::ELLIPSIS) {\012 int start_pos = peek_position();\012 Consume(Token::ELLIPSIS);\012 int expr_pos = peek_position();\012 ExpressionT argument = ParseAssignmentExpression(true, CHECK_OK);\012      elem = factory()-&gt;NewSpread(argument, start_pos, expr_pos);\012\012 if (first_spread_index &lt; 0) {\012        first_spread_index = values-&gt;length();\012 }\012\012 if (argument-&gt;IsAssignment()) {\012        classifier()-&gt;RecordPatternError(\012 Scanner::Location(start_pos, scanner()-&gt;location().end_pos),\012 MessageTemplate::kInvalidDestructuringTarget);\012 } else {\012 CheckDestructuringElement(argument, start_pos,\012                                  scanner()-&gt;location().end_pos);\012 }\012\012 if (peek() == Token::COMMA) {\012        classifier()-&gt;RecordPatternError(\012 Scanner::Location(start_pos, scanner()-&gt;location().end_pos),\012 MessageTemplate::kElementAfterRest);\012 }\012 } else {\012 int beg_pos = peek_position();\012      elem = ParseAssignmentExpression(true, CHECK_OK);\012 CheckDestructuringElement(elem, beg_pos, scanner()-&gt;location().end_pos);\012 }\012    values-&gt;Add(elem, zone_);\012 if (peek() != Token::RBRACK) {\012 Expect(Token::COMMA, CHECK_OK);\012 }\012 }\012 Expect(Token::RBRACK, CHECK_OK);\012\012 return factory()-&gt;NewArrayLiteral(values, first_spread_index, pos);\012}\012\012template &lt;class Impl&gt;\012bool ParserBase&lt;Impl&gt;::SetPropertyKindFromToken(Token::Value token,\012 PropertyKind* kind) {\012 // This returns true, setting the property kind, iff the given token is one\012 // which must occur after a property name, indicating that the previous token\012 // was in fact a name and not a modifier (like the &quot;get&quot; in &quot;get x&quot;).\012 switch (token) {\012 case Token::COLON:\012 *kind = PropertyKind::kValueProperty;\012 return true;\012 case Token::COMMA:\012 case Token::RBRACE:\012 case Token::ASSIGN:\012 *kind = PropertyKind::kShorthandProperty;\012 return true;\012 case Token::LPAREN:\012 *kind = PropertyKind::kMethodProperty;\012 return true;\012 case Token::MUL:\012 case Token::SEMICOLON:\012 *kind = PropertyKind::kClassField;\012 return true;\012 case Token::PRIVATE_NAME:\012 *kind = PropertyKind::kClassField;\012 return true;\012 default:\012 break;\012 }\012 return false;\012}\012\012template &lt;class Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParsePropertyName(\012 IdentifierT* name, PropertyKind* kind, bool* is_generator, bool* is_get,\012 bool* is_set, bool* is_async, bool* is_computed_name, bool* ok) {\012  DCHECK_EQ(*kind, PropertyKind::kNotSet);\012  DCHECK(!*is_generator);\012  DCHECK(!*is_get);\012  DCHECK(!*is_set);\012  DCHECK(!*is_async);\012  DCHECK(!*is_computed_name);\012\012 *is_generator = Check(Token::MUL);\012 if (*is_generator) {\012 *kind = PropertyKind::kMethodProperty;\012 }\012\012 Token::Value token = peek();\012 int pos = peek_position();\012\012 if (!*is_generator &amp;&amp; token == Token::ASYNC &amp;&amp;\012 !scanner()-&gt;HasLineTerminatorAfterNext()) {\012 Consume(Token::ASYNC);\012    token = peek();\012 if (token == Token::MUL &amp;&amp; !scanner()-&gt;HasLineTerminatorBeforeNext()) {\012 Consume(Token::MUL);\012      token = peek();\012 *is_generator = true;\012 } else if (SetPropertyKindFromToken(token, kind)) {\012 *name = impl()-&gt;GetSymbol(); // TODO(bakkot) specialize on 'async'\012      impl()-&gt;PushLiteralName(*name);\012 return factory()-&gt;NewStringLiteral(*name, pos);\012 }\012 *kind = PropertyKind::kMethodProperty;\012 *is_async = true;\012    pos = peek_position();\012 }\012\012 if (token == Token::IDENTIFIER &amp;&amp; !*is_generator &amp;&amp; !*is_async) {\012 // This is checking for 'get' and 'set' in particular.\012 Consume(Token::IDENTIFIER);\012    token = peek();\012 if (SetPropertyKindFromToken(token, kind) ||\012 !scanner()-&gt;IsGetOrSet(is_get, is_set)) {\012 *name = impl()-&gt;GetSymbol();\012      impl()-&gt;PushLiteralName(*name);\012 return factory()-&gt;NewStringLiteral(*name, pos);\012 }\012 *kind = PropertyKind::kAccessorProperty;\012    pos = peek_position();\012 }\012\012 // For non computed property names we normalize the name a bit:\012 //\012 //   &quot;12&quot; -&gt; 12\012 //   12.3 -&gt; &quot;12.3&quot;\012 //   12.30 -&gt; &quot;12.3&quot;\012 //   identifier -&gt; &quot;identifier&quot;\012 //\012 // This is important because we use the property name as a key in a hash\012 // table when we compute constant properties.\012 ExpressionT expression = impl()-&gt;NullExpression();\012 switch (token) {\012 case Token::STRING:\012 Consume(Token::STRING);\012 *name = impl()-&gt;GetSymbol();\012 break;\012\012 case Token::SMI:\012 Consume(Token::SMI);\012 *name = impl()-&gt;GetNumberAsSymbol();\012 break;\012\012 case Token::NUMBER:\012 Consume(Token::NUMBER);\012 *name = impl()-&gt;GetNumberAsSymbol();\012 break;\012\012 case Token::LBRACK: {\012 *name = impl()-&gt;NullIdentifier();\012 *is_computed_name = true;\012 Consume(Token::LBRACK);\012 ExpressionClassifier computed_name_classifier(this);\012      expression = ParseAssignmentExpression(true, CHECK_OK);\012 ValidateExpression(CHECK_OK);\012 AccumulateFormalParameterContainmentErrors();\012 Expect(Token::RBRACK, CHECK_OK);\012 break;\012 }\012\012 case Token::ELLIPSIS:\012 if (!*is_generator &amp;&amp; !*is_async &amp;&amp; !*is_get &amp;&amp; !*is_set) {\012 *name = impl()-&gt;NullIdentifier();\012 Consume(Token::ELLIPSIS);\012        expression = ParseAssignmentExpression(true, CHECK_OK);\012 *kind = PropertyKind::kSpreadProperty;\012\012 if (!impl()-&gt;IsIdentifier(expression)) {\012          classifier()-&gt;RecordBindingPatternError(\012              scanner()-&gt;location(),\012 MessageTemplate::kInvalidRestBindingPattern);\012 }\012\012 if (!expression-&gt;IsValidReferenceExpression()) {\012          classifier()-&gt;RecordAssignmentPatternError(\012              scanner()-&gt;location(),\012 MessageTemplate::kInvalidRestAssignmentPattern);\012 }\012\012 if (peek() != Token::RBRACE) {\012          classifier()-&gt;RecordPatternError(scanner()-&gt;location(),\012 MessageTemplate::kElementAfterRest);\012 }\012 return expression;\012 }\012      V8_FALLTHROUGH;\012\012 default:\012 *name = ParseIdentifierName(CHECK_OK);\012 break;\012 }\012\012 if (*kind == PropertyKind::kNotSet) {\012 SetPropertyKindFromToken(peek(), kind);\012 }\012\012 if (*is_computed_name) {\012 return expression;\012 }\012\012  impl()-&gt;PushLiteralName(*name);\012\012 uint32_t index;\012 return impl()-&gt;IsArrayIndex(*name, &amp;index)\012 ? factory()-&gt;NewNumberLiteral(index, pos)\012 : factory()-&gt;NewStringLiteral(*name, pos);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ClassLiteralPropertyT\012ParserBase&lt;Impl&gt;::ParseClassPropertyDefinition(\012 ClassLiteralChecker* checker, ClassInfo* class_info, IdentifierT* name,\012 bool has_extends, bool* is_computed_name,\012 ClassLiteralProperty::Kind* property_kind, bool* is_static, bool* ok) {\012  DCHECK_NOT_NULL(class_info);\012 bool is_get = false;\012 bool is_set = false;\012 bool is_generator = false;\012 bool is_async = false;\012 *is_static = false;\012 *property_kind = ClassLiteralProperty::METHOD;\012 PropertyKind kind = PropertyKind::kNotSet;\012\012 Token::Value name_token = peek();\012  DCHECK_IMPLIES(name_token == Token::PRIVATE_NAME,\012                 allow_harmony_private_fields());\012\012 int name_token_position = scanner()-&gt;peek_location().beg_pos;\012 *name = impl()-&gt;NullIdentifier();\012 ExpressionT name_expression;\012 if (name_token == Token::STATIC) {\012 Consume(Token::STATIC);\012    name_token_position = scanner()-&gt;peek_location().beg_pos;\012 if (peek() == Token::LPAREN) {\012      kind = PropertyKind::kMethodProperty;\012 *name = impl()-&gt;GetSymbol(); // TODO(bakkot) specialize on 'static'\012      name_expression = factory()-&gt;NewStringLiteral(*name, position());\012 } else if (peek() == Token::ASSIGN || peek() == Token::SEMICOLON ||\012               peek() == Token::RBRACE) {\012 *name = impl()-&gt;GetSymbol(); // TODO(bakkot) specialize on 'static'\012      name_expression = factory()-&gt;NewStringLiteral(*name, position());\012 } else if (peek() == Token::PRIVATE_NAME) {\012      DCHECK(allow_harmony_private_fields());\012 // TODO(gsathya): Make a better error message for this.\012 ReportUnexpectedToken(Next());\012 *ok = false;\012 return impl()-&gt;NullLiteralProperty();\012 } else {\012 *is_static = true;\012      name_expression = ParsePropertyName(name, &amp;kind, &amp;is_generator, &amp;is_get,\012 &amp;is_set, &amp;is_async, is_computed_name,\012                                          CHECK_OK_CUSTOM(NullLiteralProperty));\012 }\012 } else if (name_token == Token::PRIVATE_NAME) {\012 Consume(Token::PRIVATE_NAME);\012 *name = impl()-&gt;GetSymbol();\012    name_expression = factory()-&gt;NewStringLiteral(*name, position());\012 } else {\012    name_expression = ParsePropertyName(name, &amp;kind, &amp;is_generator, &amp;is_get,\012 &amp;is_set, &amp;is_async, is_computed_name,\012                                        CHECK_OK_CUSTOM(NullLiteralProperty));\012 }\012\012 if (!class_info-&gt;has_name_static_property &amp;&amp; *is_static &amp;&amp;\012      impl()-&gt;IsName(*name)) {\012    class_info-&gt;has_name_static_property = true;\012 }\012\012 switch (kind) {\012 case PropertyKind::kClassField:\012 case PropertyKind::kNotSet: // This case is a name followed by a name or\012 // other property. Here we have to assume\012 // that's an uninitialized field followed by a\012 // linebreak followed by a property, with ASI\012 // adding the semicolon. If not, there will be\012 // a syntax error after parsing the first name\012 // as an uninitialized field.\012 case PropertyKind::kShorthandProperty:\012 case PropertyKind::kValueProperty:\012 if (allow_harmony_public_fields() || allow_harmony_private_fields()) {\012 *property_kind = name_token == Token::PRIVATE_NAME\012 ? ClassLiteralProperty::PRIVATE_FIELD\012 : ClassLiteralProperty::PUBLIC_FIELD;\012 if (*is_static &amp;&amp; !allow_harmony_static_fields()) {\012 ReportUnexpectedToken(Next());\012 *ok = false;\012 return impl()-&gt;NullLiteralProperty();\012 }\012 if (!*is_computed_name) {\012          checker-&gt;CheckClassFieldName(*is_static,\012                                       CHECK_OK_CUSTOM(NullLiteralProperty));\012 }\012 ExpressionT initializer = ParseClassFieldInitializer(\012            class_info, *is_static, CHECK_OK_CUSTOM(NullLiteralProperty));\012 ExpectSemicolon(CHECK_OK_CUSTOM(NullLiteralProperty));\012 ClassLiteralPropertyT result = factory()-&gt;NewClassLiteralProperty(\012            name_expression, initializer, *property_kind, *is_static,\012 *is_computed_name);\012        impl()-&gt;SetFunctionNameFromPropertyName(result, *name);\012 return result;\012\012 } else {\012 ReportUnexpectedToken(Next());\012 *ok = false;\012 return impl()-&gt;NullLiteralProperty();\012 }\012\012 case PropertyKind::kMethodProperty: {\012      DCHECK(!is_get &amp;&amp; !is_set);\012\012 // MethodDefinition\012 //    PropertyName '(' StrictFormalParameters ')' '{' FunctionBody '}'\012 //    '*' PropertyName '(' StrictFormalParameters ')' '{' FunctionBody '}'\012 //    async PropertyName '(' StrictFormalParameters ')'\012 //        '{' FunctionBody '}'\012 //    async '*' PropertyName '(' StrictFormalParameters ')'\012 //        '{' FunctionBody '}'\012\012 if (!*is_computed_name) {\012        checker-&gt;CheckClassMethodName(name_token, PropertyKind::kMethodProperty,\012                                      is_generator, is_async, *is_static,\012                                      CHECK_OK_CUSTOM(NullLiteralProperty));\012 }\012\012 FunctionKind kind = MethodKindFor(is_generator, is_async);\012\012 if (!*is_static &amp;&amp; impl()-&gt;IsConstructor(*name)) {\012        class_info-&gt;has_seen_constructor = true;\012        kind = has_extends ? FunctionKind::kDerivedConstructor\012 : FunctionKind::kBaseConstructor;\012 }\012\012 ExpressionT value = impl()-&gt;ParseFunctionLiteral(\012 *name, scanner()-&gt;location(), kSkipFunctionNameCheck, kind,\012          FLAG_harmony_function_tostring ? name_token_position\012 : kNoSourcePosition,\012 FunctionLiteral::kAccessorOrMethod, language_mode(), nullptr,\012          CHECK_OK_CUSTOM(NullLiteralProperty));\012\012 *property_kind = ClassLiteralProperty::METHOD;\012 ClassLiteralPropertyT result = factory()-&gt;NewClassLiteralProperty(\012          name_expression, value, *property_kind, *is_static,\012 *is_computed_name);\012      impl()-&gt;SetFunctionNameFromPropertyName(result, *name);\012 return result;\012 }\012\012 case PropertyKind::kAccessorProperty: {\012      DCHECK((is_get || is_set) &amp;&amp; !is_generator &amp;&amp; !is_async);\012\012 if (!*is_computed_name) {\012        checker-&gt;CheckClassMethodName(\012            name_token, PropertyKind::kAccessorProperty, false, false,\012 *is_static, CHECK_OK_CUSTOM(NullLiteralProperty));\012 // Make sure the name expression is a string since we need a Name for\012 // Runtime_DefineAccessorPropertyUnchecked and since we can determine\012 // this statically we can skip the extra runtime check.\012        name_expression =\012            factory()-&gt;NewStringLiteral(*name, name_expression-&gt;position());\012 }\012\012 FunctionKind kind = is_get ? FunctionKind::kGetterFunction\012 : FunctionKind::kSetterFunction;\012\012 FunctionLiteralT value = impl()-&gt;ParseFunctionLiteral(\012 *name, scanner()-&gt;location(), kSkipFunctionNameCheck, kind,\012          FLAG_harmony_function_tostring ? name_token_position\012 : kNoSourcePosition,\012 FunctionLiteral::kAccessorOrMethod, language_mode(), nullptr,\012          CHECK_OK_CUSTOM(NullLiteralProperty));\012\012 *property_kind =\012          is_get ? ClassLiteralProperty::GETTER : ClassLiteralProperty::SETTER;\012 ClassLiteralPropertyT result = factory()-&gt;NewClassLiteralProperty(\012          name_expression, value, *property_kind, *is_static,\012 *is_computed_name);\012 const AstRawString* prefix =\012          is_get ? ast_value_factory()-&gt;get_space_string()\012 : ast_value_factory()-&gt;set_space_string();\012      impl()-&gt;SetFunctionNameFromPropertyName(result, *name, prefix);\012 return result;\012 }\012 case PropertyKind::kSpreadProperty:\012 ReportUnexpectedTokenAt(\012 Scanner::Location(name_token_position, name_expression-&gt;position()),\012          name_token);\012 *ok = false;\012 return impl()-&gt;NullLiteralProperty();\012 }\012  UNREACHABLE();\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT\012ParserBase&lt;Impl&gt;::ParseClassFieldInitializer(ClassInfo* class_info,\012 bool is_static, bool* ok) {\012 DeclarationScope* initializer_scope = is_static\012 ? class_info-&gt;static_fields_scope\012 : class_info-&gt;instance_fields_scope;\012\012 if (initializer_scope == nullptr) {\012    initializer_scope =\012 NewFunctionScope(FunctionKind::kClassFieldsInitializerFunction);\012 // TODO(gsathya): Make scopes be non contiguous.\012    initializer_scope-&gt;set_start_position(scanner()-&gt;location().end_pos);\012    initializer_scope-&gt;SetLanguageMode(LanguageMode::kStrict);\012 }\012\012 ExpressionT initializer;\012 if (Check(Token::ASSIGN)) {\012 FunctionState initializer_state(&amp;function_state_, &amp;scope_,\012                                    initializer_scope);\012 ExpressionClassifier expression_classifier(this);\012\012    initializer =\012 ParseAssignmentExpression(true, CHECK_OK_CUSTOM(NullExpression));\012 ValidateExpression(CHECK_OK_CUSTOM(NullExpression));\012 } else {\012    initializer = factory()-&gt;NewUndefinedLiteral(kNoSourcePosition);\012 }\012\012  initializer_scope-&gt;set_end_position(scanner()-&gt;location().end_pos);\012 if (is_static) {\012    class_info-&gt;static_fields_scope = initializer_scope;\012    class_info-&gt;has_static_class_fields = true;\012 } else {\012    class_info-&gt;instance_fields_scope = initializer_scope;\012    class_info-&gt;has_instance_class_fields = true;\012 }\012\012 return initializer;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ObjectLiteralPropertyT\012ParserBase&lt;Impl&gt;::ParseObjectPropertyDefinition(ObjectLiteralChecker* checker,\012 bool* is_computed_name,\012 bool* is_rest_property,\012 bool* ok) {\012 bool is_get = false;\012 bool is_set = false;\012 bool is_generator = false;\012 bool is_async = false;\012 PropertyKind kind = PropertyKind::kNotSet;\012\012 IdentifierT name = impl()-&gt;NullIdentifier();\012 Token::Value name_token = peek();\012 int next_beg_pos = scanner()-&gt;peek_location().beg_pos;\012 int next_end_pos = scanner()-&gt;peek_location().end_pos;\012\012 ExpressionT name_expression = ParsePropertyName(\012 &amp;name, &amp;kind, &amp;is_generator, &amp;is_get, &amp;is_set, &amp;is_async,\012      is_computed_name, CHECK_OK_CUSTOM(NullLiteralProperty));\012\012 switch (kind) {\012 case PropertyKind::kSpreadProperty:\012      DCHECK(!is_get &amp;&amp; !is_set &amp;&amp; !is_generator &amp;&amp; !is_async &amp;&amp;\012 !*is_computed_name);\012      DCHECK(name_token == Token::ELLIPSIS);\012\012 *is_computed_name = true;\012 *is_rest_property = true;\012\012 return factory()-&gt;NewObjectLiteralProperty(\012          factory()-&gt;NewTheHoleLiteral(), name_expression,\012 ObjectLiteralProperty::SPREAD, true);\012\012 case PropertyKind::kValueProperty: {\012      DCHECK(!is_get &amp;&amp; !is_set &amp;&amp; !is_generator &amp;&amp; !is_async);\012\012 if (!*is_computed_name) {\012        checker-&gt;CheckDuplicateProto(name_token);\012 }\012 Consume(Token::COLON);\012 int beg_pos = peek_position();\012 ExpressionT value =\012 ParseAssignmentExpression(true, CHECK_OK_CUSTOM(NullLiteralProperty));\012 CheckDestructuringElement(value, beg_pos, scanner()-&gt;location().end_pos);\012\012 ObjectLiteralPropertyT result = factory()-&gt;NewObjectLiteralProperty(\012          name_expression, value, *is_computed_name);\012      impl()-&gt;SetFunctionNameFromPropertyName(result, name);\012 return result;\012 }\012\012 case PropertyKind::kShorthandProperty: {\012 // PropertyDefinition\012 //    IdentifierReference\012 //    CoverInitializedName\012 //\012 // CoverInitializedName\012 //    IdentifierReference Initializer?\012      DCHECK(!is_get &amp;&amp; !is_set &amp;&amp; !is_generator &amp;&amp; !is_async);\012\012 if (!Token::IsIdentifier(name_token, language_mode(),\012 this-&gt;is_generator(),\012                               parsing_module_ || is_async_function())) {\012 ReportUnexpectedToken(Next());\012 *ok = false;\012 return impl()-&gt;NullLiteralProperty();\012 }\012\012      DCHECK(!*is_computed_name);\012\012 if (classifier()-&gt;duplicate_finder() != nullptr &amp;&amp;\012          scanner()-&gt;IsDuplicateSymbol(classifier()-&gt;duplicate_finder(),\012                                       ast_value_factory())) {\012        classifier()-&gt;RecordDuplicateFormalParameterError(\012            scanner()-&gt;location());\012 }\012\012 if (impl()-&gt;IsEvalOrArguments(name) &amp;&amp; is_strict(language_mode())) {\012        classifier()-&gt;RecordBindingPatternError(\012            scanner()-&gt;location(), MessageTemplate::kStrictEvalArguments);\012 }\012\012 if (name_token == Token::LET) {\012        classifier()-&gt;RecordLetPatternError(\012            scanner()-&gt;location(), MessageTemplate::kLetInLexicalBinding);\012 }\012 if (name_token == Token::AWAIT) {\012        DCHECK(!is_async_function());\012        classifier()-&gt;RecordAsyncArrowFormalParametersError(\012 Scanner::Location(next_beg_pos, next_end_pos),\012 MessageTemplate::kAwaitBindingIdentifier);\012 }\012 ExpressionT lhs = impl()-&gt;ExpressionFromIdentifier(name, next_beg_pos);\012 CheckDestructuringElement(lhs, next_beg_pos, next_end_pos);\012\012 ExpressionT value;\012 if (peek() == Token::ASSIGN) {\012 Consume(Token::ASSIGN);\012 ExpressionClassifier rhs_classifier(this);\012 ExpressionT rhs = ParseAssignmentExpression(\012 true, CHECK_OK_CUSTOM(NullLiteralProperty));\012 ValidateExpression(CHECK_OK_CUSTOM(NullLiteralProperty));\012 AccumulateFormalParameterContainmentErrors();\012        value = factory()-&gt;NewAssignment(Token::ASSIGN, lhs, rhs,\012                                         kNoSourcePosition);\012        classifier()-&gt;RecordExpressionError(\012 Scanner::Location(next_beg_pos, scanner()-&gt;location().end_pos),\012 MessageTemplate::kInvalidCoverInitializedName);\012\012        impl()-&gt;SetFunctionNameFromIdentifierRef(rhs, lhs);\012 } else {\012        value = lhs;\012 }\012\012 ObjectLiteralPropertyT result = factory()-&gt;NewObjectLiteralProperty(\012          name_expression, value, ObjectLiteralProperty::COMPUTED, false);\012      impl()-&gt;SetFunctionNameFromPropertyName(result, name);\012 return result;\012 }\012\012 case PropertyKind::kMethodProperty: {\012      DCHECK(!is_get &amp;&amp; !is_set);\012\012 // MethodDefinition\012 //    PropertyName '(' StrictFormalParameters ')' '{' FunctionBody '}'\012 //    '*' PropertyName '(' StrictFormalParameters ')' '{' FunctionBody '}'\012\012      classifier()-&gt;RecordPatternError(\012 Scanner::Location(next_beg_pos, scanner()-&gt;location().end_pos),\012 MessageTemplate::kInvalidDestructuringTarget);\012\012 FunctionKind kind = MethodKindFor(is_generator, is_async);\012\012 ExpressionT value = impl()-&gt;ParseFunctionLiteral(\012          name, scanner()-&gt;location(), kSkipFunctionNameCheck, kind,\012          FLAG_harmony_function_tostring ? next_beg_pos : kNoSourcePosition,\012 FunctionLiteral::kAccessorOrMethod, language_mode(), nullptr,\012          CHECK_OK_CUSTOM(NullLiteralProperty));\012\012 ObjectLiteralPropertyT result = factory()-&gt;NewObjectLiteralProperty(\012          name_expression, value, ObjectLiteralProperty::COMPUTED,\012 *is_computed_name);\012      impl()-&gt;SetFunctionNameFromPropertyName(result, name);\012 return result;\012 }\012\012 case PropertyKind::kAccessorProperty: {\012      DCHECK((is_get || is_set) &amp;&amp; !(is_set &amp;&amp; is_get) &amp;&amp; !is_generator &amp;&amp;\012 !is_async);\012\012      classifier()-&gt;RecordPatternError(\012 Scanner::Location(next_beg_pos, scanner()-&gt;location().end_pos),\012 MessageTemplate::kInvalidDestructuringTarget);\012\012 if (!*is_computed_name) {\012 // Make sure the name expression is a string since we need a Name for\012 // Runtime_DefineAccessorPropertyUnchecked and since we can determine\012 // this statically we can skip the extra runtime check.\012        name_expression =\012            factory()-&gt;NewStringLiteral(name, name_expression-&gt;position());\012 }\012\012 FunctionKind kind = is_get ? FunctionKind::kGetterFunction\012 : FunctionKind::kSetterFunction;\012\012 FunctionLiteralT value = impl()-&gt;ParseFunctionLiteral(\012          name, scanner()-&gt;location(), kSkipFunctionNameCheck, kind,\012          FLAG_harmony_function_tostring ? next_beg_pos : kNoSourcePosition,\012 FunctionLiteral::kAccessorOrMethod, language_mode(), nullptr,\012          CHECK_OK_CUSTOM(NullLiteralProperty));\012\012 ObjectLiteralPropertyT result = factory()-&gt;NewObjectLiteralProperty(\012          name_expression, value,\012          is_get ? ObjectLiteralProperty::GETTER\012 : ObjectLiteralProperty::SETTER,\012 *is_computed_name);\012 const AstRawString* prefix =\012          is_get ? ast_value_factory()-&gt;get_space_string()\012 : ast_value_factory()-&gt;set_space_string();\012      impl()-&gt;SetFunctionNameFromPropertyName(result, name, prefix);\012 return result;\012 }\012\012 case PropertyKind::kClassField:\012 case PropertyKind::kNotSet:\012 ReportUnexpectedToken(Next());\012 *ok = false;\012 return impl()-&gt;NullLiteralProperty();\012 }\012  UNREACHABLE();\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParseObjectLiteral(\012 bool* ok) {\012 // ObjectLiteral ::\012 // '{' (PropertyDefinition (',' PropertyDefinition)* ','? )? '}'\012\012 int pos = peek_position();\012 typename Types::ObjectPropertyList properties =\012      impl()-&gt;NewObjectPropertyList(4);\012 int number_of_boilerplate_properties = 0;\012\012 bool has_computed_names = false;\012 bool has_rest_property = false;\012 ObjectLiteralChecker checker(this);\012\012 Expect(Token::LBRACE, CHECK_OK);\012\012 while (peek() != Token::RBRACE) {\012 FuncNameInferrer::State fni_state(fni_);\012\012 bool is_computed_name = false;\012 bool is_rest_property = false;\012 ObjectLiteralPropertyT property = ParseObjectPropertyDefinition(\012 &amp;checker, &amp;is_computed_name, &amp;is_rest_property, CHECK_OK);\012\012 if (is_computed_name) {\012      has_computed_names = true;\012 }\012\012 if (is_rest_property) {\012      has_rest_property = true;\012 }\012\012 if (impl()-&gt;IsBoilerplateProperty(property) &amp;&amp; !has_computed_names) {\012 // Count CONSTANT or COMPUTED properties to maintain the enumeration\012 // order.\012      number_of_boilerplate_properties++;\012 }\012\012    properties-&gt;Add(property, zone());\012\012 if (peek() != Token::RBRACE) {\012 // Need {} because of the CHECK_OK macro.\012 Expect(Token::COMMA, CHECK_OK);\012 }\012\012 if (fni_ != nullptr) fni_-&gt;Infer();\012 }\012 Expect(Token::RBRACE, CHECK_OK);\012\012 // In pattern rewriter, we rewrite rest property to call out to a\012 // runtime function passing all the other properties as arguments to\012 // this runtime function. Here, we make sure that the number of\012 // properties is less than number of arguments allowed for a runtime\012 // call.\012 if (has_rest_property &amp;&amp; properties-&gt;length() &gt; Code::kMaxArguments) {\012 this-&gt;classifier()-&gt;RecordPatternError(Scanner::Location(pos, position()),\012 MessageTemplate::kTooManyArguments);\012 }\012\012 return impl()-&gt;InitializeObjectLiteral(factory()-&gt;NewObjectLiteral(\012      properties, number_of_boilerplate_properties, pos, has_rest_property));\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionListT ParserBase&lt;Impl&gt;::ParseArguments(\012 Scanner::Location* first_spread_arg_loc, bool maybe_arrow,\012 bool* is_simple_parameter_list, bool* ok) {\012 // Arguments ::\012 //   '(' (AssignmentExpression)*[','] ')'\012\012 Scanner::Location spread_arg = Scanner::Location::invalid();\012 ExpressionListT result = impl()-&gt;NewExpressionList(4);\012 Expect(Token::LPAREN, CHECK_OK_CUSTOM(NullExpressionList));\012 bool done = (peek() == Token::RPAREN);\012 while (!done) {\012 int start_pos = peek_position();\012 bool is_spread = Check(Token::ELLIPSIS);\012 int expr_pos = peek_position();\012\012 ExpressionT argument =\012 ParseAssignmentExpression(true, CHECK_OK_CUSTOM(NullExpressionList));\012 if (!impl()-&gt;IsIdentifier(argument) &amp;&amp;\012        is_simple_parameter_list != nullptr) {\012 *is_simple_parameter_list = false;\012 }\012 if (!maybe_arrow) {\012 ValidateExpression(CHECK_OK_CUSTOM(NullExpressionList));\012 }\012 if (is_spread) {\012 if (is_simple_parameter_list != nullptr) {\012 *is_simple_parameter_list = false;\012 }\012 if (!spread_arg.IsValid()) {\012        spread_arg.beg_pos = start_pos;\012        spread_arg.end_pos = peek_position();\012 }\012 if (argument-&gt;IsAssignment()) {\012        classifier()-&gt;RecordAsyncArrowFormalParametersError(\012            scanner()-&gt;location(), MessageTemplate::kRestDefaultInitializer);\012 }\012      argument = factory()-&gt;NewSpread(argument, start_pos, expr_pos);\012 }\012    result-&gt;Add(argument, zone_);\012\012 if (result-&gt;length() &gt; Code::kMaxArguments) {\012 ReportMessage(MessageTemplate::kTooManyArguments);\012 *ok = false;\012 return impl()-&gt;NullExpressionList();\012 }\012 done = (peek() != Token::COMMA);\012 if (!done) {\012 Next();\012 if (argument-&gt;IsSpread()) {\012        classifier()-&gt;RecordAsyncArrowFormalParametersError(\012            scanner()-&gt;location(), MessageTemplate::kParamAfterRest);\012 }\012 if (peek() == Token::RPAREN) {\012 // allow trailing comma\012 done = true;\012 }\012 }\012 }\012 Scanner::Location location = scanner_-&gt;location();\012 if (Token::RPAREN != Next()) {\012    impl()-&gt;ReportMessageAt(location, MessageTemplate::kUnterminatedArgList);\012 *ok = false;\012 return impl()-&gt;NullExpressionList();\012 }\012 *first_spread_arg_loc = spread_arg;\012\012 if (!maybe_arrow || peek() != Token::ARROW) {\012 if (maybe_arrow) {\012 ValidateExpression(CHECK_OK_CUSTOM(NullExpressionList));\012 }\012 }\012\012 return result;\012}\012\012// Precedence = 2\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT\012ParserBase&lt;Impl&gt;::ParseAssignmentExpression(bool accept_IN, bool* ok) {\012 // AssignmentExpression ::\012 //   ConditionalExpression\012 //   ArrowFunction\012 //   YieldExpression\012 //   LeftHandSideExpression AssignmentOperator AssignmentExpression\012 int lhs_beg_pos = peek_position();\012\012 if (peek() == Token::YIELD &amp;&amp; is_generator()) {\012 return ParseYieldExpression(accept_IN, ok);\012 }\012\012 FuncNameInferrer::State fni_state(fni_);\012 ExpressionClassifier arrow_formals_classifier(\012 this, classifier()-&gt;duplicate_finder());\012\012 Scope::Snapshot scope_snapshot(scope());\012 int rewritable_length = static_cast&lt;int&gt;(\012      function_state_-&gt;destructuring_assignments_to_rewrite().size());\012\012 bool is_async = peek() == Token::ASYNC &amp;&amp;\012 !scanner()-&gt;HasLineTerminatorAfterNext() &amp;&amp;\012 IsValidArrowFormalParametersStart(PeekAhead());\012\012 bool parenthesized_formals = peek() == Token::LPAREN;\012 if (!is_async &amp;&amp; !parenthesized_formals) {\012 ArrowFormalParametersUnexpectedToken();\012 }\012\012 // Parse a simple, faster sub-grammar (primary expression) if it's evident\012 // that we have only a trivial expression to parse.\012 ExpressionT expression;\012 if (IsTrivialExpression()) {\012    expression = ParsePrimaryExpression(&amp;is_async, CHECK_OK);\012 } else {\012    expression = ParseConditionalExpression(accept_IN, CHECK_OK);\012 }\012\012 if (is_async &amp;&amp; impl()-&gt;IsIdentifier(expression) &amp;&amp; peek_any_identifier() &amp;&amp;\012 PeekAhead() == Token::ARROW) {\012 // async Identifier =&gt; AsyncConciseBody\012 IdentifierT name = ParseAndClassifyIdentifier(CHECK_OK);\012    expression =\012        impl()-&gt;ExpressionFromIdentifier(name, position(), InferName::kNo);\012 if (fni_) {\012 // Remove `async` keyword from inferred name stack.\012      fni_-&gt;RemoveAsyncKeywordFromEnd();\012 }\012 }\012\012 if (peek() == Token::ARROW) {\012 Scanner::Location arrow_loc = scanner()-&gt;peek_location();\012 ValidateArrowFormalParameters(expression, parenthesized_formals, is_async,\012                                  CHECK_OK);\012 // This reads strangely, but is correct: it checks whether any\012 // sub-expression of the parameter list failed to be a valid formal\012 // parameter initializer. Since YieldExpressions are banned anywhere\012 // in an arrow parameter list, this is correct.\012 // TODO(adamk): Rename &quot;FormalParameterInitializerError&quot; to refer to\012 // &quot;YieldExpression&quot;, which is its only use.\012 ValidateFormalParameterInitializer(ok);\012\012 Scanner::Location loc(lhs_beg_pos, scanner()-&gt;location().end_pos);\012 DeclarationScope* scope =\012 NewFunctionScope(is_async ? FunctionKind::kAsyncArrowFunction\012 : FunctionKind::kArrowFunction);\012\012 // Because the arrow's parameters were parsed in the outer scope,\012 // we need to fix up the scope chain appropriately.\012    scope_snapshot.Reparent(scope);\012\012 FormalParametersT parameters(scope);\012 if (!classifier()-&gt;is_simple_parameter_list()) {\012      scope-&gt;SetHasNonSimpleParameters();\012      parameters.is_simple = false;\012 }\012\012    scope-&gt;set_start_position(lhs_beg_pos);\012 Scanner::Location duplicate_loc = Scanner::Location::invalid();\012    impl()-&gt;DeclareArrowFunctionFormalParameters(&amp;parameters, expression, loc,\012 &amp;duplicate_loc, CHECK_OK);\012 if (duplicate_loc.IsValid()) {\012      classifier()-&gt;RecordDuplicateFormalParameterError(duplicate_loc);\012 }\012    expression = ParseArrowFunctionLiteral(accept_IN, parameters,\012                                           rewritable_length, CHECK_OK);\012 Accumulate(ExpressionClassifier::AsyncArrowFormalParametersProduction);\012    classifier()-&gt;RecordPatternError(arrow_loc,\012 MessageTemplate::kUnexpectedToken,\012 Token::String(Token::ARROW));\012\012 if (fni_ != nullptr) fni_-&gt;Infer();\012\012 return expression;\012 }\012\012 // &quot;expression&quot; was not itself an arrow function parameter list, but it might\012 // form part of one.  Propagate speculative formal parameter error locations\012 // (including those for binding patterns, since formal parameters can\012 // themselves contain binding patterns).\012 unsigned productions = ExpressionClassifier::AllProductions &amp;\012 ~ExpressionClassifier::ArrowFormalParametersProduction;\012\012 // Parenthesized identifiers and property references are allowed as part\012 // of a larger assignment pattern, even though parenthesized patterns\012 // themselves are not allowed, e.g., &quot;[(x)] = []&quot;. Only accumulate\012 // assignment pattern errors if the parsed expression is more complex.\012 if (IsValidReferenceExpression(expression)) {\012    productions &amp;= ~ExpressionClassifier::AssignmentPatternProduction;\012 }\012\012 const bool is_destructuring_assignment =\012 IsValidPattern(expression) &amp;&amp; peek() == Token::ASSIGN;\012 if (is_destructuring_assignment) {\012 // This is definitely not an expression so don't accumulate\012 // expression-related errors.\012    productions &amp;= ~ExpressionClassifier::ExpressionProduction;\012 }\012\012 Accumulate(productions);\012 if (!Token::IsAssignmentOp(peek())) return expression;\012\012 if (is_destructuring_assignment) {\012 ValidateAssignmentPattern(CHECK_OK);\012 } else {\012    expression = CheckAndRewriteReferenceExpression(\012        expression, lhs_beg_pos, scanner()-&gt;location().end_pos,\012 MessageTemplate::kInvalidLhsInAssignment, CHECK_OK);\012 }\012\012  impl()-&gt;MarkExpressionAsAssigned(expression);\012\012 Token::Value op = Next(); // Get assignment operator.\012 if (op != Token::ASSIGN) {\012    classifier()-&gt;RecordPatternError(scanner()-&gt;location(),\012 MessageTemplate::kUnexpectedToken,\012 Token::String(op));\012 }\012 int pos = position();\012\012 ExpressionClassifier rhs_classifier(this);\012\012 ExpressionT right = ParseAssignmentExpression(accept_IN, CHECK_OK);\012 ValidateExpression(CHECK_OK);\012 AccumulateFormalParameterContainmentErrors();\012\012 // We try to estimate the set of properties set by constructors. We define a\012 // new property whenever there is an assignment to a property of 'this'. We\012 // should probably only add properties if we haven't seen them\012 // before. Otherwise we'll probably overestimate the number of properties.\012 if (op == Token::ASSIGN &amp;&amp; impl()-&gt;IsThisProperty(expression)) {\012    function_state_-&gt;AddProperty();\012 }\012\012  impl()-&gt;CheckAssigningFunctionLiteralToProperty(expression, right);\012\012 if (fni_ != nullptr) {\012 // Check if the right hand side is a call to avoid inferring a\012 // name if we're dealing with &quot;a = function(){...}();&quot;-like\012 // expression.\012 if (op == Token::ASSIGN &amp;&amp; !right-&gt;IsCall() &amp;&amp; !right-&gt;IsCallNew()) {\012      fni_-&gt;Infer();\012 } else {\012      fni_-&gt;RemoveLastFunction();\012 }\012 }\012\012 if (op == Token::ASSIGN) {\012    impl()-&gt;SetFunctionNameFromIdentifierRef(right, expression);\012 }\012\012  DCHECK_NE(op, Token::INIT);\012 ExpressionT result = factory()-&gt;NewAssignment(op, expression, right, pos);\012\012 if (is_destructuring_assignment) {\012    DCHECK_NE(op, Token::ASSIGN_EXP);\012 auto rewritable = factory()-&gt;NewRewritableExpression(result, scope());\012    impl()-&gt;QueueDestructuringAssignmentForRewriting(rewritable);\012    result = rewritable;\012 }\012\012 return result;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParseYieldExpression(\012 bool accept_IN, bool* ok) {\012 // YieldExpression ::\012 //   'yield' ([no line terminator] '*'? AssignmentExpression)?\012 int pos = peek_position();\012  classifier()-&gt;RecordPatternError(\012      scanner()-&gt;peek_location(), MessageTemplate::kInvalidDestructuringTarget);\012  classifier()-&gt;RecordFormalParameterInitializerError(\012      scanner()-&gt;peek_location(), MessageTemplate::kYieldInParameter);\012 Expect(Token::YIELD, CHECK_OK);\012 // The following initialization is necessary.\012 ExpressionT expression = impl()-&gt;NullExpression();\012 bool delegating = false; // yield*\012 if (!scanner()-&gt;HasLineTerminatorBeforeNext()) {\012 if (Check(Token::MUL)) delegating = true;\012 switch (peek()) {\012 case Token::EOS:\012 case Token::SEMICOLON:\012 case Token::RBRACE:\012 case Token::RBRACK:\012 case Token::RPAREN:\012 case Token::COLON:\012 case Token::COMMA:\012 case Token::IN:\012 // The above set of tokens is the complete set of tokens that can appear\012 // after an AssignmentExpression, and none of them can start an\012 // AssignmentExpression.  This allows us to avoid looking for an RHS for\012 // a regular yield, given only one look-ahead token.\012 if (!delegating) break;\012 // Delegating yields require an RHS; fall through.\012        V8_FALLTHROUGH;\012 default:\012        expression = ParseAssignmentExpression(accept_IN, CHECK_OK);\012 ValidateExpression(CHECK_OK);\012 break;\012 }\012 }\012\012 if (delegating) {\012 ExpressionT yieldstar = factory()-&gt;NewYieldStar(expression, pos);\012    impl()-&gt;RecordSuspendSourceRange(yieldstar, PositionAfterSemicolon());\012    function_state_-&gt;AddSuspend();\012 if (IsAsyncGeneratorFunction(function_state_-&gt;kind())) {\012 // iterator_close and delegated_iterator_output suspend ids.\012      function_state_-&gt;AddSuspend();\012      function_state_-&gt;AddSuspend();\012 }\012 return yieldstar;\012 }\012\012 // Hackily disambiguate o from o.next and o [Symbol.iterator]().\012 // TODO(verwaest): Come up with a better solution.\012 ExpressionT yield =\012      factory()-&gt;NewYield(expression, pos, Suspend::kOnExceptionThrow);\012  impl()-&gt;RecordSuspendSourceRange(yield, PositionAfterSemicolon());\012  function_state_-&gt;AddSuspend();\012 return yield;\012}\012\012// Precedence = 3\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT\012ParserBase&lt;Impl&gt;::ParseConditionalExpression(bool accept_IN,\012 bool* ok) {\012 // ConditionalExpression ::\012 //   LogicalOrExpression\012 //   LogicalOrExpression '?' AssignmentExpression ':' AssignmentExpression\012\012 SourceRange then_range, else_range;\012 int pos = peek_position();\012 // We start using the binary expression parser for prec &gt;= 4 only!\012 ExpressionT expression = ParseBinaryExpression(4, accept_IN, CHECK_OK);\012 if (peek() != Token::CONDITIONAL) return expression;\012 ValidateExpression(CHECK_OK);\012 BindingPatternUnexpectedToken();\012 ArrowFormalParametersUnexpectedToken();\012\012 ExpressionT left;\012 {\012 SourceRangeScope range_scope(scanner(), &amp;then_range);\012 Consume(Token::CONDITIONAL);\012 ExpressionClassifier classifier(this);\012 // In parsing the first assignment expression in conditional\012 // expressions we always accept the 'in' keyword; see ECMA-262,\012 // section 11.12, page 58.\012    left = ParseAssignmentExpression(true, CHECK_OK);\012 AccumulateNonBindingPatternErrors();\012 }\012 ValidateExpression(CHECK_OK);\012 ExpressionT right;\012 {\012 SourceRangeScope range_scope(scanner(), &amp;else_range);\012 Expect(Token::COLON, CHECK_OK);\012 ExpressionClassifier classifier(this);\012    right = ParseAssignmentExpression(accept_IN, CHECK_OK);\012 AccumulateNonBindingPatternErrors();\012 }\012 ValidateExpression(CHECK_OK);\012 ExpressionT expr = factory()-&gt;NewConditional(expression, left, right, pos);\012  impl()-&gt;RecordConditionalSourceRange(expr, then_range, else_range);\012 return expr;\012}\012\012\012// Precedence &gt;= 4\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParseBinaryExpression(\012 int prec, bool accept_IN, bool* ok) {\012  DCHECK_GE(prec, 4);\012 SourceRange right_range;\012 ExpressionT x = ParseUnaryExpression(CHECK_OK);\012 for (int prec1 = Precedence(peek(), accept_IN); prec1 &gt;= prec; prec1--) {\012 // prec1 &gt;= 4\012 while (Precedence(peek(), accept_IN) == prec1) {\012 ValidateExpression(CHECK_OK);\012 BindingPatternUnexpectedToken();\012 ArrowFormalParametersUnexpectedToken();\012\012 SourceRangeScope right_range_scope(scanner(), &amp;right_range);\012 Token::Value op = Next();\012 int pos = position();\012\012 const bool is_right_associative = op == Token::EXP;\012 const int next_prec = is_right_associative ? prec1 : prec1 + 1;\012 ExpressionT y = ParseBinaryExpression(next_prec, accept_IN, CHECK_OK);\012      right_range_scope.Finalize();\012 ValidateExpression(CHECK_OK);\012\012 if (impl()-&gt;ShortcutNumericLiteralBinaryExpression(&amp;x, y, op, pos)) {\012 continue;\012 }\012\012 // For now we distinguish between comparisons and other binary\012 // operations.  (We could combine the two and get rid of this\012 // code and AST node eventually.)\012 if (Token::IsCompareOp(op)) {\012 // We have a comparison.\012 Token::Value cmp = op;\012 switch (op) {\012 case Token::NE: cmp = Token::EQ; break;\012 case Token::NE_STRICT: cmp = Token::EQ_STRICT; break;\012 default: break;\012 }\012        x = factory()-&gt;NewCompareOperation(cmp, x, y, pos);\012 if (cmp != op) {\012 // The comparison was negated - add a NOT.\012          x = factory()-&gt;NewUnaryOperation(Token::NOT, x, pos);\012 }\012 } else if (impl()-&gt;CollapseNaryExpression(&amp;x, y, op, pos, right_range)) {\012 continue;\012 } else {\012 // We have a &quot;normal&quot; binary operation.\012        x = factory()-&gt;NewBinaryOperation(op, x, y, pos);\012 if (op == Token::OR || op == Token::AND) {\012          impl()-&gt;RecordBinaryOperationSourceRange(x, right_range);\012 }\012 }\012 }\012 }\012 return x;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParseUnaryExpression(\012 bool* ok) {\012 // UnaryExpression ::\012 //   PostfixExpression\012 //   'delete' UnaryExpression\012 //   'void' UnaryExpression\012 //   'typeof' UnaryExpression\012 //   '++' UnaryExpression\012 //   '--' UnaryExpression\012 //   '+' UnaryExpression\012 //   '-' UnaryExpression\012 //   '~' UnaryExpression\012 //   '!' UnaryExpression\012 //   [+Await] AwaitExpression[?Yield]\012\012 Token::Value op = peek();\012 if (Token::IsUnaryOp(op)) {\012 BindingPatternUnexpectedToken();\012 ArrowFormalParametersUnexpectedToken();\012\012    op = Next();\012 int pos = position();\012\012 // Assume &quot;! function ...&quot; indicates the function is likely to be called.\012 if (op == Token::NOT &amp;&amp; peek() == Token::FUNCTION) {\012      function_state_-&gt;set_next_function_is_likely_called();\012 }\012\012 ExpressionT expression = ParseUnaryExpression(CHECK_OK);\012 ValidateExpression(CHECK_OK);\012\012 if (op == Token::DELETE) {\012 if (impl()-&gt;IsIdentifier(expression) &amp;&amp; is_strict(language_mode())) {\012 // &quot;delete identifier&quot; is a syntax error in strict mode.\012 ReportMessage(MessageTemplate::kStrictDelete);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012\012 if (impl()-&gt;IsPropertyWithPrivateFieldKey(expression)) {\012 ReportMessage(MessageTemplate::kDeletePrivateField);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012 }\012\012 if (peek() == Token::EXP) {\012 ReportUnexpectedToken(Next());\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012\012 // Allow the parser's implementation to rewrite the expression.\012 return impl()-&gt;BuildUnaryExpression(expression, op, pos);\012 } else if (Token::IsCountOp(op)) {\012 BindingPatternUnexpectedToken();\012 ArrowFormalParametersUnexpectedToken();\012    op = Next();\012 int beg_pos = peek_position();\012 ExpressionT expression = ParseUnaryExpression(CHECK_OK);\012    expression = CheckAndRewriteReferenceExpression(\012        expression, beg_pos, scanner()-&gt;location().end_pos,\012 MessageTemplate::kInvalidLhsInPrefixOp, CHECK_OK);\012    impl()-&gt;MarkExpressionAsAssigned(expression);\012 ValidateExpression(CHECK_OK);\012\012 return factory()-&gt;NewCountOperation(op,\012 true /* prefix */,\012                                        expression,\012                                        position());\012\012 } else if (is_async_function() &amp;&amp; peek() == Token::AWAIT) {\012    classifier()-&gt;RecordFormalParameterInitializerError(\012        scanner()-&gt;peek_location(),\012 MessageTemplate::kAwaitExpressionFormalParameter);\012 int await_pos = peek_position();\012 Consume(Token::AWAIT);\012\012 ExpressionT value = ParseUnaryExpression(CHECK_OK);\012\012    classifier()-&gt;RecordBindingPatternError(\012 Scanner::Location(await_pos, scanner()-&gt;location().end_pos),\012 MessageTemplate::kInvalidDestructuringTarget);\012\012 ExpressionT expr = factory()-&gt;NewAwait(value, await_pos);\012    function_state_-&gt;AddSuspend();\012    impl()-&gt;RecordSuspendSourceRange(expr, PositionAfterSemicolon());\012 return expr;\012 } else {\012 return ParsePostfixExpression(ok);\012 }\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParsePostfixExpression(\012 bool* ok) {\012 // PostfixExpression ::\012 //   LeftHandSideExpression ('++' | '--')?\012\012 int lhs_beg_pos = peek_position();\012 ExpressionT expression = ParseLeftHandSideExpression(CHECK_OK);\012 if (!scanner()-&gt;HasLineTerminatorBeforeNext() &amp;&amp; Token::IsCountOp(peek())) {\012 BindingPatternUnexpectedToken();\012 ArrowFormalParametersUnexpectedToken();\012\012    expression = CheckAndRewriteReferenceExpression(\012        expression, lhs_beg_pos, scanner()-&gt;location().end_pos,\012 MessageTemplate::kInvalidLhsInPostfixOp, CHECK_OK);\012    impl()-&gt;MarkExpressionAsAssigned(expression);\012 ValidateExpression(CHECK_OK);\012\012 Token::Value next = Next();\012    expression =\012        factory()-&gt;NewCountOperation(next,\012 false /* postfix */,\012                                     expression,\012                                     position());\012 }\012 return expression;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT\012ParserBase&lt;Impl&gt;::ParseLeftHandSideExpression(bool* ok) {\012 // LeftHandSideExpression ::\012 //   (NewExpression | MemberExpression) ...\012\012 bool is_async = false;\012 ExpressionT result =\012 ParseMemberWithNewPrefixesExpression(&amp;is_async, CHECK_OK);\012\012 while (true) {\012 switch (peek()) {\012 case Token::LBRACK: {\012 ValidateExpression(CHECK_OK);\012 BindingPatternUnexpectedToken();\012 ArrowFormalParametersUnexpectedToken();\012 Consume(Token::LBRACK);\012 int pos = position();\012 ExpressionT index = ParseExpressionCoverGrammar(true, CHECK_OK);\012 ValidateExpression(CHECK_OK);\012        result = factory()-&gt;NewProperty(result, index, pos);\012 Expect(Token::RBRACK, CHECK_OK);\012 break;\012 }\012\012 case Token::LPAREN: {\012 int pos;\012 ValidateExpression(CHECK_OK);\012 BindingPatternUnexpectedToken();\012 if (scanner()-&gt;current_token() == Token::IDENTIFIER ||\012            scanner()-&gt;current_token() == Token::SUPER ||\012            scanner()-&gt;current_token() == Token::ASYNC) {\012 // For call of an identifier we want to report position of\012 // the identifier as position of the call in the stack trace.\012          pos = position();\012 } else {\012 // For other kinds of calls we record position of the parenthesis as\012 // position of the call. Note that this is extremely important for\012 // expressions of the form function(){...}() for which call position\012 // should not point to the closing brace otherwise it will intersect\012 // with positions recorded for function literal and confuse debugger.\012          pos = peek_position();\012 // Also the trailing parenthesis are a hint that the function will\012 // be called immediately. If we happen to have parsed a preceding\012 // function literal eagerly, we can also compile it eagerly.\012 if (result-&gt;IsFunctionLiteral()) {\012            result-&gt;AsFunctionLiteral()-&gt;SetShouldEagerCompile();\012            result-&gt;AsFunctionLiteral()-&gt;mark_as_iife();\012 }\012 }\012 Scanner::Location spread_pos;\012 ExpressionListT args;\012 if (V8_UNLIKELY(is_async &amp;&amp; impl()-&gt;IsIdentifier(result))) {\012 ExpressionClassifier async_classifier(this);\012 bool is_simple_parameter_list = true;\012          args = ParseArguments(&amp;spread_pos, true, &amp;is_simple_parameter_list,\012                                CHECK_OK);\012 if (peek() == Token::ARROW) {\012 if (fni_) {\012              fni_-&gt;RemoveAsyncKeywordFromEnd();\012 }\012 ValidateBindingPattern(CHECK_OK);\012 ValidateFormalParameterInitializer(CHECK_OK);\012 if (!classifier()-&gt;is_valid_async_arrow_formal_parameters()) {\012 ReportClassifierError(\012                  classifier()-&gt;async_arrow_formal_parameters_error());\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012 if (args-&gt;length()) {\012 // async ( Arguments ) =&gt; ...\012 if (!is_simple_parameter_list) {\012                async_classifier.previous()-&gt;RecordNonSimpleParameter();\012 }\012 return impl()-&gt;ExpressionListToExpression(args);\012 }\012 // async () =&gt; ...\012 return factory()-&gt;NewEmptyParentheses(pos);\012 } else {\012 AccumulateFormalParameterContainmentErrors();\012 }\012 } else {\012          args = ParseArguments(&amp;spread_pos, CHECK_OK);\012 }\012\012 ArrowFormalParametersUnexpectedToken();\012\012 // Keep track of eval() calls since they disable all local variable\012 // optimizations.\012 // The calls that need special treatment are the\012 // direct eval calls. These calls are all of the form eval(...), with\012 // no explicit receiver.\012 // These calls are marked as potentially direct eval calls. Whether\012 // they are actually direct calls to eval is determined at run time.\012 Call::PossiblyEval is_possibly_eval =\012 CheckPossibleEvalCall(result, scope());\012\012 if (spread_pos.IsValid()) {\012          result = impl()-&gt;SpreadCall(result, args, pos, is_possibly_eval);\012 } else {\012          result = factory()-&gt;NewCall(result, args, pos, is_possibly_eval);\012 }\012\012 if (fni_ != nullptr) fni_-&gt;RemoveLastFunction();\012 break;\012 }\012\012 case Token::PERIOD: {\012 ValidateExpression(CHECK_OK);\012 BindingPatternUnexpectedToken();\012 ArrowFormalParametersUnexpectedToken();\012 Consume(Token::PERIOD);\012 int pos = position();\012 ExpressionT key = ParseIdentifierNameOrPrivateName(CHECK_OK);\012        result = factory()-&gt;NewProperty(result, key, pos);\012 break;\012 }\012\012 case Token::TEMPLATE_SPAN:\012 case Token::TEMPLATE_TAIL: {\012 ValidateExpression(CHECK_OK);\012 BindingPatternUnexpectedToken();\012 ArrowFormalParametersUnexpectedToken();\012        result = ParseTemplateLiteral(result, position(), true, CHECK_OK);\012 break;\012 }\012\012 default:\012 return result;\012 }\012 }\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT\012ParserBase&lt;Impl&gt;::ParseMemberWithNewPrefixesExpression(bool* is_async,\012 bool* ok) {\012 // NewExpression ::\012 //   ('new')+ MemberExpression\012 //\012 // NewTarget ::\012 //   'new' '.' 'target'\012\012 // The grammar for new expressions is pretty warped. We can have several 'new'\012 // keywords following each other, and then a MemberExpression. When we see '('\012 // after the MemberExpression, it's associated with the rightmost unassociated\012 // 'new' to create a NewExpression with arguments. However, a NewExpression\012 // can also occur without arguments.\012\012 // Examples of new expression:\012 // new foo.bar().baz means (new (foo.bar)()).baz\012 // new foo()() means (new foo())()\012 // new new foo()() means (new (new foo())())\012 // new new foo means new (new foo)\012 // new new foo() means new (new foo())\012 // new new foo().bar().baz means (new (new foo()).bar()).baz\012\012 if (peek() == Token::NEW) {\012 BindingPatternUnexpectedToken();\012 ArrowFormalParametersUnexpectedToken();\012 Consume(Token::NEW);\012 int new_pos = position();\012 ExpressionT result;\012 if (peek() == Token::SUPER) {\012 const bool is_new = true;\012      result = ParseSuperExpression(is_new, CHECK_OK);\012 } else if (allow_harmony_dynamic_import() &amp;&amp; peek() == Token::IMPORT &amp;&amp;\012 (!allow_harmony_import_meta() || PeekAhead() == Token::LPAREN)) {\012      impl()-&gt;ReportMessageAt(scanner()-&gt;peek_location(),\012 MessageTemplate::kImportCallNotNewExpression);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 } else if (peek() == Token::PERIOD) {\012 *is_async = false;\012      result = ParseNewTargetExpression(CHECK_OK);\012 return ParseMemberExpressionContinuation(result, is_async, CHECK_OK);\012 } else {\012      result = ParseMemberWithNewPrefixesExpression(is_async, CHECK_OK);\012 }\012 ValidateExpression(CHECK_OK);\012 if (peek() == Token::LPAREN) {\012 // NewExpression with arguments.\012 Scanner::Location spread_pos;\012 ExpressionListT args = ParseArguments(&amp;spread_pos, CHECK_OK);\012\012 if (spread_pos.IsValid()) {\012        result = impl()-&gt;SpreadCallNew(result, args, new_pos);\012 } else {\012        result = factory()-&gt;NewCallNew(result, args, new_pos);\012 }\012 // The expression can still continue with . or [ after the arguments.\012      result = ParseMemberExpressionContinuation(result, is_async, CHECK_OK);\012 return result;\012 }\012 // NewExpression without arguments.\012 return factory()-&gt;NewCallNew(result, impl()-&gt;NewExpressionList(0), new_pos);\012 }\012 // No 'new' or 'super' keyword.\012 return ParseMemberExpression(is_async, ok);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParseMemberExpression(\012 bool* is_async, bool* ok) {\012 // MemberExpression ::\012 //   (PrimaryExpression | FunctionLiteral | ClassLiteral)\012 //     ('[' Expression ']' | '.' Identifier | Arguments | TemplateLiteral)*\012 //\012 // CallExpression ::\012 //   (SuperCall | ImportCall)\012 //     ('[' Expression ']' | '.' Identifier | Arguments | TemplateLiteral)*\012 //\012 // The '[' Expression ']' and '.' Identifier parts are parsed by\012 // ParseMemberExpressionContinuation, and the Arguments part is parsed by the\012 // caller.\012\012 // Parse the initial primary or function expression.\012 ExpressionT result;\012 if (peek() == Token::FUNCTION) {\012 BindingPatternUnexpectedToken();\012 ArrowFormalParametersUnexpectedToken();\012\012 Consume(Token::FUNCTION);\012 int function_token_position = position();\012\012 FunctionKind function_kind = Check(Token::MUL)\012 ? FunctionKind::kGeneratorFunction\012 : FunctionKind::kNormalFunction;\012 IdentifierT name = impl()-&gt;NullIdentifier();\012 bool is_strict_reserved_name = false;\012 Scanner::Location function_name_location = Scanner::Location::invalid();\012 FunctionLiteral::FunctionType function_type =\012 FunctionLiteral::kAnonymousExpression;\012 if (impl()-&gt;ParsingDynamicFunctionDeclaration()) {\012 // We don't want dynamic functions to actually declare their name\012 // &quot;anonymous&quot;. We just want that name in the toString().\012 if (stack_overflow()) {\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012 Consume(Token::IDENTIFIER);\012      DCHECK(scanner()-&gt;CurrentMatchesContextual(Token::ANONYMOUS));\012 } else if (peek_any_identifier()) {\012 bool is_await = false;\012      name = ParseIdentifierOrStrictReservedWord(\012          function_kind, &amp;is_strict_reserved_name, &amp;is_await, CHECK_OK);\012      function_name_location = scanner()-&gt;location();\012      function_type = FunctionLiteral::kNamedExpression;\012 }\012    result = impl()-&gt;ParseFunctionLiteral(\012        name, function_name_location,\012        is_strict_reserved_name ? kFunctionNameIsStrictReserved\012 : kFunctionNameValidityUnknown,\012        function_kind, function_token_position, function_type, language_mode(),\012 nullptr, CHECK_OK);\012 } else if (peek() == Token::SUPER) {\012 const bool is_new = false;\012    result = ParseSuperExpression(is_new, CHECK_OK);\012 } else if (allow_harmony_dynamic_import() &amp;&amp; peek() == Token::IMPORT) {\012    result = ParseImportExpressions(CHECK_OK);\012 } else {\012    result = ParsePrimaryExpression(is_async, CHECK_OK);\012 }\012\012  result = ParseMemberExpressionContinuation(result, is_async, CHECK_OK);\012 return result;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParseImportExpressions(\012 bool* ok) {\012  DCHECK(allow_harmony_dynamic_import());\012\012  classifier()-&gt;RecordPatternError(scanner()-&gt;peek_location(),\012 MessageTemplate::kUnexpectedToken,\012 Token::String(Token::IMPORT));\012\012 Consume(Token::IMPORT);\012 int pos = position();\012 if (allow_harmony_import_meta() &amp;&amp; peek() == Token::PERIOD) {\012 ExpectMetaProperty(Token::META, &quot;import.meta&quot;, pos, CHECK_OK);\012 if (!parsing_module_) {\012      impl()-&gt;ReportMessageAt(scanner()-&gt;location(),\012 MessageTemplate::kImportMetaOutsideModule);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012\012 return impl()-&gt;ImportMetaExpression(pos);\012 }\012 Expect(Token::LPAREN, CHECK_OK);\012 if (peek() == Token::RPAREN) {\012    impl()-&gt;ReportMessageAt(scanner()-&gt;location(),\012 MessageTemplate::kImportMissingSpecifier);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012 ExpressionT arg = ParseAssignmentExpression(true, CHECK_OK);\012 Expect(Token::RPAREN, CHECK_OK);\012 return factory()-&gt;NewImportCallExpression(arg, pos);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParseSuperExpression(\012 bool is_new, bool* ok) {\012 Expect(Token::SUPER, CHECK_OK);\012 int pos = position();\012\012 DeclarationScope* scope = GetReceiverScope();\012 FunctionKind kind = scope-&gt;function_kind();\012 if (IsConciseMethod(kind) || IsAccessorFunction(kind) ||\012 IsClassConstructor(kind)) {\012 if (peek() == Token::PERIOD || peek() == Token::LBRACK) {\012      scope-&gt;RecordSuperPropertyUsage();\012 return impl()-&gt;NewSuperPropertyReference(pos);\012 }\012 // new super() is never allowed.\012 // super() is only allowed in derived constructor\012 if (!is_new &amp;&amp; peek() == Token::LPAREN &amp;&amp; IsDerivedConstructor(kind)) {\012 // TODO(rossberg): This might not be the correct FunctionState for the\012 // method here.\012 return impl()-&gt;NewSuperCallReference(pos);\012 }\012 }\012\012  impl()-&gt;ReportMessageAt(scanner()-&gt;location(),\012 MessageTemplate::kUnexpectedSuper);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::ExpectMetaProperty(Token::Value property_name,\012 const char* full_name, int pos,\012 bool* ok) {\012 Consume(Token::PERIOD);\012 ExpectContextualKeyword(property_name, CHECK_OK_CUSTOM(Void));\012 if (scanner()-&gt;literal_contains_escapes()) {\012    impl()-&gt;ReportMessageAt(\012 Scanner::Location(pos, scanner()-&gt;location().end_pos),\012 MessageTemplate::kInvalidEscapedMetaProperty, full_name);\012 *ok = false;\012 }\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT\012ParserBase&lt;Impl&gt;::ParseNewTargetExpression(bool* ok) {\012 int pos = position();\012 ExpectMetaProperty(Token::TARGET, &quot;new.target&quot;, pos, CHECK_OK);\012\012  classifier()-&gt;RecordAssignmentPatternError(\012 Scanner::Location(pos, scanner()-&gt;location().end_pos),\012 MessageTemplate::kInvalidDestructuringTarget);\012\012 if (!GetReceiverScope()-&gt;is_function_scope()) {\012    impl()-&gt;ReportMessageAt(scanner()-&gt;location(),\012 MessageTemplate::kUnexpectedNewTarget);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012\012 return impl()-&gt;NewTargetExpression(pos);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT\012ParserBase&lt;Impl&gt;::ParseMemberExpressionContinuation(ExpressionT expression,\012 bool* is_async, bool* ok) {\012 // Parses this part of MemberExpression:\012 // ('[' Expression ']' | '.' Identifier | TemplateLiteral)*\012 while (true) {\012 switch (peek()) {\012 case Token::LBRACK: {\012 *is_async = false;\012 ValidateExpression(CHECK_OK);\012 BindingPatternUnexpectedToken();\012 ArrowFormalParametersUnexpectedToken();\012\012 Consume(Token::LBRACK);\012 int pos = position();\012 ExpressionT index = ParseExpressionCoverGrammar(true, CHECK_OK);\012 ValidateExpression(CHECK_OK);\012        expression = factory()-&gt;NewProperty(expression, index, pos);\012        impl()-&gt;PushPropertyName(index);\012 Expect(Token::RBRACK, CHECK_OK);\012 break;\012 }\012 case Token::PERIOD: {\012 *is_async = false;\012 ValidateExpression(CHECK_OK);\012 BindingPatternUnexpectedToken();\012 ArrowFormalParametersUnexpectedToken();\012\012 Consume(Token::PERIOD);\012 int pos = peek_position();\012 ExpressionT key = ParseIdentifierNameOrPrivateName(CHECK_OK);\012        expression = factory()-&gt;NewProperty(expression, key, pos);\012 break;\012 }\012 case Token::TEMPLATE_SPAN:\012 case Token::TEMPLATE_TAIL: {\012 *is_async = false;\012 ValidateExpression(CHECK_OK);\012 BindingPatternUnexpectedToken();\012 ArrowFormalParametersUnexpectedToken();\012 int pos;\012 if (scanner()-&gt;current_token() == Token::IDENTIFIER) {\012          pos = position();\012 } else {\012          pos = peek_position();\012 if (expression-&gt;IsFunctionLiteral()) {\012 // If the tag function looks like an IIFE, set_parenthesized() to\012 // force eager compilation.\012            expression-&gt;AsFunctionLiteral()-&gt;SetShouldEagerCompile();\012 }\012 }\012        expression = ParseTemplateLiteral(expression, pos, true, CHECK_OK);\012 break;\012 }\012 case Token::ILLEGAL: {\012 ReportUnexpectedTokenAt(scanner()-&gt;peek_location(), Token::ILLEGAL);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012 default:\012 return expression;\012 }\012 }\012  DCHECK(false);\012 return impl()-&gt;NullExpression();\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::ParseFormalParameter(FormalParametersT* parameters,\012 bool* ok) {\012 // FormalParameter[Yield,GeneratorParameter] :\012 //   BindingElement[?Yield, ?GeneratorParameter]\012 bool is_rest = parameters-&gt;has_rest;\012\012 FuncNameInferrer::State fni_state(fni_);\012 ExpressionT pattern = ParsePrimaryExpression(CHECK_OK_CUSTOM(Void));\012 ValidateBindingPattern(CHECK_OK_CUSTOM(Void));\012\012 if (!impl()-&gt;IsIdentifier(pattern)) {\012    parameters-&gt;is_simple = false;\012 ValidateFormalParameterInitializer(CHECK_OK_CUSTOM(Void));\012    classifier()-&gt;RecordNonSimpleParameter();\012 }\012\012 ExpressionT initializer = impl()-&gt;NullExpression();\012 if (Check(Token::ASSIGN)) {\012 if (is_rest) {\012 ReportMessage(MessageTemplate::kRestDefaultInitializer);\012 *ok = false;\012 return;\012 }\012 ExpressionClassifier init_classifier(this);\012    initializer = ParseAssignmentExpression(true, CHECK_OK_CUSTOM(Void));\012 ValidateExpression(CHECK_OK_CUSTOM(Void));\012 ValidateFormalParameterInitializer(CHECK_OK_CUSTOM(Void));\012    parameters-&gt;is_simple = false;\012 DiscardExpressionClassifier();\012    classifier()-&gt;RecordNonSimpleParameter();\012\012    impl()-&gt;SetFunctionNameFromIdentifierRef(initializer, pattern);\012 }\012\012  impl()-&gt;AddFormalParameter(parameters, pattern, initializer,\012                             scanner()-&gt;location().end_pos, is_rest);\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::ParseFormalParameterList(FormalParametersT* parameters,\012 bool* ok) {\012 // FormalParameters[Yield] :\012 //   [empty]\012 //   FunctionRestParameter[?Yield]\012 //   FormalParameterList[?Yield]\012 //   FormalParameterList[?Yield] ,\012 //   FormalParameterList[?Yield] , FunctionRestParameter[?Yield]\012 //\012 // FormalParameterList[Yield] :\012 //   FormalParameter[?Yield]\012 //   FormalParameterList[?Yield] , FormalParameter[?Yield]\012\012  DCHECK_EQ(0, parameters-&gt;arity);\012\012 if (peek() != Token::RPAREN) {\012 while (true) {\012 // Add one since we're going to be adding a parameter.\012 if (parameters-&gt;arity + 1 &gt; Code::kMaxArguments) {\012 ReportMessage(MessageTemplate::kTooManyParameters);\012 *ok = false;\012 return;\012 }\012      parameters-&gt;has_rest = Check(Token::ELLIPSIS);\012 ParseFormalParameter(parameters, CHECK_OK_CUSTOM(Void));\012\012 if (parameters-&gt;has_rest) {\012        parameters-&gt;is_simple = false;\012        classifier()-&gt;RecordNonSimpleParameter();\012 if (peek() == Token::COMMA) {\012          impl()-&gt;ReportMessageAt(scanner()-&gt;peek_location(),\012 MessageTemplate::kParamAfterRest);\012 *ok = false;\012 return;\012 }\012 break;\012 }\012 if (!Check(Token::COMMA)) break;\012 if (peek() == Token::RPAREN) {\012 // allow the trailing comma\012 break;\012 }\012 }\012 }\012\012  impl()-&gt;DeclareFormalParameters(parameters-&gt;scope, parameters-&gt;params,\012                                  parameters-&gt;is_simple);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::BlockT ParserBase&lt;Impl&gt;::ParseVariableDeclarations(\012 VariableDeclarationContext var_context,\012 DeclarationParsingResult* parsing_result,\012 ZonePtrList&lt;const AstRawString&gt;* names, bool* ok) {\012 // VariableDeclarations ::\012 //   ('var' | 'const' | 'let') (Identifier ('=' AssignmentExpression)?)+[',']\012 //\012 // ES6:\012 // FIXME(marja, nikolaos): Add an up-to-date comment about ES6 variable\012 // declaration syntax.\012\012  DCHECK_NOT_NULL(parsing_result);\012  parsing_result-&gt;descriptor.declaration_kind = DeclarationDescriptor::NORMAL;\012  parsing_result-&gt;descriptor.declaration_pos = peek_position();\012  parsing_result-&gt;descriptor.initialization_pos = peek_position();\012\012 BlockT init_block = impl()-&gt;NullStatement();\012 if (var_context != kForStatement) {\012    init_block = factory()-&gt;NewBlock(1, true);\012 }\012\012 switch (peek()) {\012 case Token::VAR:\012      parsing_result-&gt;descriptor.mode = VariableMode::kVar;\012 Consume(Token::VAR);\012 break;\012 case Token::CONST:\012 Consume(Token::CONST);\012      DCHECK_NE(var_context, kStatement);\012      parsing_result-&gt;descriptor.mode = VariableMode::kConst;\012 break;\012 case Token::LET:\012 Consume(Token::LET);\012      DCHECK_NE(var_context, kStatement);\012      parsing_result-&gt;descriptor.mode = VariableMode::kLet;\012 break;\012 default:\012      UNREACHABLE(); // by current callers\012 break;\012 }\012\012  parsing_result-&gt;descriptor.scope = scope();\012\012 int bindings_start = peek_position();\012 do {\012 // Parse binding pattern.\012 FuncNameInferrer::State fni_state(fni_);\012\012 ExpressionT pattern = impl()-&gt;NullExpression();\012 int decl_pos = peek_position();\012 {\012 ExpressionClassifier pattern_classifier(this);\012      pattern = ParsePrimaryExpression(CHECK_OK_CUSTOM(NullStatement));\012\012 ValidateBindingPattern(CHECK_OK_CUSTOM(NullStatement));\012 if (IsLexicalVariableMode(parsing_result-&gt;descriptor.mode)) {\012 ValidateLetPattern(CHECK_OK_CUSTOM(NullStatement));\012 }\012 }\012\012 Scanner::Location variable_loc = scanner()-&gt;location();\012 bool single_name = impl()-&gt;IsIdentifier(pattern);\012\012 if (single_name) {\012      impl()-&gt;PushVariableName(impl()-&gt;AsIdentifier(pattern));\012 }\012\012 ExpressionT value = impl()-&gt;NullExpression();\012 int initializer_position = kNoSourcePosition;\012 int value_beg_position = kNoSourcePosition;\012 if (Check(Token::ASSIGN)) {\012      value_beg_position = peek_position();\012\012 ExpressionClassifier classifier(this);\012      value = ParseAssignmentExpression(var_context != kForStatement,\012                                        CHECK_OK_CUSTOM(NullStatement));\012 ValidateExpression(CHECK_OK_CUSTOM(NullStatement));\012      variable_loc.end_pos = scanner()-&gt;location().end_pos;\012\012 if (!parsing_result-&gt;first_initializer_loc.IsValid()) {\012        parsing_result-&gt;first_initializer_loc = variable_loc;\012 }\012\012 // Don't infer if it is &quot;a = function(){...}();&quot;-like expression.\012 if (single_name &amp;&amp; fni_ != nullptr) {\012 if (!value-&gt;IsCall() &amp;&amp; !value-&gt;IsCallNew()) {\012          fni_-&gt;Infer();\012 } else {\012          fni_-&gt;RemoveLastFunction();\012 }\012 }\012\012      impl()-&gt;SetFunctionNameFromIdentifierRef(value, pattern);\012\012 // End position of the initializer is after the assignment expression.\012      initializer_position = scanner()-&gt;location().end_pos;\012 } else {\012 if (var_context != kForStatement || !PeekInOrOf()) {\012 // ES6 'const' and binding patterns require initializers.\012 if (parsing_result-&gt;descriptor.mode == VariableMode::kConst ||\012 !impl()-&gt;IsIdentifier(pattern)) {\012          impl()-&gt;ReportMessageAt(\012 Scanner::Location(decl_pos, scanner()-&gt;location().end_pos),\012 MessageTemplate::kDeclarationMissingInitializer,\012 !impl()-&gt;IsIdentifier(pattern) ? &quot;destructuring&quot; : &quot;const&quot;);\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 }\012 // 'let x' initializes 'x' to undefined.\012 if (parsing_result-&gt;descriptor.mode == VariableMode::kLet) {\012          value = factory()-&gt;NewUndefinedLiteral(position());\012 }\012 }\012\012 // End position of the initializer is after the variable.\012      initializer_position = position();\012 }\012\012 typename DeclarationParsingResult::Declaration decl(\012        pattern, initializer_position, value);\012    decl.value_beg_position = value_beg_position;\012 if (var_context == kForStatement) {\012 // Save the declaration for further handling in ParseForStatement.\012      parsing_result-&gt;declarations.push_back(decl);\012 } else {\012 // Immediately declare the variable otherwise. This avoids O(N^2)\012 // behavior (where N is the number of variables in a single\012 // declaration) in the PatternRewriter having to do with removing\012 // and adding VariableProxies to the Scope (see bug 4699).\012      impl()-&gt;DeclareAndInitializeVariables(\012          init_block, &amp;parsing_result-&gt;descriptor, &amp;decl, names,\012          CHECK_OK_CUSTOM(NullStatement));\012 }\012 } while (Check(Token::COMMA));\012\012  parsing_result-&gt;bindings_loc =\012 Scanner::Location(bindings_start, scanner()-&gt;location().end_pos);\012\012  DCHECK(*ok);\012 return init_block;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT\012ParserBase&lt;Impl&gt;::ParseFunctionDeclaration(bool* ok) {\012 Consume(Token::FUNCTION);\012 int pos = position();\012 ParseFunctionFlags flags = ParseFunctionFlags::kIsNormal;\012 if (Check(Token::MUL)) {\012    impl()-&gt;ReportMessageAt(\012        scanner()-&gt;location(),\012 MessageTemplate::kGeneratorInSingleStatementContext);\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 }\012 return ParseHoistableDeclaration(pos, flags, nullptr, false, ok);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT\012ParserBase&lt;Impl&gt;::ParseHoistableDeclaration(\012 ZonePtrList&lt;const AstRawString&gt;* names, bool default_export, bool* ok) {\012 Expect(Token::FUNCTION, CHECK_OK_CUSTOM(NullStatement));\012 int pos = position();\012 ParseFunctionFlags flags = ParseFunctionFlags::kIsNormal;\012 if (Check(Token::MUL)) {\012    flags |= ParseFunctionFlags::kIsGenerator;\012 }\012 return ParseHoistableDeclaration(pos, flags, names, default_export, ok);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT\012ParserBase&lt;Impl&gt;::ParseHoistableDeclaration(\012 int pos, ParseFunctionFlags flags, ZonePtrList&lt;const AstRawString&gt;* names,\012 bool default_export, bool* ok) {\012 // FunctionDeclaration ::\012 //   'function' Identifier '(' FormalParameters ')' '{' FunctionBody '}'\012 //   'function' '(' FormalParameters ')' '{' FunctionBody '}'\012 // GeneratorDeclaration ::\012 //   'function' '*' Identifier '(' FormalParameters ')' '{' FunctionBody '}'\012 //   'function' '*' '(' FormalParameters ')' '{' FunctionBody '}'\012 //\012 // The anonymous forms are allowed iff [default_export] is true.\012 //\012 // 'function' and '*' (if present) have been consumed by the caller.\012\012 bool is_generator = flags &amp; ParseFunctionFlags::kIsGenerator;\012 const bool is_async = flags &amp; ParseFunctionFlags::kIsAsync;\012  DCHECK(!is_generator || !is_async);\012\012 if (is_async &amp;&amp; Check(Token::MUL)) {\012 // Async generator\012    is_generator = true;\012 }\012\012 IdentifierT name;\012 FunctionNameValidity name_validity;\012 IdentifierT variable_name;\012 if (default_export &amp;&amp; peek() == Token::LPAREN) {\012    impl()-&gt;GetDefaultStrings(&amp;name, &amp;variable_name);\012    name_validity = kSkipFunctionNameCheck;\012 } else {\012 bool is_strict_reserved;\012 bool is_await = false;\012    name = ParseIdentifierOrStrictReservedWord(&amp;is_strict_reserved, &amp;is_await,\012                                               CHECK_OK_CUSTOM(NullStatement));\012    name_validity = is_strict_reserved ? kFunctionNameIsStrictReserved\012 : kFunctionNameValidityUnknown;\012    variable_name = name;\012 }\012\012 FuncNameInferrer::State fni_state(fni_);\012  impl()-&gt;PushEnclosingName(name);\012\012 FunctionKind kind = FunctionKindFor(is_generator, is_async);\012\012 FunctionLiteralT function = impl()-&gt;ParseFunctionLiteral(\012      name, scanner()-&gt;location(), name_validity, kind, pos,\012 FunctionLiteral::kDeclaration, language_mode(), nullptr,\012      CHECK_OK_CUSTOM(NullStatement));\012\012 // In ES6, a function behaves as a lexical binding, except in\012 // a script scope, or the initial scope of eval or another function.\012 VariableMode mode =\012 (!scope()-&gt;is_declaration_scope() || scope()-&gt;is_module_scope())\012 ? VariableMode::kLet\012 : VariableMode::kVar;\012 // Async functions don't undergo sloppy mode block scoped hoisting, and don't\012 // allow duplicates in a block. Both are represented by the\012 // sloppy_block_function_map. Don't add them to the map for async functions.\012 // Generators are also supposed to be prohibited; currently doing this behind\012 // a flag and UseCounting violations to assess web compatibility.\012 bool is_sloppy_block_function = is_sloppy(language_mode()) &amp;&amp;\012 !scope()-&gt;is_declaration_scope() &amp;&amp;\012 !is_async &amp;&amp; !is_generator;\012\012 return impl()-&gt;DeclareFunction(variable_name, function, mode, pos,\012                                 is_sloppy_block_function, names, ok);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseClassDeclaration(\012 ZonePtrList&lt;const AstRawString&gt;* names, bool default_export, bool* ok) {\012 // ClassDeclaration ::\012 //   'class' Identifier ('extends' LeftHandExpression)? '{' ClassBody '}'\012 //   'class' ('extends' LeftHandExpression)? '{' ClassBody '}'\012 //\012 // The anonymous form is allowed iff [default_export] is true.\012 //\012 // 'class' is expected to be consumed by the caller.\012 //\012 // A ClassDeclaration\012 //\012 //   class C { ... }\012 //\012 // has the same semantics as:\012 //\012 //   let C = class C { ... };\012 //\012 // so rewrite it as such.\012\012 int class_token_pos = position();\012 IdentifierT name = impl()-&gt;NullIdentifier();\012 bool is_strict_reserved = false;\012 IdentifierT variable_name = impl()-&gt;NullIdentifier();\012 if (default_export &amp;&amp; (peek() == Token::EXTENDS || peek() == Token::LBRACE)) {\012    impl()-&gt;GetDefaultStrings(&amp;name, &amp;variable_name);\012 } else {\012 bool is_await = false;\012    name = ParseIdentifierOrStrictReservedWord(&amp;is_strict_reserved, &amp;is_await,\012                                               CHECK_OK_CUSTOM(NullStatement));\012    variable_name = name;\012 }\012\012 ExpressionClassifier no_classifier(this);\012 ExpressionT value =\012 ParseClassLiteral(name, scanner()-&gt;location(), is_strict_reserved,\012                        class_token_pos, CHECK_OK_CUSTOM(NullStatement));\012 int end_pos = position();\012 return impl()-&gt;DeclareClass(variable_name, value, names, class_token_pos,\012                              end_pos, ok);\012}\012\012// Language extension which is only enabled for source files loaded\012// through the API's extension mechanism.  A native function\012// declaration is resolved by looking up the function through a\012// callback provided by the extension.\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseNativeDeclaration(\012 bool* ok) {\012  function_state_-&gt;DisableOptimization(BailoutReason::kNativeFunctionLiteral);\012\012 int pos = peek_position();\012 Expect(Token::FUNCTION, CHECK_OK_CUSTOM(NullStatement));\012 // Allow &quot;eval&quot; or &quot;arguments&quot; for backward compatibility.\012 IdentifierT name = ParseIdentifier(kAllowRestrictedIdentifiers,\012                                     CHECK_OK_CUSTOM(NullStatement));\012 Expect(Token::LPAREN, CHECK_OK_CUSTOM(NullStatement));\012 if (peek() != Token::RPAREN) {\012 do {\012 ParseIdentifier(kAllowRestrictedIdentifiers,\012                      CHECK_OK_CUSTOM(NullStatement));\012 } while (Check(Token::COMMA));\012 }\012 Expect(Token::RPAREN, CHECK_OK_CUSTOM(NullStatement));\012 Expect(Token::SEMICOLON, CHECK_OK_CUSTOM(NullStatement));\012 return impl()-&gt;DeclareNative(name, pos, ok);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT\012ParserBase&lt;Impl&gt;::ParseAsyncFunctionDeclaration(\012 ZonePtrList&lt;const AstRawString&gt;* names, bool default_export, bool* ok) {\012 // AsyncFunctionDeclaration ::\012 //   async [no LineTerminator here] function BindingIdentifier[Await]\012 //       ( FormalParameters[Await] ) { AsyncFunctionBody }\012  DCHECK_EQ(scanner()-&gt;current_token(), Token::ASYNC);\012 int pos = position();\012 if (scanner()-&gt;HasLineTerminatorBeforeNext()) {\012 *ok = false;\012    impl()-&gt;ReportUnexpectedToken(scanner()-&gt;current_token());\012 return impl()-&gt;NullStatement();\012 }\012 Expect(Token::FUNCTION, CHECK_OK_CUSTOM(NullStatement));\012 ParseFunctionFlags flags = ParseFunctionFlags::kIsAsync;\012 return ParseHoistableDeclaration(pos, flags, names, default_export, ok);\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::ParseFunctionBody(\012 typename ParserBase&lt;Impl&gt;::StatementListT result, IdentifierT function_name,\012 int pos, const FormalParametersT&amp; parameters, FunctionKind kind,\012 FunctionLiteral::FunctionType function_type, bool* ok) {\012 DeclarationScope* function_scope = scope()-&gt;AsDeclarationScope();\012 DeclarationScope* inner_scope = function_scope;\012 BlockT inner_block = impl()-&gt;NullStatement();\012\012 StatementListT body = result;\012 if (!parameters.is_simple) {\012    inner_scope = NewVarblockScope();\012    inner_scope-&gt;set_start_position(scanner()-&gt;location().beg_pos);\012    inner_block = factory()-&gt;NewBlock(8, true);\012    inner_block-&gt;set_scope(inner_scope);\012    body = inner_block-&gt;statements();\012 }\012\012 // If we are parsing the source as if it is wrapped in a function, the source\012 // ends without a closing brace.\012 Token::Value closing_token =\012      function_type == FunctionLiteral::kWrapped ? Token::EOS : Token::RBRACE;\012\012 {\012 BlockState block_state(&amp;scope_, inner_scope);\012\012 if (IsResumableFunction(kind)) impl()-&gt;PrepareGeneratorVariables();\012\012 if (IsAsyncGeneratorFunction(kind)) {\012      impl()-&gt;ParseAndRewriteAsyncGeneratorFunctionBody(pos, kind, body, ok);\012 } else if (IsGeneratorFunction(kind)) {\012      impl()-&gt;ParseAndRewriteGeneratorFunctionBody(pos, kind, body, ok);\012 } else if (IsAsyncFunction(kind)) {\012 ParseAsyncFunctionBody(inner_scope, body, CHECK_OK_VOID);\012 } else {\012 ParseStatementList(body, closing_token, CHECK_OK_VOID);\012 }\012\012 if (IsDerivedConstructor(kind)) {\012      body-&gt;Add(factory()-&gt;NewReturnStatement(impl()-&gt;ThisExpression(),\012                                              kNoSourcePosition),\012                zone());\012 }\012 }\012\012 Expect(closing_token, CHECK_OK_VOID);\012  scope()-&gt;set_end_position(scanner()-&gt;location().end_pos);\012\012 if (!parameters.is_simple) {\012    DCHECK_NOT_NULL(inner_scope);\012    DCHECK_EQ(function_scope, scope());\012    DCHECK_EQ(function_scope, inner_scope-&gt;outer_scope());\012    impl()-&gt;SetLanguageMode(function_scope, inner_scope-&gt;language_mode());\012 BlockT init_block =\012        impl()-&gt;BuildParameterInitializationBlock(parameters, CHECK_OK_VOID);\012\012 if (is_sloppy(inner_scope-&gt;language_mode())) {\012      impl()-&gt;InsertSloppyBlockFunctionVarBindings(inner_scope);\012 }\012\012 // TODO(littledan): Merge the two rejection blocks into one\012 if (IsAsyncFunction(kind) &amp;&amp; !IsAsyncGeneratorFunction(kind)) {\012      init_block = impl()-&gt;BuildRejectPromiseOnException(init_block);\012 }\012\012    inner_scope-&gt;set_end_position(scanner()-&gt;location().end_pos);\012 if (inner_scope-&gt;FinalizeBlockScope() != nullptr) {\012      impl()-&gt;CheckConflictingVarDeclarations(inner_scope, CHECK_OK_VOID);\012      impl()-&gt;InsertShadowingVarBindingInitializers(inner_block);\012 } else {\012      inner_block-&gt;set_scope(nullptr);\012 }\012    inner_scope = nullptr;\012\012    result-&gt;Add(init_block, zone());\012    result-&gt;Add(inner_block, zone());\012 } else {\012    DCHECK_EQ(inner_scope, function_scope);\012 if (is_sloppy(function_scope-&gt;language_mode())) {\012      impl()-&gt;InsertSloppyBlockFunctionVarBindings(function_scope);\012 }\012 }\012\012 if (!IsArrowFunction(kind)) {\012 // Declare arguments after parsing the function since lexical 'arguments'\012 // masks the arguments object. Declare arguments before declaring the\012 // function var since the arguments object masks 'function arguments'.\012    function_scope-&gt;DeclareArguments(ast_value_factory());\012 }\012\012  impl()-&gt;DeclareFunctionNameVar(function_name, function_type, function_scope);\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::CheckArityRestrictions(int param_count,\012 FunctionKind function_kind,\012 bool has_rest,\012 int formals_start_pos,\012 int formals_end_pos, bool* ok) {\012 if (IsGetterFunction(function_kind)) {\012 if (param_count != 0) {\012      impl()-&gt;ReportMessageAt(\012 Scanner::Location(formals_start_pos, formals_end_pos),\012 MessageTemplate::kBadGetterArity);\012 *ok = false;\012 }\012 } else if (IsSetterFunction(function_kind)) {\012 if (param_count != 1) {\012      impl()-&gt;ReportMessageAt(\012 Scanner::Location(formals_start_pos, formals_end_pos),\012 MessageTemplate::kBadSetterArity);\012 *ok = false;\012 }\012 if (has_rest) {\012      impl()-&gt;ReportMessageAt(\012 Scanner::Location(formals_start_pos, formals_end_pos),\012 MessageTemplate::kBadSetterRestParameter);\012 *ok = false;\012 }\012 }\012}\012\012template &lt;typename Impl&gt;\012bool ParserBase&lt;Impl&gt;::IsNextLetKeyword() {\012  DCHECK(peek() == Token::LET);\012 Token::Value next_next = PeekAhead();\012 switch (next_next) {\012 case Token::LBRACE:\012 case Token::LBRACK:\012 case Token::IDENTIFIER:\012 case Token::STATIC:\012 case Token::LET: // `let let;` is disallowed by static semantics, but the\012 // token must be first interpreted as a keyword in order\012 // for those semantics to apply. This ensures that ASI is\012 // not honored when a LineTerminator separates the\012 // tokens.\012 case Token::YIELD:\012 case Token::AWAIT:\012 case Token::ASYNC:\012 return true;\012 case Token::FUTURE_STRICT_RESERVED_WORD:\012 return is_sloppy(language_mode());\012 default:\012 return false;\012 }\012}\012\012template &lt;typename Impl&gt;\012bool ParserBase&lt;Impl&gt;::IsTrivialExpression() {\012 Token::Value peek_token = peek();\012 if (peek_token == Token::SMI || peek_token == Token::NUMBER ||\012      peek_token == Token::BIGINT || peek_token == Token::NULL_LITERAL ||\012      peek_token == Token::TRUE_LITERAL || peek_token == Token::FALSE_LITERAL ||\012      peek_token == Token::STRING || peek_token == Token::IDENTIFIER ||\012      peek_token == Token::THIS) {\012 // PeekAhead() is expensive &amp; may not always be called, so we only call it\012 // after checking peek().\012 Token::Value peek_ahead = PeekAhead();\012 if (peek_ahead == Token::COMMA || peek_ahead == Token::RPAREN ||\012        peek_ahead == Token::SEMICOLON || peek_ahead == Token::RBRACK) {\012 return true;\012 }\012 }\012 return false;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT\012ParserBase&lt;Impl&gt;::ParseArrowFunctionLiteral(\012 bool accept_IN, const FormalParametersT&amp; formal_parameters,\012 int rewritable_length, bool* ok) {\012 const RuntimeCallCounterId counters[2][2] = {\012 {RuntimeCallCounterId::kParseBackgroundArrowFunctionLiteral,\012 RuntimeCallCounterId::kParseArrowFunctionLiteral},\012 {RuntimeCallCounterId::kPreParseBackgroundArrowFunctionLiteral,\012 RuntimeCallCounterId::kPreParseArrowFunctionLiteral}};\012 RuntimeCallTimerScope runtime_timer(\012      runtime_call_stats_,\012      counters[Impl::IsPreParser()][parsing_on_main_thread_]);\012 base::ElapsedTimer timer;\012 if (V8_UNLIKELY(FLAG_log_function_events)) timer.Start();\012\012 if (peek() == Token::ARROW &amp;&amp; scanner_-&gt;HasLineTerminatorBeforeNext()) {\012 // ASI inserts `;` after arrow parameters if a line terminator is found.\012 // `=&gt; ...` is never a valid expression, so report as syntax error.\012 // If next token is not `=&gt;`, it's a syntax error anyways.\012 ReportUnexpectedTokenAt(scanner_-&gt;peek_location(), Token::ARROW);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012\012 StatementListT body = impl()-&gt;NullStatementList();\012 int expected_property_count = -1;\012 int suspend_count = 0;\012 int function_literal_id = GetNextFunctionLiteralId();\012\012 FunctionKind kind = formal_parameters.scope-&gt;function_kind();\012 FunctionLiteral::EagerCompileHint eager_compile_hint =\012      default_eager_compile_hint_;\012 bool can_preparse = impl()-&gt;parse_lazily() &amp;&amp;\012                      eager_compile_hint == FunctionLiteral::kShouldLazyCompile;\012 // TODO(marja): consider lazy-parsing inner arrow functions too. is_this\012 // handling in Scope::ResolveVariable needs to change.\012 bool is_lazy_top_level_function =\012      can_preparse &amp;&amp; impl()-&gt;AllowsLazyParsingWithoutUnresolvedVariables();\012 bool has_braces = true;\012 ProducedPreParsedScopeData* produced_preparsed_scope_data = nullptr;\012 {\012 FunctionState function_state(&amp;function_state_, &amp;scope_,\012                                 formal_parameters.scope);\012\012 // Move any queued destructuring assignments which appeared\012 // in this function's parameter list into its own function_state.\012    function_state.AdoptDestructuringAssignmentsFromParentState(\012        rewritable_length);\012\012 Expect(Token::ARROW, CHECK_OK);\012\012 if (peek() == Token::LBRACE) {\012 // Multiple statement body\012      DCHECK_EQ(scope(), formal_parameters.scope);\012 if (is_lazy_top_level_function) {\012 // FIXME(marja): Arrow function parameters will be parsed even if the\012 // body is preparsed; move relevant parts of parameter handling to\012 // simulate consistent parameter handling.\012\012 // For arrow functions, we don't need to retrieve data about function\012 // parameters.\012 int dummy_num_parameters = -1;\012        DCHECK_NE(kind &amp; FunctionKind::kArrowFunction, 0);\012 LazyParsingResult result = impl()-&gt;SkipFunction(\012 nullptr, kind, FunctionLiteral::kAnonymousExpression,\012            formal_parameters.scope, &amp;dummy_num_parameters,\012 &amp;produced_preparsed_scope_data, false, false, CHECK_OK);\012        DCHECK_NE(result, kLazyParsingAborted);\012        DCHECK_NULL(produced_preparsed_scope_data);\012        USE(result);\012        formal_parameters.scope-&gt;ResetAfterPreparsing(ast_value_factory_,\012 false);\012 // Discard any queued destructuring assignments which appeared\012 // in this function's parameter list, and which were adopted\012 // into this function state, above.\012        function_state.RewindDestructuringAssignments(0);\012 } else {\012 Consume(Token::LBRACE);\012        body = impl()-&gt;NewStatementList(8);\012 ParseFunctionBody(body, impl()-&gt;NullIdentifier(), kNoSourcePosition,\012                          formal_parameters, kind,\012 FunctionLiteral::kAnonymousExpression, CHECK_OK);\012        expected_property_count = function_state.expected_property_count();\012 }\012 } else {\012 // Single-expression body\012      has_braces = false;\012 const bool is_async = IsAsyncFunction(kind);\012      body = impl()-&gt;NewStatementList(1);\012      impl()-&gt;AddParameterInitializationBlock(formal_parameters, body, is_async,\012                                              CHECK_OK);\012 ParseSingleExpressionFunctionBody(body, is_async, accept_IN, CHECK_OK);\012      expected_property_count = function_state.expected_property_count();\012 }\012\012    formal_parameters.scope-&gt;set_end_position(scanner()-&gt;location().end_pos);\012\012 // Arrow function formal parameters are parsed as StrictFormalParameterList,\012 // which is not the same as &quot;parameters of a strict function&quot;; it only means\012 // that duplicates are not allowed.  Of course, the arrow function may\012 // itself be strict as well.\012 const bool allow_duplicate_parameters = false;\012 ValidateFormalParameters(language_mode(), allow_duplicate_parameters,\012                             CHECK_OK);\012\012 // Validate strict mode.\012 if (is_strict(language_mode())) {\012 CheckStrictOctalLiteral(formal_parameters.scope-&gt;start_position(),\012                              scanner()-&gt;location().end_pos, CHECK_OK);\012 }\012    impl()-&gt;CheckConflictingVarDeclarations(formal_parameters.scope, CHECK_OK);\012\012    impl()-&gt;RewriteDestructuringAssignments();\012    suspend_count = function_state.suspend_count();\012 }\012\012 FunctionLiteralT function_literal = factory()-&gt;NewFunctionLiteral(\012      impl()-&gt;EmptyIdentifierString(), formal_parameters.scope, body,\012      expected_property_count, formal_parameters.num_parameters(),\012      formal_parameters.function_length,\012 FunctionLiteral::kNoDuplicateParameters,\012 FunctionLiteral::kAnonymousExpression, eager_compile_hint,\012      formal_parameters.scope-&gt;start_position(), has_braces,\012      function_literal_id, produced_preparsed_scope_data);\012\012  function_literal-&gt;set_suspend_count(suspend_count);\012  function_literal-&gt;set_function_token_position(\012      formal_parameters.scope-&gt;start_position());\012\012  impl()-&gt;AddFunctionForNameInference(function_literal);\012\012 if (V8_UNLIKELY((FLAG_log_function_events))) {\012 Scope* scope = formal_parameters.scope;\012 double ms = timer.Elapsed().InMillisecondsF();\012 const char* event_name =\012        is_lazy_top_level_function ? &quot;preparse-no-resolution&quot; : &quot;parse&quot;;\012 const char* name = &quot;arrow function&quot;;\012    logger_-&gt;FunctionEvent(event_name, script_id(), ms, scope-&gt;start_position(),\012                           scope-&gt;end_position(), name, strlen(name));\012 }\012\012 return function_literal;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParseClassLiteral(\012 IdentifierT name, Scanner::Location class_name_location,\012 bool name_is_strict_reserved, int class_token_pos, bool* ok) {\012 bool is_anonymous = impl()-&gt;IsNull(name);\012\012 // All parts of a ClassDeclaration and ClassExpression are strict code.\012 if (!is_anonymous) {\012 if (name_is_strict_reserved) {\012      impl()-&gt;ReportMessageAt(class_name_location,\012 MessageTemplate::kUnexpectedStrictReserved);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012 if (impl()-&gt;IsEvalOrArguments(name)) {\012      impl()-&gt;ReportMessageAt(class_name_location,\012 MessageTemplate::kStrictEvalArguments);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012 }\012\012 Scope* block_scope = NewScope(BLOCK_SCOPE);\012 BlockState block_state(&amp;scope_, block_scope);\012 RaiseLanguageMode(LanguageMode::kStrict);\012\012 ClassInfo class_info(this);\012  class_info.is_anonymous = is_anonymous;\012  impl()-&gt;DeclareClassVariable(name, &amp;class_info, class_token_pos, CHECK_OK);\012\012  scope()-&gt;set_start_position(scanner()-&gt;location().end_pos);\012 if (Check(Token::EXTENDS)) {\012 FuncNameInferrer::State fni_state(fni_);\012 ExpressionClassifier extends_classifier(this);\012    class_info.extends = ParseLeftHandSideExpression(CHECK_OK);\012 ValidateExpression(CHECK_OK);\012 AccumulateFormalParameterContainmentErrors();\012 }\012\012 ClassLiteralChecker checker(this);\012\012 Expect(Token::LBRACE, CHECK_OK);\012\012 const bool has_extends = !impl()-&gt;IsNull(class_info.extends);\012 while (peek() != Token::RBRACE) {\012 if (Check(Token::SEMICOLON)) continue;\012 FuncNameInferrer::State fni_state(fni_);\012 bool is_computed_name = false; // Classes do not care about computed\012 // property names here.\012 bool is_static;\012 ClassLiteralProperty::Kind property_kind;\012 ExpressionClassifier property_classifier(this);\012 IdentifierT property_name;\012 // If we haven't seen the constructor yet, it potentially is the next\012 // property.\012 bool is_constructor = !class_info.has_seen_constructor;\012 ClassLiteralPropertyT property = ParseClassPropertyDefinition(\012 &amp;checker, &amp;class_info, &amp;property_name, has_extends, &amp;is_computed_name,\012 &amp;property_kind, &amp;is_static, CHECK_OK);\012 if (!class_info.has_static_computed_names &amp;&amp; is_static &amp;&amp;\012        is_computed_name) {\012      class_info.has_static_computed_names = true;\012 }\012 if (is_computed_name &amp;&amp;\012        property_kind == ClassLiteralProperty::PUBLIC_FIELD) {\012      class_info.computed_field_count++;\012 }\012    is_constructor &amp;= class_info.has_seen_constructor;\012 ValidateExpression(CHECK_OK);\012 AccumulateFormalParameterContainmentErrors();\012\012    impl()-&gt;DeclareClassProperty(name, property, property_name, property_kind,\012                                 is_static, is_constructor, is_computed_name,\012 &amp;class_info, CHECK_OK);\012    impl()-&gt;InferFunctionName();\012 }\012\012 Expect(Token::RBRACE, CHECK_OK);\012 int end_pos = scanner()-&gt;location().end_pos;\012  block_scope-&gt;set_end_position(end_pos);\012 return impl()-&gt;RewriteClassLiteral(block_scope, name, &amp;class_info,\012                                     class_token_pos, end_pos, ok);\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::ParseSingleExpressionFunctionBody(StatementListT body,\012 bool is_async,\012 bool accept_IN,\012 bool* ok) {\012 if (is_async) impl()-&gt;PrepareGeneratorVariables();\012\012 ExpressionClassifier classifier(this);\012 ExpressionT expression = ParseAssignmentExpression(accept_IN, CHECK_OK_VOID);\012 ValidateExpression(CHECK_OK_VOID);\012\012 if (is_async) {\012 BlockT block = factory()-&gt;NewBlock(1, true);\012    impl()-&gt;RewriteAsyncFunctionBody(body, block, expression, CHECK_OK_VOID);\012 } else {\012    body-&gt;Add(BuildReturnStatement(expression, expression-&gt;position()), zone());\012 }\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::ParseAsyncFunctionBody(Scope* scope, StatementListT body,\012 bool* ok) {\012 BlockT block = factory()-&gt;NewBlock(8, true);\012\012 ParseStatementList(block-&gt;statements(), Token::RBRACE, CHECK_OK_VOID);\012  impl()-&gt;RewriteAsyncFunctionBody(\012      body, block, factory()-&gt;NewUndefinedLiteral(kNoSourcePosition),\012      CHECK_OK_VOID);\012  scope-&gt;set_end_position(scanner()-&gt;location().end_pos);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT\012ParserBase&lt;Impl&gt;::ParseAsyncFunctionLiteral(bool* ok) {\012 // AsyncFunctionLiteral ::\012 //   async [no LineTerminator here] function ( FormalParameters[Await] )\012 //       { AsyncFunctionBody }\012 //\012 //   async [no LineTerminator here] function BindingIdentifier[Await]\012 //       ( FormalParameters[Await] ) { AsyncFunctionBody }\012  DCHECK_EQ(scanner()-&gt;current_token(), Token::ASYNC);\012 int pos = position();\012 Expect(Token::FUNCTION, CHECK_OK);\012 bool is_strict_reserved = false;\012 IdentifierT name = impl()-&gt;NullIdentifier();\012 FunctionLiteral::FunctionType type = FunctionLiteral::kAnonymousExpression;\012\012 bool is_generator = Check(Token::MUL);\012 const bool kIsAsync = true;\012 const FunctionKind kind = FunctionKindFor(is_generator, kIsAsync);\012\012 if (impl()-&gt;ParsingDynamicFunctionDeclaration()) {\012 // We don't want dynamic functions to actually declare their name\012 // &quot;anonymous&quot;. We just want that name in the toString().\012 if (stack_overflow()) {\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012 Consume(Token::IDENTIFIER);\012    DCHECK(scanner()-&gt;CurrentMatchesContextual(Token::ANONYMOUS));\012 } else if (peek_any_identifier()) {\012    type = FunctionLiteral::kNamedExpression;\012 bool is_await = false;\012    name = ParseIdentifierOrStrictReservedWord(kind, &amp;is_strict_reserved,\012 &amp;is_await, CHECK_OK);\012 // If the function name is &quot;await&quot;, ParseIdentifierOrStrictReservedWord\012 // recognized the error.\012    DCHECK(!is_await);\012 }\012 return impl()-&gt;ParseFunctionLiteral(\012      name, scanner()-&gt;location(),\012      is_strict_reserved ? kFunctionNameIsStrictReserved\012 : kFunctionNameValidityUnknown,\012      kind, pos, type, language_mode(), nullptr, CHECK_OK);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParseTemplateLiteral(\012 ExpressionT tag, int start, bool tagged, bool* ok) {\012 // A TemplateLiteral is made up of 0 or more TEMPLATE_SPAN tokens (literal\012 // text followed by a substitution expression), finalized by a single\012 // TEMPLATE_TAIL.\012 //\012 // In terms of draft language, TEMPLATE_SPAN may be either the TemplateHead or\012 // TemplateMiddle productions, while TEMPLATE_TAIL is either TemplateTail, or\012 // NoSubstitutionTemplate.\012 //\012 // When parsing a TemplateLiteral, we must have scanned either an initial\012 // TEMPLATE_SPAN, or a TEMPLATE_TAIL.\012  DCHECK(peek() == Token::TEMPLATE_SPAN || peek() == Token::TEMPLATE_TAIL);\012\012 if (tagged) {\012 // TaggedTemplate expressions prevent the eval compilation cache from being\012 // used. This flag is only used if an eval is being parsed.\012    set_allow_eval_cache(false);\012 }\012\012 bool forbid_illegal_escapes = !tagged;\012\012 // If we reach a TEMPLATE_TAIL first, we are parsing a NoSubstitutionTemplate.\012 // In this case we may simply consume the token and build a template with a\012 // single TEMPLATE_SPAN and no expressions.\012 if (peek() == Token::TEMPLATE_TAIL) {\012 Consume(Token::TEMPLATE_TAIL);\012 int pos = position();\012 typename Impl::TemplateLiteralState ts = impl()-&gt;OpenTemplateLiteral(pos);\012 bool is_valid = CheckTemplateEscapes(forbid_illegal_escapes, CHECK_OK);\012    impl()-&gt;AddTemplateSpan(&amp;ts, is_valid, true);\012 return impl()-&gt;CloseTemplateLiteral(&amp;ts, start, tag);\012 }\012\012 Consume(Token::TEMPLATE_SPAN);\012 int pos = position();\012 typename Impl::TemplateLiteralState ts = impl()-&gt;OpenTemplateLiteral(pos);\012 bool is_valid = CheckTemplateEscapes(forbid_illegal_escapes, CHECK_OK);\012  impl()-&gt;AddTemplateSpan(&amp;ts, is_valid, false);\012 Token::Value next;\012\012 // If we open with a TEMPLATE_SPAN, we must scan the subsequent expression,\012 // and repeat if the following token is a TEMPLATE_SPAN as well (in this\012 // case, representing a TemplateMiddle).\012\012 do {\012 next = peek();\012 if (next == Token::EOS) {\012      impl()-&gt;ReportMessageAt(Scanner::Location(start, peek_position()),\012 MessageTemplate::kUnterminatedTemplate);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 } else if (next == Token::ILLEGAL) {\012      impl()-&gt;ReportMessageAt(\012 Scanner::Location(position() + 1, peek_position()),\012 MessageTemplate::kUnexpectedToken, &quot;ILLEGAL&quot;, kSyntaxError);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012\012 int expr_pos = peek_position();\012 ExpressionT expression = ParseExpressionCoverGrammar(true, CHECK_OK);\012 ValidateExpression(CHECK_OK);\012    impl()-&gt;AddTemplateExpression(&amp;ts, expression);\012\012 if (peek() != Token::RBRACE) {\012      impl()-&gt;ReportMessageAt(Scanner::Location(expr_pos, peek_position()),\012 MessageTemplate::kUnterminatedTemplateExpr);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012\012 // If we didn't die parsing that expression, our next token should be a\012 // TEMPLATE_SPAN or TEMPLATE_TAIL.\012 next = scanner()-&gt;ScanTemplateContinuation();\012 Next();\012    pos = position();\012\012 if (next == Token::EOS) {\012      impl()-&gt;ReportMessageAt(Scanner::Location(start, pos),\012 MessageTemplate::kUnterminatedTemplate);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 } else if (next == Token::ILLEGAL) {\012      impl()-&gt;ReportMessageAt(\012 Scanner::Location(position() + 1, peek_position()),\012 MessageTemplate::kUnexpectedToken, &quot;ILLEGAL&quot;, kSyntaxError);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012\012 bool is_valid = CheckTemplateEscapes(forbid_illegal_escapes, CHECK_OK);\012    impl()-&gt;AddTemplateSpan(&amp;ts, is_valid, next == Token::TEMPLATE_TAIL);\012 } while (next == Token::TEMPLATE_SPAN);\012\012  DCHECK_EQ(next, Token::TEMPLATE_TAIL);\012 // Once we've reached a TEMPLATE_TAIL, we can close the TemplateLiteral.\012 return impl()-&gt;CloseTemplateLiteral(&amp;ts, start, tag);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT\012ParserBase&lt;Impl&gt;::CheckAndRewriteReferenceExpression(\012 ExpressionT expression, int beg_pos, int end_pos,\012 MessageTemplate::Template message, bool* ok) {\012 return CheckAndRewriteReferenceExpression(expression, beg_pos, end_pos,\012                                            message, kReferenceError, ok);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT\012ParserBase&lt;Impl&gt;::CheckAndRewriteReferenceExpression(\012 ExpressionT expression, int beg_pos, int end_pos,\012 MessageTemplate::Template message, ParseErrorType type, bool* ok) {\012 if (impl()-&gt;IsIdentifier(expression) &amp;&amp; is_strict(language_mode()) &amp;&amp;\012      impl()-&gt;IsEvalOrArguments(impl()-&gt;AsIdentifier(expression))) {\012 ReportMessageAt(Scanner::Location(beg_pos, end_pos),\012 MessageTemplate::kStrictEvalArguments, kSyntaxError);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012 if (expression-&gt;IsValidReferenceExpression()) {\012 return expression;\012 }\012 if (expression-&gt;IsCall() &amp;&amp; !expression-&gt;AsCall()-&gt;is_tagged_template()) {\012 // If it is a call, make it a runtime error for legacy web compatibility.\012 // Bug: https://bugs.chromium.org/p/v8/issues/detail?id=4480\012 // Rewrite `expr' to `expr[throw ReferenceError]'.\012    impl()-&gt;CountUsage(\012        is_strict(language_mode())\012 ? v8::Isolate::kAssigmentExpressionLHSIsCallInStrict\012 : v8::Isolate::kAssigmentExpressionLHSIsCallInSloppy);\012 ExpressionT error = impl()-&gt;NewThrowReferenceError(message, beg_pos);\012 return factory()-&gt;NewProperty(expression, error, beg_pos);\012 }\012 ReportMessageAt(Scanner::Location(beg_pos, end_pos), message, type);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012}\012\012template &lt;typename Impl&gt;\012bool ParserBase&lt;Impl&gt;::IsValidReferenceExpression(ExpressionT expression) {\012 return IsAssignableIdentifier(expression) || expression-&gt;IsProperty();\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::CheckDestructuringElement(ExpressionT expression,\012 int begin, int end) {\012 if (!IsValidPattern(expression) &amp;&amp; !expression-&gt;IsAssignment() &amp;&amp;\012 !IsValidReferenceExpression(expression)) {\012    classifier()-&gt;RecordAssignmentPatternError(\012 Scanner::Location(begin, end),\012 MessageTemplate::kInvalidDestructuringTarget);\012 }\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParseV8Intrinsic(\012 bool* ok) {\012 // CallRuntime ::\012 //   '%' Identifier Arguments\012\012 int pos = peek_position();\012 Expect(Token::MOD, CHECK_OK);\012 // Allow &quot;eval&quot; or &quot;arguments&quot; for backward compatibility.\012 IdentifierT name = ParseIdentifier(kAllowRestrictedIdentifiers, CHECK_OK);\012 Scanner::Location spread_pos;\012 ExpressionClassifier classifier(this);\012 ExpressionListT args = ParseArguments(&amp;spread_pos, CHECK_OK);\012\012 if (spread_pos.IsValid()) {\012 *ok = false;\012 ReportMessageAt(spread_pos, MessageTemplate::kIntrinsicWithSpread,\012                    kSyntaxError);\012 return impl()-&gt;NullExpression();\012 }\012\012 return impl()-&gt;NewV8Intrinsic(name, args, pos, ok);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParseDoExpression(\012 bool* ok) {\012 // AssignmentExpression ::\012 //     do '{' StatementList '}'\012\012 int pos = peek_position();\012 Expect(Token::DO, CHECK_OK);\012 BlockT block = ParseBlock(nullptr, CHECK_OK);\012 return impl()-&gt;RewriteDoExpression(block, pos, ok);\012}\012\012// Redefinition of CHECK_OK for parsing statements.\012#undef CHECK_OK\012#define CHECK_OK CHECK_OK_CUSTOM(NullStatement)\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::LazyParsingResult\012ParserBase&lt;Impl&gt;::ParseStatementList(StatementListT body,\012 Token::Value end_token, bool may_abort,\012 bool* ok) {\012 // StatementList ::\012 //   (StatementListItem)* &lt;end_token&gt;\012\012 // Allocate a target stack to use for this set of source\012 // elements. This way, all scripts and functions get their own\012 // target stack thus avoiding illegal breaks and continues across\012 // functions.\012 typename Types::TargetScope target_scope(this);\012 int count_statements = 0;\012\012  DCHECK(!impl()-&gt;IsNull(body));\012 bool directive_prologue = true; // Parsing directive prologue.\012\012 while (peek() != end_token) {\012 if (directive_prologue &amp;&amp; peek() != Token::STRING) {\012      directive_prologue = false;\012 }\012\012 bool starts_with_identifier = peek() == Token::IDENTIFIER;\012 Scanner::Location token_loc = scanner()-&gt;peek_location();\012 StatementT stat =\012 ParseStatementListItem(CHECK_OK_CUSTOM(Return, kLazyParsingComplete));\012\012 if (impl()-&gt;IsNull(stat) || stat-&gt;IsEmptyStatement()) {\012      directive_prologue = false; // End of directive prologue.\012 continue;\012 }\012\012 if (directive_prologue) {\012 // The length of the token is used to distinguish between strings literals\012 // that evaluate equal to directives but contain either escape sequences\012 // (e.g., &quot;use \x73trict&quot;) or line continuations (e.g., &quot;use \(newline)\012 // strict&quot;).\012 if (impl()-&gt;IsUseStrictDirective(stat) &amp;&amp;\012          token_loc.end_pos - token_loc.beg_pos == sizeof(&quot;use strict&quot;) + 1) {\012 // Directive &quot;use strict&quot; (ES5 14.1).\012 RaiseLanguageMode(LanguageMode::kStrict);\012 if (!scope()-&gt;HasSimpleParameters()) {\012 // TC39 deemed &quot;use strict&quot; directives to be an error when occurring\012 // in the body of a function with non-simple parameter list, on\012 // 29/7/2015. https://goo.gl/ueA7Ln\012          impl()-&gt;ReportMessageAt(\012              token_loc, MessageTemplate::kIllegalLanguageModeDirective,\012 &quot;use strict&quot;);\012 *ok = false;\012 return kLazyParsingComplete;\012 }\012 } else if (impl()-&gt;IsUseAsmDirective(stat) &amp;&amp;\012                 token_loc.end_pos - token_loc.beg_pos ==\012 sizeof(&quot;use asm&quot;) + 1) {\012 // Directive &quot;use asm&quot;.\012        impl()-&gt;SetAsmModule();\012 } else if (impl()-&gt;IsStringLiteral(stat)) {\012 // Possibly an unknown directive.\012 // Should not change mode, but will increment usage counters\012 // as appropriate. Ditto usages below.\012 RaiseLanguageMode(LanguageMode::kSloppy);\012 } else {\012 // End of the directive prologue.\012        directive_prologue = false;\012 RaiseLanguageMode(LanguageMode::kSloppy);\012 }\012 } else {\012 RaiseLanguageMode(LanguageMode::kSloppy);\012 }\012\012 // If we're allowed to abort, we will do so when we see a &quot;long and\012 // trivial&quot; function. Our current definition of &quot;long and trivial&quot; is:\012 // - over kLazyParseTrialLimit statements\012 // - all starting with an identifier (i.e., no if, for, while, etc.)\012 if (may_abort) {\012 if (!starts_with_identifier) {\012        may_abort = false;\012 } else if (++count_statements &gt; kLazyParseTrialLimit) {\012 return kLazyParsingAborted;\012 }\012 }\012\012    body-&gt;Add(stat, zone());\012 }\012 return kLazyParsingComplete;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseStatementListItem(\012 bool* ok) {\012 // ECMA 262 6th Edition\012 // StatementListItem[Yield, Return] :\012 //   Statement[?Yield, ?Return]\012 //   Declaration[?Yield]\012 //\012 // Declaration[Yield] :\012 //   HoistableDeclaration[?Yield]\012 //   ClassDeclaration[?Yield]\012 //   LexicalDeclaration[In, ?Yield]\012 //\012 // HoistableDeclaration[Yield, Default] :\012 //   FunctionDeclaration[?Yield, ?Default]\012 //   GeneratorDeclaration[?Yield, ?Default]\012 //\012 // LexicalDeclaration[In, Yield] :\012 //   LetOrConst BindingList[?In, ?Yield] ;\012\012 switch (peek()) {\012 case Token::FUNCTION:\012 return ParseHoistableDeclaration(nullptr, false, ok);\012 case Token::CLASS:\012 Consume(Token::CLASS);\012 return ParseClassDeclaration(nullptr, false, ok);\012 case Token::VAR:\012 case Token::CONST:\012 return ParseVariableStatement(kStatementListItem, nullptr, ok);\012 case Token::LET:\012 if (IsNextLetKeyword()) {\012 return ParseVariableStatement(kStatementListItem, nullptr, ok);\012 }\012 break;\012 case Token::ASYNC:\012 if (PeekAhead() == Token::FUNCTION &amp;&amp;\012 !scanner()-&gt;HasLineTerminatorAfterNext()) {\012 Consume(Token::ASYNC);\012 return ParseAsyncFunctionDeclaration(nullptr, false, ok);\012 }\012 break;\012 default:\012 break;\012 }\012 return ParseStatement(nullptr, nullptr, kAllowLabelledFunctionStatement, ok);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseStatement(\012 ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels,\012 AllowLabelledFunctionStatement allow_function, bool* ok) {\012 // Statement ::\012 //   Block\012 //   VariableStatement\012 //   EmptyStatement\012 //   ExpressionStatement\012 //   IfStatement\012 //   IterationStatement\012 //   ContinueStatement\012 //   BreakStatement\012 //   ReturnStatement\012 //   WithStatement\012 //   LabelledStatement\012 //   SwitchStatement\012 //   ThrowStatement\012 //   TryStatement\012 //   DebuggerStatement\012\012 // {own_labels} is always a subset of {labels}.\012  DCHECK_IMPLIES(labels == nullptr, own_labels == nullptr);\012\012 // Note: Since labels can only be used by 'break' and 'continue'\012 // statements, which themselves are only valid within blocks,\012 // iterations or 'switch' statements (i.e., BreakableStatements),\012 // labels can be simply ignored in all other cases; except for\012 // trivial labeled break statements 'label: break label' which is\012 // parsed into an empty statement.\012 switch (peek()) {\012 case Token::LBRACE:\012 return ParseBlock(labels, ok);\012 case Token::SEMICOLON:\012 Next();\012 return factory()-&gt;NewEmptyStatement(kNoSourcePosition);\012 case Token::IF:\012 return ParseIfStatement(labels, ok);\012 case Token::DO:\012 return ParseDoWhileStatement(labels, own_labels, ok);\012 case Token::WHILE:\012 return ParseWhileStatement(labels, own_labels, ok);\012 case Token::FOR:\012 if (V8_UNLIKELY(is_async_function() &amp;&amp; PeekAhead() == Token::AWAIT)) {\012 return ParseForAwaitStatement(labels, own_labels, ok);\012 }\012 return ParseForStatement(labels, own_labels, ok);\012 case Token::CONTINUE:\012 return ParseContinueStatement(ok);\012 case Token::BREAK:\012 return ParseBreakStatement(labels, ok);\012 case Token::RETURN:\012 return ParseReturnStatement(ok);\012 case Token::THROW:\012 return ParseThrowStatement(ok);\012 case Token::TRY: {\012 // It is somewhat complicated to have labels on try-statements.\012 // When breaking out of a try-finally statement, one must take\012 // great care not to treat it as a fall-through. It is much easier\012 // just to wrap the entire try-statement in a statement block and\012 // put the labels there.\012 if (labels == nullptr) return ParseTryStatement(ok);\012 BlockT result = factory()-&gt;NewBlock(1, false, labels);\012 typename Types::Target target(this, result);\012 StatementT statement = ParseTryStatement(CHECK_OK);\012      result-&gt;statements()-&gt;Add(statement, zone());\012 return result;\012 }\012 case Token::WITH:\012 return ParseWithStatement(labels, ok);\012 case Token::SWITCH:\012 return ParseSwitchStatement(labels, ok);\012 case Token::FUNCTION:\012 // FunctionDeclaration only allowed as a StatementListItem, not in\012 // an arbitrary Statement position. Exceptions such as\012 // ES#sec-functiondeclarations-in-ifstatement-statement-clauses\012 // are handled by calling ParseScopedStatement rather than\012 // ParseStatement directly.\012      impl()-&gt;ReportMessageAt(scanner()-&gt;peek_location(),\012                              is_strict(language_mode())\012 ? MessageTemplate::kStrictFunction\012 : MessageTemplate::kSloppyFunction);\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 case Token::DEBUGGER:\012 return ParseDebuggerStatement(ok);\012 case Token::VAR:\012 return ParseVariableStatement(kStatement, nullptr, ok);\012 case Token::ASYNC:\012 if (!scanner()-&gt;HasLineTerminatorAfterNext() &amp;&amp;\012 PeekAhead() == Token::FUNCTION) {\012        impl()-&gt;ReportMessageAt(\012            scanner()-&gt;peek_location(),\012 MessageTemplate::kAsyncFunctionInSingleStatementContext);\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 }\012      V8_FALLTHROUGH;\012 default:\012 return ParseExpressionOrLabelledStatement(labels, own_labels,\012                                                allow_function, ok);\012 }\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::BlockT ParserBase&lt;Impl&gt;::ParseBlock(\012 ZonePtrList&lt;const AstRawString&gt;* labels, bool* ok) {\012 // Block ::\012 //   '{' StatementList '}'\012\012 // Construct block expecting 16 statements.\012 BlockT body = factory()-&gt;NewBlock(16, false, labels);\012\012 // Parse the statements and collect escaping labels.\012 Expect(Token::LBRACE, CHECK_OK_CUSTOM(NullStatement));\012 {\012 BlockState block_state(zone(), &amp;scope_);\012    scope()-&gt;set_start_position(scanner()-&gt;location().beg_pos);\012 typename Types::Target target(this, body);\012\012 while (peek() != Token::RBRACE) {\012 StatementT stat = ParseStatementListItem(CHECK_OK_CUSTOM(NullStatement));\012 if (!impl()-&gt;IsNull(stat) &amp;&amp; !stat-&gt;IsEmptyStatement()) {\012        body-&gt;statements()-&gt;Add(stat, zone());\012 }\012 }\012\012 Expect(Token::RBRACE, CHECK_OK_CUSTOM(NullStatement));\012 int end_pos = scanner()-&gt;location().end_pos;\012    scope()-&gt;set_end_position(end_pos);\012    impl()-&gt;RecordBlockSourceRange(body, end_pos);\012    body-&gt;set_scope(scope()-&gt;FinalizeBlockScope());\012 }\012 return body;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseScopedStatement(\012 ZonePtrList&lt;const AstRawString&gt;* labels, bool* ok) {\012 if (is_strict(language_mode()) || peek() != Token::FUNCTION) {\012 return ParseStatement(labels, nullptr, ok);\012 } else {\012 // Make a block around the statement for a lexical binding\012 // is introduced by a FunctionDeclaration.\012 BlockState block_state(zone(), &amp;scope_);\012    scope()-&gt;set_start_position(scanner()-&gt;location().beg_pos);\012 BlockT block = factory()-&gt;NewBlock(1, false);\012 StatementT body = ParseFunctionDeclaration(CHECK_OK);\012    block-&gt;statements()-&gt;Add(body, zone());\012    scope()-&gt;set_end_position(scanner()-&gt;location().end_pos);\012    block-&gt;set_scope(scope()-&gt;FinalizeBlockScope());\012 return block;\012 }\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseVariableStatement(\012 VariableDeclarationContext var_context,\012 ZonePtrList&lt;const AstRawString&gt;* names, bool* ok) {\012 // VariableStatement ::\012 //   VariableDeclarations ';'\012\012 // The scope of a var declared variable anywhere inside a function\012 // is the entire function (ECMA-262, 3rd, 10.1.3, and 12.2). Thus we can\012 // transform a source-level var declaration into a (Function) Scope\012 // declaration, and rewrite the source-level initialization into an assignment\012 // statement. We use a block to collect multiple assignments.\012 //\012 // We mark the block as initializer block because we don't want the\012 // rewriter to add a '.result' assignment to such a block (to get compliant\012 // behavior for code such as print(eval('var x = 7')), and for cosmetic\012 // reasons when pretty-printing. Also, unless an assignment (initialization)\012 // is inside an initializer block, it is ignored.\012\012 DeclarationParsingResult parsing_result;\012 StatementT result =\012 ParseVariableDeclarations(var_context, &amp;parsing_result, names, CHECK_OK);\012 ExpectSemicolon(CHECK_OK);\012 return result;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseDebuggerStatement(\012 bool* ok) {\012 // In ECMA-262 'debugger' is defined as a reserved keyword. In some browser\012 // contexts this is used as a statement which invokes the debugger as i a\012 // break point is present.\012 // DebuggerStatement ::\012 //   'debugger' ';'\012\012 int pos = peek_position();\012 Expect(Token::DEBUGGER, CHECK_OK);\012 ExpectSemicolon(CHECK_OK);\012 return factory()-&gt;NewDebuggerStatement(pos);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT\012ParserBase&lt;Impl&gt;::ParseExpressionOrLabelledStatement(\012 ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels,\012 AllowLabelledFunctionStatement allow_function, bool* ok) {\012 // ExpressionStatement | LabelledStatement ::\012 //   Expression ';'\012 //   Identifier ':' Statement\012 //\012 // ExpressionStatement[Yield] :\012 //   [lookahead notin {{, function, class, let [}] Expression[In, ?Yield] ;\012\012 int pos = peek_position();\012\012 switch (peek()) {\012 case Token::FUNCTION:\012 case Token::LBRACE:\012      UNREACHABLE(); // Always handled by the callers.\012 case Token::CLASS:\012 ReportUnexpectedToken(Next());\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 case Token::LET: {\012 Token::Value next_next = PeekAhead();\012 // &quot;let&quot; followed by either &quot;[&quot;, &quot;{&quot; or an identifier means a lexical\012 // declaration, which should not appear here.\012 // However, ASI may insert a line break before an identifier or a brace.\012 if (next_next != Token::LBRACK &amp;&amp;\012 ((next_next != Token::LBRACE &amp;&amp; next_next != Token::IDENTIFIER) ||\012           scanner_-&gt;HasLineTerminatorAfterNext())) {\012 break;\012 }\012      impl()-&gt;ReportMessageAt(scanner()-&gt;peek_location(),\012 MessageTemplate::kUnexpectedLexicalDeclaration);\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 }\012 default:\012 break;\012 }\012\012 bool starts_with_identifier = peek_any_identifier();\012 ExpressionT expr = ParseExpression(true, CHECK_OK);\012 if (peek() == Token::COLON &amp;&amp; starts_with_identifier &amp;&amp;\012      impl()-&gt;IsIdentifier(expr)) {\012 // The whole expression was a single identifier, and not, e.g.,\012 // something starting with an identifier or a parenthesized identifier.\012    impl()-&gt;DeclareLabel(&amp;labels, &amp;own_labels,\012                         impl()-&gt;AsIdentifierExpression(expr), CHECK_OK);\012 Consume(Token::COLON);\012 // ES#sec-labelled-function-declarations Labelled Function Declarations\012 if (peek() == Token::FUNCTION &amp;&amp; is_sloppy(language_mode()) &amp;&amp;\012        allow_function == kAllowLabelledFunctionStatement) {\012 return ParseFunctionDeclaration(ok);\012 }\012 return ParseStatement(labels, own_labels, allow_function, ok);\012 }\012\012 // If we have an extension, we allow a native function declaration.\012 // A native function declaration starts with &quot;native function&quot; with\012 // no line-terminator between the two words.\012 if (extension_ != nullptr &amp;&amp; peek() == Token::FUNCTION &amp;&amp;\012 !scanner()-&gt;HasLineTerminatorBeforeNext() &amp;&amp; impl()-&gt;IsNative(expr) &amp;&amp;\012 !scanner()-&gt;literal_contains_escapes()) {\012 return ParseNativeDeclaration(ok);\012 }\012\012 // Parsed expression statement, followed by semicolon.\012 ExpectSemicolon(CHECK_OK);\012 return factory()-&gt;NewExpressionStatement(expr, pos);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseIfStatement(\012 ZonePtrList&lt;const AstRawString&gt;* labels, bool* ok) {\012 // IfStatement ::\012 //   'if' '(' Expression ')' Statement ('else' Statement)?\012\012 int pos = peek_position();\012 Expect(Token::IF, CHECK_OK);\012 Expect(Token::LPAREN, CHECK_OK);\012 ExpressionT condition = ParseExpression(true, CHECK_OK);\012 Expect(Token::RPAREN, CHECK_OK);\012\012 SourceRange then_range, else_range;\012 StatementT then_statement = impl()-&gt;NullStatement();\012 {\012 SourceRangeScope range_scope(scanner(), &amp;then_range);\012    then_statement = ParseScopedStatement(labels, CHECK_OK);\012 }\012\012 StatementT else_statement = impl()-&gt;NullStatement();\012 if (Check(Token::ELSE)) {\012    else_range = SourceRange::ContinuationOf(then_range);\012    else_statement = ParseScopedStatement(labels, CHECK_OK);\012    else_range.end = scanner_-&gt;location().end_pos;\012 } else {\012    else_statement = factory()-&gt;NewEmptyStatement(kNoSourcePosition);\012 }\012 StatementT stmt =\012      factory()-&gt;NewIfStatement(condition, then_statement, else_statement, pos);\012  impl()-&gt;RecordIfStatementSourceRange(stmt, then_range, else_range);\012 return stmt;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseContinueStatement(\012 bool* ok) {\012 // ContinueStatement ::\012 //   'continue' Identifier? ';'\012\012 int pos = peek_position();\012 Expect(Token::CONTINUE, CHECK_OK);\012 IdentifierT label = impl()-&gt;NullIdentifier();\012 Token::Value tok = peek();\012 if (!scanner()-&gt;HasLineTerminatorBeforeNext() &amp;&amp; tok != Token::SEMICOLON &amp;&amp;\012      tok != Token::RBRACE &amp;&amp; tok != Token::EOS) {\012 // ECMA allows &quot;eval&quot; or &quot;arguments&quot; as labels even in strict mode.\012    label = ParseIdentifier(kAllowRestrictedIdentifiers, CHECK_OK);\012 }\012 typename Types::IterationStatement target =\012      impl()-&gt;LookupContinueTarget(label, CHECK_OK);\012 if (impl()-&gt;IsNull(target)) {\012 // Illegal continue statement.\012 MessageTemplate::Template message = MessageTemplate::kIllegalContinue;\012 typename Types::BreakableStatement breakable_target =\012        impl()-&gt;LookupBreakTarget(label, CHECK_OK);\012 if (impl()-&gt;IsNull(label)) {\012      message = MessageTemplate::kNoIterationStatement;\012 } else if (impl()-&gt;IsNull(breakable_target)) {\012      message = MessageTemplate::kUnknownLabel;\012 }\012 ReportMessage(message, label);\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 }\012 ExpectSemicolon(CHECK_OK);\012 StatementT stmt = factory()-&gt;NewContinueStatement(target, pos);\012  impl()-&gt;RecordJumpStatementSourceRange(stmt, scanner_-&gt;location().end_pos);\012 return stmt;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseBreakStatement(\012 ZonePtrList&lt;const AstRawString&gt;* labels, bool* ok) {\012 // BreakStatement ::\012 //   'break' Identifier? ';'\012\012 int pos = peek_position();\012 Expect(Token::BREAK, CHECK_OK);\012 IdentifierT label = impl()-&gt;NullIdentifier();\012 Token::Value tok = peek();\012 if (!scanner()-&gt;HasLineTerminatorBeforeNext() &amp;&amp; tok != Token::SEMICOLON &amp;&amp;\012      tok != Token::RBRACE &amp;&amp; tok != Token::EOS) {\012 // ECMA allows &quot;eval&quot; or &quot;arguments&quot; as labels even in strict mode.\012    label = ParseIdentifier(kAllowRestrictedIdentifiers, CHECK_OK);\012 }\012 // Parse labeled break statements that target themselves into\012 // empty statements, e.g. 'l1: l2: l3: break l2;'\012 if (!impl()-&gt;IsNull(label) &amp;&amp; impl()-&gt;ContainsLabel(labels, label)) {\012 ExpectSemicolon(CHECK_OK);\012 return factory()-&gt;NewEmptyStatement(pos);\012 }\012 typename Types::BreakableStatement target =\012      impl()-&gt;LookupBreakTarget(label, CHECK_OK);\012 if (impl()-&gt;IsNull(target)) {\012 // Illegal break statement.\012 MessageTemplate::Template message = MessageTemplate::kIllegalBreak;\012 if (!impl()-&gt;IsNull(label)) {\012      message = MessageTemplate::kUnknownLabel;\012 }\012 ReportMessage(message, label);\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 }\012 ExpectSemicolon(CHECK_OK);\012 StatementT stmt = factory()-&gt;NewBreakStatement(target, pos);\012  impl()-&gt;RecordJumpStatementSourceRange(stmt, scanner_-&gt;location().end_pos);\012 return stmt;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseReturnStatement(\012 bool* ok) {\012 // ReturnStatement ::\012 //   'return' [no line terminator] Expression? ';'\012\012 // Consume the return token. It is necessary to do that before\012 // reporting any errors on it, because of the way errors are\012 // reported (underlining).\012 Expect(Token::RETURN, CHECK_OK);\012 Scanner::Location loc = scanner()-&gt;location();\012\012 switch (GetDeclarationScope()-&gt;scope_type()) {\012 case SCRIPT_SCOPE:\012 case EVAL_SCOPE:\012 case MODULE_SCOPE:\012      impl()-&gt;ReportMessageAt(loc, MessageTemplate::kIllegalReturn);\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 default:\012 break;\012 }\012\012 Token::Value tok = peek();\012 ExpressionT return_value = impl()-&gt;NullExpression();\012 if (scanner()-&gt;HasLineTerminatorBeforeNext() || tok == Token::SEMICOLON ||\012      tok == Token::RBRACE || tok == Token::EOS) {\012 if (IsDerivedConstructor(function_state_-&gt;kind())) {\012      return_value = impl()-&gt;ThisExpression(loc.beg_pos);\012 }\012 } else {\012    return_value = ParseExpression(true, CHECK_OK);\012 }\012 ExpectSemicolon(CHECK_OK);\012  return_value = impl()-&gt;RewriteReturn(return_value, loc.beg_pos);\012 int continuation_pos = scanner_-&gt;location().end_pos;\012 StatementT stmt =\012 BuildReturnStatement(return_value, loc.beg_pos, continuation_pos);\012  impl()-&gt;RecordJumpStatementSourceRange(stmt, scanner_-&gt;location().end_pos);\012 return stmt;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseWithStatement(\012 ZonePtrList&lt;const AstRawString&gt;* labels, bool* ok) {\012 // WithStatement ::\012 //   'with' '(' Expression ')' Statement\012\012 Expect(Token::WITH, CHECK_OK);\012 int pos = position();\012\012 if (is_strict(language_mode())) {\012 ReportMessage(MessageTemplate::kStrictWith);\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 }\012\012 Expect(Token::LPAREN, CHECK_OK);\012 ExpressionT expr = ParseExpression(true, CHECK_OK);\012 Expect(Token::RPAREN, CHECK_OK);\012\012 Scope* with_scope = NewScope(WITH_SCOPE);\012 StatementT body = impl()-&gt;NullStatement();\012 {\012 BlockState block_state(&amp;scope_, with_scope);\012    with_scope-&gt;set_start_position(scanner()-&gt;peek_location().beg_pos);\012    body = ParseStatement(labels, nullptr, CHECK_OK);\012    with_scope-&gt;set_end_position(scanner()-&gt;location().end_pos);\012 }\012 return factory()-&gt;NewWithStatement(with_scope, expr, body, pos);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseDoWhileStatement(\012 ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels, bool* ok) {\012 // DoStatement ::\012 //   'do' Statement 'while' '(' Expression ')' ';'\012\012 auto loop =\012      factory()-&gt;NewDoWhileStatement(labels, own_labels, peek_position());\012 typename Types::Target target(this, loop);\012\012 SourceRange body_range;\012 StatementT body = impl()-&gt;NullStatement();\012\012 Expect(Token::DO, CHECK_OK);\012 {\012 SourceRangeScope range_scope(scanner(), &amp;body_range);\012    body = ParseStatement(nullptr, nullptr, CHECK_OK);\012 }\012 Expect(Token::WHILE, CHECK_OK);\012 Expect(Token::LPAREN, CHECK_OK);\012\012 ExpressionT cond = ParseExpression(true, CHECK_OK);\012 Expect(Token::RPAREN, CHECK_OK);\012\012 // Allow do-statements to be terminated with and without\012 // semi-colons. This allows code such as 'do;while(0)return' to\012 // parse, which would not be the case if we had used the\012 // ExpectSemicolon() functionality here.\012 Check(Token::SEMICOLON);\012\012  loop-&gt;Initialize(cond, body);\012  impl()-&gt;RecordIterationStatementSourceRange(loop, body_range);\012\012 return loop;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseWhileStatement(\012 ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels, bool* ok) {\012 // WhileStatement ::\012 //   'while' '(' Expression ')' Statement\012\012 auto loop = factory()-&gt;NewWhileStatement(labels, own_labels, peek_position());\012 typename Types::Target target(this, loop);\012\012 SourceRange body_range;\012 StatementT body = impl()-&gt;NullStatement();\012\012 Expect(Token::WHILE, CHECK_OK);\012 Expect(Token::LPAREN, CHECK_OK);\012 ExpressionT cond = ParseExpression(true, CHECK_OK);\012 Expect(Token::RPAREN, CHECK_OK);\012 {\012 SourceRangeScope range_scope(scanner(), &amp;body_range);\012    body = ParseStatement(nullptr, nullptr, CHECK_OK);\012 }\012\012  loop-&gt;Initialize(cond, body);\012  impl()-&gt;RecordIterationStatementSourceRange(loop, body_range);\012\012 return loop;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseThrowStatement(\012 bool* ok) {\012 // ThrowStatement ::\012 //   'throw' Expression ';'\012\012 Expect(Token::THROW, CHECK_OK);\012 int pos = position();\012 if (scanner()-&gt;HasLineTerminatorBeforeNext()) {\012 ReportMessage(MessageTemplate::kNewlineAfterThrow);\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 }\012 ExpressionT exception = ParseExpression(true, CHECK_OK);\012 ExpectSemicolon(CHECK_OK);\012\012 StatementT stmt = impl()-&gt;NewThrowStatement(exception, pos);\012  impl()-&gt;RecordThrowSourceRange(stmt, scanner_-&gt;location().end_pos);\012\012 return stmt;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseSwitchStatement(\012 ZonePtrList&lt;const AstRawString&gt;* labels, bool* ok) {\012 // SwitchStatement ::\012 //   'switch' '(' Expression ')' '{' CaseClause* '}'\012 // CaseClause ::\012 //   'case' Expression ':' StatementList\012 //   'default' ':' StatementList\012\012 int switch_pos = peek_position();\012\012 Expect(Token::SWITCH, CHECK_OK);\012 Expect(Token::LPAREN, CHECK_OK);\012 ExpressionT tag = ParseExpression(true, CHECK_OK);\012 Expect(Token::RPAREN, CHECK_OK);\012\012 auto switch_statement =\012      factory()-&gt;NewSwitchStatement(labels, tag, switch_pos);\012\012 {\012 BlockState cases_block_state(zone(), &amp;scope_);\012    scope()-&gt;set_start_position(switch_pos);\012    scope()-&gt;SetNonlinear();\012 typename Types::Target target(this, switch_statement);\012\012 bool default_seen = false;\012 Expect(Token::LBRACE, CHECK_OK);\012 while (peek() != Token::RBRACE) {\012 // An empty label indicates the default case.\012 ExpressionT label = impl()-&gt;NullExpression();\012 SourceRange clause_range;\012 SourceRangeScope range_scope(scanner(), &amp;clause_range);\012 if (Check(Token::CASE)) {\012        label = ParseExpression(true, CHECK_OK);\012 } else {\012 Expect(Token::DEFAULT, CHECK_OK);\012 if (default_seen) {\012 ReportMessage(MessageTemplate::kMultipleDefaultsInSwitch);\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 }\012        default_seen = true;\012 }\012 Expect(Token::COLON, CHECK_OK);\012 StatementListT statements = impl()-&gt;NewStatementList(5);\012 while (peek() != Token::CASE &amp;&amp; peek() != Token::DEFAULT &amp;&amp;\012             peek() != Token::RBRACE) {\012 StatementT stat = ParseStatementListItem(CHECK_OK);\012        statements-&gt;Add(stat, zone());\012 }\012 auto clause = factory()-&gt;NewCaseClause(label, statements);\012      impl()-&gt;RecordCaseClauseSourceRange(clause, range_scope.Finalize());\012      switch_statement-&gt;cases()-&gt;Add(clause, zone());\012 }\012 Expect(Token::RBRACE, CHECK_OK);\012\012 int end_position = scanner()-&gt;location().end_pos;\012    scope()-&gt;set_end_position(end_position);\012    impl()-&gt;RecordSwitchStatementSourceRange(switch_statement, end_position);\012 Scope* switch_scope = scope()-&gt;FinalizeBlockScope();\012 if (switch_scope != nullptr) {\012 return impl()-&gt;RewriteSwitchStatement(switch_statement, switch_scope);\012 }\012 return switch_statement;\012 }\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseTryStatement(\012 bool* ok) {\012 // TryStatement ::\012 //   'try' Block Catch\012 //   'try' Block Finally\012 //   'try' Block Catch Finally\012 //\012 // Catch ::\012 //   'catch' '(' Identifier ')' Block\012 //\012 // Finally ::\012 //   'finally' Block\012\012 Expect(Token::TRY, CHECK_OK);\012 int pos = position();\012\012 BlockT try_block = ParseBlock(nullptr, CHECK_OK);\012\012 CatchInfo catch_info(this);\012\012 if (peek() != Token::CATCH &amp;&amp; peek() != Token::FINALLY) {\012 ReportMessage(MessageTemplate::kNoCatchOrFinally);\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 }\012\012 SourceRange catch_range, finally_range;\012\012 BlockT catch_block = impl()-&gt;NullStatement();\012 {\012 SourceRangeScope catch_range_scope(scanner(), &amp;catch_range);\012 if (Check(Token::CATCH)) {\012 bool has_binding;\012      has_binding = Check(Token::LPAREN);\012\012 if (has_binding) {\012        catch_info.scope = NewScope(CATCH_SCOPE);\012        catch_info.scope-&gt;set_start_position(scanner()-&gt;location().beg_pos);\012\012 {\012 BlockState catch_block_state(&amp;scope_, catch_info.scope);\012\012          catch_block = factory()-&gt;NewBlock(16, false);\012\012 // Create a block scope to hold any lexical declarations created\012 // as part of destructuring the catch parameter.\012 {\012 BlockState catch_variable_block_state(zone(), &amp;scope_);\012            scope()-&gt;set_start_position(scanner()-&gt;location().beg_pos);\012\012 // This does not simply call ParsePrimaryExpression to avoid\012 // ExpressionFromIdentifier from being called in the first\012 // branch, which would introduce an unresolved symbol and mess\012 // with arrow function names.\012 if (peek_any_identifier()) {\012              catch_info.name =\012 ParseIdentifier(kDontAllowRestrictedIdentifiers, CHECK_OK);\012 } else {\012 ExpressionClassifier pattern_classifier(this);\012              catch_info.pattern = ParsePrimaryExpression(CHECK_OK);\012 ValidateBindingPattern(CHECK_OK);\012 }\012\012 Expect(Token::RPAREN, CHECK_OK);\012            impl()-&gt;RewriteCatchPattern(&amp;catch_info, CHECK_OK);\012 if (!impl()-&gt;IsNull(catch_info.init_block)) {\012              catch_block-&gt;statements()-&gt;Add(catch_info.init_block, zone());\012 }\012\012            catch_info.inner_block = ParseBlock(nullptr, CHECK_OK);\012            catch_block-&gt;statements()-&gt;Add(catch_info.inner_block, zone());\012            impl()-&gt;ValidateCatchBlock(catch_info, CHECK_OK);\012            scope()-&gt;set_end_position(scanner()-&gt;location().end_pos);\012            catch_block-&gt;set_scope(scope()-&gt;FinalizeBlockScope());\012 }\012 }\012\012        catch_info.scope-&gt;set_end_position(scanner()-&gt;location().end_pos);\012 } else {\012        catch_block = ParseBlock(nullptr, CHECK_OK);\012 }\012 }\012 }\012\012 BlockT finally_block = impl()-&gt;NullStatement();\012  DCHECK(peek() == Token::FINALLY || !impl()-&gt;IsNull(catch_block));\012 {\012 SourceRangeScope range_scope(scanner(), &amp;finally_range);\012 if (Check(Token::FINALLY)) {\012      finally_block = ParseBlock(nullptr, CHECK_OK);\012 }\012 }\012\012 return impl()-&gt;RewriteTryStatement(try_block, catch_block, catch_range,\012                                     finally_block, finally_range, catch_info,\012                                     pos);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseForStatement(\012 ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels, bool* ok) {\012 // Either a standard for loop\012 //   for (&lt;init&gt;; &lt;cond&gt;; &lt;next&gt;) { ... }\012 // or a for-each loop\012 //   for (&lt;each&gt; of|in &lt;iterable&gt;) { ... }\012 //\012 // We parse a declaration/expression after the 'for (' and then read the first\012 // expression/declaration before we know if this is a for or a for-each.\012\012 int stmt_pos = peek_position();\012 ForInfo for_info(this);\012\012 Expect(Token::FOR, CHECK_OK);\012 Expect(Token::LPAREN, CHECK_OK);\012\012 if (peek() == Token::CONST || (peek() == Token::LET &amp;&amp; IsNextLetKeyword())) {\012 // The initializer contains lexical declarations,\012 // so create an in-between scope.\012 BlockState for_state(zone(), &amp;scope_);\012    scope()-&gt;set_start_position(scanner()-&gt;location().beg_pos);\012\012 // Also record whether inner functions or evals are found inside\012 // this loop, as this information is used to simplify the desugaring\012 // if none are found.\012 typename FunctionState::FunctionOrEvalRecordingScope recording_scope(\012        function_state_);\012\012 // Create an inner block scope which will be the parent scope of scopes\012 // possibly created by ParseVariableDeclarations.\012 Scope* inner_block_scope = NewScope(BLOCK_SCOPE);\012 {\012 BlockState inner_state(&amp;scope_, inner_block_scope);\012 ParseVariableDeclarations(kForStatement, &amp;for_info.parsing_result,\012 nullptr, CHECK_OK);\012 }\012    DCHECK(IsLexicalVariableMode(for_info.parsing_result.descriptor.mode));\012    for_info.position = scanner()-&gt;location().beg_pos;\012\012 if (CheckInOrOf(&amp;for_info.mode)) {\012      scope()-&gt;set_is_hidden();\012 return ParseForEachStatementWithDeclarations(\012          stmt_pos, &amp;for_info, labels, own_labels, inner_block_scope, ok);\012 }\012\012 Expect(Token::SEMICOLON, CHECK_OK);\012\012 StatementT init = impl()-&gt;BuildInitializationBlock(\012 &amp;for_info.parsing_result, &amp;for_info.bound_names, CHECK_OK);\012\012 Scope* finalized = inner_block_scope-&gt;FinalizeBlockScope();\012 // No variable declarations will have been created in inner_block_scope.\012    DCHECK_NULL(finalized);\012    USE(finalized);\012 return ParseStandardForLoopWithLexicalDeclarations(\012        stmt_pos, init, &amp;for_info, labels, own_labels, ok);\012 }\012\012 StatementT init = impl()-&gt;NullStatement();\012 if (peek() == Token::VAR) {\012 ParseVariableDeclarations(kForStatement, &amp;for_info.parsing_result, nullptr,\012                              CHECK_OK);\012    DCHECK_EQ(for_info.parsing_result.descriptor.mode, VariableMode::kVar);\012    for_info.position = scanner()-&gt;location().beg_pos;\012\012 if (CheckInOrOf(&amp;for_info.mode)) {\012 return ParseForEachStatementWithDeclarations(stmt_pos, &amp;for_info, labels,\012                                                   own_labels, nullptr, ok);\012 }\012\012    init = impl()-&gt;BuildInitializationBlock(&amp;for_info.parsing_result, nullptr,\012                                            CHECK_OK);\012 } else if (peek() != Token::SEMICOLON) {\012 // The initializer does not contain declarations.\012 int lhs_beg_pos = peek_position();\012 ExpressionClassifier classifier(this);\012 ExpressionT expression = ParseExpressionCoverGrammar(false, CHECK_OK);\012 int lhs_end_pos = scanner()-&gt;location().end_pos;\012\012 bool is_for_each = CheckInOrOf(&amp;for_info.mode);\012 bool is_destructuring = is_for_each &amp;&amp; (expression-&gt;IsArrayLiteral() ||\012                                            expression-&gt;IsObjectLiteral());\012\012 if (is_destructuring) {\012 ValidateAssignmentPattern(CHECK_OK);\012 } else {\012 ValidateExpression(CHECK_OK);\012 }\012\012 if (is_for_each) {\012 return ParseForEachStatementWithoutDeclarations(\012          stmt_pos, expression, lhs_beg_pos, lhs_end_pos, &amp;for_info, labels,\012          own_labels, ok);\012 }\012 // Initializer is just an expression.\012    init = factory()-&gt;NewExpressionStatement(expression, lhs_beg_pos);\012 }\012\012 Expect(Token::SEMICOLON, CHECK_OK);\012\012 // Standard 'for' loop, we have parsed the initializer at this point.\012 ExpressionT cond = impl()-&gt;NullExpression();\012 StatementT next = impl()-&gt;NullStatement();\012 StatementT body = impl()-&gt;NullStatement();\012 ForStatementT loop = ParseStandardForLoop(stmt_pos, labels, own_labels, &amp;cond,\012 &amp;next, &amp;body, CHECK_OK);\012  loop-&gt;Initialize(init, cond, next, body);\012 return loop;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT\012ParserBase&lt;Impl&gt;::ParseForEachStatementWithDeclarations(\012 int stmt_pos, ForInfo* for_info, ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels, Scope* inner_block_scope,\012 bool* ok) {\012 // Just one declaration followed by in/of.\012 if (for_info-&gt;parsing_result.declarations.size() != 1) {\012    impl()-&gt;ReportMessageAt(for_info-&gt;parsing_result.bindings_loc,\012 MessageTemplate::kForInOfLoopMultiBindings,\012 ForEachStatement::VisitModeString(for_info-&gt;mode));\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 }\012 if (for_info-&gt;parsing_result.first_initializer_loc.IsValid() &amp;&amp;\012 (is_strict(language_mode()) ||\012       for_info-&gt;mode == ForEachStatement::ITERATE ||\012 IsLexicalVariableMode(for_info-&gt;parsing_result.descriptor.mode) ||\012 !impl()-&gt;IsIdentifier(\012           for_info-&gt;parsing_result.declarations[0].pattern))) {\012    impl()-&gt;ReportMessageAt(for_info-&gt;parsing_result.first_initializer_loc,\012 MessageTemplate::kForInOfLoopInitializer,\012 ForEachStatement::VisitModeString(for_info-&gt;mode));\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 }\012\012 // Reset the declaration_kind to ensure proper processing during declaration.\012  for_info-&gt;parsing_result.descriptor.declaration_kind =\012 DeclarationDescriptor::FOR_EACH;\012\012 BlockT init_block = impl()-&gt;RewriteForVarInLegacy(*for_info);\012\012 auto loop = factory()-&gt;NewForEachStatement(for_info-&gt;mode, labels, own_labels,\012                                             stmt_pos);\012 typename Types::Target target(this, loop);\012\012 ExpressionT enumerable = impl()-&gt;NullExpression();\012 if (for_info-&gt;mode == ForEachStatement::ITERATE) {\012 ExpressionClassifier classifier(this);\012    enumerable = ParseAssignmentExpression(true, CHECK_OK);\012 ValidateExpression(CHECK_OK);\012 } else {\012    enumerable = ParseExpression(true, CHECK_OK);\012 }\012\012 Expect(Token::RPAREN, CHECK_OK);\012\012 Scope* for_scope = nullptr;\012 if (inner_block_scope != nullptr) {\012    for_scope = inner_block_scope-&gt;outer_scope();\012    DCHECK(for_scope == scope());\012    inner_block_scope-&gt;set_start_position(scanner()-&gt;location().beg_pos);\012 }\012\012 ExpressionT each_variable = impl()-&gt;NullExpression();\012 BlockT body_block = impl()-&gt;NullStatement();\012 {\012 BlockState block_state(\012 &amp;scope_, inner_block_scope != nullptr ? inner_block_scope : scope_);\012\012 SourceRange body_range;\012 SourceRangeScope range_scope(scanner(), &amp;body_range);\012\012 StatementT body = ParseStatement(nullptr, nullptr, CHECK_OK);\012    impl()-&gt;RecordIterationStatementSourceRange(loop, range_scope.Finalize());\012\012    impl()-&gt;DesugarBindingInForEachStatement(for_info, &amp;body_block,\012 &amp;each_variable, CHECK_OK);\012    body_block-&gt;statements()-&gt;Add(body, zone());\012\012 if (inner_block_scope != nullptr) {\012      inner_block_scope-&gt;set_end_position(scanner()-&gt;location().end_pos);\012      body_block-&gt;set_scope(inner_block_scope-&gt;FinalizeBlockScope());\012 }\012 }\012\012 StatementT final_loop = impl()-&gt;InitializeForEachStatement(\012      loop, each_variable, enumerable, body_block);\012\012  init_block = impl()-&gt;CreateForEachStatementTDZ(init_block, *for_info, ok);\012\012 if (for_scope != nullptr) {\012    for_scope-&gt;set_end_position(scanner()-&gt;location().end_pos);\012    for_scope = for_scope-&gt;FinalizeBlockScope();\012 }\012\012 // Parsed for-in loop w/ variable declarations.\012 if (!impl()-&gt;IsNull(init_block)) {\012    init_block-&gt;statements()-&gt;Add(final_loop, zone());\012    init_block-&gt;set_scope(for_scope);\012 return init_block;\012 }\012\012  DCHECK_NULL(for_scope);\012 return final_loop;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT\012ParserBase&lt;Impl&gt;::ParseForEachStatementWithoutDeclarations(\012 int stmt_pos, ExpressionT expression, int lhs_beg_pos, int lhs_end_pos,\012 ForInfo* for_info, ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels, bool* ok) {\012 // Initializer is reference followed by in/of.\012 if (!expression-&gt;IsArrayLiteral() &amp;&amp; !expression-&gt;IsObjectLiteral()) {\012    expression = CheckAndRewriteReferenceExpression(\012        expression, lhs_beg_pos, lhs_end_pos, MessageTemplate::kInvalidLhsInFor,\012        kSyntaxError, CHECK_OK);\012 }\012\012 auto loop = factory()-&gt;NewForEachStatement(for_info-&gt;mode, labels, own_labels,\012                                             stmt_pos);\012 typename Types::Target target(this, loop);\012\012 ExpressionT enumerable = impl()-&gt;NullExpression();\012 if (for_info-&gt;mode == ForEachStatement::ITERATE) {\012 ExpressionClassifier classifier(this);\012    enumerable = ParseAssignmentExpression(true, CHECK_OK);\012 ValidateExpression(CHECK_OK);\012 } else {\012    enumerable = ParseExpression(true, CHECK_OK);\012 }\012\012 Expect(Token::RPAREN, CHECK_OK);\012\012 StatementT body = impl()-&gt;NullStatement();\012 {\012 SourceRange body_range;\012 SourceRangeScope range_scope(scanner(), &amp;body_range);\012\012    body = ParseStatement(nullptr, nullptr, CHECK_OK);\012    impl()-&gt;RecordIterationStatementSourceRange(loop, range_scope.Finalize());\012 }\012 return impl()-&gt;InitializeForEachStatement(loop, expression, enumerable, body);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT\012ParserBase&lt;Impl&gt;::ParseStandardForLoopWithLexicalDeclarations(\012 int stmt_pos, StatementT init, ForInfo* for_info,\012 ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels, bool* ok) {\012 // The condition and the next statement of the for loop must be parsed\012 // in a new scope.\012 Scope* inner_scope = NewScope(BLOCK_SCOPE);\012 ForStatementT loop = impl()-&gt;NullStatement();\012 ExpressionT cond = impl()-&gt;NullExpression();\012 StatementT next = impl()-&gt;NullStatement();\012 StatementT body = impl()-&gt;NullStatement();\012 {\012 BlockState block_state(&amp;scope_, inner_scope);\012    scope()-&gt;set_start_position(scanner()-&gt;location().beg_pos);\012    loop = ParseStandardForLoop(stmt_pos, labels, own_labels, &amp;cond, &amp;next,\012 &amp;body, CHECK_OK);\012    scope()-&gt;set_end_position(scanner()-&gt;location().end_pos);\012 }\012\012  scope()-&gt;set_end_position(scanner()-&gt;location().end_pos);\012 if (for_info-&gt;bound_names.length() &gt; 0 &amp;&amp;\012      function_state_-&gt;contains_function_or_eval()) {\012    scope()-&gt;set_is_hidden();\012 return impl()-&gt;DesugarLexicalBindingsInForStatement(\012        loop, init, cond, next, body, inner_scope, *for_info, ok);\012 } else {\012    inner_scope = inner_scope-&gt;FinalizeBlockScope();\012    DCHECK_NULL(inner_scope);\012    USE(inner_scope);\012 }\012\012 Scope* for_scope = scope()-&gt;FinalizeBlockScope();\012 if (for_scope != nullptr) {\012 // Rewrite a for statement of the form\012 //   for (const x = i; c; n) b\012 //\012 // into\012 //\012 //   {\012 //     const x = i;\012 //     for (; c; n) b\012 //   }\012 //\012    DCHECK(!impl()-&gt;IsNull(init));\012 BlockT block = factory()-&gt;NewBlock(2, false);\012    block-&gt;statements()-&gt;Add(init, zone());\012    block-&gt;statements()-&gt;Add(loop, zone());\012    block-&gt;set_scope(for_scope);\012    loop-&gt;Initialize(impl()-&gt;NullStatement(), cond, next, body);\012 return block;\012 }\012\012  loop-&gt;Initialize(init, cond, next, body);\012 return loop;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ForStatementT ParserBase&lt;Impl&gt;::ParseStandardForLoop(\012 int stmt_pos, ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels, ExpressionT* cond,\012 StatementT* next, StatementT* body, bool* ok) {\012 ForStatementT loop = factory()-&gt;NewForStatement(labels, own_labels, stmt_pos);\012 typename Types::Target target(this, loop);\012\012 if (peek() != Token::SEMICOLON) {\012 *cond = ParseExpression(true, CHECK_OK);\012 }\012 Expect(Token::SEMICOLON, CHECK_OK);\012\012 if (peek() != Token::RPAREN) {\012 ExpressionT exp = ParseExpression(true, CHECK_OK);\012 *next = factory()-&gt;NewExpressionStatement(exp, exp-&gt;position());\012 }\012 Expect(Token::RPAREN, CHECK_OK);\012\012 SourceRange body_range;\012 {\012 SourceRangeScope range_scope(scanner(), &amp;body_range);\012 *body = ParseStatement(nullptr, nullptr, CHECK_OK);\012 }\012  impl()-&gt;RecordIterationStatementSourceRange(loop, body_range);\012\012 return loop;\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::MarkLoopVariableAsAssigned(\012 Scope* scope, Variable* var,\012 typename DeclarationDescriptor::Kind declaration_kind) {\012 if (!IsLexicalVariableMode(var-&gt;mode()) &amp;&amp;\012 (!scope-&gt;is_function_scope() ||\012       declaration_kind == DeclarationDescriptor::FOR_EACH)) {\012 var-&gt;set_maybe_assigned();\012 }\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseForAwaitStatement(\012 ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels, bool* ok) {\012 // for await '(' ForDeclaration of AssignmentExpression ')'\012  DCHECK(is_async_function());\012\012 int stmt_pos = peek_position();\012\012 ForInfo for_info(this);\012  for_info.mode = ForEachStatement::ITERATE;\012\012 // Create an in-between scope for let-bound iteration variables.\012 BlockState for_state(zone(), &amp;scope_);\012 Expect(Token::FOR, CHECK_OK);\012 Expect(Token::AWAIT, CHECK_OK);\012 Expect(Token::LPAREN, CHECK_OK);\012  scope()-&gt;set_start_position(scanner()-&gt;location().beg_pos);\012  scope()-&gt;set_is_hidden();\012\012 auto loop = factory()-&gt;NewForOfStatement(labels, own_labels, stmt_pos);\012 typename Types::Target target(this, loop);\012\012 ExpressionT each_variable = impl()-&gt;NullExpression();\012\012 bool has_declarations = false;\012 Scope* inner_block_scope = NewScope(BLOCK_SCOPE);\012\012 if (peek() == Token::VAR || peek() == Token::CONST ||\012 (peek() == Token::LET &amp;&amp; IsNextLetKeyword())) {\012 // The initializer contains declarations\012 // 'for' 'await' '(' ForDeclaration 'of' AssignmentExpression ')'\012 //     Statement\012 // 'for' 'await' '(' 'var' ForBinding 'of' AssignmentExpression ')'\012 //     Statement\012    has_declarations = true;\012\012 {\012 BlockState inner_state(&amp;scope_, inner_block_scope);\012 ParseVariableDeclarations(kForStatement, &amp;for_info.parsing_result,\012 nullptr, CHECK_OK);\012 }\012    for_info.position = scanner()-&gt;location().beg_pos;\012\012 // Only a single declaration is allowed in for-await-of loops\012 if (for_info.parsing_result.declarations.size() != 1) {\012      impl()-&gt;ReportMessageAt(for_info.parsing_result.bindings_loc,\012 MessageTemplate::kForInOfLoopMultiBindings,\012 &quot;for-await-of&quot;);\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 }\012\012 // for-await-of's declarations do not permit initializers.\012 if (for_info.parsing_result.first_initializer_loc.IsValid()) {\012      impl()-&gt;ReportMessageAt(for_info.parsing_result.first_initializer_loc,\012 MessageTemplate::kForInOfLoopInitializer,\012 &quot;for-await-of&quot;);\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 }\012 } else {\012 // The initializer does not contain declarations.\012 // 'for' 'await' '(' LeftHandSideExpression 'of' AssignmentExpression ')'\012 //     Statement\012 int lhs_beg_pos = peek_position();\012 BlockState inner_state(&amp;scope_, inner_block_scope);\012 ExpressionClassifier classifier(this);\012 ExpressionT lhs = each_variable = ParseLeftHandSideExpression(CHECK_OK);\012 int lhs_end_pos = scanner()-&gt;location().end_pos;\012\012 if (lhs-&gt;IsArrayLiteral() || lhs-&gt;IsObjectLiteral()) {\012 ValidateAssignmentPattern(CHECK_OK);\012 } else {\012 ValidateExpression(CHECK_OK);\012      each_variable = CheckAndRewriteReferenceExpression(\012          lhs, lhs_beg_pos, lhs_end_pos, MessageTemplate::kInvalidLhsInFor,\012          kSyntaxError, CHECK_OK);\012 }\012 }\012\012 ExpectContextualKeyword(Token::OF, CHECK_OK);\012 int each_keyword_pos = scanner()-&gt;location().beg_pos;\012\012 const bool kAllowIn = true;\012 ExpressionT iterable = impl()-&gt;NullExpression();\012\012 {\012 ExpressionClassifier classifier(this);\012    iterable = ParseAssignmentExpression(kAllowIn, CHECK_OK);\012 ValidateExpression(CHECK_OK);\012 }\012\012 Expect(Token::RPAREN, CHECK_OK);\012\012 StatementT body = impl()-&gt;NullStatement();\012 {\012 BlockState block_state(&amp;scope_, inner_block_scope);\012    scope()-&gt;set_start_position(scanner()-&gt;location().beg_pos);\012\012 SourceRange body_range;\012 SourceRangeScope range_scope(scanner(), &amp;body_range);\012\012    body = ParseStatement(nullptr, nullptr, CHECK_OK);\012    scope()-&gt;set_end_position(scanner()-&gt;location().end_pos);\012    impl()-&gt;RecordIterationStatementSourceRange(loop, range_scope.Finalize());\012\012 if (has_declarations) {\012 BlockT body_block = impl()-&gt;NullStatement();\012      impl()-&gt;DesugarBindingInForEachStatement(&amp;for_info, &amp;body_block,\012 &amp;each_variable, CHECK_OK);\012      body_block-&gt;statements()-&gt;Add(body, zone());\012      body_block-&gt;set_scope(scope()-&gt;FinalizeBlockScope());\012      body = body_block;\012 } else {\012 Scope* block_scope = scope()-&gt;FinalizeBlockScope();\012      DCHECK_NULL(block_scope);\012      USE(block_scope);\012 }\012 }\012 const bool finalize = true;\012 StatementT final_loop = impl()-&gt;InitializeForOfStatement(\012      loop, each_variable, iterable, body, finalize, IteratorType::kAsync,\012      each_keyword_pos);\012\012 if (!has_declarations) {\012 Scope* for_scope = scope()-&gt;FinalizeBlockScope();\012    DCHECK_NULL(for_scope);\012    USE(for_scope);\012 return final_loop;\012 }\012\012 BlockT init_block =\012      impl()-&gt;CreateForEachStatementTDZ(impl()-&gt;NullStatement(), for_info, ok);\012\012  scope()-&gt;set_end_position(scanner()-&gt;location().end_pos);\012 Scope* for_scope = scope()-&gt;FinalizeBlockScope();\012 // Parsed for-in loop w/ variable declarations.\012 if (!impl()-&gt;IsNull(init_block)) {\012    init_block-&gt;statements()-&gt;Add(final_loop, zone());\012    init_block-&gt;set_scope(for_scope);\012 return init_block;\012 }\012  DCHECK_NULL(for_scope);\012 return final_loop;\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::ObjectLiteralChecker::CheckDuplicateProto(\012 Token::Value property) {\012 if (property == Token::SMI || property == Token::NUMBER) return;\012\012 if (IsProto()) {\012 if (has_seen_proto_) {\012 this-&gt;parser()-&gt;classifier()-&gt;RecordExpressionError(\012 this-&gt;scanner()-&gt;location(), MessageTemplate::kDuplicateProto);\012 return;\012 }\012    has_seen_proto_ = true;\012 }\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::ClassLiteralChecker::CheckClassMethodName(\012 Token::Value property, PropertyKind type, bool is_generator, bool is_async,\012 bool is_static, bool* ok) {\012  DCHECK(type == PropertyKind::kMethodProperty ||\012         type == PropertyKind::kAccessorProperty);\012\012 if (property == Token::SMI || property == Token::NUMBER) return;\012\012 if (is_static) {\012 if (IsPrototype()) {\012 this-&gt;parser()-&gt;ReportMessage(MessageTemplate::kStaticPrototype);\012 *ok = false;\012 return;\012 }\012 } else if (IsConstructor()) {\012 if (is_generator || is_async || type == PropertyKind::kAccessorProperty) {\012 MessageTemplate::Template msg =\012          is_generator ? MessageTemplate::kConstructorIsGenerator\012 : is_async ? MessageTemplate::kConstructorIsAsync\012 : MessageTemplate::kConstructorIsAccessor;\012 this-&gt;parser()-&gt;ReportMessage(msg);\012 *ok = false;\012 return;\012 }\012 if (has_seen_constructor_) {\012 this-&gt;parser()-&gt;ReportMessage(MessageTemplate::kDuplicateConstructor);\012 *ok = false;\012 return;\012 }\012    has_seen_constructor_ = true;\012 return;\012 }\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::ClassLiteralChecker::CheckClassFieldName(bool is_static,\012 bool* ok) {\012 if (is_static &amp;&amp; IsPrototype()) {\012 this-&gt;parser()-&gt;ReportMessage(MessageTemplate::kStaticPrototype);\012 *ok = false;\012 return;\012 }\012\012 if (IsConstructor() || IsPrivateConstructor()) {\012 this-&gt;parser()-&gt;ReportMessage(MessageTemplate::kConstructorClassField);\012 *ok = false;\012 return;\012 }\012}\012\012#undef CHECK_OK\012#undef CHECK_OK_CUSTOM\012#undef CHECK_OK_VOID\012\012} // namespace internal\012})<SUB>26</SUB>> ]
+"14" [label = <(UNKNOWN,namespace v8 {\012namespace internal {\012\012enum FunctionNameValidity {\012  kFunctionNameIsStrictReserved,\012  kSkipFunctionNameCheck,\012  kFunctionNameValidityUnknown\012};\012\012enum AllowLabelledFunctionStatement {\012  kAllowLabelledFunctionStatement,\012  kDisallowLabelledFunctionStatement,\012};\012\012enum class ParseFunctionFlags {\012  kIsNormal = 0,\012  kIsGenerator = 1,\012  kIsAsync = 2,\012  kIsDefault = 4\012};\012\012static inline ParseFunctionFlags operator|(ParseFunctionFlags lhs,\012 ParseFunctionFlags rhs) {\012 typedef unsigned char T;\012 return static_cast&lt;ParseFunctionFlags&gt;(static_cast&lt;T&gt;(lhs) |\012 static_cast&lt;T&gt;(rhs));\012}\012\012static inline ParseFunctionFlags&amp; operator|=(ParseFunctionFlags&amp; lhs,\012 const ParseFunctionFlags&amp; rhs) {\012  lhs = lhs | rhs;\012 return lhs;\012}\012\012static inline bool operator&amp;(ParseFunctionFlags bitfield,\012 ParseFunctionFlags mask) {\012 typedef unsigned char T;\012 return static_cast&lt;T&gt;(bitfield) &amp; static_cast&lt;T&gt;(mask);\012}\012\012struct FormalParametersBase {\012 explicit FormalParametersBase(DeclarationScope* scope) : scope(scope) {}\012\012 int num_parameters() const {\012 // Don't include the rest parameter into the function's formal parameter\012 // count (esp. the SharedFunctionInfo::internal_formal_parameter_count,\012 // which says whether we need to create an arguments adaptor frame).\012 return arity - has_rest;\012 }\012\012 void UpdateArityAndFunctionLength(bool is_optional, bool is_rest) {\012 if (!is_optional &amp;&amp; !is_rest &amp;&amp; function_length == arity) {\012 ++function_length;\012 }\012 ++arity;\012 }\012\012 DeclarationScope* scope;\012 bool has_rest = false;\012 bool is_simple = true;\012 int function_length = 0;\012 int arity = 0;\012};\012\012// Stack-allocated scope to collect source ranges from the parser.\012class SourceRangeScope final {\012 public:\012 enum PositionKind {\012    POSITION_BEG,\012    POSITION_END,\012    PEEK_POSITION_BEG,\012    PEEK_POSITION_END,\012 };\012\012 SourceRangeScope(Scanner* scanner, SourceRange* range,\012 PositionKind pre_kind = PEEK_POSITION_BEG,\012 PositionKind post_kind = POSITION_END)\012 : scanner_(scanner), range_(range), post_kind_(post_kind) {\012    range_-&gt;start = GetPosition(pre_kind);\012    DCHECK_NE(range_-&gt;start, kNoSourcePosition);\012 }\012\012 ~SourceRangeScope() { Finalize(); }\012\012 const SourceRange&amp; Finalize() {\012 if (is_finalized_) return *range_;\012    is_finalized_ = true;\012    range_-&gt;end = GetPosition(post_kind_);\012    DCHECK_NE(range_-&gt;end, kNoSourcePosition);\012 return *range_;\012 }\012\012 private:\012 int32_t GetPosition(PositionKind kind) {\012 switch (kind) {\012 case POSITION_BEG:\012 return scanner_-&gt;location().beg_pos;\012 case POSITION_END:\012 return scanner_-&gt;location().end_pos;\012 case PEEK_POSITION_BEG:\012 return scanner_-&gt;peek_location().beg_pos;\012 case PEEK_POSITION_END:\012 return scanner_-&gt;peek_location().end_pos;\012 default:\012        UNREACHABLE();\012 }\012 }\012\012 Scanner* scanner_;\012 SourceRange* range_;\012 PositionKind post_kind_;\012 bool is_finalized_ = false;\012\012  DISALLOW_IMPLICIT_CONSTRUCTORS(SourceRangeScope);\012};\012\012// ----------------------------------------------------------------------------\012// The CHECK_OK macro is a convenient macro to enforce error\012// handling for functions that may fail (by returning !*ok).\012//\012// CAUTION: This macro appends extra statements after a call,\012// thus it must never be used where only a single statement\012// is correct (e.g. an if statement branch w/o braces)!\012\012#define CHECK_OK_CUSTOM(x, ...) ok);       \\012 if (!*ok) return impl()-&gt;x(__VA_ARGS__); \\012 ((void)0\012#define DUMMY ) // to make indentation work\012#undef DUMMY\012\012// Used in functions where the return type is ExpressionT.\012#define CHECK_OK CHECK_OK_CUSTOM(NullExpression)\012\012#define CHECK_OK_VOID ok); \\012 if (!*ok) return;        \\012 ((void)0\012#define DUMMY ) // to make indentation work\012#undef DUMMY\012\012// Common base class template shared between parser and pre-parser.\012// The Impl parameter is the actual class of the parser/pre-parser,\012// following the Curiously Recurring Template Pattern (CRTP).\012// The structure of the parser objects is roughly the following:\012//\012//   // A structure template containing type definitions, needed to\012//   // avoid a cyclic dependency.\012//   template &lt;typename Impl&gt;\012//   struct ParserTypes;\012//\012//   // The parser base object, which should just implement pure\012//   // parser behavior.  The Impl parameter is the actual derived\012//   // class (according to CRTP), which implements impure parser\012//   // behavior.\012//   template &lt;typename Impl&gt;\012//   class ParserBase { ... };\012//\012//   // And then, for each parser variant (e.g., parser, preparser, etc):\012//   class Parser;\012//\012//   template &lt;&gt;\012//   class ParserTypes&lt;Parser&gt; { ... };\012//\012//   class Parser : public ParserBase&lt;Parser&gt; { ... };\012//\012// The parser base object implements pure parsing, according to the\012// language grammar.  Different parser implementations may exhibit\012// different parser-driven behavior that is not considered as pure\012// parsing, e.g., early error detection and reporting, AST generation, etc.\012\012// The ParserTypes structure encapsulates the differences in the\012// types used in parsing methods.  E.g., Parser methods use Expression*\012// and PreParser methods use PreParserExpression.  For any given parser\012// implementation class Impl, it is expected to contain the following typedefs:\012//\012// template &lt;&gt;\012// struct ParserTypes&lt;Impl&gt; {\012//   // Synonyms for ParserBase&lt;Impl&gt; and Impl, respectively.\012//   typedef Base;\012//   typedef Impl;\012//   // Return types for traversing functions.\012//   typedef Identifier;\012//   typedef Expression;\012//   typedef FunctionLiteral;\012//   typedef ObjectLiteralProperty;\012//   typedef ClassLiteralProperty;\012//   typedef ExpressionList;\012//   typedef ObjectPropertyList;\012//   typedef ClassPropertyList;\012//   typedef FormalParameters;\012//   typedef Statement;\012//   typedef StatementList;\012//   typedef Block;\012//   typedef BreakableStatement;\012//   typedef ForStatement;\012//   typedef IterationStatement;\012//   // For constructing objects returned by the traversing functions.\012//   typedef Factory;\012//   // For other implementation-specific tasks.\012//   typedef Target;\012//   typedef TargetScope;\012// };\012\012template &lt;typename Impl&gt;\012struct ParserTypes;\012\012template &lt;typename Impl&gt;\012class ParserBase {\012 public:\012 // Shorten type names defined by ParserTypes&lt;Impl&gt;.\012 typedef ParserTypes&lt;Impl&gt; Types;\012 typedef typename Types::Identifier IdentifierT;\012 typedef typename Types::Expression ExpressionT;\012 typedef typename Types::FunctionLiteral FunctionLiteralT;\012 typedef typename Types::ObjectLiteralProperty ObjectLiteralPropertyT;\012 typedef typename Types::ClassLiteralProperty ClassLiteralPropertyT;\012 typedef typename Types::Suspend SuspendExpressionT;\012 typedef typename Types::RewritableExpression RewritableExpressionT;\012 typedef typename Types::ExpressionList ExpressionListT;\012 typedef typename Types::FormalParameters FormalParametersT;\012 typedef typename Types::Statement StatementT;\012 typedef typename Types::StatementList StatementListT;\012 typedef typename Types::Block BlockT;\012 typedef typename Types::ForStatement ForStatementT;\012 typedef typename v8::internal::ExpressionClassifier&lt;Types&gt;\012 ExpressionClassifier;\012\012 // All implementation-specific methods must be called through this.\012 Impl* impl() { return static_cast&lt;Impl*&gt;(this); }\012 const Impl* impl() const { return static_cast&lt;const Impl*&gt;(this); }\012\012 ParserBase(Zone* zone, Scanner* scanner, uintptr_t stack_limit,\012             v8::Extension* extension, AstValueFactory* ast_value_factory,\012 PendingCompilationErrorHandler* pending_error_handler,\012 RuntimeCallStats* runtime_call_stats, Logger* logger,\012 int script_id, bool parsing_module, bool parsing_on_main_thread)\012 : scope_(nullptr),\012        original_scope_(nullptr),\012        function_state_(nullptr),\012        extension_(extension),\012        fni_(nullptr),\012        ast_value_factory_(ast_value_factory),\012        ast_node_factory_(ast_value_factory, zone),\012        runtime_call_stats_(runtime_call_stats),\012        logger_(logger),\012        parsing_on_main_thread_(parsing_on_main_thread),\012        parsing_module_(parsing_module),\012        stack_limit_(stack_limit),\012        pending_error_handler_(pending_error_handler),\012        zone_(zone),\012        classifier_(nullptr),\012        scanner_(scanner),\012        default_eager_compile_hint_(FunctionLiteral::kShouldLazyCompile),\012        function_literal_id_(0),\012        script_id_(script_id),\012        allow_natives_(false),\012        allow_harmony_do_expressions_(false),\012        allow_harmony_public_fields_(false),\012        allow_harmony_static_fields_(false),\012        allow_harmony_dynamic_import_(false),\012        allow_harmony_import_meta_(false),\012        allow_harmony_private_fields_(false),\012        allow_eval_cache_(true) {}\012\012#define ALLOW_ACCESSORS(name)                           \\012 bool allow_##name() const { return allow_##name##_; } \\012 void set_allow_##name(bool allow) { allow_##name##_ = allow; }\012\012  ALLOW_ACCESSORS(natives);\012  ALLOW_ACCESSORS(harmony_do_expressions);\012  ALLOW_ACCESSORS(harmony_public_fields);\012  ALLOW_ACCESSORS(harmony_static_fields);\012  ALLOW_ACCESSORS(harmony_dynamic_import);\012  ALLOW_ACCESSORS(harmony_import_meta);\012  ALLOW_ACCESSORS(eval_cache);\012\012#undef ALLOW_ACCESSORS\012\012 bool allow_harmony_bigint() const {\012 return scanner()-&gt;allow_harmony_bigint();\012 }\012 void set_allow_harmony_bigint(bool allow) {\012    scanner()-&gt;set_allow_harmony_bigint(allow);\012 }\012 bool allow_harmony_numeric_separator() const {\012 return scanner()-&gt;allow_harmony_numeric_separator();\012 }\012 void set_allow_harmony_numeric_separator(bool allow) {\012    scanner()-&gt;set_allow_harmony_numeric_separator(allow);\012 }\012\012 bool allow_harmony_private_fields() const {\012 return scanner()-&gt;allow_harmony_private_fields();\012 }\012 void set_allow_harmony_private_fields(bool allow) {\012    scanner()-&gt;set_allow_harmony_private_fields(allow);\012 }\012\012 uintptr_t stack_limit() const { return stack_limit_; }\012\012 void set_stack_limit(uintptr_t stack_limit) { stack_limit_ = stack_limit; }\012\012 void set_default_eager_compile_hint(\012 FunctionLiteral::EagerCompileHint eager_compile_hint) {\012    default_eager_compile_hint_ = eager_compile_hint;\012 }\012\012 FunctionLiteral::EagerCompileHint default_eager_compile_hint() const {\012 return default_eager_compile_hint_;\012 }\012\012 int GetNextFunctionLiteralId() { return ++function_literal_id_; }\012 int GetLastFunctionLiteralId() const { return function_literal_id_; }\012\012 void SkipFunctionLiterals(int delta) { function_literal_id_ += delta; }\012\012 void ResetFunctionLiteralId() { function_literal_id_ = 0; }\012\012 // The Zone where the parsing outputs are stored.\012 Zone* main_zone() const { return ast_value_factory()-&gt;zone(); }\012\012 // The current Zone, which might be the main zone or a temporary Zone.\012 Zone* zone() const { return zone_; }\012\012 protected:\012 friend class v8::internal::ExpressionClassifier&lt;ParserTypes&lt;Impl&gt;&gt;;\012\012 enum AllowRestrictedIdentifiers {\012    kAllowRestrictedIdentifiers,\012    kDontAllowRestrictedIdentifiers\012 };\012\012 enum LazyParsingResult { kLazyParsingComplete, kLazyParsingAborted };\012\012 enum VariableDeclarationContext {\012    kStatementListItem,\012    kStatement,\012    kForStatement\012 };\012\012 class ClassLiteralChecker;\012 class ObjectLiteralChecker;\012\012 // ---------------------------------------------------------------------------\012 // BlockState and FunctionState implement the parser's scope stack.\012 // The parser's current scope is in scope_. BlockState and FunctionState\012 // constructors push on the scope stack and the destructors pop. They are also\012 // used to hold the parser's per-funcion state.\012 class BlockState BASE_EMBEDDED {\012 public:\012 BlockState(Scope** scope_stack, Scope* scope)\012 : scope_stack_(scope_stack), outer_scope_(*scope_stack) {\012 *scope_stack_ = scope;\012 }\012\012 BlockState(Zone* zone, Scope** scope_stack)\012 : BlockState(scope_stack,\012 new (zone) Scope(zone, *scope_stack, BLOCK_SCOPE)) {}\012\012 ~BlockState() { *scope_stack_ = outer_scope_; }\012\012 private:\012 Scope** const scope_stack_;\012 Scope* const outer_scope_;\012 };\012\012 class FunctionState final : public BlockState {\012 public:\012 FunctionState(FunctionState** function_state_stack, Scope** scope_stack,\012 DeclarationScope* scope);\012 ~FunctionState();\012\012 DeclarationScope* scope() const { return scope_-&gt;AsDeclarationScope(); }\012\012 void AddProperty() { expected_property_count_++; }\012 int expected_property_count() { return expected_property_count_; }\012\012 void DisableOptimization(BailoutReason reason) {\012      dont_optimize_reason_ = reason;\012 }\012 BailoutReason dont_optimize_reason() { return dont_optimize_reason_; }\012\012 void AddSuspend() { suspend_count_++; }\012 int suspend_count() const { return suspend_count_; }\012 bool CanSuspend() const { return suspend_count_ &gt; 0; }\012\012 FunctionKind kind() const { return scope()-&gt;function_kind(); }\012\012 void RewindDestructuringAssignments(int pos) {\012      destructuring_assignments_to_rewrite_.Rewind(pos);\012 }\012\012 void AdoptDestructuringAssignmentsFromParentState(int pos) {\012 const auto&amp; outer_assignments =\012          outer_function_state_-&gt;destructuring_assignments_to_rewrite_;\012      DCHECK_GE(outer_assignments.size(), pos);\012 auto it = outer_assignments.begin();\012      it.Advance(pos);\012 for (; it != outer_assignments.end(); ++it) {\012 auto expr = *it;\012        expr-&gt;set_scope(scope_);\012        destructuring_assignments_to_rewrite_.push_back(expr);\012 }\012      outer_function_state_-&gt;RewindDestructuringAssignments(pos);\012 }\012\012 const ZoneChunkList&lt;RewritableExpressionT&gt;&amp;\012    destructuring_assignments_to_rewrite() const {\012 return destructuring_assignments_to_rewrite_;\012 }\012\012 ZoneVector&lt;typename ExpressionClassifier::Error&gt;* GetReportedErrorList() {\012 return &amp;reported_errors_;\012 }\012\012 bool next_function_is_likely_called() const {\012 return next_function_is_likely_called_;\012 }\012\012 bool previous_function_was_likely_called() const {\012 return previous_function_was_likely_called_;\012 }\012\012 void set_next_function_is_likely_called() {\012      next_function_is_likely_called_ = true;\012 }\012\012 void RecordFunctionOrEvalCall() { contains_function_or_eval_ = true; }\012 bool contains_function_or_eval() const {\012 return contains_function_or_eval_;\012 }\012\012 class FunctionOrEvalRecordingScope {\012 public:\012 explicit FunctionOrEvalRecordingScope(FunctionState* state)\012 : state_(state) {\012        prev_value_ = state-&gt;contains_function_or_eval_;\012        state-&gt;contains_function_or_eval_ = false;\012 }\012 ~FunctionOrEvalRecordingScope() {\012 bool found = state_-&gt;contains_function_or_eval_;\012 if (!found) {\012          state_-&gt;contains_function_or_eval_ = prev_value_;\012 }\012 }\012\012 private:\012 FunctionState* state_;\012 bool prev_value_;\012 };\012\012 private:\012 void AddDestructuringAssignment(RewritableExpressionT expr) {\012      destructuring_assignments_to_rewrite_.push_back(expr);\012 }\012\012 // Properties count estimation.\012 int expected_property_count_;\012\012 // How many suspends are needed for this function.\012 int suspend_count_;\012\012 FunctionState** function_state_stack_;\012 FunctionState* outer_function_state_;\012 DeclarationScope* scope_;\012\012 ZoneChunkList&lt;RewritableExpressionT&gt; destructuring_assignments_to_rewrite_;\012\012 // We use a ZoneVector here because we need to do a lot of random access.\012 ZoneVector&lt;typename ExpressionClassifier::Error&gt; reported_errors_;\012\012 // A reason, if any, why this function should not be optimized.\012 BailoutReason dont_optimize_reason_;\012\012 // Record whether the next (=== immediately following) function literal is\012 // preceded by a parenthesis / exclamation mark. Also record the previous\012 // state.\012 // These are managed by the FunctionState constructor; the caller may only\012 // call set_next_function_is_likely_called.\012 bool next_function_is_likely_called_;\012 bool previous_function_was_likely_called_;\012\012 // Track if a function or eval occurs within this FunctionState\012 bool contains_function_or_eval_;\012\012 friend Impl;\012 };\012\012 struct DeclarationDescriptor {\012 enum Kind { NORMAL, PARAMETER, FOR_EACH };\012 Scope* scope;\012 VariableMode mode;\012 int declaration_pos;\012 int initialization_pos;\012 Kind declaration_kind;\012 };\012\012 struct DeclarationParsingResult {\012 struct Declaration {\012 Declaration(ExpressionT pattern, int initializer_position,\012 ExpressionT initializer)\012 : pattern(pattern),\012            initializer_position(initializer_position),\012            initializer(initializer) {}\012\012 ExpressionT pattern;\012 int initializer_position;\012 int value_beg_position = kNoSourcePosition;\012 ExpressionT initializer;\012 };\012\012 DeclarationParsingResult()\012 : first_initializer_loc(Scanner::Location::invalid()),\012          bindings_loc(Scanner::Location::invalid()) {}\012\012 DeclarationDescriptor descriptor;\012    std::vector&lt;Declaration&gt; declarations;\012 Scanner::Location first_initializer_loc;\012 Scanner::Location bindings_loc;\012 };\012\012 struct CatchInfo {\012 public:\012 explicit CatchInfo(ParserBase* parser)\012 : name(parser-&gt;impl()-&gt;NullIdentifier()),\012          pattern(parser-&gt;impl()-&gt;NullExpression()),\012          scope(nullptr),\012          init_block(parser-&gt;impl()-&gt;NullStatement()),\012          inner_block(parser-&gt;impl()-&gt;NullStatement()),\012          bound_names(1, parser-&gt;zone()) {}\012 IdentifierT name;\012 ExpressionT pattern;\012 Scope* scope;\012 BlockT init_block;\012 BlockT inner_block;\012 ZonePtrList&lt;const AstRawString&gt; bound_names;\012 };\012\012 struct ForInfo {\012 public:\012 explicit ForInfo(ParserBase* parser)\012 : bound_names(1, parser-&gt;zone()),\012          mode(ForEachStatement::ENUMERATE),\012          position(kNoSourcePosition),\012          parsing_result() {}\012 ZonePtrList&lt;const AstRawString&gt; bound_names;\012 ForEachStatement::VisitMode mode;\012 int position;\012 DeclarationParsingResult parsing_result;\012 };\012\012 struct ClassInfo {\012 public:\012 explicit ClassInfo(ParserBase* parser)\012 : variable(nullptr),\012 extends(parser-&gt;impl()-&gt;NullExpression()),\012          properties(parser-&gt;impl()-&gt;NewClassPropertyList(4)),\012          static_fields(parser-&gt;impl()-&gt;NewClassPropertyList(4)),\012          instance_fields(parser-&gt;impl()-&gt;NewClassPropertyList(4)),\012          constructor(parser-&gt;impl()-&gt;NullExpression()),\012          has_seen_constructor(false),\012          has_name_static_property(false),\012          has_static_computed_names(false),\012          has_static_class_fields(false),\012          has_instance_class_fields(false),\012          is_anonymous(false),\012          static_fields_scope(nullptr),\012          instance_fields_scope(nullptr),\012          computed_field_count(0) {}\012 Variable* variable;\012 ExpressionT extends;\012 typename Types::ClassPropertyList properties;\012 typename Types::ClassPropertyList static_fields;\012 typename Types::ClassPropertyList instance_fields;\012 FunctionLiteralT constructor;\012\012 bool has_seen_constructor;\012 bool has_name_static_property;\012 bool has_static_computed_names;\012 bool has_static_class_fields;\012 bool has_instance_class_fields;\012 bool is_anonymous;\012 DeclarationScope* static_fields_scope;\012 DeclarationScope* instance_fields_scope;\012 int computed_field_count;\012 };\012\012 const AstRawString* ClassFieldVariableName(AstValueFactory* ast_value_factory,\012 int index) {\012    std::string name = &quot;.class-field-&quot; + std::to_string(index);\012 return ast_value_factory-&gt;GetOneByteString(name.c_str());\012 }\012\012 DeclarationScope* NewScriptScope() const {\012 return new (zone()) DeclarationScope(zone(), ast_value_factory());\012 }\012\012 DeclarationScope* NewVarblockScope() const {\012 return new (zone()) DeclarationScope(zone(), scope(), BLOCK_SCOPE);\012 }\012\012 ModuleScope* NewModuleScope(DeclarationScope* parent) const {\012 return new (zone()) ModuleScope(parent, ast_value_factory());\012 }\012\012 DeclarationScope* NewEvalScope(Scope* parent) const {\012 return new (zone()) DeclarationScope(zone(), parent, EVAL_SCOPE);\012 }\012\012 Scope* NewScope(ScopeType scope_type) const {\012 return NewScopeWithParent(scope(), scope_type);\012 }\012\012 // This constructor should only be used when absolutely necessary. Most scopes\012 // should automatically use scope() as parent, and be fine with\012 // NewScope(ScopeType) above.\012 Scope* NewScopeWithParent(Scope* parent, ScopeType scope_type) const {\012 // Must always use the specific constructors for the blacklisted scope\012 // types.\012    DCHECK_NE(FUNCTION_SCOPE, scope_type);\012    DCHECK_NE(SCRIPT_SCOPE, scope_type);\012    DCHECK_NE(MODULE_SCOPE, scope_type);\012    DCHECK_NOT_NULL(parent);\012 return new (zone()) Scope(zone(), parent, scope_type);\012 }\012\012 // Creates a function scope that always allocates in zone(). The function\012 // scope itself is either allocated in zone() or in target_zone if one is\012 // passed in.\012 DeclarationScope* NewFunctionScope(FunctionKind kind,\012 Zone* target_zone = nullptr) const {\012    DCHECK(ast_value_factory());\012 if (target_zone == nullptr) target_zone = zone();\012 DeclarationScope* result = new (target_zone)\012 DeclarationScope(zone(), scope(), FUNCTION_SCOPE, kind);\012\012 // Record presence of an inner function scope\012    function_state_-&gt;RecordFunctionOrEvalCall();\012\012 // TODO(verwaest): Move into the DeclarationScope constructor.\012 if (!IsArrowFunction(kind)) {\012      result-&gt;DeclareDefaultFunctionVariables(ast_value_factory());\012 }\012 return result;\012 }\012\012  V8_INLINE DeclarationScope* GetDeclarationScope() const {\012 return scope()-&gt;GetDeclarationScope();\012 }\012  V8_INLINE DeclarationScope* GetClosureScope() const {\012 return scope()-&gt;GetClosureScope();\012 }\012\012 Scanner* scanner() const { return scanner_; }\012 AstValueFactory* ast_value_factory() const { return ast_value_factory_; }\012 int position() const { return scanner_-&gt;location().beg_pos; }\012 int peek_position() const { return scanner_-&gt;peek_location().beg_pos; }\012 bool stack_overflow() const {\012 return pending_error_handler()-&gt;stack_overflow();\012 }\012 void set_stack_overflow() { pending_error_handler()-&gt;set_stack_overflow(); }\012 int script_id() { return script_id_; }\012 void set_script_id(int id) { script_id_ = id; }\012\012  V8_INLINE Token::Value peek() {\012 if (stack_overflow()) return Token::ILLEGAL;\012 return scanner()-&gt;peek();\012 }\012\012 // Returns the position past the following semicolon (if it exists), and the\012 // position past the end of the current token otherwise.\012 int PositionAfterSemicolon() {\012 return (peek() == Token::SEMICOLON) ? scanner_-&gt;peek_location().end_pos\012 : scanner_-&gt;location().end_pos;\012 }\012\012  V8_INLINE Token::Value PeekAhead() {\012 if (stack_overflow()) return Token::ILLEGAL;\012 return scanner()-&gt;PeekAhead();\012 }\012\012  V8_INLINE Token::Value Next() {\012 if (stack_overflow()) return Token::ILLEGAL;\012 {\012 if (GetCurrentStackPosition() &lt; stack_limit_) {\012 // Any further calls to Next or peek will return the illegal token.\012 // The current call must return the next token, which might already\012 // have been peek'ed.\012        set_stack_overflow();\012 }\012 }\012 return scanner()-&gt;Next();\012 }\012\012 void Consume(Token::Value token) {\012 Token::Value next = Next();\012    USE(next);\012    USE(token);\012    DCHECK(next == token);\012 }\012\012 bool Check(Token::Value token) {\012 Token::Value next = peek();\012 if (next == token) {\012 Consume(next);\012 return true;\012 }\012 return false;\012 }\012\012 void Expect(Token::Value token, bool* ok) {\012 Token::Value next = Next();\012 if (next != token) {\012 ReportUnexpectedToken(next);\012 *ok = false;\012 }\012 }\012\012 void ExpectSemicolon(bool* ok) {\012 // Check for automatic semicolon insertion according to\012 // the rules given in ECMA-262, section 7.9, page 21.\012 Token::Value tok = peek();\012 if (tok == Token::SEMICOLON) {\012 Next();\012 return;\012 }\012 if (scanner()-&gt;HasLineTerminatorBeforeNext() || tok == Token::RBRACE ||\012        tok == Token::EOS) {\012 return;\012 }\012\012 Token::Value current = scanner()-&gt;current_token();\012 Scanner::Location current_location = scanner()-&gt;location();\012 Token::Value next = Next();\012\012 if (next == Token::SEMICOLON) {\012 return;\012 }\012\012 *ok = false;\012 if (current == Token::AWAIT &amp;&amp; !is_async_function()) {\012 ReportMessageAt(current_location,\012 MessageTemplate::kAwaitNotInAsyncFunction, kSyntaxError);\012 return;\012 }\012\012 ReportUnexpectedToken(next);\012 }\012\012 // Dummy functions, just useful as arguments to CHECK_OK_CUSTOM.\012 static void Void() {}\012 template &lt;typename T&gt;\012 static T Return(T result) {\012 return result;\012 }\012\012 bool is_any_identifier(Token::Value token) {\012 return token == Token::IDENTIFIER || token == Token::ENUM ||\012           token == Token::AWAIT || token == Token::ASYNC ||\012           token == Token::ESCAPED_STRICT_RESERVED_WORD ||\012           token == Token::FUTURE_STRICT_RESERVED_WORD || token == Token::LET ||\012           token == Token::STATIC || token == Token::YIELD;\012 }\012 bool peek_any_identifier() { return is_any_identifier(peek()); }\012\012 bool CheckContextualKeyword(Token::Value token) {\012 if (PeekContextualKeyword(token)) {\012 Consume(Token::IDENTIFIER);\012 return true;\012 }\012 return false;\012 }\012\012 bool PeekContextualKeyword(Token::Value token) {\012    DCHECK(Token::IsContextualKeyword(token));\012 return peek() == Token::IDENTIFIER &amp;&amp;\012           scanner()-&gt;next_contextual_token() == token;\012 }\012\012 void ExpectMetaProperty(Token::Value property_name, const char* full_name,\012 int pos, bool* ok);\012\012 void ExpectContextualKeyword(Token::Value token, bool* ok) {\012    DCHECK(Token::IsContextualKeyword(token));\012 Expect(Token::IDENTIFIER, CHECK_OK_CUSTOM(Void));\012 if (scanner()-&gt;current_contextual_token() != token) {\012 ReportUnexpectedToken(scanner()-&gt;current_token());\012 *ok = false;\012 }\012 }\012\012 bool CheckInOrOf(ForEachStatement::VisitMode* visit_mode) {\012 if (Check(Token::IN)) {\012 *visit_mode = ForEachStatement::ENUMERATE;\012 return true;\012 } else if (CheckContextualKeyword(Token::OF)) {\012 *visit_mode = ForEachStatement::ITERATE;\012 return true;\012 }\012 return false;\012 }\012\012 bool PeekInOrOf() {\012 return peek() == Token::IN || PeekContextualKeyword(Token::OF);\012 }\012\012 // Checks whether an octal literal was last seen between beg_pos and end_pos.\012 // Only called for strict mode strings.\012 void CheckStrictOctalLiteral(int beg_pos, int end_pos, bool* ok) {\012 Scanner::Location octal = scanner()-&gt;octal_position();\012 if (octal.IsValid() &amp;&amp; beg_pos &lt;= octal.beg_pos &amp;&amp;\012        octal.end_pos &lt;= end_pos) {\012 MessageTemplate::Template message = scanner()-&gt;octal_message();\012      DCHECK_NE(message, MessageTemplate::kNone);\012      impl()-&gt;ReportMessageAt(octal, message);\012      scanner()-&gt;clear_octal_position();\012 if (message == MessageTemplate::kStrictDecimalWithLeadingZero) {\012        impl()-&gt;CountUsage(v8::Isolate::kDecimalWithLeadingZeroInStrictMode);\012 }\012 *ok = false;\012 }\012 }\012\012 // Checks if an octal literal or an invalid hex or unicode escape sequence\012 // appears in the current template literal token. In the presence of such,\012 // either returns false or reports an error, depending on should_throw.\012 // Otherwise returns true.\012 inline bool CheckTemplateEscapes(bool should_throw, bool* ok) {\012    DCHECK(scanner()-&gt;current_token() == Token::TEMPLATE_SPAN ||\012           scanner()-&gt;current_token() == Token::TEMPLATE_TAIL);\012 if (!scanner()-&gt;has_invalid_template_escape()) {\012 return true;\012 }\012\012 // Handle error case(s)\012 if (should_throw) {\012      impl()-&gt;ReportMessageAt(scanner()-&gt;invalid_template_escape_location(),\012                              scanner()-&gt;invalid_template_escape_message());\012 *ok = false;\012 }\012 return false;\012 }\012\012 void CheckDestructuringElement(ExpressionT element, int beg_pos, int end_pos);\012\012 // Checking the name of a function literal. This has to be done after parsing\012 // the function, since the function can declare itself strict.\012 void CheckFunctionName(LanguageMode language_mode, IdentifierT function_name,\012 FunctionNameValidity function_name_validity,\012 const Scanner::Location&amp; function_name_loc, bool* ok) {\012 if (impl()-&gt;IsNull(function_name)) return;\012 if (function_name_validity == kSkipFunctionNameCheck) return;\012 // The function name needs to be checked in strict mode.\012 if (is_sloppy(language_mode)) return;\012\012 if (impl()-&gt;IsEvalOrArguments(function_name)) {\012      impl()-&gt;ReportMessageAt(function_name_loc,\012 MessageTemplate::kStrictEvalArguments);\012 *ok = false;\012 return;\012 }\012 if (function_name_validity == kFunctionNameIsStrictReserved) {\012      impl()-&gt;ReportMessageAt(function_name_loc,\012 MessageTemplate::kUnexpectedStrictReserved);\012 *ok = false;\012 return;\012 }\012 }\012\012 // Determine precedence of given token.\012 static int Precedence(Token::Value token, bool accept_IN) {\012 if (token == Token::IN &amp;&amp; !accept_IN)\012 return 0; // 0 precedence will terminate binary expression parsing\012 return Token::Precedence(token);\012 }\012\012 typename Types::Factory* factory() { return &amp;ast_node_factory_; }\012\012 DeclarationScope* GetReceiverScope() const {\012 return scope()-&gt;GetReceiverScope();\012 }\012 LanguageMode language_mode() { return scope()-&gt;language_mode(); }\012 void RaiseLanguageMode(LanguageMode mode) {\012 LanguageMode old = scope()-&gt;language_mode();\012    impl()-&gt;SetLanguageMode(scope(), old &gt; mode ? old : mode);\012 }\012 bool is_generator() const {\012 return IsGeneratorFunction(function_state_-&gt;kind());\012 }\012 bool is_async_function() const {\012 return IsAsyncFunction(function_state_-&gt;kind());\012 }\012 bool is_async_generator() const {\012 return IsAsyncGeneratorFunction(function_state_-&gt;kind());\012 }\012 bool is_resumable() const {\012 return IsResumableFunction(function_state_-&gt;kind());\012 }\012\012 const PendingCompilationErrorHandler* pending_error_handler() const {\012 return pending_error_handler_;\012 }\012 PendingCompilationErrorHandler* pending_error_handler() {\012 return pending_error_handler_;\012 }\012\012 // Report syntax errors.\012 void ReportMessage(MessageTemplate::Template message) {\012 Scanner::Location source_location = scanner()-&gt;location();\012    impl()-&gt;ReportMessageAt(source_location, message,\012 static_cast&lt;const char*&gt;(nullptr), kSyntaxError);\012 }\012\012 template &lt;typename T&gt;\012 void ReportMessage(MessageTemplate::Template message, T arg,\012 ParseErrorType error_type = kSyntaxError) {\012 Scanner::Location source_location = scanner()-&gt;location();\012    impl()-&gt;ReportMessageAt(source_location, message, arg, error_type);\012 }\012\012 void ReportMessageAt(Scanner::Location location,\012 MessageTemplate::Template message,\012 ParseErrorType error_type) {\012    impl()-&gt;ReportMessageAt(location, message,\012 static_cast&lt;const char*&gt;(nullptr), error_type);\012 }\012\012 void GetUnexpectedTokenMessage(\012 Token::Value token, MessageTemplate::Template* message,\012 Scanner::Location* location, const char** arg,\012 MessageTemplate::Template default_ = MessageTemplate::kUnexpectedToken);\012\012 void ReportUnexpectedToken(Token::Value token);\012 void ReportUnexpectedTokenAt(\012 Scanner::Location location, Token::Value token,\012 MessageTemplate::Template message = MessageTemplate::kUnexpectedToken);\012\012 void ReportClassifierError(\012 const typename ExpressionClassifier::Error&amp; error) {\012    impl()-&gt;ReportMessageAt(error.location, error.message, error.arg);\012 }\012\012 void ValidateExpression(bool* ok) {\012 if (!classifier()-&gt;is_valid_expression()) {\012 ReportClassifierError(classifier()-&gt;expression_error());\012 *ok = false;\012 }\012 }\012\012 void ValidateFormalParameterInitializer(bool* ok) {\012 if (!classifier()-&gt;is_valid_formal_parameter_initializer()) {\012 ReportClassifierError(classifier()-&gt;formal_parameter_initializer_error());\012 *ok = false;\012 }\012 }\012\012 void ValidateBindingPattern(bool* ok) {\012 if (!classifier()-&gt;is_valid_binding_pattern()) {\012 ReportClassifierError(classifier()-&gt;binding_pattern_error());\012 *ok = false;\012 }\012 }\012\012 void ValidateAssignmentPattern(bool* ok) {\012 if (!classifier()-&gt;is_valid_assignment_pattern()) {\012 ReportClassifierError(classifier()-&gt;assignment_pattern_error());\012 *ok = false;\012 }\012 }\012\012 void ValidateFormalParameters(LanguageMode language_mode,\012 bool allow_duplicates, bool* ok) {\012 if (!allow_duplicates &amp;&amp;\012 !classifier()-&gt;is_valid_formal_parameter_list_without_duplicates()) {\012 ReportClassifierError(classifier()-&gt;duplicate_formal_parameter_error());\012 *ok = false;\012 } else if (is_strict(language_mode) &amp;&amp;\012 !classifier()-&gt;is_valid_strict_mode_formal_parameters()) {\012 ReportClassifierError(classifier()-&gt;strict_mode_formal_parameter_error());\012 *ok = false;\012 }\012 }\012\012 bool IsValidArrowFormalParametersStart(Token::Value token) {\012 return is_any_identifier(token) || token == Token::LPAREN;\012 }\012\012 void ValidateArrowFormalParameters(ExpressionT expr,\012 bool parenthesized_formals, bool is_async,\012 bool* ok) {\012 if (classifier()-&gt;is_valid_binding_pattern()) {\012 // A simple arrow formal parameter: IDENTIFIER =&gt; BODY.\012 if (!impl()-&gt;IsIdentifier(expr)) {\012        impl()-&gt;ReportMessageAt(scanner()-&gt;location(),\012 MessageTemplate::kUnexpectedToken,\012 Token::String(scanner()-&gt;current_token()));\012 *ok = false;\012 }\012 } else if (!classifier()-&gt;is_valid_arrow_formal_parameters()) {\012 // If after parsing the expr, we see an error but the expression is\012 // neither a valid binding pattern nor a valid parenthesized formal\012 // parameter list, show the &quot;arrow formal parameters&quot; error if the formals\012 // started with a parenthesis, and the binding pattern error otherwise.\012 const typename ExpressionClassifier::Error&amp; error =\012          parenthesized_formals ? classifier()-&gt;arrow_formal_parameters_error()\012 : classifier()-&gt;binding_pattern_error();\012 ReportClassifierError(error);\012 *ok = false;\012 }\012 if (is_async &amp;&amp; !classifier()-&gt;is_valid_async_arrow_formal_parameters()) {\012 const typename ExpressionClassifier::Error&amp; error =\012          classifier()-&gt;async_arrow_formal_parameters_error();\012 ReportClassifierError(error);\012 *ok = false;\012 }\012 }\012\012 void ValidateLetPattern(bool* ok) {\012 if (!classifier()-&gt;is_valid_let_pattern()) {\012 ReportClassifierError(classifier()-&gt;let_pattern_error());\012 *ok = false;\012 }\012 }\012\012 void BindingPatternUnexpectedToken() {\012 MessageTemplate::Template message = MessageTemplate::kUnexpectedToken;\012 const char* arg;\012 Scanner::Location location = scanner()-&gt;peek_location();\012 GetUnexpectedTokenMessage(peek(), &amp;message, &amp;location, &amp;arg);\012    classifier()-&gt;RecordBindingPatternError(location, message, arg);\012 }\012\012 void ArrowFormalParametersUnexpectedToken() {\012 MessageTemplate::Template message = MessageTemplate::kUnexpectedToken;\012 const char* arg;\012 Scanner::Location location = scanner()-&gt;peek_location();\012 GetUnexpectedTokenMessage(peek(), &amp;message, &amp;location, &amp;arg);\012    classifier()-&gt;RecordArrowFormalParametersError(location, message, arg);\012 }\012\012 // Recursive descent functions.\012 // All ParseXXX functions take as the last argument an *ok parameter\012 // which is set to false if parsing failed; it is unchanged otherwise.\012 // By making the 'exception handling' explicit, we are forced to check\012 // for failure at the call sites. The family of CHECK_OK* macros can\012 // be useful for this.\012\012 // Parses an identifier that is valid for the current scope, in particular it\012 // fails on strict mode future reserved keywords in a strict scope. If\012 // allow_eval_or_arguments is kAllowEvalOrArguments, we allow &quot;eval&quot; or\012 // &quot;arguments&quot; as identifier even in strict mode (this is needed in cases like\012 // &quot;var foo = eval;&quot;).\012 IdentifierT ParseIdentifier(AllowRestrictedIdentifiers, bool* ok);\012 IdentifierT ParseAndClassifyIdentifier(bool* ok);\012 // Parses an identifier or a strict mode future reserved word, and indicate\012 // whether it is strict mode future reserved. Allows passing in function_kind\012 // for the case of parsing the identifier in a function expression, where the\012 // relevant &quot;function_kind&quot; bit is of the function being parsed, not the\012 // containing function.\012 IdentifierT ParseIdentifierOrStrictReservedWord(FunctionKind function_kind,\012 bool* is_strict_reserved,\012 bool* is_await, bool* ok);\012 IdentifierT ParseIdentifierOrStrictReservedWord(bool* is_strict_reserved,\012 bool* is_await, bool* ok) {\012 return ParseIdentifierOrStrictReservedWord(\012        function_state_-&gt;kind(), is_strict_reserved, is_await, ok);\012 }\012\012  V8_INLINE IdentifierT ParseIdentifierName(bool* ok);\012\012 ExpressionT ParseIdentifierNameOrPrivateName(bool* ok);\012\012 ExpressionT ParseRegExpLiteral(bool* ok);\012\012 ExpressionT ParsePrimaryExpression(bool* is_async, bool* ok);\012 ExpressionT ParsePrimaryExpression(bool* ok) {\012 bool is_async;\012 return ParsePrimaryExpression(&amp;is_async, ok);\012 }\012\012 // Use when parsing an expression that is known to not be a pattern or part\012 // of a pattern.\012  V8_INLINE ExpressionT ParseExpression(bool accept_IN, bool* ok);\012\012 // This method does not wrap the parsing of the expression inside a\012 // new expression classifier; it uses the top-level classifier instead.\012 // It should be used whenever we're parsing something with the &quot;cover&quot;\012 // grammar that recognizes both patterns and non-patterns (which roughly\012 // corresponds to what's inside the parentheses generated by the symbol\012 // &quot;CoverParenthesizedExpressionAndArrowParameterList&quot; in the ES 2017\012 // specification).\012 ExpressionT ParseExpressionCoverGrammar(bool accept_IN, bool* ok);\012\012 ExpressionT ParseArrayLiteral(bool* ok);\012\012 enum class PropertyKind {\012    kAccessorProperty,\012    kValueProperty,\012    kShorthandProperty,\012    kMethodProperty,\012    kClassField,\012    kSpreadProperty,\012    kNotSet\012 };\012\012 bool SetPropertyKindFromToken(Token::Value token, PropertyKind* kind);\012 ExpressionT ParsePropertyName(IdentifierT* name, PropertyKind* kind,\012 bool* is_generator, bool* is_get, bool* is_set,\012 bool* is_async, bool* is_computed_name,\012 bool* ok);\012 ExpressionT ParseObjectLiteral(bool* ok);\012 ClassLiteralPropertyT ParseClassPropertyDefinition(\012 ClassLiteralChecker* checker, ClassInfo* class_info,\012 IdentifierT* property_name, bool has_extends, bool* is_computed_name,\012 ClassLiteralProperty::Kind* property_kind, bool* is_static, bool* ok);\012 ExpressionT ParseClassFieldInitializer(ClassInfo* class_info, bool is_static,\012 bool* ok);\012 ObjectLiteralPropertyT ParseObjectPropertyDefinition(\012 ObjectLiteralChecker* checker, bool* is_computed_name,\012 bool* is_rest_property, bool* ok);\012 ExpressionListT ParseArguments(Scanner::Location* first_spread_pos,\012 bool maybe_arrow,\012 bool* is_simple_parameter_list, bool* ok);\012 ExpressionListT ParseArguments(Scanner::Location* first_spread_pos,\012 bool* ok) {\012 return ParseArguments(first_spread_pos, false, nullptr, ok);\012 }\012\012 ExpressionT ParseAssignmentExpression(bool accept_IN, bool* ok);\012 ExpressionT ParseYieldExpression(bool accept_IN, bool* ok);\012  V8_INLINE ExpressionT ParseConditionalExpression(bool accept_IN, bool* ok);\012 ExpressionT ParseBinaryExpression(int prec, bool accept_IN, bool* ok);\012 ExpressionT ParseUnaryExpression(bool* ok);\012  V8_INLINE ExpressionT ParsePostfixExpression(bool* ok);\012  V8_INLINE ExpressionT ParseLeftHandSideExpression(bool* ok);\012 ExpressionT ParseMemberWithNewPrefixesExpression(bool* is_async, bool* ok);\012  V8_INLINE ExpressionT ParseMemberExpression(bool* is_async, bool* ok);\012  V8_INLINE ExpressionT ParseMemberExpressionContinuation(\012 ExpressionT expression, bool* is_async, bool* ok);\012\012 // `rewritable_length`: length of the destructuring_assignments_to_rewrite()\012 // queue in the parent function state, prior to parsing of formal parameters.\012 // If the arrow function is lazy, any items added during formal parameter\012 // parsing are removed from the queue.\012 ExpressionT ParseArrowFunctionLiteral(bool accept_IN,\012 const FormalParametersT&amp; parameters,\012 int rewritable_length, bool* ok);\012 void ParseSingleExpressionFunctionBody(StatementListT body, bool is_async,\012 bool accept_IN, bool* ok);\012 void ParseAsyncFunctionBody(Scope* scope, StatementListT body, bool* ok);\012 ExpressionT ParseAsyncFunctionLiteral(bool* ok);\012 ExpressionT ParseClassLiteral(IdentifierT name,\012 Scanner::Location class_name_location,\012 bool name_is_strict_reserved,\012 int class_token_pos, bool* ok);\012 ExpressionT ParseTemplateLiteral(ExpressionT tag, int start, bool tagged,\012 bool* ok);\012 ExpressionT ParseSuperExpression(bool is_new, bool* ok);\012 ExpressionT ParseImportExpressions(bool* ok);\012 ExpressionT ParseNewTargetExpression(bool* ok);\012\012  V8_INLINE void ParseFormalParameter(FormalParametersT* parameters, bool* ok);\012 void ParseFormalParameterList(FormalParametersT* parameters, bool* ok);\012 void CheckArityRestrictions(int param_count, FunctionKind function_type,\012 bool has_rest, int formals_start_pos,\012 int formals_end_pos, bool* ok);\012\012 BlockT ParseVariableDeclarations(VariableDeclarationContext var_context,\012 DeclarationParsingResult* parsing_result,\012 ZonePtrList&lt;const AstRawString&gt;* names,\012 bool* ok);\012 StatementT ParseAsyncFunctionDeclaration(\012 ZonePtrList&lt;const AstRawString&gt;* names, bool default_export, bool* ok);\012 StatementT ParseFunctionDeclaration(bool* ok);\012 StatementT ParseHoistableDeclaration(ZonePtrList&lt;const AstRawString&gt;* names,\012 bool default_export, bool* ok);\012 StatementT ParseHoistableDeclaration(int pos, ParseFunctionFlags flags,\012 ZonePtrList&lt;const AstRawString&gt;* names,\012 bool default_export, bool* ok);\012 StatementT ParseClassDeclaration(ZonePtrList&lt;const AstRawString&gt;* names,\012 bool default_export, bool* ok);\012 StatementT ParseNativeDeclaration(bool* ok);\012\012 // Consumes the ending }.\012 void ParseFunctionBody(StatementListT result, IdentifierT function_name,\012 int pos, const FormalParametersT&amp; parameters,\012 FunctionKind kind,\012 FunctionLiteral::FunctionType function_type, bool* ok);\012\012 // Under some circumstances, we allow preparsing to abort if the preparsed\012 // function is &quot;long and trivial&quot;, and fully parse instead. Our current\012 // definition of &quot;long and trivial&quot; is:\012 // - over kLazyParseTrialLimit statements\012 // - all starting with an identifier (i.e., no if, for, while, etc.)\012 static const int kLazyParseTrialLimit = 200;\012\012 // TODO(nikolaos, marja): The first argument should not really be passed\012 // by value. The method is expected to add the parsed statements to the\012 // list. This works because in the case of the parser, StatementListT is\012 // a pointer whereas the preparser does not really modify the body.\012  V8_INLINE void ParseStatementList(StatementListT body, Token::Value end_token,\012 bool* ok) {\012 LazyParsingResult result = ParseStatementList(body, end_token, false, ok);\012    USE(result);\012    DCHECK_EQ(result, kLazyParsingComplete);\012 }\012  V8_INLINE LazyParsingResult ParseStatementList(StatementListT body,\012 Token::Value end_token,\012 bool may_abort, bool* ok);\012 StatementT ParseStatementListItem(bool* ok);\012\012 StatementT ParseStatement(ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels,\012 bool* ok) {\012 return ParseStatement(labels, own_labels,\012                          kDisallowLabelledFunctionStatement, ok);\012 }\012 StatementT ParseStatement(ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels,\012 AllowLabelledFunctionStatement allow_function,\012 bool* ok);\012 BlockT ParseBlock(ZonePtrList&lt;const AstRawString&gt;* labels, bool* ok);\012\012 // Parse a SubStatement in strict mode, or with an extra block scope in\012 // sloppy mode to handle\012 // ES#sec-functiondeclarations-in-ifstatement-statement-clauses\012 StatementT ParseScopedStatement(ZonePtrList&lt;const AstRawString&gt;* labels,\012 bool* ok);\012\012 StatementT ParseVariableStatement(VariableDeclarationContext var_context,\012 ZonePtrList&lt;const AstRawString&gt;* names,\012 bool* ok);\012\012 // Magical syntax support.\012 ExpressionT ParseV8Intrinsic(bool* ok);\012\012 ExpressionT ParseDoExpression(bool* ok);\012\012 StatementT ParseDebuggerStatement(bool* ok);\012\012 StatementT ParseExpressionOrLabelledStatement(\012 ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels,\012 AllowLabelledFunctionStatement allow_function, bool* ok);\012 StatementT ParseIfStatement(ZonePtrList&lt;const AstRawString&gt;* labels,\012 bool* ok);\012 StatementT ParseContinueStatement(bool* ok);\012 StatementT ParseBreakStatement(ZonePtrList&lt;const AstRawString&gt;* labels,\012 bool* ok);\012 StatementT ParseReturnStatement(bool* ok);\012 StatementT ParseWithStatement(ZonePtrList&lt;const AstRawString&gt;* labels,\012 bool* ok);\012 StatementT ParseDoWhileStatement(ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels,\012 bool* ok);\012 StatementT ParseWhileStatement(ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels,\012 bool* ok);\012 StatementT ParseThrowStatement(bool* ok);\012 StatementT ParseSwitchStatement(ZonePtrList&lt;const AstRawString&gt;* labels,\012 bool* ok);\012  V8_INLINE StatementT ParseTryStatement(bool* ok);\012 StatementT ParseForStatement(ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels,\012 bool* ok);\012 StatementT ParseForEachStatementWithDeclarations(\012 int stmt_pos, ForInfo* for_info, ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels, Scope* inner_block_scope,\012 bool* ok);\012 StatementT ParseForEachStatementWithoutDeclarations(\012 int stmt_pos, ExpressionT expression, int lhs_beg_pos, int lhs_end_pos,\012 ForInfo* for_info, ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels, bool* ok);\012\012 // Parse a C-style for loop: 'for (&lt;init&gt;; &lt;cond&gt;; &lt;next&gt;) { ... }'\012 // &quot;for (&lt;init&gt;;&quot; is assumed to have been parser already.\012 ForStatementT ParseStandardForLoop(\012 int stmt_pos, ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels, ExpressionT* cond,\012 StatementT* next, StatementT* body, bool* ok);\012 // Same as the above, but handles those cases where &lt;init&gt; is a\012 // lexical variable declaration.\012 StatementT ParseStandardForLoopWithLexicalDeclarations(\012 int stmt_pos, StatementT init, ForInfo* for_info,\012 ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels, bool* ok);\012 StatementT ParseForAwaitStatement(ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels,\012 bool* ok);\012\012 bool IsNextLetKeyword();\012 bool IsTrivialExpression();\012\012 // Checks if the expression is a valid reference expression (e.g., on the\012 // left-hand side of assignments). Although ruled out by ECMA as early errors,\012 // we allow calls for web compatibility and rewrite them to a runtime throw.\012 ExpressionT CheckAndRewriteReferenceExpression(\012 ExpressionT expression, int beg_pos, int end_pos,\012 MessageTemplate::Template message, bool* ok);\012 ExpressionT CheckAndRewriteReferenceExpression(\012 ExpressionT expression, int beg_pos, int end_pos,\012 MessageTemplate::Template message, ParseErrorType type, bool* ok);\012\012 bool IsValidReferenceExpression(ExpressionT expression);\012\012 bool IsAssignableIdentifier(ExpressionT expression) {\012 if (!impl()-&gt;IsIdentifier(expression)) return false;\012 if (is_strict(language_mode()) &amp;&amp;\012        impl()-&gt;IsEvalOrArguments(impl()-&gt;AsIdentifier(expression))) {\012 return false;\012 }\012 return true;\012 }\012\012 bool IsValidPattern(ExpressionT expression) {\012 return expression-&gt;IsObjectLiteral() || expression-&gt;IsArrayLiteral();\012 }\012\012 // Due to hoisting, the value of a 'var'-declared variable may actually change\012 // even if the code contains only the &quot;initial&quot; assignment, namely when that\012 // assignment occurs inside a loop.  For example:\012 //\012 //   let i = 10;\012 //   do { var x = i } while (i--):\012 //\012 // As a simple and very conservative approximation of this, we explicitly mark\012 // as maybe-assigned any non-lexical variable whose initializing &quot;declaration&quot;\012 // does not syntactically occur in the function scope.  (In the example above,\012 // it occurs in a block scope.)\012 //\012 // Note that non-lexical variables include temporaries, which may also get\012 // assigned inside a loop due to the various rewritings that the parser\012 // performs.\012 //\012 // This also handles marking of loop variables in for-in and for-of loops,\012 // as determined by declaration_kind.\012 //\012 static void MarkLoopVariableAsAssigned(\012 Scope* scope, Variable* var,\012 typename DeclarationDescriptor::Kind declaration_kind);\012\012 FunctionKind FunctionKindForImpl(bool is_method, bool is_generator,\012 bool is_async) {\012 static const FunctionKind kFunctionKinds[][2][2] = {\012 {\012 // is_method=false\012 {// is_generator=false\012 FunctionKind::kNormalFunction, FunctionKind::kAsyncFunction},\012 {// is_generator=true\012 FunctionKind::kGeneratorFunction,\012 FunctionKind::kAsyncGeneratorFunction},\012 },\012 {\012 // is_method=true\012 {// is_generator=false\012 FunctionKind::kConciseMethod, FunctionKind::kAsyncConciseMethod},\012 {// is_generator=true\012 FunctionKind::kConciseGeneratorMethod,\012 FunctionKind::kAsyncConciseGeneratorMethod},\012 }};\012 return kFunctionKinds[is_method][is_generator][is_async];\012 }\012\012 inline FunctionKind FunctionKindFor(bool is_generator, bool is_async) {\012 const bool kIsMethod = false;\012 return FunctionKindForImpl(kIsMethod, is_generator, is_async);\012 }\012\012 inline FunctionKind MethodKindFor(bool is_generator, bool is_async) {\012 const bool kIsMethod = true;\012 return FunctionKindForImpl(kIsMethod, is_generator, is_async);\012 }\012\012 // Keep track of eval() calls since they disable all local variable\012 // optimizations. This checks if expression is an eval call, and if yes,\012 // forwards the information to scope.\012 Call::PossiblyEval CheckPossibleEvalCall(ExpressionT expression,\012 Scope* scope) {\012 if (impl()-&gt;IsIdentifier(expression) &amp;&amp;\012        impl()-&gt;IsEval(impl()-&gt;AsIdentifier(expression))) {\012      scope-&gt;RecordInnerScopeEvalCall();\012      function_state_-&gt;RecordFunctionOrEvalCall();\012 if (is_sloppy(scope-&gt;language_mode())) {\012 // For sloppy scopes we also have to record the call at function level,\012 // in case it includes declarations that will be hoisted.\012        scope-&gt;GetDeclarationScope()-&gt;RecordEvalCall();\012 }\012\012 // This call is only necessary to track evals that may be\012 // inside arrow function parameter lists. In that case,\012 // Scope::Snapshot::Reparent will move this bit down into\012 // the arrow function's scope.\012      scope-&gt;RecordEvalCall();\012\012 return Call::IS_POSSIBLY_EVAL;\012 }\012 return Call::NOT_EVAL;\012 }\012\012 // Convenience method which determines the type of return statement to emit\012 // depending on the current function type.\012 inline StatementT BuildReturnStatement(ExpressionT expr, int pos,\012 int end_pos = kNoSourcePosition) {\012 if (impl()-&gt;IsNull(expr)) {\012      expr = factory()-&gt;NewUndefinedLiteral(kNoSourcePosition);\012 } else if (is_async_generator()) {\012 // In async generators, if there is an explicit operand to the return\012 // statement, await the operand.\012      expr = factory()-&gt;NewAwait(expr, kNoSourcePosition);\012      function_state_-&gt;AddSuspend();\012 }\012 if (is_async_function()) {\012 return factory()-&gt;NewAsyncReturnStatement(expr, pos, end_pos);\012 }\012 return factory()-&gt;NewReturnStatement(expr, pos, end_pos);\012 }\012\012 // Validation per ES6 object literals.\012 class ObjectLiteralChecker {\012 public:\012 explicit ObjectLiteralChecker(ParserBase* parser)\012 : parser_(parser), has_seen_proto_(false) {}\012\012 void CheckDuplicateProto(Token::Value property);\012\012 private:\012 bool IsProto() const {\012 return this-&gt;scanner()-&gt;CurrentMatchesContextualEscaped(\012 Token::PROTO_UNDERSCORED);\012 }\012\012 ParserBase* parser() const { return parser_; }\012 Scanner* scanner() const { return parser_-&gt;scanner(); }\012\012 ParserBase* parser_;\012 bool has_seen_proto_;\012 };\012\012 // Validation per ES6 class literals.\012 class ClassLiteralChecker {\012 public:\012 explicit ClassLiteralChecker(ParserBase* parser)\012 : parser_(parser), has_seen_constructor_(false) {}\012\012 void CheckClassMethodName(Token::Value property, PropertyKind type,\012 bool is_generator, bool is_async, bool is_static,\012 bool* ok);\012 void CheckClassFieldName(bool is_static, bool* ok);\012\012 private:\012 bool IsConstructor() {\012 return this-&gt;scanner()-&gt;CurrentMatchesContextualEscaped(\012 Token::CONSTRUCTOR);\012 }\012 bool IsPrivateConstructor() {\012 return this-&gt;scanner()-&gt;CurrentMatchesContextualEscaped(\012 Token::PRIVATE_CONSTRUCTOR);\012 }\012 bool IsPrototype() {\012 return this-&gt;scanner()-&gt;CurrentMatchesContextualEscaped(Token::PROTOTYPE);\012 }\012\012 ParserBase* parser() const { return parser_; }\012 Scanner* scanner() const { return parser_-&gt;scanner(); }\012\012 ParserBase* parser_;\012 bool has_seen_constructor_;\012 };\012\012 ModuleDescriptor* module() const {\012 return scope()-&gt;AsModuleScope()-&gt;module();\012 }\012 Scope* scope() const { return scope_; }\012\012 // Stack of expression classifiers.\012 // The top of the stack is always pointed to by classifier().\012  V8_INLINE ExpressionClassifier* classifier() const {\012    DCHECK_NOT_NULL(classifier_);\012 return classifier_;\012 }\012\012 // Accumulates the classifier that is on top of the stack (inner) to\012 // the one that is right below (outer) and pops the inner.\012  V8_INLINE void Accumulate(unsigned productions) {\012    DCHECK_NOT_NULL(classifier_);\012 ExpressionClassifier* previous = classifier_-&gt;previous();\012    DCHECK_NOT_NULL(previous);\012    previous-&gt;Accumulate(classifier_, productions);\012    classifier_ = previous;\012 }\012\012  V8_INLINE void AccumulateNonBindingPatternErrors() {\012 this-&gt;Accumulate(ExpressionClassifier::AllProductions &amp;\012 ~(ExpressionClassifier::BindingPatternProduction |\012 ExpressionClassifier::LetPatternProduction));\012 }\012\012 // Pops and discards the classifier that is on top of the stack\012 // without accumulating.\012  V8_INLINE void DiscardExpressionClassifier() {\012    DCHECK_NOT_NULL(classifier_);\012    classifier_-&gt;Discard();\012    classifier_ = classifier_-&gt;previous();\012 }\012\012 // Accumulate errors that can be arbitrarily deep in an expression.\012 // These correspond to the ECMAScript spec's 'Contains' operation\012 // on productions. This includes:\012 //\012 // - YieldExpression is disallowed in arrow parameters in a generator.\012 // - AwaitExpression is disallowed in arrow parameters in an async function.\012 // - AwaitExpression is disallowed in async arrow parameters.\012 //\012  V8_INLINE void AccumulateFormalParameterContainmentErrors() {\012 Accumulate(ExpressionClassifier::FormalParameterInitializerProduction |\012 ExpressionClassifier::AsyncArrowFormalParametersProduction);\012 }\012\012 // Parser base's protected field members.\012\012 Scope* scope_; // Scope stack.\012 Scope* original_scope_; // The top scope for the current parsing item.\012 FunctionState* function_state_; // Function state stack.\012  v8::Extension* extension_;\012 FuncNameInferrer* fni_;\012 AstValueFactory* ast_value_factory_; // Not owned.\012 typename Types::Factory ast_node_factory_;\012 RuntimeCallStats* runtime_call_stats_;\012 internal::Logger* logger_;\012 bool parsing_on_main_thread_;\012 const bool parsing_module_;\012 uintptr_t stack_limit_;\012 PendingCompilationErrorHandler* pending_error_handler_;\012\012 // Parser base's private field members.\012\012 private:\012 Zone* zone_;\012 ExpressionClassifier* classifier_;\012\012 Scanner* scanner_;\012\012 FunctionLiteral::EagerCompileHint default_eager_compile_hint_;\012\012 int function_literal_id_;\012 int script_id_;\012\012 bool allow_natives_;\012 bool allow_harmony_do_expressions_;\012 bool allow_harmony_public_fields_;\012 bool allow_harmony_static_fields_;\012 bool allow_harmony_dynamic_import_;\012 bool allow_harmony_import_meta_;\012 bool allow_harmony_private_fields_;\012 bool allow_eval_cache_;\012\012 friend class DiscardableZoneScope;\012};\012\012template &lt;typename Impl&gt;\012ParserBase&lt;Impl&gt;::FunctionState::FunctionState(\012 FunctionState** function_state_stack, Scope** scope_stack,\012 DeclarationScope* scope)\012 : BlockState(scope_stack, scope),\012      expected_property_count_(0),\012      suspend_count_(0),\012      function_state_stack_(function_state_stack),\012      outer_function_state_(*function_state_stack),\012      scope_(scope),\012      destructuring_assignments_to_rewrite_(scope-&gt;zone()),\012      reported_errors_(scope_-&gt;zone()),\012      dont_optimize_reason_(BailoutReason::kNoReason),\012      next_function_is_likely_called_(false),\012      previous_function_was_likely_called_(false),\012      contains_function_or_eval_(false) {\012 *function_state_stack = this;\012  reported_errors_.reserve(16);\012 if (outer_function_state_) {\012    outer_function_state_-&gt;previous_function_was_likely_called_ =\012        outer_function_state_-&gt;next_function_is_likely_called_;\012    outer_function_state_-&gt;next_function_is_likely_called_ = false;\012 }\012}\012\012template &lt;typename Impl&gt;\012ParserBase&lt;Impl&gt;::FunctionState::~FunctionState() {\012 *function_state_stack_ = outer_function_state_;\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::GetUnexpectedTokenMessage(\012 Token::Value token, MessageTemplate::Template* message,\012 Scanner::Location* location, const char** arg,\012 MessageTemplate::Template default_) {\012 *arg = nullptr;\012 switch (token) {\012 case Token::EOS:\012 *message = MessageTemplate::kUnexpectedEOS;\012 break;\012 case Token::SMI:\012 case Token::NUMBER:\012 case Token::BIGINT:\012 *message = MessageTemplate::kUnexpectedTokenNumber;\012 break;\012 case Token::STRING:\012 *message = MessageTemplate::kUnexpectedTokenString;\012 break;\012 case Token::PRIVATE_NAME:\012 case Token::IDENTIFIER:\012 *message = MessageTemplate::kUnexpectedTokenIdentifier;\012 break;\012 case Token::AWAIT:\012 case Token::ENUM:\012 *message = MessageTemplate::kUnexpectedReserved;\012 break;\012 case Token::LET:\012 case Token::STATIC:\012 case Token::YIELD:\012 case Token::FUTURE_STRICT_RESERVED_WORD:\012 *message = is_strict(language_mode())\012 ? MessageTemplate::kUnexpectedStrictReserved\012 : MessageTemplate::kUnexpectedTokenIdentifier;\012 break;\012 case Token::TEMPLATE_SPAN:\012 case Token::TEMPLATE_TAIL:\012 *message = MessageTemplate::kUnexpectedTemplateString;\012 break;\012 case Token::ESCAPED_STRICT_RESERVED_WORD:\012 case Token::ESCAPED_KEYWORD:\012 *message = MessageTemplate::kInvalidEscapedReservedWord;\012 break;\012 case Token::ILLEGAL:\012 if (scanner()-&gt;has_error()) {\012 *message = scanner()-&gt;error();\012 *location = scanner()-&gt;error_location();\012 } else {\012 *message = MessageTemplate::kInvalidOrUnexpectedToken;\012 }\012 break;\012 case Token::REGEXP_LITERAL:\012 *message = MessageTemplate::kUnexpectedTokenRegExp;\012 break;\012 default:\012 const char* name = Token::String(token);\012      DCHECK_NOT_NULL(name);\012 *arg = name;\012 break;\012 }\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::ReportUnexpectedToken(Token::Value token) {\012 return ReportUnexpectedTokenAt(scanner_-&gt;location(), token);\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::ReportUnexpectedTokenAt(\012 Scanner::Location source_location, Token::Value token,\012 MessageTemplate::Template message) {\012 const char* arg;\012 GetUnexpectedTokenMessage(token, &amp;message, &amp;source_location, &amp;arg);\012  impl()-&gt;ReportMessageAt(source_location, message, arg);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::IdentifierT ParserBase&lt;Impl&gt;::ParseIdentifier(\012 AllowRestrictedIdentifiers allow_restricted_identifiers, bool* ok) {\012 ExpressionClassifier classifier(this);\012 auto result = ParseAndClassifyIdentifier(CHECK_OK_CUSTOM(NullIdentifier));\012\012 if (allow_restricted_identifiers == kDontAllowRestrictedIdentifiers) {\012 ValidateAssignmentPattern(CHECK_OK_CUSTOM(NullIdentifier));\012 ValidateBindingPattern(CHECK_OK_CUSTOM(NullIdentifier));\012 }\012\012 return result;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::IdentifierT\012ParserBase&lt;Impl&gt;::ParseAndClassifyIdentifier(bool* ok) {\012 Token::Value next = Next();\012 if (next == Token::IDENTIFIER || next == Token::ASYNC ||\012 (next == Token::AWAIT &amp;&amp; !parsing_module_ &amp;&amp; !is_async_function())) {\012 IdentifierT name = impl()-&gt;GetSymbol();\012\012 if (impl()-&gt;IsArguments(name) &amp;&amp; scope()-&gt;ShouldBanArguments()) {\012 ReportMessage(MessageTemplate::kArgumentsDisallowedInInitializer);\012 *ok = false;\012 return impl()-&gt;NullIdentifier();\012 }\012\012 // When this function is used to read a formal parameter, we don't always\012 // know whether the function is going to be strict or sloppy.  Indeed for\012 // arrow functions we don't always know that the identifier we are reading\012 // is actually a formal parameter.  Therefore besides the errors that we\012 // must detect because we know we're in strict mode, we also record any\012 // error that we might make in the future once we know the language mode.\012 if (impl()-&gt;IsEvalOrArguments(name)) {\012      classifier()-&gt;RecordStrictModeFormalParameterError(\012          scanner()-&gt;location(), MessageTemplate::kStrictEvalArguments);\012 if (is_strict(language_mode())) {\012        classifier()-&gt;RecordBindingPatternError(\012            scanner()-&gt;location(), MessageTemplate::kStrictEvalArguments);\012 }\012 } else if (next == Token::AWAIT) {\012      classifier()-&gt;RecordAsyncArrowFormalParametersError(\012          scanner()-&gt;location(), MessageTemplate::kAwaitBindingIdentifier);\012 }\012\012 if (classifier()-&gt;duplicate_finder() != nullptr &amp;&amp;\012        scanner()-&gt;IsDuplicateSymbol(classifier()-&gt;duplicate_finder(),\012                                     ast_value_factory())) {\012      classifier()-&gt;RecordDuplicateFormalParameterError(scanner()-&gt;location());\012 }\012 return name;\012 } else if (is_sloppy(language_mode()) &amp;&amp;\012 (next == Token::FUTURE_STRICT_RESERVED_WORD ||\012 next == Token::ESCAPED_STRICT_RESERVED_WORD ||\012 next == Token::LET || next == Token::STATIC ||\012 (next == Token::YIELD &amp;&amp; !is_generator()))) {\012    classifier()-&gt;RecordStrictModeFormalParameterError(\012        scanner()-&gt;location(), MessageTemplate::kUnexpectedStrictReserved);\012 if (next == Token::ESCAPED_STRICT_RESERVED_WORD &amp;&amp;\012        is_strict(language_mode())) {\012 ReportUnexpectedToken(next);\012 *ok = false;\012 return impl()-&gt;NullIdentifier();\012 }\012 if (scanner()-&gt;IsLet()) {\012      classifier()-&gt;RecordLetPatternError(\012          scanner()-&gt;location(), MessageTemplate::kLetInLexicalBinding);\012 }\012 return impl()-&gt;GetSymbol();\012 } else {\012 ReportUnexpectedToken(next);\012 *ok = false;\012 return impl()-&gt;NullIdentifier();\012 }\012}\012\012template &lt;class Impl&gt;\012typename ParserBase&lt;Impl&gt;::IdentifierT\012ParserBase&lt;Impl&gt;::ParseIdentifierOrStrictReservedWord(\012 FunctionKind function_kind, bool* is_strict_reserved, bool* is_await,\012 bool* ok) {\012 Token::Value next = Next();\012 if (next == Token::IDENTIFIER || (next == Token::AWAIT &amp;&amp; !parsing_module_ &amp;&amp;\012 !IsAsyncFunction(function_kind)) ||\012 next == Token::ASYNC) {\012 *is_strict_reserved = false;\012 *is_await = next == Token::AWAIT;\012 } else if (next == Token::ESCAPED_STRICT_RESERVED_WORD ||\012 next == Token::FUTURE_STRICT_RESERVED_WORD || next == Token::LET ||\012 next == Token::STATIC ||\012 (next == Token::YIELD &amp;&amp; !IsGeneratorFunction(function_kind))) {\012 *is_strict_reserved = true;\012 } else {\012 ReportUnexpectedToken(next);\012 *ok = false;\012 return impl()-&gt;NullIdentifier();\012 }\012\012 return impl()-&gt;GetSymbol();\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::IdentifierT ParserBase&lt;Impl&gt;::ParseIdentifierName(\012 bool* ok) {\012 Token::Value next = Next();\012 if (next != Token::IDENTIFIER &amp;&amp; next != Token::ASYNC &amp;&amp;\012 next != Token::ENUM &amp;&amp; next != Token::AWAIT &amp;&amp; next != Token::LET &amp;&amp;\012 next != Token::STATIC &amp;&amp; next != Token::YIELD &amp;&amp;\012 next != Token::FUTURE_STRICT_RESERVED_WORD &amp;&amp;\012 next != Token::ESCAPED_KEYWORD &amp;&amp;\012 next != Token::ESCAPED_STRICT_RESERVED_WORD &amp;&amp; !Token::IsKeyword(next)) {\012 ReportUnexpectedToken(next);\012 *ok = false;\012 return impl()-&gt;NullIdentifier();\012 }\012\012 return impl()-&gt;GetSymbol();\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT\012ParserBase&lt;Impl&gt;::ParseIdentifierNameOrPrivateName(bool* ok) {\012 int pos = position();\012 IdentifierT name;\012 ExpressionT key;\012 if (allow_harmony_private_fields() &amp;&amp; peek() == Token::PRIVATE_NAME) {\012 Consume(Token::PRIVATE_NAME);\012    name = impl()-&gt;GetSymbol();\012 auto key_proxy =\012        impl()-&gt;ExpressionFromIdentifier(name, pos, InferName::kNo);\012    key_proxy-&gt;set_is_private_field();\012    key = key_proxy;\012 } else {\012    name = ParseIdentifierName(CHECK_OK);\012    key = factory()-&gt;NewStringLiteral(name, pos);\012 }\012  impl()-&gt;PushLiteralName(name);\012 return key;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParseRegExpLiteral(\012 bool* ok) {\012 int pos = peek_position();\012 if (!scanner()-&gt;ScanRegExpPattern()) {\012 Next();\012 ReportMessage(MessageTemplate::kUnterminatedRegExp);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012\012 IdentifierT js_pattern = impl()-&gt;GetNextSymbol();\012 Maybe&lt;RegExp::Flags&gt; flags = scanner()-&gt;ScanRegExpFlags();\012 if (flags.IsNothing()) {\012 Next();\012 ReportMessage(MessageTemplate::kMalformedRegExpFlags);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012 int js_flags = flags.FromJust();\012 Next();\012 return factory()-&gt;NewRegExpLiteral(js_pattern, js_flags, pos);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParsePrimaryExpression(\012 bool* is_async, bool* ok) {\012 // PrimaryExpression ::\012 //   'this'\012 //   'null'\012 //   'true'\012 //   'false'\012 //   Identifier\012 //   Number\012 //   String\012 //   ArrayLiteral\012 //   ObjectLiteral\012 //   RegExpLiteral\012 //   ClassLiteral\012 //   '(' Expression ')'\012 //   TemplateLiteral\012 //   do Block\012 //   AsyncFunctionLiteral\012\012 int beg_pos = peek_position();\012 switch (peek()) {\012 case Token::THIS: {\012 BindingPatternUnexpectedToken();\012 Consume(Token::THIS);\012 return impl()-&gt;ThisExpression(beg_pos);\012 }\012\012 case Token::NULL_LITERAL:\012 case Token::TRUE_LITERAL:\012 case Token::FALSE_LITERAL:\012 case Token::SMI:\012 case Token::NUMBER:\012 case Token::BIGINT:\012 BindingPatternUnexpectedToken();\012 return impl()-&gt;ExpressionFromLiteral(Next(), beg_pos);\012\012 case Token::ASYNC:\012 if (!scanner()-&gt;HasLineTerminatorAfterNext() &amp;&amp;\012 PeekAhead() == Token::FUNCTION) {\012 BindingPatternUnexpectedToken();\012 Consume(Token::ASYNC);\012 return ParseAsyncFunctionLiteral(CHECK_OK);\012 }\012 // CoverCallExpressionAndAsyncArrowHead\012 *is_async = true;\012      V8_FALLTHROUGH;\012 case Token::IDENTIFIER:\012 case Token::LET:\012 case Token::STATIC:\012 case Token::YIELD:\012 case Token::AWAIT:\012 case Token::ESCAPED_STRICT_RESERVED_WORD:\012 case Token::FUTURE_STRICT_RESERVED_WORD: {\012 // Using eval or arguments in this context is OK even in strict mode.\012 IdentifierT name = ParseAndClassifyIdentifier(CHECK_OK);\012 return impl()-&gt;ExpressionFromIdentifier(name, beg_pos);\012 }\012\012 case Token::STRING: {\012 BindingPatternUnexpectedToken();\012 Consume(Token::STRING);\012 return impl()-&gt;ExpressionFromString(beg_pos);\012 }\012\012 case Token::ASSIGN_DIV:\012 case Token::DIV:\012      classifier()-&gt;RecordBindingPatternError(\012          scanner()-&gt;peek_location(), MessageTemplate::kUnexpectedTokenRegExp);\012 return ParseRegExpLiteral(ok);\012\012 case Token::LBRACK:\012 return ParseArrayLiteral(ok);\012\012 case Token::LBRACE:\012 return ParseObjectLiteral(ok);\012\012 case Token::LPAREN: {\012 // Arrow function formal parameters are either a single identifier or a\012 // list of BindingPattern productions enclosed in parentheses.\012 // Parentheses are not valid on the LHS of a BindingPattern, so we use the\012 // is_valid_binding_pattern() check to detect multiple levels of\012 // parenthesization.\012 bool pattern_error = !classifier()-&gt;is_valid_binding_pattern();\012      classifier()-&gt;RecordPatternError(scanner()-&gt;peek_location(),\012 MessageTemplate::kUnexpectedToken,\012 Token::String(Token::LPAREN));\012 if (pattern_error) ArrowFormalParametersUnexpectedToken();\012 Consume(Token::LPAREN);\012 if (Check(Token::RPAREN)) {\012 // ()=&gt;x.  The continuation that looks for the =&gt; is in\012 // ParseAssignmentExpression.\012        classifier()-&gt;RecordExpressionError(scanner()-&gt;location(),\012 MessageTemplate::kUnexpectedToken,\012 Token::String(Token::RPAREN));\012 return factory()-&gt;NewEmptyParentheses(beg_pos);\012 }\012 // Heuristically try to detect immediately called functions before\012 // seeing the call parentheses.\012 if (peek() == Token::FUNCTION ||\012 (peek() == Token::ASYNC &amp;&amp; PeekAhead() == Token::FUNCTION)) {\012        function_state_-&gt;set_next_function_is_likely_called();\012 }\012 ExpressionT expr = ParseExpressionCoverGrammar(true, CHECK_OK);\012 Expect(Token::RPAREN, CHECK_OK);\012 return expr;\012 }\012\012 case Token::CLASS: {\012 BindingPatternUnexpectedToken();\012 Consume(Token::CLASS);\012 int class_token_pos = position();\012 IdentifierT name = impl()-&gt;NullIdentifier();\012 bool is_strict_reserved_name = false;\012 Scanner::Location class_name_location = Scanner::Location::invalid();\012 if (peek_any_identifier()) {\012 bool is_await = false;\012        name = ParseIdentifierOrStrictReservedWord(&amp;is_strict_reserved_name,\012 &amp;is_await, CHECK_OK);\012        class_name_location = scanner()-&gt;location();\012 if (is_await) {\012          classifier()-&gt;RecordAsyncArrowFormalParametersError(\012              scanner()-&gt;location(), MessageTemplate::kAwaitBindingIdentifier);\012 }\012 }\012 return ParseClassLiteral(name, class_name_location,\012                               is_strict_reserved_name, class_token_pos, ok);\012 }\012\012 case Token::TEMPLATE_SPAN:\012 case Token::TEMPLATE_TAIL:\012 BindingPatternUnexpectedToken();\012 return ParseTemplateLiteral(impl()-&gt;NullExpression(), beg_pos, false, ok);\012\012 case Token::MOD:\012 if (allow_natives() || extension_ != nullptr) {\012 BindingPatternUnexpectedToken();\012 return ParseV8Intrinsic(ok);\012 }\012 break;\012\012 case Token::DO:\012 if (allow_harmony_do_expressions()) {\012 BindingPatternUnexpectedToken();\012 return ParseDoExpression(ok);\012 }\012 break;\012\012 default:\012 break;\012 }\012\012 ReportUnexpectedToken(Next());\012 *ok = false;\012 return impl()-&gt;NullExpression();\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParseExpression(\012 bool accept_IN, bool* ok) {\012 ExpressionClassifier classifier(this);\012 ExpressionT result = ParseExpressionCoverGrammar(accept_IN, CHECK_OK);\012 ValidateExpression(CHECK_OK);\012 return result;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT\012ParserBase&lt;Impl&gt;::ParseExpressionCoverGrammar(bool accept_IN, bool* ok) {\012 // Expression ::\012 //   AssignmentExpression\012 //   Expression ',' AssignmentExpression\012\012 ExpressionT result = impl()-&gt;NullExpression();\012 while (true) {\012 int comma_pos = position();\012 ExpressionClassifier binding_classifier(this);\012 ExpressionT right;\012 if (Check(Token::ELLIPSIS)) {\012 // 'x, y, ...z' in CoverParenthesizedExpressionAndArrowParameterList only\012 // as the formal parameters of'(x, y, ...z) =&gt; foo', and is not itself a\012 // valid expression.\012      classifier()-&gt;RecordExpressionError(scanner()-&gt;location(),\012 MessageTemplate::kUnexpectedToken,\012 Token::String(Token::ELLIPSIS));\012 int ellipsis_pos = position();\012 int pattern_pos = peek_position();\012 ExpressionT pattern = ParsePrimaryExpression(CHECK_OK);\012 if (peek() == Token::ASSIGN) {\012 ReportMessage(MessageTemplate::kRestDefaultInitializer);\012 *ok = false;\012 return result;\012 }\012 ValidateBindingPattern(CHECK_OK);\012      right = factory()-&gt;NewSpread(pattern, ellipsis_pos, pattern_pos);\012 } else {\012      right = ParseAssignmentExpression(accept_IN, CHECK_OK);\012 }\012 // No need to accumulate binding pattern-related errors, since\012 // an Expression can't be a binding pattern anyway.\012 AccumulateNonBindingPatternErrors();\012 if (!impl()-&gt;IsIdentifier(right)) classifier()-&gt;RecordNonSimpleParameter();\012 if (impl()-&gt;IsNull(result)) {\012 // First time through the loop.\012      result = right;\012 } else if (impl()-&gt;CollapseNaryExpression(&amp;result, right, Token::COMMA,\012                                              comma_pos,\012 SourceRange::Empty())) {\012 // Do nothing, &quot;result&quot; is already updated.\012 } else {\012      result =\012          factory()-&gt;NewBinaryOperation(Token::COMMA, result, right, comma_pos);\012 }\012\012 if (!Check(Token::COMMA)) break;\012\012 if (right-&gt;IsSpread()) {\012      classifier()-&gt;RecordArrowFormalParametersError(\012          scanner()-&gt;location(), MessageTemplate::kParamAfterRest);\012 }\012\012 if (peek() == Token::RPAREN &amp;&amp; PeekAhead() == Token::ARROW) {\012 // a trailing comma is allowed at the end of an arrow parameter list\012 break;\012 }\012\012 // Pass on the 'set_next_function_is_likely_called' flag if we have\012 // several function literals separated by comma.\012 if (peek() == Token::FUNCTION &amp;&amp;\012        function_state_-&gt;previous_function_was_likely_called()) {\012      function_state_-&gt;set_next_function_is_likely_called();\012 }\012 }\012\012 return result;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParseArrayLiteral(\012 bool* ok) {\012 // ArrayLiteral ::\012 //   '[' Expression? (',' Expression?)* ']'\012\012 int pos = peek_position();\012 ExpressionListT values = impl()-&gt;NewExpressionList(4);\012 int first_spread_index = -1;\012 Expect(Token::LBRACK, CHECK_OK);\012 while (peek() != Token::RBRACK) {\012 ExpressionT elem;\012 if (peek() == Token::COMMA) {\012      elem = factory()-&gt;NewTheHoleLiteral();\012 } else if (peek() == Token::ELLIPSIS) {\012 int start_pos = peek_position();\012 Consume(Token::ELLIPSIS);\012 int expr_pos = peek_position();\012 ExpressionT argument = ParseAssignmentExpression(true, CHECK_OK);\012      elem = factory()-&gt;NewSpread(argument, start_pos, expr_pos);\012\012 if (first_spread_index &lt; 0) {\012        first_spread_index = values-&gt;length();\012 }\012\012 if (argument-&gt;IsAssignment()) {\012        classifier()-&gt;RecordPatternError(\012 Scanner::Location(start_pos, scanner()-&gt;location().end_pos),\012 MessageTemplate::kInvalidDestructuringTarget);\012 } else {\012 CheckDestructuringElement(argument, start_pos,\012                                  scanner()-&gt;location().end_pos);\012 }\012\012 if (peek() == Token::COMMA) {\012        classifier()-&gt;RecordPatternError(\012 Scanner::Location(start_pos, scanner()-&gt;location().end_pos),\012 MessageTemplate::kElementAfterRest);\012 }\012 } else {\012 int beg_pos = peek_position();\012      elem = ParseAssignmentExpression(true, CHECK_OK);\012 CheckDestructuringElement(elem, beg_pos, scanner()-&gt;location().end_pos);\012 }\012    values-&gt;Add(elem, zone_);\012 if (peek() != Token::RBRACK) {\012 Expect(Token::COMMA, CHECK_OK);\012 }\012 }\012 Expect(Token::RBRACK, CHECK_OK);\012\012 return factory()-&gt;NewArrayLiteral(values, first_spread_index, pos);\012}\012\012template &lt;class Impl&gt;\012bool ParserBase&lt;Impl&gt;::SetPropertyKindFromToken(Token::Value token,\012 PropertyKind* kind) {\012 // This returns true, setting the property kind, iff the given token is one\012 // which must occur after a property name, indicating that the previous token\012 // was in fact a name and not a modifier (like the &quot;get&quot; in &quot;get x&quot;).\012 switch (token) {\012 case Token::COLON:\012 *kind = PropertyKind::kValueProperty;\012 return true;\012 case Token::COMMA:\012 case Token::RBRACE:\012 case Token::ASSIGN:\012 *kind = PropertyKind::kShorthandProperty;\012 return true;\012 case Token::LPAREN:\012 *kind = PropertyKind::kMethodProperty;\012 return true;\012 case Token::MUL:\012 case Token::SEMICOLON:\012 *kind = PropertyKind::kClassField;\012 return true;\012 case Token::PRIVATE_NAME:\012 *kind = PropertyKind::kClassField;\012 return true;\012 default:\012 break;\012 }\012 return false;\012}\012\012template &lt;class Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParsePropertyName(\012 IdentifierT* name, PropertyKind* kind, bool* is_generator, bool* is_get,\012 bool* is_set, bool* is_async, bool* is_computed_name, bool* ok) {\012  DCHECK_EQ(*kind, PropertyKind::kNotSet);\012  DCHECK(!*is_generator);\012  DCHECK(!*is_get);\012  DCHECK(!*is_set);\012  DCHECK(!*is_async);\012  DCHECK(!*is_computed_name);\012\012 *is_generator = Check(Token::MUL);\012 if (*is_generator) {\012 *kind = PropertyKind::kMethodProperty;\012 }\012\012 Token::Value token = peek();\012 int pos = peek_position();\012\012 if (!*is_generator &amp;&amp; token == Token::ASYNC &amp;&amp;\012 !scanner()-&gt;HasLineTerminatorAfterNext()) {\012 Consume(Token::ASYNC);\012    token = peek();\012 if (token == Token::MUL &amp;&amp; !scanner()-&gt;HasLineTerminatorBeforeNext()) {\012 Consume(Token::MUL);\012      token = peek();\012 *is_generator = true;\012 } else if (SetPropertyKindFromToken(token, kind)) {\012 *name = impl()-&gt;GetSymbol(); // TODO(bakkot) specialize on 'async'\012      impl()-&gt;PushLiteralName(*name);\012 return factory()-&gt;NewStringLiteral(*name, pos);\012 }\012 *kind = PropertyKind::kMethodProperty;\012 *is_async = true;\012    pos = peek_position();\012 }\012\012 if (token == Token::IDENTIFIER &amp;&amp; !*is_generator &amp;&amp; !*is_async) {\012 // This is checking for 'get' and 'set' in particular.\012 Consume(Token::IDENTIFIER);\012    token = peek();\012 if (SetPropertyKindFromToken(token, kind) ||\012 !scanner()-&gt;IsGetOrSet(is_get, is_set)) {\012 *name = impl()-&gt;GetSymbol();\012      impl()-&gt;PushLiteralName(*name);\012 return factory()-&gt;NewStringLiteral(*name, pos);\012 }\012 *kind = PropertyKind::kAccessorProperty;\012    pos = peek_position();\012 }\012\012 // For non computed property names we normalize the name a bit:\012 //\012 //   &quot;12&quot; -&gt; 12\012 //   12.3 -&gt; &quot;12.3&quot;\012 //   12.30 -&gt; &quot;12.3&quot;\012 //   identifier -&gt; &quot;identifier&quot;\012 //\012 // This is important because we use the property name as a key in a hash\012 // table when we compute constant properties.\012 ExpressionT expression = impl()-&gt;NullExpression();\012 switch (token) {\012 case Token::STRING:\012 Consume(Token::STRING);\012 *name = impl()-&gt;GetSymbol();\012 break;\012\012 case Token::SMI:\012 Consume(Token::SMI);\012 *name = impl()-&gt;GetNumberAsSymbol();\012 break;\012\012 case Token::NUMBER:\012 Consume(Token::NUMBER);\012 *name = impl()-&gt;GetNumberAsSymbol();\012 break;\012\012 case Token::LBRACK: {\012 *name = impl()-&gt;NullIdentifier();\012 *is_computed_name = true;\012 Consume(Token::LBRACK);\012 ExpressionClassifier computed_name_classifier(this);\012      expression = ParseAssignmentExpression(true, CHECK_OK);\012 ValidateExpression(CHECK_OK);\012 AccumulateFormalParameterContainmentErrors();\012 Expect(Token::RBRACK, CHECK_OK);\012 break;\012 }\012\012 case Token::ELLIPSIS:\012 if (!*is_generator &amp;&amp; !*is_async &amp;&amp; !*is_get &amp;&amp; !*is_set) {\012 *name = impl()-&gt;NullIdentifier();\012 Consume(Token::ELLIPSIS);\012        expression = ParseAssignmentExpression(true, CHECK_OK);\012 *kind = PropertyKind::kSpreadProperty;\012\012 if (!impl()-&gt;IsIdentifier(expression)) {\012          classifier()-&gt;RecordBindingPatternError(\012              scanner()-&gt;location(),\012 MessageTemplate::kInvalidRestBindingPattern);\012 }\012\012 if (!expression-&gt;IsValidReferenceExpression()) {\012          classifier()-&gt;RecordAssignmentPatternError(\012              scanner()-&gt;location(),\012 MessageTemplate::kInvalidRestAssignmentPattern);\012 }\012\012 if (peek() != Token::RBRACE) {\012          classifier()-&gt;RecordPatternError(scanner()-&gt;location(),\012 MessageTemplate::kElementAfterRest);\012 }\012 return expression;\012 }\012      V8_FALLTHROUGH;\012\012 default:\012 *name = ParseIdentifierName(CHECK_OK);\012 break;\012 }\012\012 if (*kind == PropertyKind::kNotSet) {\012 SetPropertyKindFromToken(peek(), kind);\012 }\012\012 if (*is_computed_name) {\012 return expression;\012 }\012\012  impl()-&gt;PushLiteralName(*name);\012\012 uint32_t index;\012 return impl()-&gt;IsArrayIndex(*name, &amp;index)\012 ? factory()-&gt;NewNumberLiteral(index, pos)\012 : factory()-&gt;NewStringLiteral(*name, pos);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ClassLiteralPropertyT\012ParserBase&lt;Impl&gt;::ParseClassPropertyDefinition(\012 ClassLiteralChecker* checker, ClassInfo* class_info, IdentifierT* name,\012 bool has_extends, bool* is_computed_name,\012 ClassLiteralProperty::Kind* property_kind, bool* is_static, bool* ok) {\012  DCHECK_NOT_NULL(class_info);\012 bool is_get = false;\012 bool is_set = false;\012 bool is_generator = false;\012 bool is_async = false;\012 *is_static = false;\012 *property_kind = ClassLiteralProperty::METHOD;\012 PropertyKind kind = PropertyKind::kNotSet;\012\012 Token::Value name_token = peek();\012  DCHECK_IMPLIES(name_token == Token::PRIVATE_NAME,\012                 allow_harmony_private_fields());\012\012 int name_token_position = scanner()-&gt;peek_location().beg_pos;\012 *name = impl()-&gt;NullIdentifier();\012 ExpressionT name_expression;\012 if (name_token == Token::STATIC) {\012 Consume(Token::STATIC);\012    name_token_position = scanner()-&gt;peek_location().beg_pos;\012 if (peek() == Token::LPAREN) {\012      kind = PropertyKind::kMethodProperty;\012 *name = impl()-&gt;GetSymbol(); // TODO(bakkot) specialize on 'static'\012      name_expression = factory()-&gt;NewStringLiteral(*name, position());\012 } else if (peek() == Token::ASSIGN || peek() == Token::SEMICOLON ||\012               peek() == Token::RBRACE) {\012 *name = impl()-&gt;GetSymbol(); // TODO(bakkot) specialize on 'static'\012      name_expression = factory()-&gt;NewStringLiteral(*name, position());\012 } else if (peek() == Token::PRIVATE_NAME) {\012      DCHECK(allow_harmony_private_fields());\012 // TODO(gsathya): Make a better error message for this.\012 ReportUnexpectedToken(Next());\012 *ok = false;\012 return impl()-&gt;NullLiteralProperty();\012 } else {\012 *is_static = true;\012      name_expression = ParsePropertyName(name, &amp;kind, &amp;is_generator, &amp;is_get,\012 &amp;is_set, &amp;is_async, is_computed_name,\012                                          CHECK_OK_CUSTOM(NullLiteralProperty));\012 }\012 } else if (name_token == Token::PRIVATE_NAME) {\012 Consume(Token::PRIVATE_NAME);\012 *name = impl()-&gt;GetSymbol();\012    name_expression = factory()-&gt;NewStringLiteral(*name, position());\012 } else {\012    name_expression = ParsePropertyName(name, &amp;kind, &amp;is_generator, &amp;is_get,\012 &amp;is_set, &amp;is_async, is_computed_name,\012                                        CHECK_OK_CUSTOM(NullLiteralProperty));\012 }\012\012 if (!class_info-&gt;has_name_static_property &amp;&amp; *is_static &amp;&amp;\012      impl()-&gt;IsName(*name)) {\012    class_info-&gt;has_name_static_property = true;\012 }\012\012 switch (kind) {\012 case PropertyKind::kClassField:\012 case PropertyKind::kNotSet: // This case is a name followed by a name or\012 // other property. Here we have to assume\012 // that's an uninitialized field followed by a\012 // linebreak followed by a property, with ASI\012 // adding the semicolon. If not, there will be\012 // a syntax error after parsing the first name\012 // as an uninitialized field.\012 case PropertyKind::kShorthandProperty:\012 case PropertyKind::kValueProperty:\012 if (allow_harmony_public_fields() || allow_harmony_private_fields()) {\012 *property_kind = name_token == Token::PRIVATE_NAME\012 ? ClassLiteralProperty::PRIVATE_FIELD\012 : ClassLiteralProperty::PUBLIC_FIELD;\012 if (*is_static &amp;&amp; !allow_harmony_static_fields()) {\012 ReportUnexpectedToken(Next());\012 *ok = false;\012 return impl()-&gt;NullLiteralProperty();\012 }\012 if (!*is_computed_name) {\012          checker-&gt;CheckClassFieldName(*is_static,\012                                       CHECK_OK_CUSTOM(NullLiteralProperty));\012 }\012 ExpressionT initializer = ParseClassFieldInitializer(\012            class_info, *is_static, CHECK_OK_CUSTOM(NullLiteralProperty));\012 ExpectSemicolon(CHECK_OK_CUSTOM(NullLiteralProperty));\012 ClassLiteralPropertyT result = factory()-&gt;NewClassLiteralProperty(\012            name_expression, initializer, *property_kind, *is_static,\012 *is_computed_name);\012        impl()-&gt;SetFunctionNameFromPropertyName(result, *name);\012 return result;\012\012 } else {\012 ReportUnexpectedToken(Next());\012 *ok = false;\012 return impl()-&gt;NullLiteralProperty();\012 }\012\012 case PropertyKind::kMethodProperty: {\012      DCHECK(!is_get &amp;&amp; !is_set);\012\012 // MethodDefinition\012 //    PropertyName '(' StrictFormalParameters ')' '{' FunctionBody '}'\012 //    '*' PropertyName '(' StrictFormalParameters ')' '{' FunctionBody '}'\012 //    async PropertyName '(' StrictFormalParameters ')'\012 //        '{' FunctionBody '}'\012 //    async '*' PropertyName '(' StrictFormalParameters ')'\012 //        '{' FunctionBody '}'\012\012 if (!*is_computed_name) {\012        checker-&gt;CheckClassMethodName(name_token, PropertyKind::kMethodProperty,\012                                      is_generator, is_async, *is_static,\012                                      CHECK_OK_CUSTOM(NullLiteralProperty));\012 }\012\012 FunctionKind kind = MethodKindFor(is_generator, is_async);\012\012 if (!*is_static &amp;&amp; impl()-&gt;IsConstructor(*name)) {\012        class_info-&gt;has_seen_constructor = true;\012        kind = has_extends ? FunctionKind::kDerivedConstructor\012 : FunctionKind::kBaseConstructor;\012 }\012\012 ExpressionT value = impl()-&gt;ParseFunctionLiteral(\012 *name, scanner()-&gt;location(), kSkipFunctionNameCheck, kind,\012          FLAG_harmony_function_tostring ? name_token_position\012 : kNoSourcePosition,\012 FunctionLiteral::kAccessorOrMethod, language_mode(), nullptr,\012          CHECK_OK_CUSTOM(NullLiteralProperty));\012\012 *property_kind = ClassLiteralProperty::METHOD;\012 ClassLiteralPropertyT result = factory()-&gt;NewClassLiteralProperty(\012          name_expression, value, *property_kind, *is_static,\012 *is_computed_name);\012      impl()-&gt;SetFunctionNameFromPropertyName(result, *name);\012 return result;\012 }\012\012 case PropertyKind::kAccessorProperty: {\012      DCHECK((is_get || is_set) &amp;&amp; !is_generator &amp;&amp; !is_async);\012\012 if (!*is_computed_name) {\012        checker-&gt;CheckClassMethodName(\012            name_token, PropertyKind::kAccessorProperty, false, false,\012 *is_static, CHECK_OK_CUSTOM(NullLiteralProperty));\012 // Make sure the name expression is a string since we need a Name for\012 // Runtime_DefineAccessorPropertyUnchecked and since we can determine\012 // this statically we can skip the extra runtime check.\012        name_expression =\012            factory()-&gt;NewStringLiteral(*name, name_expression-&gt;position());\012 }\012\012 FunctionKind kind = is_get ? FunctionKind::kGetterFunction\012 : FunctionKind::kSetterFunction;\012\012 FunctionLiteralT value = impl()-&gt;ParseFunctionLiteral(\012 *name, scanner()-&gt;location(), kSkipFunctionNameCheck, kind,\012          FLAG_harmony_function_tostring ? name_token_position\012 : kNoSourcePosition,\012 FunctionLiteral::kAccessorOrMethod, language_mode(), nullptr,\012          CHECK_OK_CUSTOM(NullLiteralProperty));\012\012 *property_kind =\012          is_get ? ClassLiteralProperty::GETTER : ClassLiteralProperty::SETTER;\012 ClassLiteralPropertyT result = factory()-&gt;NewClassLiteralProperty(\012          name_expression, value, *property_kind, *is_static,\012 *is_computed_name);\012 const AstRawString* prefix =\012          is_get ? ast_value_factory()-&gt;get_space_string()\012 : ast_value_factory()-&gt;set_space_string();\012      impl()-&gt;SetFunctionNameFromPropertyName(result, *name, prefix);\012 return result;\012 }\012 case PropertyKind::kSpreadProperty:\012 ReportUnexpectedTokenAt(\012 Scanner::Location(name_token_position, name_expression-&gt;position()),\012          name_token);\012 *ok = false;\012 return impl()-&gt;NullLiteralProperty();\012 }\012  UNREACHABLE();\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT\012ParserBase&lt;Impl&gt;::ParseClassFieldInitializer(ClassInfo* class_info,\012 bool is_static, bool* ok) {\012 DeclarationScope* initializer_scope = is_static\012 ? class_info-&gt;static_fields_scope\012 : class_info-&gt;instance_fields_scope;\012\012 if (initializer_scope == nullptr) {\012    initializer_scope =\012 NewFunctionScope(FunctionKind::kClassFieldsInitializerFunction);\012 // TODO(gsathya): Make scopes be non contiguous.\012    initializer_scope-&gt;set_start_position(scanner()-&gt;location().end_pos);\012    initializer_scope-&gt;SetLanguageMode(LanguageMode::kStrict);\012 }\012\012 ExpressionT initializer;\012 if (Check(Token::ASSIGN)) {\012 FunctionState initializer_state(&amp;function_state_, &amp;scope_,\012                                    initializer_scope);\012 ExpressionClassifier expression_classifier(this);\012\012    initializer =\012 ParseAssignmentExpression(true, CHECK_OK_CUSTOM(NullExpression));\012 ValidateExpression(CHECK_OK_CUSTOM(NullExpression));\012 } else {\012    initializer = factory()-&gt;NewUndefinedLiteral(kNoSourcePosition);\012 }\012\012  initializer_scope-&gt;set_end_position(scanner()-&gt;location().end_pos);\012 if (is_static) {\012    class_info-&gt;static_fields_scope = initializer_scope;\012    class_info-&gt;has_static_class_fields = true;\012 } else {\012    class_info-&gt;instance_fields_scope = initializer_scope;\012    class_info-&gt;has_instance_class_fields = true;\012 }\012\012 return initializer;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ObjectLiteralPropertyT\012ParserBase&lt;Impl&gt;::ParseObjectPropertyDefinition(ObjectLiteralChecker* checker,\012 bool* is_computed_name,\012 bool* is_rest_property,\012 bool* ok) {\012 bool is_get = false;\012 bool is_set = false;\012 bool is_generator = false;\012 bool is_async = false;\012 PropertyKind kind = PropertyKind::kNotSet;\012\012 IdentifierT name = impl()-&gt;NullIdentifier();\012 Token::Value name_token = peek();\012 int next_beg_pos = scanner()-&gt;peek_location().beg_pos;\012 int next_end_pos = scanner()-&gt;peek_location().end_pos;\012\012 ExpressionT name_expression = ParsePropertyName(\012 &amp;name, &amp;kind, &amp;is_generator, &amp;is_get, &amp;is_set, &amp;is_async,\012      is_computed_name, CHECK_OK_CUSTOM(NullLiteralProperty));\012\012 switch (kind) {\012 case PropertyKind::kSpreadProperty:\012      DCHECK(!is_get &amp;&amp; !is_set &amp;&amp; !is_generator &amp;&amp; !is_async &amp;&amp;\012 !*is_computed_name);\012      DCHECK(name_token == Token::ELLIPSIS);\012\012 *is_computed_name = true;\012 *is_rest_property = true;\012\012 return factory()-&gt;NewObjectLiteralProperty(\012          factory()-&gt;NewTheHoleLiteral(), name_expression,\012 ObjectLiteralProperty::SPREAD, true);\012\012 case PropertyKind::kValueProperty: {\012      DCHECK(!is_get &amp;&amp; !is_set &amp;&amp; !is_generator &amp;&amp; !is_async);\012\012 if (!*is_computed_name) {\012        checker-&gt;CheckDuplicateProto(name_token);\012 }\012 Consume(Token::COLON);\012 int beg_pos = peek_position();\012 ExpressionT value =\012 ParseAssignmentExpression(true, CHECK_OK_CUSTOM(NullLiteralProperty));\012 CheckDestructuringElement(value, beg_pos, scanner()-&gt;location().end_pos);\012\012 ObjectLiteralPropertyT result = factory()-&gt;NewObjectLiteralProperty(\012          name_expression, value, *is_computed_name);\012      impl()-&gt;SetFunctionNameFromPropertyName(result, name);\012 return result;\012 }\012\012 case PropertyKind::kShorthandProperty: {\012 // PropertyDefinition\012 //    IdentifierReference\012 //    CoverInitializedName\012 //\012 // CoverInitializedName\012 //    IdentifierReference Initializer?\012      DCHECK(!is_get &amp;&amp; !is_set &amp;&amp; !is_generator &amp;&amp; !is_async);\012\012 if (!Token::IsIdentifier(name_token, language_mode(),\012 this-&gt;is_generator(),\012                               parsing_module_ || is_async_function())) {\012 ReportUnexpectedToken(Next());\012 *ok = false;\012 return impl()-&gt;NullLiteralProperty();\012 }\012\012      DCHECK(!*is_computed_name);\012\012 if (classifier()-&gt;duplicate_finder() != nullptr &amp;&amp;\012          scanner()-&gt;IsDuplicateSymbol(classifier()-&gt;duplicate_finder(),\012                                       ast_value_factory())) {\012        classifier()-&gt;RecordDuplicateFormalParameterError(\012            scanner()-&gt;location());\012 }\012\012 if (impl()-&gt;IsEvalOrArguments(name) &amp;&amp; is_strict(language_mode())) {\012        classifier()-&gt;RecordBindingPatternError(\012            scanner()-&gt;location(), MessageTemplate::kStrictEvalArguments);\012 }\012\012 if (name_token == Token::LET) {\012        classifier()-&gt;RecordLetPatternError(\012            scanner()-&gt;location(), MessageTemplate::kLetInLexicalBinding);\012 }\012 if (name_token == Token::AWAIT) {\012        DCHECK(!is_async_function());\012        classifier()-&gt;RecordAsyncArrowFormalParametersError(\012 Scanner::Location(next_beg_pos, next_end_pos),\012 MessageTemplate::kAwaitBindingIdentifier);\012 }\012 ExpressionT lhs = impl()-&gt;ExpressionFromIdentifier(name, next_beg_pos);\012 CheckDestructuringElement(lhs, next_beg_pos, next_end_pos);\012\012 ExpressionT value;\012 if (peek() == Token::ASSIGN) {\012 Consume(Token::ASSIGN);\012 ExpressionClassifier rhs_classifier(this);\012 ExpressionT rhs = ParseAssignmentExpression(\012 true, CHECK_OK_CUSTOM(NullLiteralProperty));\012 ValidateExpression(CHECK_OK_CUSTOM(NullLiteralProperty));\012 AccumulateFormalParameterContainmentErrors();\012        value = factory()-&gt;NewAssignment(Token::ASSIGN, lhs, rhs,\012                                         kNoSourcePosition);\012        classifier()-&gt;RecordExpressionError(\012 Scanner::Location(next_beg_pos, scanner()-&gt;location().end_pos),\012 MessageTemplate::kInvalidCoverInitializedName);\012\012        impl()-&gt;SetFunctionNameFromIdentifierRef(rhs, lhs);\012 } else {\012        value = lhs;\012 }\012\012 ObjectLiteralPropertyT result = factory()-&gt;NewObjectLiteralProperty(\012          name_expression, value, ObjectLiteralProperty::COMPUTED, false);\012      impl()-&gt;SetFunctionNameFromPropertyName(result, name);\012 return result;\012 }\012\012 case PropertyKind::kMethodProperty: {\012      DCHECK(!is_get &amp;&amp; !is_set);\012\012 // MethodDefinition\012 //    PropertyName '(' StrictFormalParameters ')' '{' FunctionBody '}'\012 //    '*' PropertyName '(' StrictFormalParameters ')' '{' FunctionBody '}'\012\012      classifier()-&gt;RecordPatternError(\012 Scanner::Location(next_beg_pos, scanner()-&gt;location().end_pos),\012 MessageTemplate::kInvalidDestructuringTarget);\012\012 FunctionKind kind = MethodKindFor(is_generator, is_async);\012\012 ExpressionT value = impl()-&gt;ParseFunctionLiteral(\012          name, scanner()-&gt;location(), kSkipFunctionNameCheck, kind,\012          FLAG_harmony_function_tostring ? next_beg_pos : kNoSourcePosition,\012 FunctionLiteral::kAccessorOrMethod, language_mode(), nullptr,\012          CHECK_OK_CUSTOM(NullLiteralProperty));\012\012 ObjectLiteralPropertyT result = factory()-&gt;NewObjectLiteralProperty(\012          name_expression, value, ObjectLiteralProperty::COMPUTED,\012 *is_computed_name);\012      impl()-&gt;SetFunctionNameFromPropertyName(result, name);\012 return result;\012 }\012\012 case PropertyKind::kAccessorProperty: {\012      DCHECK((is_get || is_set) &amp;&amp; !(is_set &amp;&amp; is_get) &amp;&amp; !is_generator &amp;&amp;\012 !is_async);\012\012      classifier()-&gt;RecordPatternError(\012 Scanner::Location(next_beg_pos, scanner()-&gt;location().end_pos),\012 MessageTemplate::kInvalidDestructuringTarget);\012\012 if (!*is_computed_name) {\012 // Make sure the name expression is a string since we need a Name for\012 // Runtime_DefineAccessorPropertyUnchecked and since we can determine\012 // this statically we can skip the extra runtime check.\012        name_expression =\012            factory()-&gt;NewStringLiteral(name, name_expression-&gt;position());\012 }\012\012 FunctionKind kind = is_get ? FunctionKind::kGetterFunction\012 : FunctionKind::kSetterFunction;\012\012 FunctionLiteralT value = impl()-&gt;ParseFunctionLiteral(\012          name, scanner()-&gt;location(), kSkipFunctionNameCheck, kind,\012          FLAG_harmony_function_tostring ? next_beg_pos : kNoSourcePosition,\012 FunctionLiteral::kAccessorOrMethod, language_mode(), nullptr,\012          CHECK_OK_CUSTOM(NullLiteralProperty));\012\012 ObjectLiteralPropertyT result = factory()-&gt;NewObjectLiteralProperty(\012          name_expression, value,\012          is_get ? ObjectLiteralProperty::GETTER\012 : ObjectLiteralProperty::SETTER,\012 *is_computed_name);\012 const AstRawString* prefix =\012          is_get ? ast_value_factory()-&gt;get_space_string()\012 : ast_value_factory()-&gt;set_space_string();\012      impl()-&gt;SetFunctionNameFromPropertyName(result, name, prefix);\012 return result;\012 }\012\012 case PropertyKind::kClassField:\012 case PropertyKind::kNotSet:\012 ReportUnexpectedToken(Next());\012 *ok = false;\012 return impl()-&gt;NullLiteralProperty();\012 }\012  UNREACHABLE();\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParseObjectLiteral(\012 bool* ok) {\012 // ObjectLiteral ::\012 // '{' (PropertyDefinition (',' PropertyDefinition)* ','? )? '}'\012\012 int pos = peek_position();\012 typename Types::ObjectPropertyList properties =\012      impl()-&gt;NewObjectPropertyList(4);\012 int number_of_boilerplate_properties = 0;\012\012 bool has_computed_names = false;\012 bool has_rest_property = false;\012 ObjectLiteralChecker checker(this);\012\012 Expect(Token::LBRACE, CHECK_OK);\012\012 while (peek() != Token::RBRACE) {\012 FuncNameInferrer::State fni_state(fni_);\012\012 bool is_computed_name = false;\012 bool is_rest_property = false;\012 ObjectLiteralPropertyT property = ParseObjectPropertyDefinition(\012 &amp;checker, &amp;is_computed_name, &amp;is_rest_property, CHECK_OK);\012\012 if (is_computed_name) {\012      has_computed_names = true;\012 }\012\012 if (is_rest_property) {\012      has_rest_property = true;\012 }\012\012 if (impl()-&gt;IsBoilerplateProperty(property) &amp;&amp; !has_computed_names) {\012 // Count CONSTANT or COMPUTED properties to maintain the enumeration\012 // order.\012      number_of_boilerplate_properties++;\012 }\012\012    properties-&gt;Add(property, zone());\012\012 if (peek() != Token::RBRACE) {\012 // Need {} because of the CHECK_OK macro.\012 Expect(Token::COMMA, CHECK_OK);\012 }\012\012 if (fni_ != nullptr) fni_-&gt;Infer();\012 }\012 Expect(Token::RBRACE, CHECK_OK);\012\012 // In pattern rewriter, we rewrite rest property to call out to a\012 // runtime function passing all the other properties as arguments to\012 // this runtime function. Here, we make sure that the number of\012 // properties is less than number of arguments allowed for a runtime\012 // call.\012 if (has_rest_property &amp;&amp; properties-&gt;length() &gt; Code::kMaxArguments) {\012 this-&gt;classifier()-&gt;RecordPatternError(Scanner::Location(pos, position()),\012 MessageTemplate::kTooManyArguments);\012 }\012\012 return impl()-&gt;InitializeObjectLiteral(factory()-&gt;NewObjectLiteral(\012      properties, number_of_boilerplate_properties, pos, has_rest_property));\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionListT ParserBase&lt;Impl&gt;::ParseArguments(\012 Scanner::Location* first_spread_arg_loc, bool maybe_arrow,\012 bool* is_simple_parameter_list, bool* ok) {\012 // Arguments ::\012 //   '(' (AssignmentExpression)*[','] ')'\012\012 Scanner::Location spread_arg = Scanner::Location::invalid();\012 ExpressionListT result = impl()-&gt;NewExpressionList(4);\012 Expect(Token::LPAREN, CHECK_OK_CUSTOM(NullExpressionList));\012 bool done = (peek() == Token::RPAREN);\012 while (!done) {\012 int start_pos = peek_position();\012 bool is_spread = Check(Token::ELLIPSIS);\012 int expr_pos = peek_position();\012\012 ExpressionT argument =\012 ParseAssignmentExpression(true, CHECK_OK_CUSTOM(NullExpressionList));\012 if (!impl()-&gt;IsIdentifier(argument) &amp;&amp;\012        is_simple_parameter_list != nullptr) {\012 *is_simple_parameter_list = false;\012 }\012 if (!maybe_arrow) {\012 ValidateExpression(CHECK_OK_CUSTOM(NullExpressionList));\012 }\012 if (is_spread) {\012 if (is_simple_parameter_list != nullptr) {\012 *is_simple_parameter_list = false;\012 }\012 if (!spread_arg.IsValid()) {\012        spread_arg.beg_pos = start_pos;\012        spread_arg.end_pos = peek_position();\012 }\012 if (argument-&gt;IsAssignment()) {\012        classifier()-&gt;RecordAsyncArrowFormalParametersError(\012            scanner()-&gt;location(), MessageTemplate::kRestDefaultInitializer);\012 }\012      argument = factory()-&gt;NewSpread(argument, start_pos, expr_pos);\012 }\012    result-&gt;Add(argument, zone_);\012\012 if (result-&gt;length() &gt; Code::kMaxArguments) {\012 ReportMessage(MessageTemplate::kTooManyArguments);\012 *ok = false;\012 return impl()-&gt;NullExpressionList();\012 }\012 done = (peek() != Token::COMMA);\012 if (!done) {\012 Next();\012 if (argument-&gt;IsSpread()) {\012        classifier()-&gt;RecordAsyncArrowFormalParametersError(\012            scanner()-&gt;location(), MessageTemplate::kParamAfterRest);\012 }\012 if (peek() == Token::RPAREN) {\012 // allow trailing comma\012 done = true;\012 }\012 }\012 }\012 Scanner::Location location = scanner_-&gt;location();\012 if (Token::RPAREN != Next()) {\012    impl()-&gt;ReportMessageAt(location, MessageTemplate::kUnterminatedArgList);\012 *ok = false;\012 return impl()-&gt;NullExpressionList();\012 }\012 *first_spread_arg_loc = spread_arg;\012\012 if (!maybe_arrow || peek() != Token::ARROW) {\012 if (maybe_arrow) {\012 ValidateExpression(CHECK_OK_CUSTOM(NullExpressionList));\012 }\012 }\012\012 return result;\012}\012\012// Precedence = 2\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT\012ParserBase&lt;Impl&gt;::ParseAssignmentExpression(bool accept_IN, bool* ok) {\012 // AssignmentExpression ::\012 //   ConditionalExpression\012 //   ArrowFunction\012 //   YieldExpression\012 //   LeftHandSideExpression AssignmentOperator AssignmentExpression\012 int lhs_beg_pos = peek_position();\012\012 if (peek() == Token::YIELD &amp;&amp; is_generator()) {\012 return ParseYieldExpression(accept_IN, ok);\012 }\012\012 FuncNameInferrer::State fni_state(fni_);\012 ExpressionClassifier arrow_formals_classifier(\012 this, classifier()-&gt;duplicate_finder());\012\012 Scope::Snapshot scope_snapshot(scope());\012 int rewritable_length = static_cast&lt;int&gt;(\012      function_state_-&gt;destructuring_assignments_to_rewrite().size());\012\012 bool is_async = peek() == Token::ASYNC &amp;&amp;\012 !scanner()-&gt;HasLineTerminatorAfterNext() &amp;&amp;\012 IsValidArrowFormalParametersStart(PeekAhead());\012\012 bool parenthesized_formals = peek() == Token::LPAREN;\012 if (!is_async &amp;&amp; !parenthesized_formals) {\012 ArrowFormalParametersUnexpectedToken();\012 }\012\012 // Parse a simple, faster sub-grammar (primary expression) if it's evident\012 // that we have only a trivial expression to parse.\012 ExpressionT expression;\012 if (IsTrivialExpression()) {\012    expression = ParsePrimaryExpression(&amp;is_async, CHECK_OK);\012 } else {\012    expression = ParseConditionalExpression(accept_IN, CHECK_OK);\012 }\012\012 if (is_async &amp;&amp; impl()-&gt;IsIdentifier(expression) &amp;&amp; peek_any_identifier() &amp;&amp;\012 PeekAhead() == Token::ARROW) {\012 // async Identifier =&gt; AsyncConciseBody\012 IdentifierT name = ParseAndClassifyIdentifier(CHECK_OK);\012    expression =\012        impl()-&gt;ExpressionFromIdentifier(name, position(), InferName::kNo);\012 if (fni_) {\012 // Remove `async` keyword from inferred name stack.\012      fni_-&gt;RemoveAsyncKeywordFromEnd();\012 }\012 }\012\012 if (peek() == Token::ARROW) {\012 Scanner::Location arrow_loc = scanner()-&gt;peek_location();\012 ValidateArrowFormalParameters(expression, parenthesized_formals, is_async,\012                                  CHECK_OK);\012 // This reads strangely, but is correct: it checks whether any\012 // sub-expression of the parameter list failed to be a valid formal\012 // parameter initializer. Since YieldExpressions are banned anywhere\012 // in an arrow parameter list, this is correct.\012 // TODO(adamk): Rename &quot;FormalParameterInitializerError&quot; to refer to\012 // &quot;YieldExpression&quot;, which is its only use.\012 ValidateFormalParameterInitializer(ok);\012\012 Scanner::Location loc(lhs_beg_pos, scanner()-&gt;location().end_pos);\012 DeclarationScope* scope =\012 NewFunctionScope(is_async ? FunctionKind::kAsyncArrowFunction\012 : FunctionKind::kArrowFunction);\012\012 // Because the arrow's parameters were parsed in the outer scope,\012 // we need to fix up the scope chain appropriately.\012    scope_snapshot.Reparent(scope);\012\012 FormalParametersT parameters(scope);\012 if (!classifier()-&gt;is_simple_parameter_list()) {\012      scope-&gt;SetHasNonSimpleParameters();\012      parameters.is_simple = false;\012 }\012\012    scope-&gt;set_start_position(lhs_beg_pos);\012 Scanner::Location duplicate_loc = Scanner::Location::invalid();\012    impl()-&gt;DeclareArrowFunctionFormalParameters(&amp;parameters, expression, loc,\012 &amp;duplicate_loc, CHECK_OK);\012 if (duplicate_loc.IsValid()) {\012      classifier()-&gt;RecordDuplicateFormalParameterError(duplicate_loc);\012 }\012    expression = ParseArrowFunctionLiteral(accept_IN, parameters,\012                                           rewritable_length, CHECK_OK);\012 Accumulate(ExpressionClassifier::AsyncArrowFormalParametersProduction);\012    classifier()-&gt;RecordPatternError(arrow_loc,\012 MessageTemplate::kUnexpectedToken,\012 Token::String(Token::ARROW));\012\012 if (fni_ != nullptr) fni_-&gt;Infer();\012\012 return expression;\012 }\012\012 // &quot;expression&quot; was not itself an arrow function parameter list, but it might\012 // form part of one.  Propagate speculative formal parameter error locations\012 // (including those for binding patterns, since formal parameters can\012 // themselves contain binding patterns).\012 unsigned productions = ExpressionClassifier::AllProductions &amp;\012 ~ExpressionClassifier::ArrowFormalParametersProduction;\012\012 // Parenthesized identifiers and property references are allowed as part\012 // of a larger assignment pattern, even though parenthesized patterns\012 // themselves are not allowed, e.g., &quot;[(x)] = []&quot;. Only accumulate\012 // assignment pattern errors if the parsed expression is more complex.\012 if (IsValidReferenceExpression(expression)) {\012    productions &amp;= ~ExpressionClassifier::AssignmentPatternProduction;\012 }\012\012 const bool is_destructuring_assignment =\012 IsValidPattern(expression) &amp;&amp; peek() == Token::ASSIGN;\012 if (is_destructuring_assignment) {\012 // This is definitely not an expression so don't accumulate\012 // expression-related errors.\012    productions &amp;= ~ExpressionClassifier::ExpressionProduction;\012 }\012\012 Accumulate(productions);\012 if (!Token::IsAssignmentOp(peek())) return expression;\012\012 if (is_destructuring_assignment) {\012 ValidateAssignmentPattern(CHECK_OK);\012 } else {\012    expression = CheckAndRewriteReferenceExpression(\012        expression, lhs_beg_pos, scanner()-&gt;location().end_pos,\012 MessageTemplate::kInvalidLhsInAssignment, CHECK_OK);\012 }\012\012  impl()-&gt;MarkExpressionAsAssigned(expression);\012\012 Token::Value op = Next(); // Get assignment operator.\012 if (op != Token::ASSIGN) {\012    classifier()-&gt;RecordPatternError(scanner()-&gt;location(),\012 MessageTemplate::kUnexpectedToken,\012 Token::String(op));\012 }\012 int pos = position();\012\012 ExpressionClassifier rhs_classifier(this);\012\012 ExpressionT right = ParseAssignmentExpression(accept_IN, CHECK_OK);\012 ValidateExpression(CHECK_OK);\012 AccumulateFormalParameterContainmentErrors();\012\012 // We try to estimate the set of properties set by constructors. We define a\012 // new property whenever there is an assignment to a property of 'this'. We\012 // should probably only add properties if we haven't seen them\012 // before. Otherwise we'll probably overestimate the number of properties.\012 if (op == Token::ASSIGN &amp;&amp; impl()-&gt;IsThisProperty(expression)) {\012    function_state_-&gt;AddProperty();\012 }\012\012  impl()-&gt;CheckAssigningFunctionLiteralToProperty(expression, right);\012\012 if (fni_ != nullptr) {\012 // Check if the right hand side is a call to avoid inferring a\012 // name if we're dealing with &quot;a = function(){...}();&quot;-like\012 // expression.\012 if (op == Token::ASSIGN &amp;&amp; !right-&gt;IsCall() &amp;&amp; !right-&gt;IsCallNew()) {\012      fni_-&gt;Infer();\012 } else {\012      fni_-&gt;RemoveLastFunction();\012 }\012 }\012\012 if (op == Token::ASSIGN) {\012    impl()-&gt;SetFunctionNameFromIdentifierRef(right, expression);\012 }\012\012  DCHECK_NE(op, Token::INIT);\012 ExpressionT result = factory()-&gt;NewAssignment(op, expression, right, pos);\012\012 if (is_destructuring_assignment) {\012    DCHECK_NE(op, Token::ASSIGN_EXP);\012 auto rewritable = factory()-&gt;NewRewritableExpression(result, scope());\012    impl()-&gt;QueueDestructuringAssignmentForRewriting(rewritable);\012    result = rewritable;\012 }\012\012 return result;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParseYieldExpression(\012 bool accept_IN, bool* ok) {\012 // YieldExpression ::\012 //   'yield' ([no line terminator] '*'? AssignmentExpression)?\012 int pos = peek_position();\012  classifier()-&gt;RecordPatternError(\012      scanner()-&gt;peek_location(), MessageTemplate::kInvalidDestructuringTarget);\012  classifier()-&gt;RecordFormalParameterInitializerError(\012      scanner()-&gt;peek_location(), MessageTemplate::kYieldInParameter);\012 Expect(Token::YIELD, CHECK_OK);\012 // The following initialization is necessary.\012 ExpressionT expression = impl()-&gt;NullExpression();\012 bool delegating = false; // yield*\012 if (!scanner()-&gt;HasLineTerminatorBeforeNext()) {\012 if (Check(Token::MUL)) delegating = true;\012 switch (peek()) {\012 case Token::EOS:\012 case Token::SEMICOLON:\012 case Token::RBRACE:\012 case Token::RBRACK:\012 case Token::RPAREN:\012 case Token::COLON:\012 case Token::COMMA:\012 case Token::IN:\012 // The above set of tokens is the complete set of tokens that can appear\012 // after an AssignmentExpression, and none of them can start an\012 // AssignmentExpression.  This allows us to avoid looking for an RHS for\012 // a regular yield, given only one look-ahead token.\012 if (!delegating) break;\012 // Delegating yields require an RHS; fall through.\012        V8_FALLTHROUGH;\012 default:\012        expression = ParseAssignmentExpression(accept_IN, CHECK_OK);\012 ValidateExpression(CHECK_OK);\012 break;\012 }\012 }\012\012 if (delegating) {\012 ExpressionT yieldstar = factory()-&gt;NewYieldStar(expression, pos);\012    impl()-&gt;RecordSuspendSourceRange(yieldstar, PositionAfterSemicolon());\012    function_state_-&gt;AddSuspend();\012 if (IsAsyncGeneratorFunction(function_state_-&gt;kind())) {\012 // iterator_close and delegated_iterator_output suspend ids.\012      function_state_-&gt;AddSuspend();\012      function_state_-&gt;AddSuspend();\012 }\012 return yieldstar;\012 }\012\012 // Hackily disambiguate o from o.next and o [Symbol.iterator]().\012 // TODO(verwaest): Come up with a better solution.\012 ExpressionT yield =\012      factory()-&gt;NewYield(expression, pos, Suspend::kOnExceptionThrow);\012  impl()-&gt;RecordSuspendSourceRange(yield, PositionAfterSemicolon());\012  function_state_-&gt;AddSuspend();\012 return yield;\012}\012\012// Precedence = 3\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT\012ParserBase&lt;Impl&gt;::ParseConditionalExpression(bool accept_IN,\012 bool* ok) {\012 // ConditionalExpression ::\012 //   LogicalOrExpression\012 //   LogicalOrExpression '?' AssignmentExpression ':' AssignmentExpression\012\012 SourceRange then_range, else_range;\012 int pos = peek_position();\012 // We start using the binary expression parser for prec &gt;= 4 only!\012 ExpressionT expression = ParseBinaryExpression(4, accept_IN, CHECK_OK);\012 if (peek() != Token::CONDITIONAL) return expression;\012 ValidateExpression(CHECK_OK);\012 BindingPatternUnexpectedToken();\012 ArrowFormalParametersUnexpectedToken();\012\012 ExpressionT left;\012 {\012 SourceRangeScope range_scope(scanner(), &amp;then_range);\012 Consume(Token::CONDITIONAL);\012 ExpressionClassifier classifier(this);\012 // In parsing the first assignment expression in conditional\012 // expressions we always accept the 'in' keyword; see ECMA-262,\012 // section 11.12, page 58.\012    left = ParseAssignmentExpression(true, CHECK_OK);\012 AccumulateNonBindingPatternErrors();\012 }\012 ValidateExpression(CHECK_OK);\012 ExpressionT right;\012 {\012 SourceRangeScope range_scope(scanner(), &amp;else_range);\012 Expect(Token::COLON, CHECK_OK);\012 ExpressionClassifier classifier(this);\012    right = ParseAssignmentExpression(accept_IN, CHECK_OK);\012 AccumulateNonBindingPatternErrors();\012 }\012 ValidateExpression(CHECK_OK);\012 ExpressionT expr = factory()-&gt;NewConditional(expression, left, right, pos);\012  impl()-&gt;RecordConditionalSourceRange(expr, then_range, else_range);\012 return expr;\012}\012\012\012// Precedence &gt;= 4\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParseBinaryExpression(\012 int prec, bool accept_IN, bool* ok) {\012  DCHECK_GE(prec, 4);\012 SourceRange right_range;\012 ExpressionT x = ParseUnaryExpression(CHECK_OK);\012 for (int prec1 = Precedence(peek(), accept_IN); prec1 &gt;= prec; prec1--) {\012 // prec1 &gt;= 4\012 while (Precedence(peek(), accept_IN) == prec1) {\012 ValidateExpression(CHECK_OK);\012 BindingPatternUnexpectedToken();\012 ArrowFormalParametersUnexpectedToken();\012\012 SourceRangeScope right_range_scope(scanner(), &amp;right_range);\012 Token::Value op = Next();\012 int pos = position();\012\012 const bool is_right_associative = op == Token::EXP;\012 const int next_prec = is_right_associative ? prec1 : prec1 + 1;\012 ExpressionT y = ParseBinaryExpression(next_prec, accept_IN, CHECK_OK);\012      right_range_scope.Finalize();\012 ValidateExpression(CHECK_OK);\012\012 if (impl()-&gt;ShortcutNumericLiteralBinaryExpression(&amp;x, y, op, pos)) {\012 continue;\012 }\012\012 // For now we distinguish between comparisons and other binary\012 // operations.  (We could combine the two and get rid of this\012 // code and AST node eventually.)\012 if (Token::IsCompareOp(op)) {\012 // We have a comparison.\012 Token::Value cmp = op;\012 switch (op) {\012 case Token::NE: cmp = Token::EQ; break;\012 case Token::NE_STRICT: cmp = Token::EQ_STRICT; break;\012 default: break;\012 }\012        x = factory()-&gt;NewCompareOperation(cmp, x, y, pos);\012 if (cmp != op) {\012 // The comparison was negated - add a NOT.\012          x = factory()-&gt;NewUnaryOperation(Token::NOT, x, pos);\012 }\012 } else if (impl()-&gt;CollapseNaryExpression(&amp;x, y, op, pos, right_range)) {\012 continue;\012 } else {\012 // We have a &quot;normal&quot; binary operation.\012        x = factory()-&gt;NewBinaryOperation(op, x, y, pos);\012 if (op == Token::OR || op == Token::AND) {\012          impl()-&gt;RecordBinaryOperationSourceRange(x, right_range);\012 }\012 }\012 }\012 }\012 return x;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParseUnaryExpression(\012 bool* ok) {\012 // UnaryExpression ::\012 //   PostfixExpression\012 //   'delete' UnaryExpression\012 //   'void' UnaryExpression\012 //   'typeof' UnaryExpression\012 //   '++' UnaryExpression\012 //   '--' UnaryExpression\012 //   '+' UnaryExpression\012 //   '-' UnaryExpression\012 //   '~' UnaryExpression\012 //   '!' UnaryExpression\012 //   [+Await] AwaitExpression[?Yield]\012\012 Token::Value op = peek();\012 if (Token::IsUnaryOp(op)) {\012 BindingPatternUnexpectedToken();\012 ArrowFormalParametersUnexpectedToken();\012\012    op = Next();\012 int pos = position();\012\012 // Assume &quot;! function ...&quot; indicates the function is likely to be called.\012 if (op == Token::NOT &amp;&amp; peek() == Token::FUNCTION) {\012      function_state_-&gt;set_next_function_is_likely_called();\012 }\012\012 ExpressionT expression = ParseUnaryExpression(CHECK_OK);\012 ValidateExpression(CHECK_OK);\012\012 if (op == Token::DELETE) {\012 if (impl()-&gt;IsIdentifier(expression) &amp;&amp; is_strict(language_mode())) {\012 // &quot;delete identifier&quot; is a syntax error in strict mode.\012 ReportMessage(MessageTemplate::kStrictDelete);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012\012 if (impl()-&gt;IsPropertyWithPrivateFieldKey(expression)) {\012 ReportMessage(MessageTemplate::kDeletePrivateField);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012 }\012\012 if (peek() == Token::EXP) {\012 ReportUnexpectedToken(Next());\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012\012 // Allow the parser's implementation to rewrite the expression.\012 return impl()-&gt;BuildUnaryExpression(expression, op, pos);\012 } else if (Token::IsCountOp(op)) {\012 BindingPatternUnexpectedToken();\012 ArrowFormalParametersUnexpectedToken();\012    op = Next();\012 int beg_pos = peek_position();\012 ExpressionT expression = ParseUnaryExpression(CHECK_OK);\012    expression = CheckAndRewriteReferenceExpression(\012        expression, beg_pos, scanner()-&gt;location().end_pos,\012 MessageTemplate::kInvalidLhsInPrefixOp, CHECK_OK);\012    impl()-&gt;MarkExpressionAsAssigned(expression);\012 ValidateExpression(CHECK_OK);\012\012 return factory()-&gt;NewCountOperation(op,\012 true /* prefix */,\012                                        expression,\012                                        position());\012\012 } else if (is_async_function() &amp;&amp; peek() == Token::AWAIT) {\012    classifier()-&gt;RecordFormalParameterInitializerError(\012        scanner()-&gt;peek_location(),\012 MessageTemplate::kAwaitExpressionFormalParameter);\012 int await_pos = peek_position();\012 Consume(Token::AWAIT);\012\012 ExpressionT value = ParseUnaryExpression(CHECK_OK);\012\012    classifier()-&gt;RecordBindingPatternError(\012 Scanner::Location(await_pos, scanner()-&gt;location().end_pos),\012 MessageTemplate::kInvalidDestructuringTarget);\012\012 ExpressionT expr = factory()-&gt;NewAwait(value, await_pos);\012    function_state_-&gt;AddSuspend();\012    impl()-&gt;RecordSuspendSourceRange(expr, PositionAfterSemicolon());\012 return expr;\012 } else {\012 return ParsePostfixExpression(ok);\012 }\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParsePostfixExpression(\012 bool* ok) {\012 // PostfixExpression ::\012 //   LeftHandSideExpression ('++' | '--')?\012\012 int lhs_beg_pos = peek_position();\012 ExpressionT expression = ParseLeftHandSideExpression(CHECK_OK);\012 if (!scanner()-&gt;HasLineTerminatorBeforeNext() &amp;&amp; Token::IsCountOp(peek())) {\012 BindingPatternUnexpectedToken();\012 ArrowFormalParametersUnexpectedToken();\012\012    expression = CheckAndRewriteReferenceExpression(\012        expression, lhs_beg_pos, scanner()-&gt;location().end_pos,\012 MessageTemplate::kInvalidLhsInPostfixOp, CHECK_OK);\012    impl()-&gt;MarkExpressionAsAssigned(expression);\012 ValidateExpression(CHECK_OK);\012\012 Token::Value next = Next();\012    expression =\012        factory()-&gt;NewCountOperation(next,\012 false /* postfix */,\012                                     expression,\012                                     position());\012 }\012 return expression;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT\012ParserBase&lt;Impl&gt;::ParseLeftHandSideExpression(bool* ok) {\012 // LeftHandSideExpression ::\012 //   (NewExpression | MemberExpression) ...\012\012 bool is_async = false;\012 ExpressionT result =\012 ParseMemberWithNewPrefixesExpression(&amp;is_async, CHECK_OK);\012\012 while (true) {\012 switch (peek()) {\012 case Token::LBRACK: {\012 ValidateExpression(CHECK_OK);\012 BindingPatternUnexpectedToken();\012 ArrowFormalParametersUnexpectedToken();\012 Consume(Token::LBRACK);\012 int pos = position();\012 ExpressionT index = ParseExpressionCoverGrammar(true, CHECK_OK);\012 ValidateExpression(CHECK_OK);\012        result = factory()-&gt;NewProperty(result, index, pos);\012 Expect(Token::RBRACK, CHECK_OK);\012 break;\012 }\012\012 case Token::LPAREN: {\012 int pos;\012 ValidateExpression(CHECK_OK);\012 BindingPatternUnexpectedToken();\012 if (scanner()-&gt;current_token() == Token::IDENTIFIER ||\012            scanner()-&gt;current_token() == Token::SUPER ||\012            scanner()-&gt;current_token() == Token::ASYNC) {\012 // For call of an identifier we want to report position of\012 // the identifier as position of the call in the stack trace.\012          pos = position();\012 } else {\012 // For other kinds of calls we record position of the parenthesis as\012 // position of the call. Note that this is extremely important for\012 // expressions of the form function(){...}() for which call position\012 // should not point to the closing brace otherwise it will intersect\012 // with positions recorded for function literal and confuse debugger.\012          pos = peek_position();\012 // Also the trailing parenthesis are a hint that the function will\012 // be called immediately. If we happen to have parsed a preceding\012 // function literal eagerly, we can also compile it eagerly.\012 if (result-&gt;IsFunctionLiteral()) {\012            result-&gt;AsFunctionLiteral()-&gt;SetShouldEagerCompile();\012            result-&gt;AsFunctionLiteral()-&gt;mark_as_iife();\012 }\012 }\012 Scanner::Location spread_pos;\012 ExpressionListT args;\012 if (V8_UNLIKELY(is_async &amp;&amp; impl()-&gt;IsIdentifier(result))) {\012 ExpressionClassifier async_classifier(this);\012 bool is_simple_parameter_list = true;\012          args = ParseArguments(&amp;spread_pos, true, &amp;is_simple_parameter_list,\012                                CHECK_OK);\012 if (peek() == Token::ARROW) {\012 if (fni_) {\012              fni_-&gt;RemoveAsyncKeywordFromEnd();\012 }\012 ValidateBindingPattern(CHECK_OK);\012 ValidateFormalParameterInitializer(CHECK_OK);\012 if (!classifier()-&gt;is_valid_async_arrow_formal_parameters()) {\012 ReportClassifierError(\012                  classifier()-&gt;async_arrow_formal_parameters_error());\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012 if (args-&gt;length()) {\012 // async ( Arguments ) =&gt; ...\012 if (!is_simple_parameter_list) {\012                async_classifier.previous()-&gt;RecordNonSimpleParameter();\012 }\012 return impl()-&gt;ExpressionListToExpression(args);\012 }\012 // async () =&gt; ...\012 return factory()-&gt;NewEmptyParentheses(pos);\012 } else {\012 AccumulateFormalParameterContainmentErrors();\012 }\012 } else {\012          args = ParseArguments(&amp;spread_pos, CHECK_OK);\012 }\012\012 ArrowFormalParametersUnexpectedToken();\012\012 // Keep track of eval() calls since they disable all local variable\012 // optimizations.\012 // The calls that need special treatment are the\012 // direct eval calls. These calls are all of the form eval(...), with\012 // no explicit receiver.\012 // These calls are marked as potentially direct eval calls. Whether\012 // they are actually direct calls to eval is determined at run time.\012 Call::PossiblyEval is_possibly_eval =\012 CheckPossibleEvalCall(result, scope());\012\012 if (spread_pos.IsValid()) {\012          result = impl()-&gt;SpreadCall(result, args, pos, is_possibly_eval);\012 } else {\012          result = factory()-&gt;NewCall(result, args, pos, is_possibly_eval);\012 }\012\012 if (fni_ != nullptr) fni_-&gt;RemoveLastFunction();\012 break;\012 }\012\012 case Token::PERIOD: {\012 ValidateExpression(CHECK_OK);\012 BindingPatternUnexpectedToken();\012 ArrowFormalParametersUnexpectedToken();\012 Consume(Token::PERIOD);\012 int pos = position();\012 ExpressionT key = ParseIdentifierNameOrPrivateName(CHECK_OK);\012        result = factory()-&gt;NewProperty(result, key, pos);\012 break;\012 }\012\012 case Token::TEMPLATE_SPAN:\012 case Token::TEMPLATE_TAIL: {\012 ValidateExpression(CHECK_OK);\012 BindingPatternUnexpectedToken();\012 ArrowFormalParametersUnexpectedToken();\012        result = ParseTemplateLiteral(result, position(), true, CHECK_OK);\012 break;\012 }\012\012 default:\012 return result;\012 }\012 }\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT\012ParserBase&lt;Impl&gt;::ParseMemberWithNewPrefixesExpression(bool* is_async,\012 bool* ok) {\012 // NewExpression ::\012 //   ('new')+ MemberExpression\012 //\012 // NewTarget ::\012 //   'new' '.' 'target'\012\012 // The grammar for new expressions is pretty warped. We can have several 'new'\012 // keywords following each other, and then a MemberExpression. When we see '('\012 // after the MemberExpression, it's associated with the rightmost unassociated\012 // 'new' to create a NewExpression with arguments. However, a NewExpression\012 // can also occur without arguments.\012\012 // Examples of new expression:\012 // new foo.bar().baz means (new (foo.bar)()).baz\012 // new foo()() means (new foo())()\012 // new new foo()() means (new (new foo())())\012 // new new foo means new (new foo)\012 // new new foo() means new (new foo())\012 // new new foo().bar().baz means (new (new foo()).bar()).baz\012\012 if (peek() == Token::NEW) {\012 BindingPatternUnexpectedToken();\012 ArrowFormalParametersUnexpectedToken();\012 Consume(Token::NEW);\012 int new_pos = position();\012 ExpressionT result;\012 if (peek() == Token::SUPER) {\012 const bool is_new = true;\012      result = ParseSuperExpression(is_new, CHECK_OK);\012 } else if (allow_harmony_dynamic_import() &amp;&amp; peek() == Token::IMPORT &amp;&amp;\012 (!allow_harmony_import_meta() || PeekAhead() == Token::LPAREN)) {\012      impl()-&gt;ReportMessageAt(scanner()-&gt;peek_location(),\012 MessageTemplate::kImportCallNotNewExpression);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 } else if (peek() == Token::PERIOD) {\012 *is_async = false;\012      result = ParseNewTargetExpression(CHECK_OK);\012 return ParseMemberExpressionContinuation(result, is_async, CHECK_OK);\012 } else {\012      result = ParseMemberWithNewPrefixesExpression(is_async, CHECK_OK);\012 }\012 ValidateExpression(CHECK_OK);\012 if (peek() == Token::LPAREN) {\012 // NewExpression with arguments.\012 Scanner::Location spread_pos;\012 ExpressionListT args = ParseArguments(&amp;spread_pos, CHECK_OK);\012\012 if (spread_pos.IsValid()) {\012        result = impl()-&gt;SpreadCallNew(result, args, new_pos);\012 } else {\012        result = factory()-&gt;NewCallNew(result, args, new_pos);\012 }\012 // The expression can still continue with . or [ after the arguments.\012      result = ParseMemberExpressionContinuation(result, is_async, CHECK_OK);\012 return result;\012 }\012 // NewExpression without arguments.\012 return factory()-&gt;NewCallNew(result, impl()-&gt;NewExpressionList(0), new_pos);\012 }\012 // No 'new' or 'super' keyword.\012 return ParseMemberExpression(is_async, ok);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParseMemberExpression(\012 bool* is_async, bool* ok) {\012 // MemberExpression ::\012 //   (PrimaryExpression | FunctionLiteral | ClassLiteral)\012 //     ('[' Expression ']' | '.' Identifier | Arguments | TemplateLiteral)*\012 //\012 // CallExpression ::\012 //   (SuperCall | ImportCall)\012 //     ('[' Expression ']' | '.' Identifier | Arguments | TemplateLiteral)*\012 //\012 // The '[' Expression ']' and '.' Identifier parts are parsed by\012 // ParseMemberExpressionContinuation, and the Arguments part is parsed by the\012 // caller.\012\012 // Parse the initial primary or function expression.\012 ExpressionT result;\012 if (peek() == Token::FUNCTION) {\012 BindingPatternUnexpectedToken();\012 ArrowFormalParametersUnexpectedToken();\012\012 Consume(Token::FUNCTION);\012 int function_token_position = position();\012\012 FunctionKind function_kind = Check(Token::MUL)\012 ? FunctionKind::kGeneratorFunction\012 : FunctionKind::kNormalFunction;\012 IdentifierT name = impl()-&gt;NullIdentifier();\012 bool is_strict_reserved_name = false;\012 Scanner::Location function_name_location = Scanner::Location::invalid();\012 FunctionLiteral::FunctionType function_type =\012 FunctionLiteral::kAnonymousExpression;\012 if (impl()-&gt;ParsingDynamicFunctionDeclaration()) {\012 // We don't want dynamic functions to actually declare their name\012 // &quot;anonymous&quot;. We just want that name in the toString().\012 if (stack_overflow()) {\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012 Consume(Token::IDENTIFIER);\012      DCHECK(scanner()-&gt;CurrentMatchesContextual(Token::ANONYMOUS));\012 } else if (peek_any_identifier()) {\012 bool is_await = false;\012      name = ParseIdentifierOrStrictReservedWord(\012          function_kind, &amp;is_strict_reserved_name, &amp;is_await, CHECK_OK);\012      function_name_location = scanner()-&gt;location();\012      function_type = FunctionLiteral::kNamedExpression;\012 }\012    result = impl()-&gt;ParseFunctionLiteral(\012        name, function_name_location,\012        is_strict_reserved_name ? kFunctionNameIsStrictReserved\012 : kFunctionNameValidityUnknown,\012        function_kind, function_token_position, function_type, language_mode(),\012 nullptr, CHECK_OK);\012 } else if (peek() == Token::SUPER) {\012 const bool is_new = false;\012    result = ParseSuperExpression(is_new, CHECK_OK);\012 } else if (allow_harmony_dynamic_import() &amp;&amp; peek() == Token::IMPORT) {\012    result = ParseImportExpressions(CHECK_OK);\012 } else {\012    result = ParsePrimaryExpression(is_async, CHECK_OK);\012 }\012\012  result = ParseMemberExpressionContinuation(result, is_async, CHECK_OK);\012 return result;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParseImportExpressions(\012 bool* ok) {\012  DCHECK(allow_harmony_dynamic_import());\012\012  classifier()-&gt;RecordPatternError(scanner()-&gt;peek_location(),\012 MessageTemplate::kUnexpectedToken,\012 Token::String(Token::IMPORT));\012\012 Consume(Token::IMPORT);\012 int pos = position();\012 if (allow_harmony_import_meta() &amp;&amp; peek() == Token::PERIOD) {\012 ExpectMetaProperty(Token::META, &quot;import.meta&quot;, pos, CHECK_OK);\012 if (!parsing_module_) {\012      impl()-&gt;ReportMessageAt(scanner()-&gt;location(),\012 MessageTemplate::kImportMetaOutsideModule);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012\012 return impl()-&gt;ImportMetaExpression(pos);\012 }\012 Expect(Token::LPAREN, CHECK_OK);\012 if (peek() == Token::RPAREN) {\012    impl()-&gt;ReportMessageAt(scanner()-&gt;location(),\012 MessageTemplate::kImportMissingSpecifier);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012 ExpressionT arg = ParseAssignmentExpression(true, CHECK_OK);\012 Expect(Token::RPAREN, CHECK_OK);\012 return factory()-&gt;NewImportCallExpression(arg, pos);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParseSuperExpression(\012 bool is_new, bool* ok) {\012 Expect(Token::SUPER, CHECK_OK);\012 int pos = position();\012\012 DeclarationScope* scope = GetReceiverScope();\012 FunctionKind kind = scope-&gt;function_kind();\012 if (IsConciseMethod(kind) || IsAccessorFunction(kind) ||\012 IsClassConstructor(kind)) {\012 if (peek() == Token::PERIOD || peek() == Token::LBRACK) {\012      scope-&gt;RecordSuperPropertyUsage();\012 return impl()-&gt;NewSuperPropertyReference(pos);\012 }\012 // new super() is never allowed.\012 // super() is only allowed in derived constructor\012 if (!is_new &amp;&amp; peek() == Token::LPAREN &amp;&amp; IsDerivedConstructor(kind)) {\012 // TODO(rossberg): This might not be the correct FunctionState for the\012 // method here.\012 return impl()-&gt;NewSuperCallReference(pos);\012 }\012 }\012\012  impl()-&gt;ReportMessageAt(scanner()-&gt;location(),\012 MessageTemplate::kUnexpectedSuper);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::ExpectMetaProperty(Token::Value property_name,\012 const char* full_name, int pos,\012 bool* ok) {\012 Consume(Token::PERIOD);\012 ExpectContextualKeyword(property_name, CHECK_OK_CUSTOM(Void));\012 if (scanner()-&gt;literal_contains_escapes()) {\012    impl()-&gt;ReportMessageAt(\012 Scanner::Location(pos, scanner()-&gt;location().end_pos),\012 MessageTemplate::kInvalidEscapedMetaProperty, full_name);\012 *ok = false;\012 }\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT\012ParserBase&lt;Impl&gt;::ParseNewTargetExpression(bool* ok) {\012 int pos = position();\012 ExpectMetaProperty(Token::TARGET, &quot;new.target&quot;, pos, CHECK_OK);\012\012  classifier()-&gt;RecordAssignmentPatternError(\012 Scanner::Location(pos, scanner()-&gt;location().end_pos),\012 MessageTemplate::kInvalidDestructuringTarget);\012\012 if (!GetReceiverScope()-&gt;is_function_scope()) {\012    impl()-&gt;ReportMessageAt(scanner()-&gt;location(),\012 MessageTemplate::kUnexpectedNewTarget);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012\012 return impl()-&gt;NewTargetExpression(pos);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT\012ParserBase&lt;Impl&gt;::ParseMemberExpressionContinuation(ExpressionT expression,\012 bool* is_async, bool* ok) {\012 // Parses this part of MemberExpression:\012 // ('[' Expression ']' | '.' Identifier | TemplateLiteral)*\012 while (true) {\012 switch (peek()) {\012 case Token::LBRACK: {\012 *is_async = false;\012 ValidateExpression(CHECK_OK);\012 BindingPatternUnexpectedToken();\012 ArrowFormalParametersUnexpectedToken();\012\012 Consume(Token::LBRACK);\012 int pos = position();\012 ExpressionT index = ParseExpressionCoverGrammar(true, CHECK_OK);\012 ValidateExpression(CHECK_OK);\012        expression = factory()-&gt;NewProperty(expression, index, pos);\012        impl()-&gt;PushPropertyName(index);\012 Expect(Token::RBRACK, CHECK_OK);\012 break;\012 }\012 case Token::PERIOD: {\012 *is_async = false;\012 ValidateExpression(CHECK_OK);\012 BindingPatternUnexpectedToken();\012 ArrowFormalParametersUnexpectedToken();\012\012 Consume(Token::PERIOD);\012 int pos = peek_position();\012 ExpressionT key = ParseIdentifierNameOrPrivateName(CHECK_OK);\012        expression = factory()-&gt;NewProperty(expression, key, pos);\012 break;\012 }\012 case Token::TEMPLATE_SPAN:\012 case Token::TEMPLATE_TAIL: {\012 *is_async = false;\012 ValidateExpression(CHECK_OK);\012 BindingPatternUnexpectedToken();\012 ArrowFormalParametersUnexpectedToken();\012 int pos;\012 if (scanner()-&gt;current_token() == Token::IDENTIFIER) {\012          pos = position();\012 } else {\012          pos = peek_position();\012 if (expression-&gt;IsFunctionLiteral()) {\012 // If the tag function looks like an IIFE, set_parenthesized() to\012 // force eager compilation.\012            expression-&gt;AsFunctionLiteral()-&gt;SetShouldEagerCompile();\012 }\012 }\012        expression = ParseTemplateLiteral(expression, pos, true, CHECK_OK);\012 break;\012 }\012 case Token::ILLEGAL: {\012 ReportUnexpectedTokenAt(scanner()-&gt;peek_location(), Token::ILLEGAL);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012 default:\012 return expression;\012 }\012 }\012  DCHECK(false);\012 return impl()-&gt;NullExpression();\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::ParseFormalParameter(FormalParametersT* parameters,\012 bool* ok) {\012 // FormalParameter[Yield,GeneratorParameter] :\012 //   BindingElement[?Yield, ?GeneratorParameter]\012 bool is_rest = parameters-&gt;has_rest;\012\012 FuncNameInferrer::State fni_state(fni_);\012 ExpressionT pattern = ParsePrimaryExpression(CHECK_OK_CUSTOM(Void));\012 ValidateBindingPattern(CHECK_OK_CUSTOM(Void));\012\012 if (!impl()-&gt;IsIdentifier(pattern)) {\012    parameters-&gt;is_simple = false;\012 ValidateFormalParameterInitializer(CHECK_OK_CUSTOM(Void));\012    classifier()-&gt;RecordNonSimpleParameter();\012 }\012\012 ExpressionT initializer = impl()-&gt;NullExpression();\012 if (Check(Token::ASSIGN)) {\012 if (is_rest) {\012 ReportMessage(MessageTemplate::kRestDefaultInitializer);\012 *ok = false;\012 return;\012 }\012 ExpressionClassifier init_classifier(this);\012    initializer = ParseAssignmentExpression(true, CHECK_OK_CUSTOM(Void));\012 ValidateExpression(CHECK_OK_CUSTOM(Void));\012 ValidateFormalParameterInitializer(CHECK_OK_CUSTOM(Void));\012    parameters-&gt;is_simple = false;\012 DiscardExpressionClassifier();\012    classifier()-&gt;RecordNonSimpleParameter();\012\012    impl()-&gt;SetFunctionNameFromIdentifierRef(initializer, pattern);\012 }\012\012  impl()-&gt;AddFormalParameter(parameters, pattern, initializer,\012                             scanner()-&gt;location().end_pos, is_rest);\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::ParseFormalParameterList(FormalParametersT* parameters,\012 bool* ok) {\012 // FormalParameters[Yield] :\012 //   [empty]\012 //   FunctionRestParameter[?Yield]\012 //   FormalParameterList[?Yield]\012 //   FormalParameterList[?Yield] ,\012 //   FormalParameterList[?Yield] , FunctionRestParameter[?Yield]\012 //\012 // FormalParameterList[Yield] :\012 //   FormalParameter[?Yield]\012 //   FormalParameterList[?Yield] , FormalParameter[?Yield]\012\012  DCHECK_EQ(0, parameters-&gt;arity);\012\012 if (peek() != Token::RPAREN) {\012 while (true) {\012 if (parameters-&gt;arity &gt; Code::kMaxArguments) {\012 ReportMessage(MessageTemplate::kTooManyParameters);\012 *ok = false;\012 return;\012 }\012      parameters-&gt;has_rest = Check(Token::ELLIPSIS);\012 ParseFormalParameter(parameters, CHECK_OK_CUSTOM(Void));\012\012 if (parameters-&gt;has_rest) {\012        parameters-&gt;is_simple = false;\012        classifier()-&gt;RecordNonSimpleParameter();\012 if (peek() == Token::COMMA) {\012          impl()-&gt;ReportMessageAt(scanner()-&gt;peek_location(),\012 MessageTemplate::kParamAfterRest);\012 *ok = false;\012 return;\012 }\012 break;\012 }\012 if (!Check(Token::COMMA)) break;\012 if (peek() == Token::RPAREN) {\012 // allow the trailing comma\012 break;\012 }\012 }\012 }\012\012  impl()-&gt;DeclareFormalParameters(parameters-&gt;scope, parameters-&gt;params,\012                                  parameters-&gt;is_simple);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::BlockT ParserBase&lt;Impl&gt;::ParseVariableDeclarations(\012 VariableDeclarationContext var_context,\012 DeclarationParsingResult* parsing_result,\012 ZonePtrList&lt;const AstRawString&gt;* names, bool* ok) {\012 // VariableDeclarations ::\012 //   ('var' | 'const' | 'let') (Identifier ('=' AssignmentExpression)?)+[',']\012 //\012 // ES6:\012 // FIXME(marja, nikolaos): Add an up-to-date comment about ES6 variable\012 // declaration syntax.\012\012  DCHECK_NOT_NULL(parsing_result);\012  parsing_result-&gt;descriptor.declaration_kind = DeclarationDescriptor::NORMAL;\012  parsing_result-&gt;descriptor.declaration_pos = peek_position();\012  parsing_result-&gt;descriptor.initialization_pos = peek_position();\012\012 BlockT init_block = impl()-&gt;NullStatement();\012 if (var_context != kForStatement) {\012    init_block = factory()-&gt;NewBlock(1, true);\012 }\012\012 switch (peek()) {\012 case Token::VAR:\012      parsing_result-&gt;descriptor.mode = VariableMode::kVar;\012 Consume(Token::VAR);\012 break;\012 case Token::CONST:\012 Consume(Token::CONST);\012      DCHECK_NE(var_context, kStatement);\012      parsing_result-&gt;descriptor.mode = VariableMode::kConst;\012 break;\012 case Token::LET:\012 Consume(Token::LET);\012      DCHECK_NE(var_context, kStatement);\012      parsing_result-&gt;descriptor.mode = VariableMode::kLet;\012 break;\012 default:\012      UNREACHABLE(); // by current callers\012 break;\012 }\012\012  parsing_result-&gt;descriptor.scope = scope();\012\012 int bindings_start = peek_position();\012 do {\012 // Parse binding pattern.\012 FuncNameInferrer::State fni_state(fni_);\012\012 ExpressionT pattern = impl()-&gt;NullExpression();\012 int decl_pos = peek_position();\012 {\012 ExpressionClassifier pattern_classifier(this);\012      pattern = ParsePrimaryExpression(CHECK_OK_CUSTOM(NullStatement));\012\012 ValidateBindingPattern(CHECK_OK_CUSTOM(NullStatement));\012 if (IsLexicalVariableMode(parsing_result-&gt;descriptor.mode)) {\012 ValidateLetPattern(CHECK_OK_CUSTOM(NullStatement));\012 }\012 }\012\012 Scanner::Location variable_loc = scanner()-&gt;location();\012 bool single_name = impl()-&gt;IsIdentifier(pattern);\012\012 if (single_name) {\012      impl()-&gt;PushVariableName(impl()-&gt;AsIdentifier(pattern));\012 }\012\012 ExpressionT value = impl()-&gt;NullExpression();\012 int initializer_position = kNoSourcePosition;\012 int value_beg_position = kNoSourcePosition;\012 if (Check(Token::ASSIGN)) {\012      value_beg_position = peek_position();\012\012 ExpressionClassifier classifier(this);\012      value = ParseAssignmentExpression(var_context != kForStatement,\012                                        CHECK_OK_CUSTOM(NullStatement));\012 ValidateExpression(CHECK_OK_CUSTOM(NullStatement));\012      variable_loc.end_pos = scanner()-&gt;location().end_pos;\012\012 if (!parsing_result-&gt;first_initializer_loc.IsValid()) {\012        parsing_result-&gt;first_initializer_loc = variable_loc;\012 }\012\012 // Don't infer if it is &quot;a = function(){...}();&quot;-like expression.\012 if (single_name &amp;&amp; fni_ != nullptr) {\012 if (!value-&gt;IsCall() &amp;&amp; !value-&gt;IsCallNew()) {\012          fni_-&gt;Infer();\012 } else {\012          fni_-&gt;RemoveLastFunction();\012 }\012 }\012\012      impl()-&gt;SetFunctionNameFromIdentifierRef(value, pattern);\012\012 // End position of the initializer is after the assignment expression.\012      initializer_position = scanner()-&gt;location().end_pos;\012 } else {\012 if (var_context != kForStatement || !PeekInOrOf()) {\012 // ES6 'const' and binding patterns require initializers.\012 if (parsing_result-&gt;descriptor.mode == VariableMode::kConst ||\012 !impl()-&gt;IsIdentifier(pattern)) {\012          impl()-&gt;ReportMessageAt(\012 Scanner::Location(decl_pos, scanner()-&gt;location().end_pos),\012 MessageTemplate::kDeclarationMissingInitializer,\012 !impl()-&gt;IsIdentifier(pattern) ? &quot;destructuring&quot; : &quot;const&quot;);\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 }\012 // 'let x' initializes 'x' to undefined.\012 if (parsing_result-&gt;descriptor.mode == VariableMode::kLet) {\012          value = factory()-&gt;NewUndefinedLiteral(position());\012 }\012 }\012\012 // End position of the initializer is after the variable.\012      initializer_position = position();\012 }\012\012 typename DeclarationParsingResult::Declaration decl(\012        pattern, initializer_position, value);\012    decl.value_beg_position = value_beg_position;\012 if (var_context == kForStatement) {\012 // Save the declaration for further handling in ParseForStatement.\012      parsing_result-&gt;declarations.push_back(decl);\012 } else {\012 // Immediately declare the variable otherwise. This avoids O(N^2)\012 // behavior (where N is the number of variables in a single\012 // declaration) in the PatternRewriter having to do with removing\012 // and adding VariableProxies to the Scope (see bug 4699).\012      impl()-&gt;DeclareAndInitializeVariables(\012          init_block, &amp;parsing_result-&gt;descriptor, &amp;decl, names,\012          CHECK_OK_CUSTOM(NullStatement));\012 }\012 } while (Check(Token::COMMA));\012\012  parsing_result-&gt;bindings_loc =\012 Scanner::Location(bindings_start, scanner()-&gt;location().end_pos);\012\012  DCHECK(*ok);\012 return init_block;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT\012ParserBase&lt;Impl&gt;::ParseFunctionDeclaration(bool* ok) {\012 Consume(Token::FUNCTION);\012 int pos = position();\012 ParseFunctionFlags flags = ParseFunctionFlags::kIsNormal;\012 if (Check(Token::MUL)) {\012    impl()-&gt;ReportMessageAt(\012        scanner()-&gt;location(),\012 MessageTemplate::kGeneratorInSingleStatementContext);\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 }\012 return ParseHoistableDeclaration(pos, flags, nullptr, false, ok);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT\012ParserBase&lt;Impl&gt;::ParseHoistableDeclaration(\012 ZonePtrList&lt;const AstRawString&gt;* names, bool default_export, bool* ok) {\012 Expect(Token::FUNCTION, CHECK_OK_CUSTOM(NullStatement));\012 int pos = position();\012 ParseFunctionFlags flags = ParseFunctionFlags::kIsNormal;\012 if (Check(Token::MUL)) {\012    flags |= ParseFunctionFlags::kIsGenerator;\012 }\012 return ParseHoistableDeclaration(pos, flags, names, default_export, ok);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT\012ParserBase&lt;Impl&gt;::ParseHoistableDeclaration(\012 int pos, ParseFunctionFlags flags, ZonePtrList&lt;const AstRawString&gt;* names,\012 bool default_export, bool* ok) {\012 // FunctionDeclaration ::\012 //   'function' Identifier '(' FormalParameters ')' '{' FunctionBody '}'\012 //   'function' '(' FormalParameters ')' '{' FunctionBody '}'\012 // GeneratorDeclaration ::\012 //   'function' '*' Identifier '(' FormalParameters ')' '{' FunctionBody '}'\012 //   'function' '*' '(' FormalParameters ')' '{' FunctionBody '}'\012 //\012 // The anonymous forms are allowed iff [default_export] is true.\012 //\012 // 'function' and '*' (if present) have been consumed by the caller.\012\012 bool is_generator = flags &amp; ParseFunctionFlags::kIsGenerator;\012 const bool is_async = flags &amp; ParseFunctionFlags::kIsAsync;\012  DCHECK(!is_generator || !is_async);\012\012 if (is_async &amp;&amp; Check(Token::MUL)) {\012 // Async generator\012    is_generator = true;\012 }\012\012 IdentifierT name;\012 FunctionNameValidity name_validity;\012 IdentifierT variable_name;\012 if (default_export &amp;&amp; peek() == Token::LPAREN) {\012    impl()-&gt;GetDefaultStrings(&amp;name, &amp;variable_name);\012    name_validity = kSkipFunctionNameCheck;\012 } else {\012 bool is_strict_reserved;\012 bool is_await = false;\012    name = ParseIdentifierOrStrictReservedWord(&amp;is_strict_reserved, &amp;is_await,\012                                               CHECK_OK_CUSTOM(NullStatement));\012    name_validity = is_strict_reserved ? kFunctionNameIsStrictReserved\012 : kFunctionNameValidityUnknown;\012    variable_name = name;\012 }\012\012 FuncNameInferrer::State fni_state(fni_);\012  impl()-&gt;PushEnclosingName(name);\012\012 FunctionKind kind = FunctionKindFor(is_generator, is_async);\012\012 FunctionLiteralT function = impl()-&gt;ParseFunctionLiteral(\012      name, scanner()-&gt;location(), name_validity, kind, pos,\012 FunctionLiteral::kDeclaration, language_mode(), nullptr,\012      CHECK_OK_CUSTOM(NullStatement));\012\012 // In ES6, a function behaves as a lexical binding, except in\012 // a script scope, or the initial scope of eval or another function.\012 VariableMode mode =\012 (!scope()-&gt;is_declaration_scope() || scope()-&gt;is_module_scope())\012 ? VariableMode::kLet\012 : VariableMode::kVar;\012 // Async functions don't undergo sloppy mode block scoped hoisting, and don't\012 // allow duplicates in a block. Both are represented by the\012 // sloppy_block_function_map. Don't add them to the map for async functions.\012 // Generators are also supposed to be prohibited; currently doing this behind\012 // a flag and UseCounting violations to assess web compatibility.\012 bool is_sloppy_block_function = is_sloppy(language_mode()) &amp;&amp;\012 !scope()-&gt;is_declaration_scope() &amp;&amp;\012 !is_async &amp;&amp; !is_generator;\012\012 return impl()-&gt;DeclareFunction(variable_name, function, mode, pos,\012                                 is_sloppy_block_function, names, ok);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseClassDeclaration(\012 ZonePtrList&lt;const AstRawString&gt;* names, bool default_export, bool* ok) {\012 // ClassDeclaration ::\012 //   'class' Identifier ('extends' LeftHandExpression)? '{' ClassBody '}'\012 //   'class' ('extends' LeftHandExpression)? '{' ClassBody '}'\012 //\012 // The anonymous form is allowed iff [default_export] is true.\012 //\012 // 'class' is expected to be consumed by the caller.\012 //\012 // A ClassDeclaration\012 //\012 //   class C { ... }\012 //\012 // has the same semantics as:\012 //\012 //   let C = class C { ... };\012 //\012 // so rewrite it as such.\012\012 int class_token_pos = position();\012 IdentifierT name = impl()-&gt;NullIdentifier();\012 bool is_strict_reserved = false;\012 IdentifierT variable_name = impl()-&gt;NullIdentifier();\012 if (default_export &amp;&amp; (peek() == Token::EXTENDS || peek() == Token::LBRACE)) {\012    impl()-&gt;GetDefaultStrings(&amp;name, &amp;variable_name);\012 } else {\012 bool is_await = false;\012    name = ParseIdentifierOrStrictReservedWord(&amp;is_strict_reserved, &amp;is_await,\012                                               CHECK_OK_CUSTOM(NullStatement));\012    variable_name = name;\012 }\012\012 ExpressionClassifier no_classifier(this);\012 ExpressionT value =\012 ParseClassLiteral(name, scanner()-&gt;location(), is_strict_reserved,\012                        class_token_pos, CHECK_OK_CUSTOM(NullStatement));\012 int end_pos = position();\012 return impl()-&gt;DeclareClass(variable_name, value, names, class_token_pos,\012                              end_pos, ok);\012}\012\012// Language extension which is only enabled for source files loaded\012// through the API's extension mechanism.  A native function\012// declaration is resolved by looking up the function through a\012// callback provided by the extension.\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseNativeDeclaration(\012 bool* ok) {\012  function_state_-&gt;DisableOptimization(BailoutReason::kNativeFunctionLiteral);\012\012 int pos = peek_position();\012 Expect(Token::FUNCTION, CHECK_OK_CUSTOM(NullStatement));\012 // Allow &quot;eval&quot; or &quot;arguments&quot; for backward compatibility.\012 IdentifierT name = ParseIdentifier(kAllowRestrictedIdentifiers,\012                                     CHECK_OK_CUSTOM(NullStatement));\012 Expect(Token::LPAREN, CHECK_OK_CUSTOM(NullStatement));\012 if (peek() != Token::RPAREN) {\012 do {\012 ParseIdentifier(kAllowRestrictedIdentifiers,\012                      CHECK_OK_CUSTOM(NullStatement));\012 } while (Check(Token::COMMA));\012 }\012 Expect(Token::RPAREN, CHECK_OK_CUSTOM(NullStatement));\012 Expect(Token::SEMICOLON, CHECK_OK_CUSTOM(NullStatement));\012 return impl()-&gt;DeclareNative(name, pos, ok);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT\012ParserBase&lt;Impl&gt;::ParseAsyncFunctionDeclaration(\012 ZonePtrList&lt;const AstRawString&gt;* names, bool default_export, bool* ok) {\012 // AsyncFunctionDeclaration ::\012 //   async [no LineTerminator here] function BindingIdentifier[Await]\012 //       ( FormalParameters[Await] ) { AsyncFunctionBody }\012  DCHECK_EQ(scanner()-&gt;current_token(), Token::ASYNC);\012 int pos = position();\012 if (scanner()-&gt;HasLineTerminatorBeforeNext()) {\012 *ok = false;\012    impl()-&gt;ReportUnexpectedToken(scanner()-&gt;current_token());\012 return impl()-&gt;NullStatement();\012 }\012 Expect(Token::FUNCTION, CHECK_OK_CUSTOM(NullStatement));\012 ParseFunctionFlags flags = ParseFunctionFlags::kIsAsync;\012 return ParseHoistableDeclaration(pos, flags, names, default_export, ok);\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::ParseFunctionBody(\012 typename ParserBase&lt;Impl&gt;::StatementListT result, IdentifierT function_name,\012 int pos, const FormalParametersT&amp; parameters, FunctionKind kind,\012 FunctionLiteral::FunctionType function_type, bool* ok) {\012 DeclarationScope* function_scope = scope()-&gt;AsDeclarationScope();\012 DeclarationScope* inner_scope = function_scope;\012 BlockT inner_block = impl()-&gt;NullStatement();\012\012 StatementListT body = result;\012 if (!parameters.is_simple) {\012    inner_scope = NewVarblockScope();\012    inner_scope-&gt;set_start_position(scanner()-&gt;location().beg_pos);\012    inner_block = factory()-&gt;NewBlock(8, true);\012    inner_block-&gt;set_scope(inner_scope);\012    body = inner_block-&gt;statements();\012 }\012\012 // If we are parsing the source as if it is wrapped in a function, the source\012 // ends without a closing brace.\012 Token::Value closing_token =\012      function_type == FunctionLiteral::kWrapped ? Token::EOS : Token::RBRACE;\012\012 {\012 BlockState block_state(&amp;scope_, inner_scope);\012\012 if (IsResumableFunction(kind)) impl()-&gt;PrepareGeneratorVariables();\012\012 if (IsAsyncGeneratorFunction(kind)) {\012      impl()-&gt;ParseAndRewriteAsyncGeneratorFunctionBody(pos, kind, body, ok);\012 } else if (IsGeneratorFunction(kind)) {\012      impl()-&gt;ParseAndRewriteGeneratorFunctionBody(pos, kind, body, ok);\012 } else if (IsAsyncFunction(kind)) {\012 ParseAsyncFunctionBody(inner_scope, body, CHECK_OK_VOID);\012 } else {\012 ParseStatementList(body, closing_token, CHECK_OK_VOID);\012 }\012\012 if (IsDerivedConstructor(kind)) {\012      body-&gt;Add(factory()-&gt;NewReturnStatement(impl()-&gt;ThisExpression(),\012                                              kNoSourcePosition),\012                zone());\012 }\012 }\012\012 Expect(closing_token, CHECK_OK_VOID);\012  scope()-&gt;set_end_position(scanner()-&gt;location().end_pos);\012\012 if (!parameters.is_simple) {\012    DCHECK_NOT_NULL(inner_scope);\012    DCHECK_EQ(function_scope, scope());\012    DCHECK_EQ(function_scope, inner_scope-&gt;outer_scope());\012    impl()-&gt;SetLanguageMode(function_scope, inner_scope-&gt;language_mode());\012 BlockT init_block =\012        impl()-&gt;BuildParameterInitializationBlock(parameters, CHECK_OK_VOID);\012\012 if (is_sloppy(inner_scope-&gt;language_mode())) {\012      impl()-&gt;InsertSloppyBlockFunctionVarBindings(inner_scope);\012 }\012\012 // TODO(littledan): Merge the two rejection blocks into one\012 if (IsAsyncFunction(kind) &amp;&amp; !IsAsyncGeneratorFunction(kind)) {\012      init_block = impl()-&gt;BuildRejectPromiseOnException(init_block);\012 }\012\012    inner_scope-&gt;set_end_position(scanner()-&gt;location().end_pos);\012 if (inner_scope-&gt;FinalizeBlockScope() != nullptr) {\012      impl()-&gt;CheckConflictingVarDeclarations(inner_scope, CHECK_OK_VOID);\012      impl()-&gt;InsertShadowingVarBindingInitializers(inner_block);\012 } else {\012      inner_block-&gt;set_scope(nullptr);\012 }\012    inner_scope = nullptr;\012\012    result-&gt;Add(init_block, zone());\012    result-&gt;Add(inner_block, zone());\012 } else {\012    DCHECK_EQ(inner_scope, function_scope);\012 if (is_sloppy(function_scope-&gt;language_mode())) {\012      impl()-&gt;InsertSloppyBlockFunctionVarBindings(function_scope);\012 }\012 }\012\012 if (!IsArrowFunction(kind)) {\012 // Declare arguments after parsing the function since lexical 'arguments'\012 // masks the arguments object. Declare arguments before declaring the\012 // function var since the arguments object masks 'function arguments'.\012    function_scope-&gt;DeclareArguments(ast_value_factory());\012 }\012\012  impl()-&gt;DeclareFunctionNameVar(function_name, function_type, function_scope);\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::CheckArityRestrictions(int param_count,\012 FunctionKind function_kind,\012 bool has_rest,\012 int formals_start_pos,\012 int formals_end_pos, bool* ok) {\012 if (IsGetterFunction(function_kind)) {\012 if (param_count != 0) {\012      impl()-&gt;ReportMessageAt(\012 Scanner::Location(formals_start_pos, formals_end_pos),\012 MessageTemplate::kBadGetterArity);\012 *ok = false;\012 }\012 } else if (IsSetterFunction(function_kind)) {\012 if (param_count != 1) {\012      impl()-&gt;ReportMessageAt(\012 Scanner::Location(formals_start_pos, formals_end_pos),\012 MessageTemplate::kBadSetterArity);\012 *ok = false;\012 }\012 if (has_rest) {\012      impl()-&gt;ReportMessageAt(\012 Scanner::Location(formals_start_pos, formals_end_pos),\012 MessageTemplate::kBadSetterRestParameter);\012 *ok = false;\012 }\012 }\012}\012\012template &lt;typename Impl&gt;\012bool ParserBase&lt;Impl&gt;::IsNextLetKeyword() {\012  DCHECK(peek() == Token::LET);\012 Token::Value next_next = PeekAhead();\012 switch (next_next) {\012 case Token::LBRACE:\012 case Token::LBRACK:\012 case Token::IDENTIFIER:\012 case Token::STATIC:\012 case Token::LET: // `let let;` is disallowed by static semantics, but the\012 // token must be first interpreted as a keyword in order\012 // for those semantics to apply. This ensures that ASI is\012 // not honored when a LineTerminator separates the\012 // tokens.\012 case Token::YIELD:\012 case Token::AWAIT:\012 case Token::ASYNC:\012 return true;\012 case Token::FUTURE_STRICT_RESERVED_WORD:\012 return is_sloppy(language_mode());\012 default:\012 return false;\012 }\012}\012\012template &lt;typename Impl&gt;\012bool ParserBase&lt;Impl&gt;::IsTrivialExpression() {\012 Token::Value peek_token = peek();\012 if (peek_token == Token::SMI || peek_token == Token::NUMBER ||\012      peek_token == Token::BIGINT || peek_token == Token::NULL_LITERAL ||\012      peek_token == Token::TRUE_LITERAL || peek_token == Token::FALSE_LITERAL ||\012      peek_token == Token::STRING || peek_token == Token::IDENTIFIER ||\012      peek_token == Token::THIS) {\012 // PeekAhead() is expensive &amp; may not always be called, so we only call it\012 // after checking peek().\012 Token::Value peek_ahead = PeekAhead();\012 if (peek_ahead == Token::COMMA || peek_ahead == Token::RPAREN ||\012        peek_ahead == Token::SEMICOLON || peek_ahead == Token::RBRACK) {\012 return true;\012 }\012 }\012 return false;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT\012ParserBase&lt;Impl&gt;::ParseArrowFunctionLiteral(\012 bool accept_IN, const FormalParametersT&amp; formal_parameters,\012 int rewritable_length, bool* ok) {\012 const RuntimeCallCounterId counters[2][2] = {\012 {RuntimeCallCounterId::kParseBackgroundArrowFunctionLiteral,\012 RuntimeCallCounterId::kParseArrowFunctionLiteral},\012 {RuntimeCallCounterId::kPreParseBackgroundArrowFunctionLiteral,\012 RuntimeCallCounterId::kPreParseArrowFunctionLiteral}};\012 RuntimeCallTimerScope runtime_timer(\012      runtime_call_stats_,\012      counters[Impl::IsPreParser()][parsing_on_main_thread_]);\012 base::ElapsedTimer timer;\012 if (V8_UNLIKELY(FLAG_log_function_events)) timer.Start();\012\012 if (peek() == Token::ARROW &amp;&amp; scanner_-&gt;HasLineTerminatorBeforeNext()) {\012 // ASI inserts `;` after arrow parameters if a line terminator is found.\012 // `=&gt; ...` is never a valid expression, so report as syntax error.\012 // If next token is not `=&gt;`, it's a syntax error anyways.\012 ReportUnexpectedTokenAt(scanner_-&gt;peek_location(), Token::ARROW);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012\012 StatementListT body = impl()-&gt;NullStatementList();\012 int expected_property_count = -1;\012 int suspend_count = 0;\012 int function_literal_id = GetNextFunctionLiteralId();\012\012 FunctionKind kind = formal_parameters.scope-&gt;function_kind();\012 FunctionLiteral::EagerCompileHint eager_compile_hint =\012      default_eager_compile_hint_;\012 bool can_preparse = impl()-&gt;parse_lazily() &amp;&amp;\012                      eager_compile_hint == FunctionLiteral::kShouldLazyCompile;\012 // TODO(marja): consider lazy-parsing inner arrow functions too. is_this\012 // handling in Scope::ResolveVariable needs to change.\012 bool is_lazy_top_level_function =\012      can_preparse &amp;&amp; impl()-&gt;AllowsLazyParsingWithoutUnresolvedVariables();\012 bool has_braces = true;\012 ProducedPreParsedScopeData* produced_preparsed_scope_data = nullptr;\012 {\012 FunctionState function_state(&amp;function_state_, &amp;scope_,\012                                 formal_parameters.scope);\012\012 // Move any queued destructuring assignments which appeared\012 // in this function's parameter list into its own function_state.\012    function_state.AdoptDestructuringAssignmentsFromParentState(\012        rewritable_length);\012\012 Expect(Token::ARROW, CHECK_OK);\012\012 if (peek() == Token::LBRACE) {\012 // Multiple statement body\012      DCHECK_EQ(scope(), formal_parameters.scope);\012 if (is_lazy_top_level_function) {\012 // FIXME(marja): Arrow function parameters will be parsed even if the\012 // body is preparsed; move relevant parts of parameter handling to\012 // simulate consistent parameter handling.\012\012 // For arrow functions, we don't need to retrieve data about function\012 // parameters.\012 int dummy_num_parameters = -1;\012        DCHECK_NE(kind &amp; FunctionKind::kArrowFunction, 0);\012 LazyParsingResult result = impl()-&gt;SkipFunction(\012 nullptr, kind, FunctionLiteral::kAnonymousExpression,\012            formal_parameters.scope, &amp;dummy_num_parameters,\012 &amp;produced_preparsed_scope_data, false, false, CHECK_OK);\012        DCHECK_NE(result, kLazyParsingAborted);\012        DCHECK_NULL(produced_preparsed_scope_data);\012        USE(result);\012        formal_parameters.scope-&gt;ResetAfterPreparsing(ast_value_factory_,\012 false);\012 // Discard any queued destructuring assignments which appeared\012 // in this function's parameter list, and which were adopted\012 // into this function state, above.\012        function_state.RewindDestructuringAssignments(0);\012 } else {\012 Consume(Token::LBRACE);\012        body = impl()-&gt;NewStatementList(8);\012 ParseFunctionBody(body, impl()-&gt;NullIdentifier(), kNoSourcePosition,\012                          formal_parameters, kind,\012 FunctionLiteral::kAnonymousExpression, CHECK_OK);\012        expected_property_count = function_state.expected_property_count();\012 }\012 } else {\012 // Single-expression body\012      has_braces = false;\012 const bool is_async = IsAsyncFunction(kind);\012      body = impl()-&gt;NewStatementList(1);\012      impl()-&gt;AddParameterInitializationBlock(formal_parameters, body, is_async,\012                                              CHECK_OK);\012 ParseSingleExpressionFunctionBody(body, is_async, accept_IN, CHECK_OK);\012      expected_property_count = function_state.expected_property_count();\012 }\012\012    formal_parameters.scope-&gt;set_end_position(scanner()-&gt;location().end_pos);\012\012 // Arrow function formal parameters are parsed as StrictFormalParameterList,\012 // which is not the same as &quot;parameters of a strict function&quot;; it only means\012 // that duplicates are not allowed.  Of course, the arrow function may\012 // itself be strict as well.\012 const bool allow_duplicate_parameters = false;\012 ValidateFormalParameters(language_mode(), allow_duplicate_parameters,\012                             CHECK_OK);\012\012 // Validate strict mode.\012 if (is_strict(language_mode())) {\012 CheckStrictOctalLiteral(formal_parameters.scope-&gt;start_position(),\012                              scanner()-&gt;location().end_pos, CHECK_OK);\012 }\012    impl()-&gt;CheckConflictingVarDeclarations(formal_parameters.scope, CHECK_OK);\012\012    impl()-&gt;RewriteDestructuringAssignments();\012    suspend_count = function_state.suspend_count();\012 }\012\012 FunctionLiteralT function_literal = factory()-&gt;NewFunctionLiteral(\012      impl()-&gt;EmptyIdentifierString(), formal_parameters.scope, body,\012      expected_property_count, formal_parameters.num_parameters(),\012      formal_parameters.function_length,\012 FunctionLiteral::kNoDuplicateParameters,\012 FunctionLiteral::kAnonymousExpression, eager_compile_hint,\012      formal_parameters.scope-&gt;start_position(), has_braces,\012      function_literal_id, produced_preparsed_scope_data);\012\012  function_literal-&gt;set_suspend_count(suspend_count);\012  function_literal-&gt;set_function_token_position(\012      formal_parameters.scope-&gt;start_position());\012\012  impl()-&gt;AddFunctionForNameInference(function_literal);\012\012 if (V8_UNLIKELY((FLAG_log_function_events))) {\012 Scope* scope = formal_parameters.scope;\012 double ms = timer.Elapsed().InMillisecondsF();\012 const char* event_name =\012        is_lazy_top_level_function ? &quot;preparse-no-resolution&quot; : &quot;parse&quot;;\012 const char* name = &quot;arrow function&quot;;\012    logger_-&gt;FunctionEvent(event_name, script_id(), ms, scope-&gt;start_position(),\012                           scope-&gt;end_position(), name, strlen(name));\012 }\012\012 return function_literal;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParseClassLiteral(\012 IdentifierT name, Scanner::Location class_name_location,\012 bool name_is_strict_reserved, int class_token_pos, bool* ok) {\012 bool is_anonymous = impl()-&gt;IsNull(name);\012\012 // All parts of a ClassDeclaration and ClassExpression are strict code.\012 if (!is_anonymous) {\012 if (name_is_strict_reserved) {\012      impl()-&gt;ReportMessageAt(class_name_location,\012 MessageTemplate::kUnexpectedStrictReserved);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012 if (impl()-&gt;IsEvalOrArguments(name)) {\012      impl()-&gt;ReportMessageAt(class_name_location,\012 MessageTemplate::kStrictEvalArguments);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012 }\012\012 Scope* block_scope = NewScope(BLOCK_SCOPE);\012 BlockState block_state(&amp;scope_, block_scope);\012 RaiseLanguageMode(LanguageMode::kStrict);\012\012 ClassInfo class_info(this);\012  class_info.is_anonymous = is_anonymous;\012  impl()-&gt;DeclareClassVariable(name, &amp;class_info, class_token_pos, CHECK_OK);\012\012  scope()-&gt;set_start_position(scanner()-&gt;location().end_pos);\012 if (Check(Token::EXTENDS)) {\012 FuncNameInferrer::State fni_state(fni_);\012 ExpressionClassifier extends_classifier(this);\012    class_info.extends = ParseLeftHandSideExpression(CHECK_OK);\012 ValidateExpression(CHECK_OK);\012 AccumulateFormalParameterContainmentErrors();\012 }\012\012 ClassLiteralChecker checker(this);\012\012 Expect(Token::LBRACE, CHECK_OK);\012\012 const bool has_extends = !impl()-&gt;IsNull(class_info.extends);\012 while (peek() != Token::RBRACE) {\012 if (Check(Token::SEMICOLON)) continue;\012 FuncNameInferrer::State fni_state(fni_);\012 bool is_computed_name = false; // Classes do not care about computed\012 // property names here.\012 bool is_static;\012 ClassLiteralProperty::Kind property_kind;\012 ExpressionClassifier property_classifier(this);\012 IdentifierT property_name;\012 // If we haven't seen the constructor yet, it potentially is the next\012 // property.\012 bool is_constructor = !class_info.has_seen_constructor;\012 ClassLiteralPropertyT property = ParseClassPropertyDefinition(\012 &amp;checker, &amp;class_info, &amp;property_name, has_extends, &amp;is_computed_name,\012 &amp;property_kind, &amp;is_static, CHECK_OK);\012 if (!class_info.has_static_computed_names &amp;&amp; is_static &amp;&amp;\012        is_computed_name) {\012      class_info.has_static_computed_names = true;\012 }\012 if (is_computed_name &amp;&amp;\012        property_kind == ClassLiteralProperty::PUBLIC_FIELD) {\012      class_info.computed_field_count++;\012 }\012    is_constructor &amp;= class_info.has_seen_constructor;\012 ValidateExpression(CHECK_OK);\012 AccumulateFormalParameterContainmentErrors();\012\012    impl()-&gt;DeclareClassProperty(name, property, property_name, property_kind,\012                                 is_static, is_constructor, is_computed_name,\012 &amp;class_info, CHECK_OK);\012    impl()-&gt;InferFunctionName();\012 }\012\012 Expect(Token::RBRACE, CHECK_OK);\012 int end_pos = scanner()-&gt;location().end_pos;\012  block_scope-&gt;set_end_position(end_pos);\012 return impl()-&gt;RewriteClassLiteral(block_scope, name, &amp;class_info,\012                                     class_token_pos, end_pos, ok);\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::ParseSingleExpressionFunctionBody(StatementListT body,\012 bool is_async,\012 bool accept_IN,\012 bool* ok) {\012 if (is_async) impl()-&gt;PrepareGeneratorVariables();\012\012 ExpressionClassifier classifier(this);\012 ExpressionT expression = ParseAssignmentExpression(accept_IN, CHECK_OK_VOID);\012 ValidateExpression(CHECK_OK_VOID);\012\012 if (is_async) {\012 BlockT block = factory()-&gt;NewBlock(1, true);\012    impl()-&gt;RewriteAsyncFunctionBody(body, block, expression, CHECK_OK_VOID);\012 } else {\012    body-&gt;Add(BuildReturnStatement(expression, expression-&gt;position()), zone());\012 }\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::ParseAsyncFunctionBody(Scope* scope, StatementListT body,\012 bool* ok) {\012 BlockT block = factory()-&gt;NewBlock(8, true);\012\012 ParseStatementList(block-&gt;statements(), Token::RBRACE, CHECK_OK_VOID);\012  impl()-&gt;RewriteAsyncFunctionBody(\012      body, block, factory()-&gt;NewUndefinedLiteral(kNoSourcePosition),\012      CHECK_OK_VOID);\012  scope-&gt;set_end_position(scanner()-&gt;location().end_pos);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT\012ParserBase&lt;Impl&gt;::ParseAsyncFunctionLiteral(bool* ok) {\012 // AsyncFunctionLiteral ::\012 //   async [no LineTerminator here] function ( FormalParameters[Await] )\012 //       { AsyncFunctionBody }\012 //\012 //   async [no LineTerminator here] function BindingIdentifier[Await]\012 //       ( FormalParameters[Await] ) { AsyncFunctionBody }\012  DCHECK_EQ(scanner()-&gt;current_token(), Token::ASYNC);\012 int pos = position();\012 Expect(Token::FUNCTION, CHECK_OK);\012 bool is_strict_reserved = false;\012 IdentifierT name = impl()-&gt;NullIdentifier();\012 FunctionLiteral::FunctionType type = FunctionLiteral::kAnonymousExpression;\012\012 bool is_generator = Check(Token::MUL);\012 const bool kIsAsync = true;\012 const FunctionKind kind = FunctionKindFor(is_generator, kIsAsync);\012\012 if (impl()-&gt;ParsingDynamicFunctionDeclaration()) {\012 // We don't want dynamic functions to actually declare their name\012 // &quot;anonymous&quot;. We just want that name in the toString().\012 if (stack_overflow()) {\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012 Consume(Token::IDENTIFIER);\012    DCHECK(scanner()-&gt;CurrentMatchesContextual(Token::ANONYMOUS));\012 } else if (peek_any_identifier()) {\012    type = FunctionLiteral::kNamedExpression;\012 bool is_await = false;\012    name = ParseIdentifierOrStrictReservedWord(kind, &amp;is_strict_reserved,\012 &amp;is_await, CHECK_OK);\012 // If the function name is &quot;await&quot;, ParseIdentifierOrStrictReservedWord\012 // recognized the error.\012    DCHECK(!is_await);\012 }\012 return impl()-&gt;ParseFunctionLiteral(\012      name, scanner()-&gt;location(),\012      is_strict_reserved ? kFunctionNameIsStrictReserved\012 : kFunctionNameValidityUnknown,\012      kind, pos, type, language_mode(), nullptr, CHECK_OK);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParseTemplateLiteral(\012 ExpressionT tag, int start, bool tagged, bool* ok) {\012 // A TemplateLiteral is made up of 0 or more TEMPLATE_SPAN tokens (literal\012 // text followed by a substitution expression), finalized by a single\012 // TEMPLATE_TAIL.\012 //\012 // In terms of draft language, TEMPLATE_SPAN may be either the TemplateHead or\012 // TemplateMiddle productions, while TEMPLATE_TAIL is either TemplateTail, or\012 // NoSubstitutionTemplate.\012 //\012 // When parsing a TemplateLiteral, we must have scanned either an initial\012 // TEMPLATE_SPAN, or a TEMPLATE_TAIL.\012  DCHECK(peek() == Token::TEMPLATE_SPAN || peek() == Token::TEMPLATE_TAIL);\012\012 if (tagged) {\012 // TaggedTemplate expressions prevent the eval compilation cache from being\012 // used. This flag is only used if an eval is being parsed.\012    set_allow_eval_cache(false);\012 }\012\012 bool forbid_illegal_escapes = !tagged;\012\012 // If we reach a TEMPLATE_TAIL first, we are parsing a NoSubstitutionTemplate.\012 // In this case we may simply consume the token and build a template with a\012 // single TEMPLATE_SPAN and no expressions.\012 if (peek() == Token::TEMPLATE_TAIL) {\012 Consume(Token::TEMPLATE_TAIL);\012 int pos = position();\012 typename Impl::TemplateLiteralState ts = impl()-&gt;OpenTemplateLiteral(pos);\012 bool is_valid = CheckTemplateEscapes(forbid_illegal_escapes, CHECK_OK);\012    impl()-&gt;AddTemplateSpan(&amp;ts, is_valid, true);\012 return impl()-&gt;CloseTemplateLiteral(&amp;ts, start, tag);\012 }\012\012 Consume(Token::TEMPLATE_SPAN);\012 int pos = position();\012 typename Impl::TemplateLiteralState ts = impl()-&gt;OpenTemplateLiteral(pos);\012 bool is_valid = CheckTemplateEscapes(forbid_illegal_escapes, CHECK_OK);\012  impl()-&gt;AddTemplateSpan(&amp;ts, is_valid, false);\012 Token::Value next;\012\012 // If we open with a TEMPLATE_SPAN, we must scan the subsequent expression,\012 // and repeat if the following token is a TEMPLATE_SPAN as well (in this\012 // case, representing a TemplateMiddle).\012\012 do {\012 next = peek();\012 if (next == Token::EOS) {\012      impl()-&gt;ReportMessageAt(Scanner::Location(start, peek_position()),\012 MessageTemplate::kUnterminatedTemplate);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 } else if (next == Token::ILLEGAL) {\012      impl()-&gt;ReportMessageAt(\012 Scanner::Location(position() + 1, peek_position()),\012 MessageTemplate::kUnexpectedToken, &quot;ILLEGAL&quot;, kSyntaxError);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012\012 int expr_pos = peek_position();\012 ExpressionT expression = ParseExpressionCoverGrammar(true, CHECK_OK);\012 ValidateExpression(CHECK_OK);\012    impl()-&gt;AddTemplateExpression(&amp;ts, expression);\012\012 if (peek() != Token::RBRACE) {\012      impl()-&gt;ReportMessageAt(Scanner::Location(expr_pos, peek_position()),\012 MessageTemplate::kUnterminatedTemplateExpr);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012\012 // If we didn't die parsing that expression, our next token should be a\012 // TEMPLATE_SPAN or TEMPLATE_TAIL.\012 next = scanner()-&gt;ScanTemplateContinuation();\012 Next();\012    pos = position();\012\012 if (next == Token::EOS) {\012      impl()-&gt;ReportMessageAt(Scanner::Location(start, pos),\012 MessageTemplate::kUnterminatedTemplate);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 } else if (next == Token::ILLEGAL) {\012      impl()-&gt;ReportMessageAt(\012 Scanner::Location(position() + 1, peek_position()),\012 MessageTemplate::kUnexpectedToken, &quot;ILLEGAL&quot;, kSyntaxError);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012\012 bool is_valid = CheckTemplateEscapes(forbid_illegal_escapes, CHECK_OK);\012    impl()-&gt;AddTemplateSpan(&amp;ts, is_valid, next == Token::TEMPLATE_TAIL);\012 } while (next == Token::TEMPLATE_SPAN);\012\012  DCHECK_EQ(next, Token::TEMPLATE_TAIL);\012 // Once we've reached a TEMPLATE_TAIL, we can close the TemplateLiteral.\012 return impl()-&gt;CloseTemplateLiteral(&amp;ts, start, tag);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT\012ParserBase&lt;Impl&gt;::CheckAndRewriteReferenceExpression(\012 ExpressionT expression, int beg_pos, int end_pos,\012 MessageTemplate::Template message, bool* ok) {\012 return CheckAndRewriteReferenceExpression(expression, beg_pos, end_pos,\012                                            message, kReferenceError, ok);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT\012ParserBase&lt;Impl&gt;::CheckAndRewriteReferenceExpression(\012 ExpressionT expression, int beg_pos, int end_pos,\012 MessageTemplate::Template message, ParseErrorType type, bool* ok) {\012 if (impl()-&gt;IsIdentifier(expression) &amp;&amp; is_strict(language_mode()) &amp;&amp;\012      impl()-&gt;IsEvalOrArguments(impl()-&gt;AsIdentifier(expression))) {\012 ReportMessageAt(Scanner::Location(beg_pos, end_pos),\012 MessageTemplate::kStrictEvalArguments, kSyntaxError);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012 if (expression-&gt;IsValidReferenceExpression()) {\012 return expression;\012 }\012 if (expression-&gt;IsCall() &amp;&amp; !expression-&gt;AsCall()-&gt;is_tagged_template()) {\012 // If it is a call, make it a runtime error for legacy web compatibility.\012 // Bug: https://bugs.chromium.org/p/v8/issues/detail?id=4480\012 // Rewrite `expr' to `expr[throw ReferenceError]'.\012    impl()-&gt;CountUsage(\012        is_strict(language_mode())\012 ? v8::Isolate::kAssigmentExpressionLHSIsCallInStrict\012 : v8::Isolate::kAssigmentExpressionLHSIsCallInSloppy);\012 ExpressionT error = impl()-&gt;NewThrowReferenceError(message, beg_pos);\012 return factory()-&gt;NewProperty(expression, error, beg_pos);\012 }\012 ReportMessageAt(Scanner::Location(beg_pos, end_pos), message, type);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012}\012\012template &lt;typename Impl&gt;\012bool ParserBase&lt;Impl&gt;::IsValidReferenceExpression(ExpressionT expression) {\012 return IsAssignableIdentifier(expression) || expression-&gt;IsProperty();\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::CheckDestructuringElement(ExpressionT expression,\012 int begin, int end) {\012 if (!IsValidPattern(expression) &amp;&amp; !expression-&gt;IsAssignment() &amp;&amp;\012 !IsValidReferenceExpression(expression)) {\012    classifier()-&gt;RecordAssignmentPatternError(\012 Scanner::Location(begin, end),\012 MessageTemplate::kInvalidDestructuringTarget);\012 }\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParseV8Intrinsic(\012 bool* ok) {\012 // CallRuntime ::\012 //   '%' Identifier Arguments\012\012 int pos = peek_position();\012 Expect(Token::MOD, CHECK_OK);\012 // Allow &quot;eval&quot; or &quot;arguments&quot; for backward compatibility.\012 IdentifierT name = ParseIdentifier(kAllowRestrictedIdentifiers, CHECK_OK);\012 Scanner::Location spread_pos;\012 ExpressionClassifier classifier(this);\012 ExpressionListT args = ParseArguments(&amp;spread_pos, CHECK_OK);\012\012 if (spread_pos.IsValid()) {\012 *ok = false;\012 ReportMessageAt(spread_pos, MessageTemplate::kIntrinsicWithSpread,\012                    kSyntaxError);\012 return impl()-&gt;NullExpression();\012 }\012\012 return impl()-&gt;NewV8Intrinsic(name, args, pos, ok);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParseDoExpression(\012 bool* ok) {\012 // AssignmentExpression ::\012 //     do '{' StatementList '}'\012\012 int pos = peek_position();\012 Expect(Token::DO, CHECK_OK);\012 BlockT block = ParseBlock(nullptr, CHECK_OK);\012 return impl()-&gt;RewriteDoExpression(block, pos, ok);\012}\012\012// Redefinition of CHECK_OK for parsing statements.\012#undef CHECK_OK\012#define CHECK_OK CHECK_OK_CUSTOM(NullStatement)\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::LazyParsingResult\012ParserBase&lt;Impl&gt;::ParseStatementList(StatementListT body,\012 Token::Value end_token, bool may_abort,\012 bool* ok) {\012 // StatementList ::\012 //   (StatementListItem)* &lt;end_token&gt;\012\012 // Allocate a target stack to use for this set of source\012 // elements. This way, all scripts and functions get their own\012 // target stack thus avoiding illegal breaks and continues across\012 // functions.\012 typename Types::TargetScope target_scope(this);\012 int count_statements = 0;\012\012  DCHECK(!impl()-&gt;IsNull(body));\012 bool directive_prologue = true; // Parsing directive prologue.\012\012 while (peek() != end_token) {\012 if (directive_prologue &amp;&amp; peek() != Token::STRING) {\012      directive_prologue = false;\012 }\012\012 bool starts_with_identifier = peek() == Token::IDENTIFIER;\012 Scanner::Location token_loc = scanner()-&gt;peek_location();\012 StatementT stat =\012 ParseStatementListItem(CHECK_OK_CUSTOM(Return, kLazyParsingComplete));\012\012 if (impl()-&gt;IsNull(stat) || stat-&gt;IsEmptyStatement()) {\012      directive_prologue = false; // End of directive prologue.\012 continue;\012 }\012\012 if (directive_prologue) {\012 // The length of the token is used to distinguish between strings literals\012 // that evaluate equal to directives but contain either escape sequences\012 // (e.g., &quot;use \x73trict&quot;) or line continuations (e.g., &quot;use \(newline)\012 // strict&quot;).\012 if (impl()-&gt;IsUseStrictDirective(stat) &amp;&amp;\012          token_loc.end_pos - token_loc.beg_pos == sizeof(&quot;use strict&quot;) + 1) {\012 // Directive &quot;use strict&quot; (ES5 14.1).\012 RaiseLanguageMode(LanguageMode::kStrict);\012 if (!scope()-&gt;HasSimpleParameters()) {\012 // TC39 deemed &quot;use strict&quot; directives to be an error when occurring\012 // in the body of a function with non-simple parameter list, on\012 // 29/7/2015. https://goo.gl/ueA7Ln\012          impl()-&gt;ReportMessageAt(\012              token_loc, MessageTemplate::kIllegalLanguageModeDirective,\012 &quot;use strict&quot;);\012 *ok = false;\012 return kLazyParsingComplete;\012 }\012 } else if (impl()-&gt;IsUseAsmDirective(stat) &amp;&amp;\012                 token_loc.end_pos - token_loc.beg_pos ==\012 sizeof(&quot;use asm&quot;) + 1) {\012 // Directive &quot;use asm&quot;.\012        impl()-&gt;SetAsmModule();\012 } else if (impl()-&gt;IsStringLiteral(stat)) {\012 // Possibly an unknown directive.\012 // Should not change mode, but will increment usage counters\012 // as appropriate. Ditto usages below.\012 RaiseLanguageMode(LanguageMode::kSloppy);\012 } else {\012 // End of the directive prologue.\012        directive_prologue = false;\012 RaiseLanguageMode(LanguageMode::kSloppy);\012 }\012 } else {\012 RaiseLanguageMode(LanguageMode::kSloppy);\012 }\012\012 // If we're allowed to abort, we will do so when we see a &quot;long and\012 // trivial&quot; function. Our current definition of &quot;long and trivial&quot; is:\012 // - over kLazyParseTrialLimit statements\012 // - all starting with an identifier (i.e., no if, for, while, etc.)\012 if (may_abort) {\012 if (!starts_with_identifier) {\012        may_abort = false;\012 } else if (++count_statements &gt; kLazyParseTrialLimit) {\012 return kLazyParsingAborted;\012 }\012 }\012\012    body-&gt;Add(stat, zone());\012 }\012 return kLazyParsingComplete;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseStatementListItem(\012 bool* ok) {\012 // ECMA 262 6th Edition\012 // StatementListItem[Yield, Return] :\012 //   Statement[?Yield, ?Return]\012 //   Declaration[?Yield]\012 //\012 // Declaration[Yield] :\012 //   HoistableDeclaration[?Yield]\012 //   ClassDeclaration[?Yield]\012 //   LexicalDeclaration[In, ?Yield]\012 //\012 // HoistableDeclaration[Yield, Default] :\012 //   FunctionDeclaration[?Yield, ?Default]\012 //   GeneratorDeclaration[?Yield, ?Default]\012 //\012 // LexicalDeclaration[In, Yield] :\012 //   LetOrConst BindingList[?In, ?Yield] ;\012\012 switch (peek()) {\012 case Token::FUNCTION:\012 return ParseHoistableDeclaration(nullptr, false, ok);\012 case Token::CLASS:\012 Consume(Token::CLASS);\012 return ParseClassDeclaration(nullptr, false, ok);\012 case Token::VAR:\012 case Token::CONST:\012 return ParseVariableStatement(kStatementListItem, nullptr, ok);\012 case Token::LET:\012 if (IsNextLetKeyword()) {\012 return ParseVariableStatement(kStatementListItem, nullptr, ok);\012 }\012 break;\012 case Token::ASYNC:\012 if (PeekAhead() == Token::FUNCTION &amp;&amp;\012 !scanner()-&gt;HasLineTerminatorAfterNext()) {\012 Consume(Token::ASYNC);\012 return ParseAsyncFunctionDeclaration(nullptr, false, ok);\012 }\012 break;\012 default:\012 break;\012 }\012 return ParseStatement(nullptr, nullptr, kAllowLabelledFunctionStatement, ok);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseStatement(\012 ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels,\012 AllowLabelledFunctionStatement allow_function, bool* ok) {\012 // Statement ::\012 //   Block\012 //   VariableStatement\012 //   EmptyStatement\012 //   ExpressionStatement\012 //   IfStatement\012 //   IterationStatement\012 //   ContinueStatement\012 //   BreakStatement\012 //   ReturnStatement\012 //   WithStatement\012 //   LabelledStatement\012 //   SwitchStatement\012 //   ThrowStatement\012 //   TryStatement\012 //   DebuggerStatement\012\012 // {own_labels} is always a subset of {labels}.\012  DCHECK_IMPLIES(labels == nullptr, own_labels == nullptr);\012\012 // Note: Since labels can only be used by 'break' and 'continue'\012 // statements, which themselves are only valid within blocks,\012 // iterations or 'switch' statements (i.e., BreakableStatements),\012 // labels can be simply ignored in all other cases; except for\012 // trivial labeled break statements 'label: break label' which is\012 // parsed into an empty statement.\012 switch (peek()) {\012 case Token::LBRACE:\012 return ParseBlock(labels, ok);\012 case Token::SEMICOLON:\012 Next();\012 return factory()-&gt;NewEmptyStatement(kNoSourcePosition);\012 case Token::IF:\012 return ParseIfStatement(labels, ok);\012 case Token::DO:\012 return ParseDoWhileStatement(labels, own_labels, ok);\012 case Token::WHILE:\012 return ParseWhileStatement(labels, own_labels, ok);\012 case Token::FOR:\012 if (V8_UNLIKELY(is_async_function() &amp;&amp; PeekAhead() == Token::AWAIT)) {\012 return ParseForAwaitStatement(labels, own_labels, ok);\012 }\012 return ParseForStatement(labels, own_labels, ok);\012 case Token::CONTINUE:\012 return ParseContinueStatement(ok);\012 case Token::BREAK:\012 return ParseBreakStatement(labels, ok);\012 case Token::RETURN:\012 return ParseReturnStatement(ok);\012 case Token::THROW:\012 return ParseThrowStatement(ok);\012 case Token::TRY: {\012 // It is somewhat complicated to have labels on try-statements.\012 // When breaking out of a try-finally statement, one must take\012 // great care not to treat it as a fall-through. It is much easier\012 // just to wrap the entire try-statement in a statement block and\012 // put the labels there.\012 if (labels == nullptr) return ParseTryStatement(ok);\012 BlockT result = factory()-&gt;NewBlock(1, false, labels);\012 typename Types::Target target(this, result);\012 StatementT statement = ParseTryStatement(CHECK_OK);\012      result-&gt;statements()-&gt;Add(statement, zone());\012 return result;\012 }\012 case Token::WITH:\012 return ParseWithStatement(labels, ok);\012 case Token::SWITCH:\012 return ParseSwitchStatement(labels, ok);\012 case Token::FUNCTION:\012 // FunctionDeclaration only allowed as a StatementListItem, not in\012 // an arbitrary Statement position. Exceptions such as\012 // ES#sec-functiondeclarations-in-ifstatement-statement-clauses\012 // are handled by calling ParseScopedStatement rather than\012 // ParseStatement directly.\012      impl()-&gt;ReportMessageAt(scanner()-&gt;peek_location(),\012                              is_strict(language_mode())\012 ? MessageTemplate::kStrictFunction\012 : MessageTemplate::kSloppyFunction);\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 case Token::DEBUGGER:\012 return ParseDebuggerStatement(ok);\012 case Token::VAR:\012 return ParseVariableStatement(kStatement, nullptr, ok);\012 case Token::ASYNC:\012 if (!scanner()-&gt;HasLineTerminatorAfterNext() &amp;&amp;\012 PeekAhead() == Token::FUNCTION) {\012        impl()-&gt;ReportMessageAt(\012            scanner()-&gt;peek_location(),\012 MessageTemplate::kAsyncFunctionInSingleStatementContext);\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 }\012      V8_FALLTHROUGH;\012 default:\012 return ParseExpressionOrLabelledStatement(labels, own_labels,\012                                                allow_function, ok);\012 }\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::BlockT ParserBase&lt;Impl&gt;::ParseBlock(\012 ZonePtrList&lt;const AstRawString&gt;* labels, bool* ok) {\012 // Block ::\012 //   '{' StatementList '}'\012\012 // Construct block expecting 16 statements.\012 BlockT body = factory()-&gt;NewBlock(16, false, labels);\012\012 // Parse the statements and collect escaping labels.\012 Expect(Token::LBRACE, CHECK_OK_CUSTOM(NullStatement));\012 {\012 BlockState block_state(zone(), &amp;scope_);\012    scope()-&gt;set_start_position(scanner()-&gt;location().beg_pos);\012 typename Types::Target target(this, body);\012\012 while (peek() != Token::RBRACE) {\012 StatementT stat = ParseStatementListItem(CHECK_OK_CUSTOM(NullStatement));\012 if (!impl()-&gt;IsNull(stat) &amp;&amp; !stat-&gt;IsEmptyStatement()) {\012        body-&gt;statements()-&gt;Add(stat, zone());\012 }\012 }\012\012 Expect(Token::RBRACE, CHECK_OK_CUSTOM(NullStatement));\012 int end_pos = scanner()-&gt;location().end_pos;\012    scope()-&gt;set_end_position(end_pos);\012    impl()-&gt;RecordBlockSourceRange(body, end_pos);\012    body-&gt;set_scope(scope()-&gt;FinalizeBlockScope());\012 }\012 return body;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseScopedStatement(\012 ZonePtrList&lt;const AstRawString&gt;* labels, bool* ok) {\012 if (is_strict(language_mode()) || peek() != Token::FUNCTION) {\012 return ParseStatement(labels, nullptr, ok);\012 } else {\012 // Make a block around the statement for a lexical binding\012 // is introduced by a FunctionDeclaration.\012 BlockState block_state(zone(), &amp;scope_);\012    scope()-&gt;set_start_position(scanner()-&gt;location().beg_pos);\012 BlockT block = factory()-&gt;NewBlock(1, false);\012 StatementT body = ParseFunctionDeclaration(CHECK_OK);\012    block-&gt;statements()-&gt;Add(body, zone());\012    scope()-&gt;set_end_position(scanner()-&gt;location().end_pos);\012    block-&gt;set_scope(scope()-&gt;FinalizeBlockScope());\012 return block;\012 }\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseVariableStatement(\012 VariableDeclarationContext var_context,\012 ZonePtrList&lt;const AstRawString&gt;* names, bool* ok) {\012 // VariableStatement ::\012 //   VariableDeclarations ';'\012\012 // The scope of a var declared variable anywhere inside a function\012 // is the entire function (ECMA-262, 3rd, 10.1.3, and 12.2). Thus we can\012 // transform a source-level var declaration into a (Function) Scope\012 // declaration, and rewrite the source-level initialization into an assignment\012 // statement. We use a block to collect multiple assignments.\012 //\012 // We mark the block as initializer block because we don't want the\012 // rewriter to add a '.result' assignment to such a block (to get compliant\012 // behavior for code such as print(eval('var x = 7')), and for cosmetic\012 // reasons when pretty-printing. Also, unless an assignment (initialization)\012 // is inside an initializer block, it is ignored.\012\012 DeclarationParsingResult parsing_result;\012 StatementT result =\012 ParseVariableDeclarations(var_context, &amp;parsing_result, names, CHECK_OK);\012 ExpectSemicolon(CHECK_OK);\012 return result;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseDebuggerStatement(\012 bool* ok) {\012 // In ECMA-262 'debugger' is defined as a reserved keyword. In some browser\012 // contexts this is used as a statement which invokes the debugger as i a\012 // break point is present.\012 // DebuggerStatement ::\012 //   'debugger' ';'\012\012 int pos = peek_position();\012 Expect(Token::DEBUGGER, CHECK_OK);\012 ExpectSemicolon(CHECK_OK);\012 return factory()-&gt;NewDebuggerStatement(pos);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT\012ParserBase&lt;Impl&gt;::ParseExpressionOrLabelledStatement(\012 ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels,\012 AllowLabelledFunctionStatement allow_function, bool* ok) {\012 // ExpressionStatement | LabelledStatement ::\012 //   Expression ';'\012 //   Identifier ':' Statement\012 //\012 // ExpressionStatement[Yield] :\012 //   [lookahead notin {{, function, class, let [}] Expression[In, ?Yield] ;\012\012 int pos = peek_position();\012\012 switch (peek()) {\012 case Token::FUNCTION:\012 case Token::LBRACE:\012      UNREACHABLE(); // Always handled by the callers.\012 case Token::CLASS:\012 ReportUnexpectedToken(Next());\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 case Token::LET: {\012 Token::Value next_next = PeekAhead();\012 // &quot;let&quot; followed by either &quot;[&quot;, &quot;{&quot; or an identifier means a lexical\012 // declaration, which should not appear here.\012 // However, ASI may insert a line break before an identifier or a brace.\012 if (next_next != Token::LBRACK &amp;&amp;\012 ((next_next != Token::LBRACE &amp;&amp; next_next != Token::IDENTIFIER) ||\012           scanner_-&gt;HasLineTerminatorAfterNext())) {\012 break;\012 }\012      impl()-&gt;ReportMessageAt(scanner()-&gt;peek_location(),\012 MessageTemplate::kUnexpectedLexicalDeclaration);\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 }\012 default:\012 break;\012 }\012\012 bool starts_with_identifier = peek_any_identifier();\012 ExpressionT expr = ParseExpression(true, CHECK_OK);\012 if (peek() == Token::COLON &amp;&amp; starts_with_identifier &amp;&amp;\012      impl()-&gt;IsIdentifier(expr)) {\012 // The whole expression was a single identifier, and not, e.g.,\012 // something starting with an identifier or a parenthesized identifier.\012    impl()-&gt;DeclareLabel(&amp;labels, &amp;own_labels,\012                         impl()-&gt;AsIdentifierExpression(expr), CHECK_OK);\012 Consume(Token::COLON);\012 // ES#sec-labelled-function-declarations Labelled Function Declarations\012 if (peek() == Token::FUNCTION &amp;&amp; is_sloppy(language_mode()) &amp;&amp;\012        allow_function == kAllowLabelledFunctionStatement) {\012 return ParseFunctionDeclaration(ok);\012 }\012 return ParseStatement(labels, own_labels, allow_function, ok);\012 }\012\012 // If we have an extension, we allow a native function declaration.\012 // A native function declaration starts with &quot;native function&quot; with\012 // no line-terminator between the two words.\012 if (extension_ != nullptr &amp;&amp; peek() == Token::FUNCTION &amp;&amp;\012 !scanner()-&gt;HasLineTerminatorBeforeNext() &amp;&amp; impl()-&gt;IsNative(expr) &amp;&amp;\012 !scanner()-&gt;literal_contains_escapes()) {\012 return ParseNativeDeclaration(ok);\012 }\012\012 // Parsed expression statement, followed by semicolon.\012 ExpectSemicolon(CHECK_OK);\012 return factory()-&gt;NewExpressionStatement(expr, pos);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseIfStatement(\012 ZonePtrList&lt;const AstRawString&gt;* labels, bool* ok) {\012 // IfStatement ::\012 //   'if' '(' Expression ')' Statement ('else' Statement)?\012\012 int pos = peek_position();\012 Expect(Token::IF, CHECK_OK);\012 Expect(Token::LPAREN, CHECK_OK);\012 ExpressionT condition = ParseExpression(true, CHECK_OK);\012 Expect(Token::RPAREN, CHECK_OK);\012\012 SourceRange then_range, else_range;\012 StatementT then_statement = impl()-&gt;NullStatement();\012 {\012 SourceRangeScope range_scope(scanner(), &amp;then_range);\012    then_statement = ParseScopedStatement(labels, CHECK_OK);\012 }\012\012 StatementT else_statement = impl()-&gt;NullStatement();\012 if (Check(Token::ELSE)) {\012    else_range = SourceRange::ContinuationOf(then_range);\012    else_statement = ParseScopedStatement(labels, CHECK_OK);\012    else_range.end = scanner_-&gt;location().end_pos;\012 } else {\012    else_statement = factory()-&gt;NewEmptyStatement(kNoSourcePosition);\012 }\012 StatementT stmt =\012      factory()-&gt;NewIfStatement(condition, then_statement, else_statement, pos);\012  impl()-&gt;RecordIfStatementSourceRange(stmt, then_range, else_range);\012 return stmt;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseContinueStatement(\012 bool* ok) {\012 // ContinueStatement ::\012 //   'continue' Identifier? ';'\012\012 int pos = peek_position();\012 Expect(Token::CONTINUE, CHECK_OK);\012 IdentifierT label = impl()-&gt;NullIdentifier();\012 Token::Value tok = peek();\012 if (!scanner()-&gt;HasLineTerminatorBeforeNext() &amp;&amp; tok != Token::SEMICOLON &amp;&amp;\012      tok != Token::RBRACE &amp;&amp; tok != Token::EOS) {\012 // ECMA allows &quot;eval&quot; or &quot;arguments&quot; as labels even in strict mode.\012    label = ParseIdentifier(kAllowRestrictedIdentifiers, CHECK_OK);\012 }\012 typename Types::IterationStatement target =\012      impl()-&gt;LookupContinueTarget(label, CHECK_OK);\012 if (impl()-&gt;IsNull(target)) {\012 // Illegal continue statement.\012 MessageTemplate::Template message = MessageTemplate::kIllegalContinue;\012 typename Types::BreakableStatement breakable_target =\012        impl()-&gt;LookupBreakTarget(label, CHECK_OK);\012 if (impl()-&gt;IsNull(label)) {\012      message = MessageTemplate::kNoIterationStatement;\012 } else if (impl()-&gt;IsNull(breakable_target)) {\012      message = MessageTemplate::kUnknownLabel;\012 }\012 ReportMessage(message, label);\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 }\012 ExpectSemicolon(CHECK_OK);\012 StatementT stmt = factory()-&gt;NewContinueStatement(target, pos);\012  impl()-&gt;RecordJumpStatementSourceRange(stmt, scanner_-&gt;location().end_pos);\012 return stmt;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseBreakStatement(\012 ZonePtrList&lt;const AstRawString&gt;* labels, bool* ok) {\012 // BreakStatement ::\012 //   'break' Identifier? ';'\012\012 int pos = peek_position();\012 Expect(Token::BREAK, CHECK_OK);\012 IdentifierT label = impl()-&gt;NullIdentifier();\012 Token::Value tok = peek();\012 if (!scanner()-&gt;HasLineTerminatorBeforeNext() &amp;&amp; tok != Token::SEMICOLON &amp;&amp;\012      tok != Token::RBRACE &amp;&amp; tok != Token::EOS) {\012 // ECMA allows &quot;eval&quot; or &quot;arguments&quot; as labels even in strict mode.\012    label = ParseIdentifier(kAllowRestrictedIdentifiers, CHECK_OK);\012 }\012 // Parse labeled break statements that target themselves into\012 // empty statements, e.g. 'l1: l2: l3: break l2;'\012 if (!impl()-&gt;IsNull(label) &amp;&amp; impl()-&gt;ContainsLabel(labels, label)) {\012 ExpectSemicolon(CHECK_OK);\012 return factory()-&gt;NewEmptyStatement(pos);\012 }\012 typename Types::BreakableStatement target =\012      impl()-&gt;LookupBreakTarget(label, CHECK_OK);\012 if (impl()-&gt;IsNull(target)) {\012 // Illegal break statement.\012 MessageTemplate::Template message = MessageTemplate::kIllegalBreak;\012 if (!impl()-&gt;IsNull(label)) {\012      message = MessageTemplate::kUnknownLabel;\012 }\012 ReportMessage(message, label);\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 }\012 ExpectSemicolon(CHECK_OK);\012 StatementT stmt = factory()-&gt;NewBreakStatement(target, pos);\012  impl()-&gt;RecordJumpStatementSourceRange(stmt, scanner_-&gt;location().end_pos);\012 return stmt;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseReturnStatement(\012 bool* ok) {\012 // ReturnStatement ::\012 //   'return' [no line terminator] Expression? ';'\012\012 // Consume the return token. It is necessary to do that before\012 // reporting any errors on it, because of the way errors are\012 // reported (underlining).\012 Expect(Token::RETURN, CHECK_OK);\012 Scanner::Location loc = scanner()-&gt;location();\012\012 switch (GetDeclarationScope()-&gt;scope_type()) {\012 case SCRIPT_SCOPE:\012 case EVAL_SCOPE:\012 case MODULE_SCOPE:\012      impl()-&gt;ReportMessageAt(loc, MessageTemplate::kIllegalReturn);\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 default:\012 break;\012 }\012\012 Token::Value tok = peek();\012 ExpressionT return_value = impl()-&gt;NullExpression();\012 if (scanner()-&gt;HasLineTerminatorBeforeNext() || tok == Token::SEMICOLON ||\012      tok == Token::RBRACE || tok == Token::EOS) {\012 if (IsDerivedConstructor(function_state_-&gt;kind())) {\012      return_value = impl()-&gt;ThisExpression(loc.beg_pos);\012 }\012 } else {\012    return_value = ParseExpression(true, CHECK_OK);\012 }\012 ExpectSemicolon(CHECK_OK);\012  return_value = impl()-&gt;RewriteReturn(return_value, loc.beg_pos);\012 int continuation_pos = scanner_-&gt;location().end_pos;\012 StatementT stmt =\012 BuildReturnStatement(return_value, loc.beg_pos, continuation_pos);\012  impl()-&gt;RecordJumpStatementSourceRange(stmt, scanner_-&gt;location().end_pos);\012 return stmt;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseWithStatement(\012 ZonePtrList&lt;const AstRawString&gt;* labels, bool* ok) {\012 // WithStatement ::\012 //   'with' '(' Expression ')' Statement\012\012 Expect(Token::WITH, CHECK_OK);\012 int pos = position();\012\012 if (is_strict(language_mode())) {\012 ReportMessage(MessageTemplate::kStrictWith);\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 }\012\012 Expect(Token::LPAREN, CHECK_OK);\012 ExpressionT expr = ParseExpression(true, CHECK_OK);\012 Expect(Token::RPAREN, CHECK_OK);\012\012 Scope* with_scope = NewScope(WITH_SCOPE);\012 StatementT body = impl()-&gt;NullStatement();\012 {\012 BlockState block_state(&amp;scope_, with_scope);\012    with_scope-&gt;set_start_position(scanner()-&gt;peek_location().beg_pos);\012    body = ParseStatement(labels, nullptr, CHECK_OK);\012    with_scope-&gt;set_end_position(scanner()-&gt;location().end_pos);\012 }\012 return factory()-&gt;NewWithStatement(with_scope, expr, body, pos);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseDoWhileStatement(\012 ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels, bool* ok) {\012 // DoStatement ::\012 //   'do' Statement 'while' '(' Expression ')' ';'\012\012 auto loop =\012      factory()-&gt;NewDoWhileStatement(labels, own_labels, peek_position());\012 typename Types::Target target(this, loop);\012\012 SourceRange body_range;\012 StatementT body = impl()-&gt;NullStatement();\012\012 Expect(Token::DO, CHECK_OK);\012 {\012 SourceRangeScope range_scope(scanner(), &amp;body_range);\012    body = ParseStatement(nullptr, nullptr, CHECK_OK);\012 }\012 Expect(Token::WHILE, CHECK_OK);\012 Expect(Token::LPAREN, CHECK_OK);\012\012 ExpressionT cond = ParseExpression(true, CHECK_OK);\012 Expect(Token::RPAREN, CHECK_OK);\012\012 // Allow do-statements to be terminated with and without\012 // semi-colons. This allows code such as 'do;while(0)return' to\012 // parse, which would not be the case if we had used the\012 // ExpectSemicolon() functionality here.\012 Check(Token::SEMICOLON);\012\012  loop-&gt;Initialize(cond, body);\012  impl()-&gt;RecordIterationStatementSourceRange(loop, body_range);\012\012 return loop;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseWhileStatement(\012 ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels, bool* ok) {\012 // WhileStatement ::\012 //   'while' '(' Expression ')' Statement\012\012 auto loop = factory()-&gt;NewWhileStatement(labels, own_labels, peek_position());\012 typename Types::Target target(this, loop);\012\012 SourceRange body_range;\012 StatementT body = impl()-&gt;NullStatement();\012\012 Expect(Token::WHILE, CHECK_OK);\012 Expect(Token::LPAREN, CHECK_OK);\012 ExpressionT cond = ParseExpression(true, CHECK_OK);\012 Expect(Token::RPAREN, CHECK_OK);\012 {\012 SourceRangeScope range_scope(scanner(), &amp;body_range);\012    body = ParseStatement(nullptr, nullptr, CHECK_OK);\012 }\012\012  loop-&gt;Initialize(cond, body);\012  impl()-&gt;RecordIterationStatementSourceRange(loop, body_range);\012\012 return loop;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseThrowStatement(\012 bool* ok) {\012 // ThrowStatement ::\012 //   'throw' Expression ';'\012\012 Expect(Token::THROW, CHECK_OK);\012 int pos = position();\012 if (scanner()-&gt;HasLineTerminatorBeforeNext()) {\012 ReportMessage(MessageTemplate::kNewlineAfterThrow);\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 }\012 ExpressionT exception = ParseExpression(true, CHECK_OK);\012 ExpectSemicolon(CHECK_OK);\012\012 StatementT stmt = impl()-&gt;NewThrowStatement(exception, pos);\012  impl()-&gt;RecordThrowSourceRange(stmt, scanner_-&gt;location().end_pos);\012\012 return stmt;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseSwitchStatement(\012 ZonePtrList&lt;const AstRawString&gt;* labels, bool* ok) {\012 // SwitchStatement ::\012 //   'switch' '(' Expression ')' '{' CaseClause* '}'\012 // CaseClause ::\012 //   'case' Expression ':' StatementList\012 //   'default' ':' StatementList\012\012 int switch_pos = peek_position();\012\012 Expect(Token::SWITCH, CHECK_OK);\012 Expect(Token::LPAREN, CHECK_OK);\012 ExpressionT tag = ParseExpression(true, CHECK_OK);\012 Expect(Token::RPAREN, CHECK_OK);\012\012 auto switch_statement =\012      factory()-&gt;NewSwitchStatement(labels, tag, switch_pos);\012\012 {\012 BlockState cases_block_state(zone(), &amp;scope_);\012    scope()-&gt;set_start_position(switch_pos);\012    scope()-&gt;SetNonlinear();\012 typename Types::Target target(this, switch_statement);\012\012 bool default_seen = false;\012 Expect(Token::LBRACE, CHECK_OK);\012 while (peek() != Token::RBRACE) {\012 // An empty label indicates the default case.\012 ExpressionT label = impl()-&gt;NullExpression();\012 SourceRange clause_range;\012 SourceRangeScope range_scope(scanner(), &amp;clause_range);\012 if (Check(Token::CASE)) {\012        label = ParseExpression(true, CHECK_OK);\012 } else {\012 Expect(Token::DEFAULT, CHECK_OK);\012 if (default_seen) {\012 ReportMessage(MessageTemplate::kMultipleDefaultsInSwitch);\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 }\012        default_seen = true;\012 }\012 Expect(Token::COLON, CHECK_OK);\012 StatementListT statements = impl()-&gt;NewStatementList(5);\012 while (peek() != Token::CASE &amp;&amp; peek() != Token::DEFAULT &amp;&amp;\012             peek() != Token::RBRACE) {\012 StatementT stat = ParseStatementListItem(CHECK_OK);\012        statements-&gt;Add(stat, zone());\012 }\012 auto clause = factory()-&gt;NewCaseClause(label, statements);\012      impl()-&gt;RecordCaseClauseSourceRange(clause, range_scope.Finalize());\012      switch_statement-&gt;cases()-&gt;Add(clause, zone());\012 }\012 Expect(Token::RBRACE, CHECK_OK);\012\012 int end_position = scanner()-&gt;location().end_pos;\012    scope()-&gt;set_end_position(end_position);\012    impl()-&gt;RecordSwitchStatementSourceRange(switch_statement, end_position);\012 Scope* switch_scope = scope()-&gt;FinalizeBlockScope();\012 if (switch_scope != nullptr) {\012 return impl()-&gt;RewriteSwitchStatement(switch_statement, switch_scope);\012 }\012 return switch_statement;\012 }\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseTryStatement(\012 bool* ok) {\012 // TryStatement ::\012 //   'try' Block Catch\012 //   'try' Block Finally\012 //   'try' Block Catch Finally\012 //\012 // Catch ::\012 //   'catch' '(' Identifier ')' Block\012 //\012 // Finally ::\012 //   'finally' Block\012\012 Expect(Token::TRY, CHECK_OK);\012 int pos = position();\012\012 BlockT try_block = ParseBlock(nullptr, CHECK_OK);\012\012 CatchInfo catch_info(this);\012\012 if (peek() != Token::CATCH &amp;&amp; peek() != Token::FINALLY) {\012 ReportMessage(MessageTemplate::kNoCatchOrFinally);\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 }\012\012 SourceRange catch_range, finally_range;\012\012 BlockT catch_block = impl()-&gt;NullStatement();\012 {\012 SourceRangeScope catch_range_scope(scanner(), &amp;catch_range);\012 if (Check(Token::CATCH)) {\012 bool has_binding;\012      has_binding = Check(Token::LPAREN);\012\012 if (has_binding) {\012        catch_info.scope = NewScope(CATCH_SCOPE);\012        catch_info.scope-&gt;set_start_position(scanner()-&gt;location().beg_pos);\012\012 {\012 BlockState catch_block_state(&amp;scope_, catch_info.scope);\012\012          catch_block = factory()-&gt;NewBlock(16, false);\012\012 // Create a block scope to hold any lexical declarations created\012 // as part of destructuring the catch parameter.\012 {\012 BlockState catch_variable_block_state(zone(), &amp;scope_);\012            scope()-&gt;set_start_position(scanner()-&gt;location().beg_pos);\012\012 // This does not simply call ParsePrimaryExpression to avoid\012 // ExpressionFromIdentifier from being called in the first\012 // branch, which would introduce an unresolved symbol and mess\012 // with arrow function names.\012 if (peek_any_identifier()) {\012              catch_info.name =\012 ParseIdentifier(kDontAllowRestrictedIdentifiers, CHECK_OK);\012 } else {\012 ExpressionClassifier pattern_classifier(this);\012              catch_info.pattern = ParsePrimaryExpression(CHECK_OK);\012 ValidateBindingPattern(CHECK_OK);\012 }\012\012 Expect(Token::RPAREN, CHECK_OK);\012            impl()-&gt;RewriteCatchPattern(&amp;catch_info, CHECK_OK);\012 if (!impl()-&gt;IsNull(catch_info.init_block)) {\012              catch_block-&gt;statements()-&gt;Add(catch_info.init_block, zone());\012 }\012\012            catch_info.inner_block = ParseBlock(nullptr, CHECK_OK);\012            catch_block-&gt;statements()-&gt;Add(catch_info.inner_block, zone());\012            impl()-&gt;ValidateCatchBlock(catch_info, CHECK_OK);\012            scope()-&gt;set_end_position(scanner()-&gt;location().end_pos);\012            catch_block-&gt;set_scope(scope()-&gt;FinalizeBlockScope());\012 }\012 }\012\012        catch_info.scope-&gt;set_end_position(scanner()-&gt;location().end_pos);\012 } else {\012        catch_block = ParseBlock(nullptr, CHECK_OK);\012 }\012 }\012 }\012\012 BlockT finally_block = impl()-&gt;NullStatement();\012  DCHECK(peek() == Token::FINALLY || !impl()-&gt;IsNull(catch_block));\012 {\012 SourceRangeScope range_scope(scanner(), &amp;finally_range);\012 if (Check(Token::FINALLY)) {\012      finally_block = ParseBlock(nullptr, CHECK_OK);\012 }\012 }\012\012 return impl()-&gt;RewriteTryStatement(try_block, catch_block, catch_range,\012                                     finally_block, finally_range, catch_info,\012                                     pos);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseForStatement(\012 ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels, bool* ok) {\012 // Either a standard for loop\012 //   for (&lt;init&gt;; &lt;cond&gt;; &lt;next&gt;) { ... }\012 // or a for-each loop\012 //   for (&lt;each&gt; of|in &lt;iterable&gt;) { ... }\012 //\012 // We parse a declaration/expression after the 'for (' and then read the first\012 // expression/declaration before we know if this is a for or a for-each.\012\012 int stmt_pos = peek_position();\012 ForInfo for_info(this);\012\012 Expect(Token::FOR, CHECK_OK);\012 Expect(Token::LPAREN, CHECK_OK);\012\012 if (peek() == Token::CONST || (peek() == Token::LET &amp;&amp; IsNextLetKeyword())) {\012 // The initializer contains lexical declarations,\012 // so create an in-between scope.\012 BlockState for_state(zone(), &amp;scope_);\012    scope()-&gt;set_start_position(scanner()-&gt;location().beg_pos);\012\012 // Also record whether inner functions or evals are found inside\012 // this loop, as this information is used to simplify the desugaring\012 // if none are found.\012 typename FunctionState::FunctionOrEvalRecordingScope recording_scope(\012        function_state_);\012\012 // Create an inner block scope which will be the parent scope of scopes\012 // possibly created by ParseVariableDeclarations.\012 Scope* inner_block_scope = NewScope(BLOCK_SCOPE);\012 {\012 BlockState inner_state(&amp;scope_, inner_block_scope);\012 ParseVariableDeclarations(kForStatement, &amp;for_info.parsing_result,\012 nullptr, CHECK_OK);\012 }\012    DCHECK(IsLexicalVariableMode(for_info.parsing_result.descriptor.mode));\012    for_info.position = scanner()-&gt;location().beg_pos;\012\012 if (CheckInOrOf(&amp;for_info.mode)) {\012      scope()-&gt;set_is_hidden();\012 return ParseForEachStatementWithDeclarations(\012          stmt_pos, &amp;for_info, labels, own_labels, inner_block_scope, ok);\012 }\012\012 Expect(Token::SEMICOLON, CHECK_OK);\012\012 StatementT init = impl()-&gt;BuildInitializationBlock(\012 &amp;for_info.parsing_result, &amp;for_info.bound_names, CHECK_OK);\012\012 Scope* finalized = inner_block_scope-&gt;FinalizeBlockScope();\012 // No variable declarations will have been created in inner_block_scope.\012    DCHECK_NULL(finalized);\012    USE(finalized);\012 return ParseStandardForLoopWithLexicalDeclarations(\012        stmt_pos, init, &amp;for_info, labels, own_labels, ok);\012 }\012\012 StatementT init = impl()-&gt;NullStatement();\012 if (peek() == Token::VAR) {\012 ParseVariableDeclarations(kForStatement, &amp;for_info.parsing_result, nullptr,\012                              CHECK_OK);\012    DCHECK_EQ(for_info.parsing_result.descriptor.mode, VariableMode::kVar);\012    for_info.position = scanner()-&gt;location().beg_pos;\012\012 if (CheckInOrOf(&amp;for_info.mode)) {\012 return ParseForEachStatementWithDeclarations(stmt_pos, &amp;for_info, labels,\012                                                   own_labels, nullptr, ok);\012 }\012\012    init = impl()-&gt;BuildInitializationBlock(&amp;for_info.parsing_result, nullptr,\012                                            CHECK_OK);\012 } else if (peek() != Token::SEMICOLON) {\012 // The initializer does not contain declarations.\012 int lhs_beg_pos = peek_position();\012 ExpressionClassifier classifier(this);\012 ExpressionT expression = ParseExpressionCoverGrammar(false, CHECK_OK);\012 int lhs_end_pos = scanner()-&gt;location().end_pos;\012\012 bool is_for_each = CheckInOrOf(&amp;for_info.mode);\012 bool is_destructuring = is_for_each &amp;&amp; (expression-&gt;IsArrayLiteral() ||\012                                            expression-&gt;IsObjectLiteral());\012\012 if (is_destructuring) {\012 ValidateAssignmentPattern(CHECK_OK);\012 } else {\012 ValidateExpression(CHECK_OK);\012 }\012\012 if (is_for_each) {\012 return ParseForEachStatementWithoutDeclarations(\012          stmt_pos, expression, lhs_beg_pos, lhs_end_pos, &amp;for_info, labels,\012          own_labels, ok);\012 }\012 // Initializer is just an expression.\012    init = factory()-&gt;NewExpressionStatement(expression, lhs_beg_pos);\012 }\012\012 Expect(Token::SEMICOLON, CHECK_OK);\012\012 // Standard 'for' loop, we have parsed the initializer at this point.\012 ExpressionT cond = impl()-&gt;NullExpression();\012 StatementT next = impl()-&gt;NullStatement();\012 StatementT body = impl()-&gt;NullStatement();\012 ForStatementT loop = ParseStandardForLoop(stmt_pos, labels, own_labels, &amp;cond,\012 &amp;next, &amp;body, CHECK_OK);\012  loop-&gt;Initialize(init, cond, next, body);\012 return loop;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT\012ParserBase&lt;Impl&gt;::ParseForEachStatementWithDeclarations(\012 int stmt_pos, ForInfo* for_info, ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels, Scope* inner_block_scope,\012 bool* ok) {\012 // Just one declaration followed by in/of.\012 if (for_info-&gt;parsing_result.declarations.size() != 1) {\012    impl()-&gt;ReportMessageAt(for_info-&gt;parsing_result.bindings_loc,\012 MessageTemplate::kForInOfLoopMultiBindings,\012 ForEachStatement::VisitModeString(for_info-&gt;mode));\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 }\012 if (for_info-&gt;parsing_result.first_initializer_loc.IsValid() &amp;&amp;\012 (is_strict(language_mode()) ||\012       for_info-&gt;mode == ForEachStatement::ITERATE ||\012 IsLexicalVariableMode(for_info-&gt;parsing_result.descriptor.mode) ||\012 !impl()-&gt;IsIdentifier(\012           for_info-&gt;parsing_result.declarations[0].pattern))) {\012    impl()-&gt;ReportMessageAt(for_info-&gt;parsing_result.first_initializer_loc,\012 MessageTemplate::kForInOfLoopInitializer,\012 ForEachStatement::VisitModeString(for_info-&gt;mode));\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 }\012\012 // Reset the declaration_kind to ensure proper processing during declaration.\012  for_info-&gt;parsing_result.descriptor.declaration_kind =\012 DeclarationDescriptor::FOR_EACH;\012\012 BlockT init_block = impl()-&gt;RewriteForVarInLegacy(*for_info);\012\012 auto loop = factory()-&gt;NewForEachStatement(for_info-&gt;mode, labels, own_labels,\012                                             stmt_pos);\012 typename Types::Target target(this, loop);\012\012 ExpressionT enumerable = impl()-&gt;NullExpression();\012 if (for_info-&gt;mode == ForEachStatement::ITERATE) {\012 ExpressionClassifier classifier(this);\012    enumerable = ParseAssignmentExpression(true, CHECK_OK);\012 ValidateExpression(CHECK_OK);\012 } else {\012    enumerable = ParseExpression(true, CHECK_OK);\012 }\012\012 Expect(Token::RPAREN, CHECK_OK);\012\012 Scope* for_scope = nullptr;\012 if (inner_block_scope != nullptr) {\012    for_scope = inner_block_scope-&gt;outer_scope();\012    DCHECK(for_scope == scope());\012    inner_block_scope-&gt;set_start_position(scanner()-&gt;location().beg_pos);\012 }\012\012 ExpressionT each_variable = impl()-&gt;NullExpression();\012 BlockT body_block = impl()-&gt;NullStatement();\012 {\012 BlockState block_state(\012 &amp;scope_, inner_block_scope != nullptr ? inner_block_scope : scope_);\012\012 SourceRange body_range;\012 SourceRangeScope range_scope(scanner(), &amp;body_range);\012\012 StatementT body = ParseStatement(nullptr, nullptr, CHECK_OK);\012    impl()-&gt;RecordIterationStatementSourceRange(loop, range_scope.Finalize());\012\012    impl()-&gt;DesugarBindingInForEachStatement(for_info, &amp;body_block,\012 &amp;each_variable, CHECK_OK);\012    body_block-&gt;statements()-&gt;Add(body, zone());\012\012 if (inner_block_scope != nullptr) {\012      inner_block_scope-&gt;set_end_position(scanner()-&gt;location().end_pos);\012      body_block-&gt;set_scope(inner_block_scope-&gt;FinalizeBlockScope());\012 }\012 }\012\012 StatementT final_loop = impl()-&gt;InitializeForEachStatement(\012      loop, each_variable, enumerable, body_block);\012\012  init_block = impl()-&gt;CreateForEachStatementTDZ(init_block, *for_info, ok);\012\012 if (for_scope != nullptr) {\012    for_scope-&gt;set_end_position(scanner()-&gt;location().end_pos);\012    for_scope = for_scope-&gt;FinalizeBlockScope();\012 }\012\012 // Parsed for-in loop w/ variable declarations.\012 if (!impl()-&gt;IsNull(init_block)) {\012    init_block-&gt;statements()-&gt;Add(final_loop, zone());\012    init_block-&gt;set_scope(for_scope);\012 return init_block;\012 }\012\012  DCHECK_NULL(for_scope);\012 return final_loop;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT\012ParserBase&lt;Impl&gt;::ParseForEachStatementWithoutDeclarations(\012 int stmt_pos, ExpressionT expression, int lhs_beg_pos, int lhs_end_pos,\012 ForInfo* for_info, ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels, bool* ok) {\012 // Initializer is reference followed by in/of.\012 if (!expression-&gt;IsArrayLiteral() &amp;&amp; !expression-&gt;IsObjectLiteral()) {\012    expression = CheckAndRewriteReferenceExpression(\012        expression, lhs_beg_pos, lhs_end_pos, MessageTemplate::kInvalidLhsInFor,\012        kSyntaxError, CHECK_OK);\012 }\012\012 auto loop = factory()-&gt;NewForEachStatement(for_info-&gt;mode, labels, own_labels,\012                                             stmt_pos);\012 typename Types::Target target(this, loop);\012\012 ExpressionT enumerable = impl()-&gt;NullExpression();\012 if (for_info-&gt;mode == ForEachStatement::ITERATE) {\012 ExpressionClassifier classifier(this);\012    enumerable = ParseAssignmentExpression(true, CHECK_OK);\012 ValidateExpression(CHECK_OK);\012 } else {\012    enumerable = ParseExpression(true, CHECK_OK);\012 }\012\012 Expect(Token::RPAREN, CHECK_OK);\012\012 StatementT body = impl()-&gt;NullStatement();\012 {\012 SourceRange body_range;\012 SourceRangeScope range_scope(scanner(), &amp;body_range);\012\012    body = ParseStatement(nullptr, nullptr, CHECK_OK);\012    impl()-&gt;RecordIterationStatementSourceRange(loop, range_scope.Finalize());\012 }\012 return impl()-&gt;InitializeForEachStatement(loop, expression, enumerable, body);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT\012ParserBase&lt;Impl&gt;::ParseStandardForLoopWithLexicalDeclarations(\012 int stmt_pos, StatementT init, ForInfo* for_info,\012 ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels, bool* ok) {\012 // The condition and the next statement of the for loop must be parsed\012 // in a new scope.\012 Scope* inner_scope = NewScope(BLOCK_SCOPE);\012 ForStatementT loop = impl()-&gt;NullStatement();\012 ExpressionT cond = impl()-&gt;NullExpression();\012 StatementT next = impl()-&gt;NullStatement();\012 StatementT body = impl()-&gt;NullStatement();\012 {\012 BlockState block_state(&amp;scope_, inner_scope);\012    scope()-&gt;set_start_position(scanner()-&gt;location().beg_pos);\012    loop = ParseStandardForLoop(stmt_pos, labels, own_labels, &amp;cond, &amp;next,\012 &amp;body, CHECK_OK);\012    scope()-&gt;set_end_position(scanner()-&gt;location().end_pos);\012 }\012\012  scope()-&gt;set_end_position(scanner()-&gt;location().end_pos);\012 if (for_info-&gt;bound_names.length() &gt; 0 &amp;&amp;\012      function_state_-&gt;contains_function_or_eval()) {\012    scope()-&gt;set_is_hidden();\012 return impl()-&gt;DesugarLexicalBindingsInForStatement(\012        loop, init, cond, next, body, inner_scope, *for_info, ok);\012 } else {\012    inner_scope = inner_scope-&gt;FinalizeBlockScope();\012    DCHECK_NULL(inner_scope);\012    USE(inner_scope);\012 }\012\012 Scope* for_scope = scope()-&gt;FinalizeBlockScope();\012 if (for_scope != nullptr) {\012 // Rewrite a for statement of the form\012 //   for (const x = i; c; n) b\012 //\012 // into\012 //\012 //   {\012 //     const x = i;\012 //     for (; c; n) b\012 //   }\012 //\012    DCHECK(!impl()-&gt;IsNull(init));\012 BlockT block = factory()-&gt;NewBlock(2, false);\012    block-&gt;statements()-&gt;Add(init, zone());\012    block-&gt;statements()-&gt;Add(loop, zone());\012    block-&gt;set_scope(for_scope);\012    loop-&gt;Initialize(impl()-&gt;NullStatement(), cond, next, body);\012 return block;\012 }\012\012  loop-&gt;Initialize(init, cond, next, body);\012 return loop;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ForStatementT ParserBase&lt;Impl&gt;::ParseStandardForLoop(\012 int stmt_pos, ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels, ExpressionT* cond,\012 StatementT* next, StatementT* body, bool* ok) {\012 ForStatementT loop = factory()-&gt;NewForStatement(labels, own_labels, stmt_pos);\012 typename Types::Target target(this, loop);\012\012 if (peek() != Token::SEMICOLON) {\012 *cond = ParseExpression(true, CHECK_OK);\012 }\012 Expect(Token::SEMICOLON, CHECK_OK);\012\012 if (peek() != Token::RPAREN) {\012 ExpressionT exp = ParseExpression(true, CHECK_OK);\012 *next = factory()-&gt;NewExpressionStatement(exp, exp-&gt;position());\012 }\012 Expect(Token::RPAREN, CHECK_OK);\012\012 SourceRange body_range;\012 {\012 SourceRangeScope range_scope(scanner(), &amp;body_range);\012 *body = ParseStatement(nullptr, nullptr, CHECK_OK);\012 }\012  impl()-&gt;RecordIterationStatementSourceRange(loop, body_range);\012\012 return loop;\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::MarkLoopVariableAsAssigned(\012 Scope* scope, Variable* var,\012 typename DeclarationDescriptor::Kind declaration_kind) {\012 if (!IsLexicalVariableMode(var-&gt;mode()) &amp;&amp;\012 (!scope-&gt;is_function_scope() ||\012       declaration_kind == DeclarationDescriptor::FOR_EACH)) {\012 var-&gt;set_maybe_assigned();\012 }\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseForAwaitStatement(\012 ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels, bool* ok) {\012 // for await '(' ForDeclaration of AssignmentExpression ')'\012  DCHECK(is_async_function());\012\012 int stmt_pos = peek_position();\012\012 ForInfo for_info(this);\012  for_info.mode = ForEachStatement::ITERATE;\012\012 // Create an in-between scope for let-bound iteration variables.\012 BlockState for_state(zone(), &amp;scope_);\012 Expect(Token::FOR, CHECK_OK);\012 Expect(Token::AWAIT, CHECK_OK);\012 Expect(Token::LPAREN, CHECK_OK);\012  scope()-&gt;set_start_position(scanner()-&gt;location().beg_pos);\012  scope()-&gt;set_is_hidden();\012\012 auto loop = factory()-&gt;NewForOfStatement(labels, own_labels, stmt_pos);\012 typename Types::Target target(this, loop);\012\012 ExpressionT each_variable = impl()-&gt;NullExpression();\012\012 bool has_declarations = false;\012 Scope* inner_block_scope = NewScope(BLOCK_SCOPE);\012\012 if (peek() == Token::VAR || peek() == Token::CONST ||\012 (peek() == Token::LET &amp;&amp; IsNextLetKeyword())) {\012 // The initializer contains declarations\012 // 'for' 'await' '(' ForDeclaration 'of' AssignmentExpression ')'\012 //     Statement\012 // 'for' 'await' '(' 'var' ForBinding 'of' AssignmentExpression ')'\012 //     Statement\012    has_declarations = true;\012\012 {\012 BlockState inner_state(&amp;scope_, inner_block_scope);\012 ParseVariableDeclarations(kForStatement, &amp;for_info.parsing_result,\012 nullptr, CHECK_OK);\012 }\012    for_info.position = scanner()-&gt;location().beg_pos;\012\012 // Only a single declaration is allowed in for-await-of loops\012 if (for_info.parsing_result.declarations.size() != 1) {\012      impl()-&gt;ReportMessageAt(for_info.parsing_result.bindings_loc,\012 MessageTemplate::kForInOfLoopMultiBindings,\012 &quot;for-await-of&quot;);\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 }\012\012 // for-await-of's declarations do not permit initializers.\012 if (for_info.parsing_result.first_initializer_loc.IsValid()) {\012      impl()-&gt;ReportMessageAt(for_info.parsing_result.first_initializer_loc,\012 MessageTemplate::kForInOfLoopInitializer,\012 &quot;for-await-of&quot;);\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 }\012 } else {\012 // The initializer does not contain declarations.\012 // 'for' 'await' '(' LeftHandSideExpression 'of' AssignmentExpression ')'\012 //     Statement\012 int lhs_beg_pos = peek_position();\012 BlockState inner_state(&amp;scope_, inner_block_scope);\012 ExpressionClassifier classifier(this);\012 ExpressionT lhs = each_variable = ParseLeftHandSideExpression(CHECK_OK);\012 int lhs_end_pos = scanner()-&gt;location().end_pos;\012\012 if (lhs-&gt;IsArrayLiteral() || lhs-&gt;IsObjectLiteral()) {\012 ValidateAssignmentPattern(CHECK_OK);\012 } else {\012 ValidateExpression(CHECK_OK);\012      each_variable = CheckAndRewriteReferenceExpression(\012          lhs, lhs_beg_pos, lhs_end_pos, MessageTemplate::kInvalidLhsInFor,\012          kSyntaxError, CHECK_OK);\012 }\012 }\012\012 ExpectContextualKeyword(Token::OF, CHECK_OK);\012 int each_keyword_pos = scanner()-&gt;location().beg_pos;\012\012 const bool kAllowIn = true;\012 ExpressionT iterable = impl()-&gt;NullExpression();\012\012 {\012 ExpressionClassifier classifier(this);\012    iterable = ParseAssignmentExpression(kAllowIn, CHECK_OK);\012 ValidateExpression(CHECK_OK);\012 }\012\012 Expect(Token::RPAREN, CHECK_OK);\012\012 StatementT body = impl()-&gt;NullStatement();\012 {\012 BlockState block_state(&amp;scope_, inner_block_scope);\012    scope()-&gt;set_start_position(scanner()-&gt;location().beg_pos);\012\012 SourceRange body_range;\012 SourceRangeScope range_scope(scanner(), &amp;body_range);\012\012    body = ParseStatement(nullptr, nullptr, CHECK_OK);\012    scope()-&gt;set_end_position(scanner()-&gt;location().end_pos);\012    impl()-&gt;RecordIterationStatementSourceRange(loop, range_scope.Finalize());\012\012 if (has_declarations) {\012 BlockT body_block = impl()-&gt;NullStatement();\012      impl()-&gt;DesugarBindingInForEachStatement(&amp;for_info, &amp;body_block,\012 &amp;each_variable, CHECK_OK);\012      body_block-&gt;statements()-&gt;Add(body, zone());\012      body_block-&gt;set_scope(scope()-&gt;FinalizeBlockScope());\012      body = body_block;\012 } else {\012 Scope* block_scope = scope()-&gt;FinalizeBlockScope();\012      DCHECK_NULL(block_scope);\012      USE(block_scope);\012 }\012 }\012 const bool finalize = true;\012 StatementT final_loop = impl()-&gt;InitializeForOfStatement(\012      loop, each_variable, iterable, body, finalize, IteratorType::kAsync,\012      each_keyword_pos);\012\012 if (!has_declarations) {\012 Scope* for_scope = scope()-&gt;FinalizeBlockScope();\012    DCHECK_NULL(for_scope);\012    USE(for_scope);\012 return final_loop;\012 }\012\012 BlockT init_block =\012      impl()-&gt;CreateForEachStatementTDZ(impl()-&gt;NullStatement(), for_info, ok);\012\012  scope()-&gt;set_end_position(scanner()-&gt;location().end_pos);\012 Scope* for_scope = scope()-&gt;FinalizeBlockScope();\012 // Parsed for-in loop w/ variable declarations.\012 if (!impl()-&gt;IsNull(init_block)) {\012    init_block-&gt;statements()-&gt;Add(final_loop, zone());\012    init_block-&gt;set_scope(for_scope);\012 return init_block;\012 }\012  DCHECK_NULL(for_scope);\012 return final_loop;\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::ObjectLiteralChecker::CheckDuplicateProto(\012 Token::Value property) {\012 if (property == Token::SMI || property == Token::NUMBER) return;\012\012 if (IsProto()) {\012 if (has_seen_proto_) {\012 this-&gt;parser()-&gt;classifier()-&gt;RecordExpressionError(\012 this-&gt;scanner()-&gt;location(), MessageTemplate::kDuplicateProto);\012 return;\012 }\012    has_seen_proto_ = true;\012 }\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::ClassLiteralChecker::CheckClassMethodName(\012 Token::Value property, PropertyKind type, bool is_generator, bool is_async,\012 bool is_static, bool* ok) {\012  DCHECK(type == PropertyKind::kMethodProperty ||\012         type == PropertyKind::kAccessorProperty);\012\012 if (property == Token::SMI || property == Token::NUMBER) return;\012\012 if (is_static) {\012 if (IsPrototype()) {\012 this-&gt;parser()-&gt;ReportMessage(MessageTemplate::kStaticPrototype);\012 *ok = false;\012 return;\012 }\012 } else if (IsConstructor()) {\012 if (is_generator || is_async || type == PropertyKind::kAccessorProperty) {\012 MessageTemplate::Template msg =\012          is_generator ? MessageTemplate::kConstructorIsGenerator\012 : is_async ? MessageTemplate::kConstructorIsAsync\012 : MessageTemplate::kConstructorIsAccessor;\012 this-&gt;parser()-&gt;ReportMessage(msg);\012 *ok = false;\012 return;\012 }\012 if (has_seen_constructor_) {\012 this-&gt;parser()-&gt;ReportMessage(MessageTemplate::kDuplicateConstructor);\012 *ok = false;\012 return;\012 }\012    has_seen_constructor_ = true;\012 return;\012 }\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::ClassLiteralChecker::CheckClassFieldName(bool is_static,\012 bool* ok) {\012 if (is_static &amp;&amp; IsPrototype()) {\012 this-&gt;parser()-&gt;ReportMessage(MessageTemplate::kStaticPrototype);\012 *ok = false;\012 return;\012 }\012\012 if (IsConstructor() || IsPrivateConstructor()) {\012 this-&gt;parser()-&gt;ReportMessage(MessageTemplate::kConstructorClassField);\012 *ok = false;\012 return;\012 }\012}\012\012#undef CHECK_OK\012#undef CHECK_OK_CUSTOM\012#undef CHECK_OK_VOID\012\012} // namespace internal\012},namespace v8 {\012namespace internal {\012\012enum FunctionNameValidity {\012  kFunctionNameIsStrictReserved,\012  kSkipFunctionNameCheck,\012  kFunctionNameValidityUnknown\012};\012\012enum AllowLabelledFunctionStatement {\012  kAllowLabelledFunctionStatement,\012  kDisallowLabelledFunctionStatement,\012};\012\012enum class ParseFunctionFlags {\012  kIsNormal = 0,\012  kIsGenerator = 1,\012  kIsAsync = 2,\012  kIsDefault = 4\012};\012\012static inline ParseFunctionFlags operator|(ParseFunctionFlags lhs,\012 ParseFunctionFlags rhs) {\012 typedef unsigned char T;\012 return static_cast&lt;ParseFunctionFlags&gt;(static_cast&lt;T&gt;(lhs) |\012 static_cast&lt;T&gt;(rhs));\012}\012\012static inline ParseFunctionFlags&amp; operator|=(ParseFunctionFlags&amp; lhs,\012 const ParseFunctionFlags&amp; rhs) {\012  lhs = lhs | rhs;\012 return lhs;\012}\012\012static inline bool operator&amp;(ParseFunctionFlags bitfield,\012 ParseFunctionFlags mask) {\012 typedef unsigned char T;\012 return static_cast&lt;T&gt;(bitfield) &amp; static_cast&lt;T&gt;(mask);\012}\012\012struct FormalParametersBase {\012 explicit FormalParametersBase(DeclarationScope* scope) : scope(scope) {}\012\012 int num_parameters() const {\012 // Don't include the rest parameter into the function's formal parameter\012 // count (esp. the SharedFunctionInfo::internal_formal_parameter_count,\012 // which says whether we need to create an arguments adaptor frame).\012 return arity - has_rest;\012 }\012\012 void UpdateArityAndFunctionLength(bool is_optional, bool is_rest) {\012 if (!is_optional &amp;&amp; !is_rest &amp;&amp; function_length == arity) {\012 ++function_length;\012 }\012 ++arity;\012 }\012\012 DeclarationScope* scope;\012 bool has_rest = false;\012 bool is_simple = true;\012 int function_length = 0;\012 int arity = 0;\012};\012\012// Stack-allocated scope to collect source ranges from the parser.\012class SourceRangeScope final {\012 public:\012 enum PositionKind {\012    POSITION_BEG,\012    POSITION_END,\012    PEEK_POSITION_BEG,\012    PEEK_POSITION_END,\012 };\012\012 SourceRangeScope(Scanner* scanner, SourceRange* range,\012 PositionKind pre_kind = PEEK_POSITION_BEG,\012 PositionKind post_kind = POSITION_END)\012 : scanner_(scanner), range_(range), post_kind_(post_kind) {\012    range_-&gt;start = GetPosition(pre_kind);\012    DCHECK_NE(range_-&gt;start, kNoSourcePosition);\012 }\012\012 ~SourceRangeScope() { Finalize(); }\012\012 const SourceRange&amp; Finalize() {\012 if (is_finalized_) return *range_;\012    is_finalized_ = true;\012    range_-&gt;end = GetPosition(post_kind_);\012    DCHECK_NE(range_-&gt;end, kNoSourcePosition);\012 return *range_;\012 }\012\012 private:\012 int32_t GetPosition(PositionKind kind) {\012 switch (kind) {\012 case POSITION_BEG:\012 return scanner_-&gt;location().beg_pos;\012 case POSITION_END:\012 return scanner_-&gt;location().end_pos;\012 case PEEK_POSITION_BEG:\012 return scanner_-&gt;peek_location().beg_pos;\012 case PEEK_POSITION_END:\012 return scanner_-&gt;peek_location().end_pos;\012 default:\012        UNREACHABLE();\012 }\012 }\012\012 Scanner* scanner_;\012 SourceRange* range_;\012 PositionKind post_kind_;\012 bool is_finalized_ = false;\012\012  DISALLOW_IMPLICIT_CONSTRUCTORS(SourceRangeScope);\012};\012\012// ----------------------------------------------------------------------------\012// The CHECK_OK macro is a convenient macro to enforce error\012// handling for functions that may fail (by returning !*ok).\012//\012// CAUTION: This macro appends extra statements after a call,\012// thus it must never be used where only a single statement\012// is correct (e.g. an if statement branch w/o braces)!\012\012#define CHECK_OK_CUSTOM(x, ...) ok);       \\012 if (!*ok) return impl()-&gt;x(__VA_ARGS__); \\012 ((void)0\012#define DUMMY ) // to make indentation work\012#undef DUMMY\012\012// Used in functions where the return type is ExpressionT.\012#define CHECK_OK CHECK_OK_CUSTOM(NullExpression)\012\012#define CHECK_OK_VOID ok); \\012 if (!*ok) return;        \\012 ((void)0\012#define DUMMY ) // to make indentation work\012#undef DUMMY\012\012// Common base class template shared between parser and pre-parser.\012// The Impl parameter is the actual class of the parser/pre-parser,\012// following the Curiously Recurring Template Pattern (CRTP).\012// The structure of the parser objects is roughly the following:\012//\012//   // A structure template containing type definitions, needed to\012//   // avoid a cyclic dependency.\012//   template &lt;typename Impl&gt;\012//   struct ParserTypes;\012//\012//   // The parser base object, which should just implement pure\012//   // parser behavior.  The Impl parameter is the actual derived\012//   // class (according to CRTP), which implements impure parser\012//   // behavior.\012//   template &lt;typename Impl&gt;\012//   class ParserBase { ... };\012//\012//   // And then, for each parser variant (e.g., parser, preparser, etc):\012//   class Parser;\012//\012//   template &lt;&gt;\012//   class ParserTypes&lt;Parser&gt; { ... };\012//\012//   class Parser : public ParserBase&lt;Parser&gt; { ... };\012//\012// The parser base object implements pure parsing, according to the\012// language grammar.  Different parser implementations may exhibit\012// different parser-driven behavior that is not considered as pure\012// parsing, e.g., early error detection and reporting, AST generation, etc.\012\012// The ParserTypes structure encapsulates the differences in the\012// types used in parsing methods.  E.g., Parser methods use Expression*\012// and PreParser methods use PreParserExpression.  For any given parser\012// implementation class Impl, it is expected to contain the following typedefs:\012//\012// template &lt;&gt;\012// struct ParserTypes&lt;Impl&gt; {\012//   // Synonyms for ParserBase&lt;Impl&gt; and Impl, respectively.\012//   typedef Base;\012//   typedef Impl;\012//   // Return types for traversing functions.\012//   typedef Identifier;\012//   typedef Expression;\012//   typedef FunctionLiteral;\012//   typedef ObjectLiteralProperty;\012//   typedef ClassLiteralProperty;\012//   typedef ExpressionList;\012//   typedef ObjectPropertyList;\012//   typedef ClassPropertyList;\012//   typedef FormalParameters;\012//   typedef Statement;\012//   typedef StatementList;\012//   typedef Block;\012//   typedef BreakableStatement;\012//   typedef ForStatement;\012//   typedef IterationStatement;\012//   // For constructing objects returned by the traversing functions.\012//   typedef Factory;\012//   // For other implementation-specific tasks.\012//   typedef Target;\012//   typedef TargetScope;\012// };\012\012template &lt;typename Impl&gt;\012struct ParserTypes;\012\012template &lt;typename Impl&gt;\012class ParserBase {\012 public:\012 // Shorten type names defined by ParserTypes&lt;Impl&gt;.\012 typedef ParserTypes&lt;Impl&gt; Types;\012 typedef typename Types::Identifier IdentifierT;\012 typedef typename Types::Expression ExpressionT;\012 typedef typename Types::FunctionLiteral FunctionLiteralT;\012 typedef typename Types::ObjectLiteralProperty ObjectLiteralPropertyT;\012 typedef typename Types::ClassLiteralProperty ClassLiteralPropertyT;\012 typedef typename Types::Suspend SuspendExpressionT;\012 typedef typename Types::RewritableExpression RewritableExpressionT;\012 typedef typename Types::ExpressionList ExpressionListT;\012 typedef typename Types::FormalParameters FormalParametersT;\012 typedef typename Types::Statement StatementT;\012 typedef typename Types::StatementList StatementListT;\012 typedef typename Types::Block BlockT;\012 typedef typename Types::ForStatement ForStatementT;\012 typedef typename v8::internal::ExpressionClassifier&lt;Types&gt;\012 ExpressionClassifier;\012\012 // All implementation-specific methods must be called through this.\012 Impl* impl() { return static_cast&lt;Impl*&gt;(this); }\012 const Impl* impl() const { return static_cast&lt;const Impl*&gt;(this); }\012\012 ParserBase(Zone* zone, Scanner* scanner, uintptr_t stack_limit,\012             v8::Extension* extension, AstValueFactory* ast_value_factory,\012 PendingCompilationErrorHandler* pending_error_handler,\012 RuntimeCallStats* runtime_call_stats, Logger* logger,\012 int script_id, bool parsing_module, bool parsing_on_main_thread)\012 : scope_(nullptr),\012        original_scope_(nullptr),\012        function_state_(nullptr),\012        extension_(extension),\012        fni_(nullptr),\012        ast_value_factory_(ast_value_factory),\012        ast_node_factory_(ast_value_factory, zone),\012        runtime_call_stats_(runtime_call_stats),\012        logger_(logger),\012        parsing_on_main_thread_(parsing_on_main_thread),\012        parsing_module_(parsing_module),\012        stack_limit_(stack_limit),\012        pending_error_handler_(pending_error_handler),\012        zone_(zone),\012        classifier_(nullptr),\012        scanner_(scanner),\012        default_eager_compile_hint_(FunctionLiteral::kShouldLazyCompile),\012        function_literal_id_(0),\012        script_id_(script_id),\012        allow_natives_(false),\012        allow_harmony_do_expressions_(false),\012        allow_harmony_public_fields_(false),\012        allow_harmony_static_fields_(false),\012        allow_harmony_dynamic_import_(false),\012        allow_harmony_import_meta_(false),\012        allow_harmony_private_fields_(false),\012        allow_eval_cache_(true) {}\012\012#define ALLOW_ACCESSORS(name)                           \\012 bool allow_##name() const { return allow_##name##_; } \\012 void set_allow_##name(bool allow) { allow_##name##_ = allow; }\012\012  ALLOW_ACCESSORS(natives);\012  ALLOW_ACCESSORS(harmony_do_expressions);\012  ALLOW_ACCESSORS(harmony_public_fields);\012  ALLOW_ACCESSORS(harmony_static_fields);\012  ALLOW_ACCESSORS(harmony_dynamic_import);\012  ALLOW_ACCESSORS(harmony_import_meta);\012  ALLOW_ACCESSORS(eval_cache);\012\012#undef ALLOW_ACCESSORS\012\012 bool allow_harmony_bigint() const {\012 return scanner()-&gt;allow_harmony_bigint();\012 }\012 void set_allow_harmony_bigint(bool allow) {\012    scanner()-&gt;set_allow_harmony_bigint(allow);\012 }\012 bool allow_harmony_numeric_separator() const {\012 return scanner()-&gt;allow_harmony_numeric_separator();\012 }\012 void set_allow_harmony_numeric_separator(bool allow) {\012    scanner()-&gt;set_allow_harmony_numeric_separator(allow);\012 }\012\012 bool allow_harmony_private_fields() const {\012 return scanner()-&gt;allow_harmony_private_fields();\012 }\012 void set_allow_harmony_private_fields(bool allow) {\012    scanner()-&gt;set_allow_harmony_private_fields(allow);\012 }\012\012 uintptr_t stack_limit() const { return stack_limit_; }\012\012 void set_stack_limit(uintptr_t stack_limit) { stack_limit_ = stack_limit; }\012\012 void set_default_eager_compile_hint(\012 FunctionLiteral::EagerCompileHint eager_compile_hint) {\012    default_eager_compile_hint_ = eager_compile_hint;\012 }\012\012 FunctionLiteral::EagerCompileHint default_eager_compile_hint() const {\012 return default_eager_compile_hint_;\012 }\012\012 int GetNextFunctionLiteralId() { return ++function_literal_id_; }\012 int GetLastFunctionLiteralId() const { return function_literal_id_; }\012\012 void SkipFunctionLiterals(int delta) { function_literal_id_ += delta; }\012\012 void ResetFunctionLiteralId() { function_literal_id_ = 0; }\012\012 // The Zone where the parsing outputs are stored.\012 Zone* main_zone() const { return ast_value_factory()-&gt;zone(); }\012\012 // The current Zone, which might be the main zone or a temporary Zone.\012 Zone* zone() const { return zone_; }\012\012 protected:\012 friend class v8::internal::ExpressionClassifier&lt;ParserTypes&lt;Impl&gt;&gt;;\012\012 enum AllowRestrictedIdentifiers {\012    kAllowRestrictedIdentifiers,\012    kDontAllowRestrictedIdentifiers\012 };\012\012 enum LazyParsingResult { kLazyParsingComplete, kLazyParsingAborted };\012\012 enum VariableDeclarationContext {\012    kStatementListItem,\012    kStatement,\012    kForStatement\012 };\012\012 class ClassLiteralChecker;\012 class ObjectLiteralChecker;\012\012 // ---------------------------------------------------------------------------\012 // BlockState and FunctionState implement the parser's scope stack.\012 // The parser's current scope is in scope_. BlockState and FunctionState\012 // constructors push on the scope stack and the destructors pop. They are also\012 // used to hold the parser's per-funcion state.\012 class BlockState BASE_EMBEDDED {\012 public:\012 BlockState(Scope** scope_stack, Scope* scope)\012 : scope_stack_(scope_stack), outer_scope_(*scope_stack) {\012 *scope_stack_ = scope;\012 }\012\012 BlockState(Zone* zone, Scope** scope_stack)\012 : BlockState(scope_stack,\012 new (zone) Scope(zone, *scope_stack, BLOCK_SCOPE)) {}\012\012 ~BlockState() { *scope_stack_ = outer_scope_; }\012\012 private:\012 Scope** const scope_stack_;\012 Scope* const outer_scope_;\012 };\012\012 class FunctionState final : public BlockState {\012 public:\012 FunctionState(FunctionState** function_state_stack, Scope** scope_stack,\012 DeclarationScope* scope);\012 ~FunctionState();\012\012 DeclarationScope* scope() const { return scope_-&gt;AsDeclarationScope(); }\012\012 void AddProperty() { expected_property_count_++; }\012 int expected_property_count() { return expected_property_count_; }\012\012 void DisableOptimization(BailoutReason reason) {\012      dont_optimize_reason_ = reason;\012 }\012 BailoutReason dont_optimize_reason() { return dont_optimize_reason_; }\012\012 void AddSuspend() { suspend_count_++; }\012 int suspend_count() const { return suspend_count_; }\012 bool CanSuspend() const { return suspend_count_ &gt; 0; }\012\012 FunctionKind kind() const { return scope()-&gt;function_kind(); }\012\012 void RewindDestructuringAssignments(int pos) {\012      destructuring_assignments_to_rewrite_.Rewind(pos);\012 }\012\012 void AdoptDestructuringAssignmentsFromParentState(int pos) {\012 const auto&amp; outer_assignments =\012          outer_function_state_-&gt;destructuring_assignments_to_rewrite_;\012      DCHECK_GE(outer_assignments.size(), pos);\012 auto it = outer_assignments.begin();\012      it.Advance(pos);\012 for (; it != outer_assignments.end(); ++it) {\012 auto expr = *it;\012        expr-&gt;set_scope(scope_);\012        destructuring_assignments_to_rewrite_.push_back(expr);\012 }\012      outer_function_state_-&gt;RewindDestructuringAssignments(pos);\012 }\012\012 const ZoneChunkList&lt;RewritableExpressionT&gt;&amp;\012    destructuring_assignments_to_rewrite() const {\012 return destructuring_assignments_to_rewrite_;\012 }\012\012 ZoneVector&lt;typename ExpressionClassifier::Error&gt;* GetReportedErrorList() {\012 return &amp;reported_errors_;\012 }\012\012 bool next_function_is_likely_called() const {\012 return next_function_is_likely_called_;\012 }\012\012 bool previous_function_was_likely_called() const {\012 return previous_function_was_likely_called_;\012 }\012\012 void set_next_function_is_likely_called() {\012      next_function_is_likely_called_ = true;\012 }\012\012 void RecordFunctionOrEvalCall() { contains_function_or_eval_ = true; }\012 bool contains_function_or_eval() const {\012 return contains_function_or_eval_;\012 }\012\012 class FunctionOrEvalRecordingScope {\012 public:\012 explicit FunctionOrEvalRecordingScope(FunctionState* state)\012 : state_(state) {\012        prev_value_ = state-&gt;contains_function_or_eval_;\012        state-&gt;contains_function_or_eval_ = false;\012 }\012 ~FunctionOrEvalRecordingScope() {\012 bool found = state_-&gt;contains_function_or_eval_;\012 if (!found) {\012          state_-&gt;contains_function_or_eval_ = prev_value_;\012 }\012 }\012\012 private:\012 FunctionState* state_;\012 bool prev_value_;\012 };\012\012 private:\012 void AddDestructuringAssignment(RewritableExpressionT expr) {\012      destructuring_assignments_to_rewrite_.push_back(expr);\012 }\012\012 // Properties count estimation.\012 int expected_property_count_;\012\012 // How many suspends are needed for this function.\012 int suspend_count_;\012\012 FunctionState** function_state_stack_;\012 FunctionState* outer_function_state_;\012 DeclarationScope* scope_;\012\012 ZoneChunkList&lt;RewritableExpressionT&gt; destructuring_assignments_to_rewrite_;\012\012 // We use a ZoneVector here because we need to do a lot of random access.\012 ZoneVector&lt;typename ExpressionClassifier::Error&gt; reported_errors_;\012\012 // A reason, if any, why this function should not be optimized.\012 BailoutReason dont_optimize_reason_;\012\012 // Record whether the next (=== immediately following) function literal is\012 // preceded by a parenthesis / exclamation mark. Also record the previous\012 // state.\012 // These are managed by the FunctionState constructor; the caller may only\012 // call set_next_function_is_likely_called.\012 bool next_function_is_likely_called_;\012 bool previous_function_was_likely_called_;\012\012 // Track if a function or eval occurs within this FunctionState\012 bool contains_function_or_eval_;\012\012 friend Impl;\012 };\012\012 struct DeclarationDescriptor {\012 enum Kind { NORMAL, PARAMETER, FOR_EACH };\012 Scope* scope;\012 VariableMode mode;\012 int declaration_pos;\012 int initialization_pos;\012 Kind declaration_kind;\012 };\012\012 struct DeclarationParsingResult {\012 struct Declaration {\012 Declaration(ExpressionT pattern, int initializer_position,\012 ExpressionT initializer)\012 : pattern(pattern),\012            initializer_position(initializer_position),\012            initializer(initializer) {}\012\012 ExpressionT pattern;\012 int initializer_position;\012 int value_beg_position = kNoSourcePosition;\012 ExpressionT initializer;\012 };\012\012 DeclarationParsingResult()\012 : first_initializer_loc(Scanner::Location::invalid()),\012          bindings_loc(Scanner::Location::invalid()) {}\012\012 DeclarationDescriptor descriptor;\012    std::vector&lt;Declaration&gt; declarations;\012 Scanner::Location first_initializer_loc;\012 Scanner::Location bindings_loc;\012 };\012\012 struct CatchInfo {\012 public:\012 explicit CatchInfo(ParserBase* parser)\012 : name(parser-&gt;impl()-&gt;NullIdentifier()),\012          pattern(parser-&gt;impl()-&gt;NullExpression()),\012          scope(nullptr),\012          init_block(parser-&gt;impl()-&gt;NullStatement()),\012          inner_block(parser-&gt;impl()-&gt;NullStatement()),\012          bound_names(1, parser-&gt;zone()) {}\012 IdentifierT name;\012 ExpressionT pattern;\012 Scope* scope;\012 BlockT init_block;\012 BlockT inner_block;\012 ZonePtrList&lt;const AstRawString&gt; bound_names;\012 };\012\012 struct ForInfo {\012 public:\012 explicit ForInfo(ParserBase* parser)\012 : bound_names(1, parser-&gt;zone()),\012          mode(ForEachStatement::ENUMERATE),\012          position(kNoSourcePosition),\012          parsing_result() {}\012 ZonePtrList&lt;const AstRawString&gt; bound_names;\012 ForEachStatement::VisitMode mode;\012 int position;\012 DeclarationParsingResult parsing_result;\012 };\012\012 struct ClassInfo {\012 public:\012 explicit ClassInfo(ParserBase* parser)\012 : variable(nullptr),\012 extends(parser-&gt;impl()-&gt;NullExpression()),\012          properties(parser-&gt;impl()-&gt;NewClassPropertyList(4)),\012          static_fields(parser-&gt;impl()-&gt;NewClassPropertyList(4)),\012          instance_fields(parser-&gt;impl()-&gt;NewClassPropertyList(4)),\012          constructor(parser-&gt;impl()-&gt;NullExpression()),\012          has_seen_constructor(false),\012          has_name_static_property(false),\012          has_static_computed_names(false),\012          has_static_class_fields(false),\012          has_instance_class_fields(false),\012          is_anonymous(false),\012          static_fields_scope(nullptr),\012          instance_fields_scope(nullptr),\012          computed_field_count(0) {}\012 Variable* variable;\012 ExpressionT extends;\012 typename Types::ClassPropertyList properties;\012 typename Types::ClassPropertyList static_fields;\012 typename Types::ClassPropertyList instance_fields;\012 FunctionLiteralT constructor;\012\012 bool has_seen_constructor;\012 bool has_name_static_property;\012 bool has_static_computed_names;\012 bool has_static_class_fields;\012 bool has_instance_class_fields;\012 bool is_anonymous;\012 DeclarationScope* static_fields_scope;\012 DeclarationScope* instance_fields_scope;\012 int computed_field_count;\012 };\012\012 const AstRawString* ClassFieldVariableName(AstValueFactory* ast_value_factory,\012 int index) {\012    std::string name = &quot;.class-field-&quot; + std::to_string(index);\012 return ast_value_factory-&gt;GetOneByteString(name.c_str());\012 }\012\012 DeclarationScope* NewScriptScope() const {\012 return new (zone()) DeclarationScope(zone(), ast_value_factory());\012 }\012\012 DeclarationScope* NewVarblockScope() const {\012 return new (zone()) DeclarationScope(zone(), scope(), BLOCK_SCOPE);\012 }\012\012 ModuleScope* NewModuleScope(DeclarationScope* parent) const {\012 return new (zone()) ModuleScope(parent, ast_value_factory());\012 }\012\012 DeclarationScope* NewEvalScope(Scope* parent) const {\012 return new (zone()) DeclarationScope(zone(), parent, EVAL_SCOPE);\012 }\012\012 Scope* NewScope(ScopeType scope_type) const {\012 return NewScopeWithParent(scope(), scope_type);\012 }\012\012 // This constructor should only be used when absolutely necessary. Most scopes\012 // should automatically use scope() as parent, and be fine with\012 // NewScope(ScopeType) above.\012 Scope* NewScopeWithParent(Scope* parent, ScopeType scope_type) const {\012 // Must always use the specific constructors for the blacklisted scope\012 // types.\012    DCHECK_NE(FUNCTION_SCOPE, scope_type);\012    DCHECK_NE(SCRIPT_SCOPE, scope_type);\012    DCHECK_NE(MODULE_SCOPE, scope_type);\012    DCHECK_NOT_NULL(parent);\012 return new (zone()) Scope(zone(), parent, scope_type);\012 }\012\012 // Creates a function scope that always allocates in zone(). The function\012 // scope itself is either allocated in zone() or in target_zone if one is\012 // passed in.\012 DeclarationScope* NewFunctionScope(FunctionKind kind,\012 Zone* target_zone = nullptr) const {\012    DCHECK(ast_value_factory());\012 if (target_zone == nullptr) target_zone = zone();\012 DeclarationScope* result = new (target_zone)\012 DeclarationScope(zone(), scope(), FUNCTION_SCOPE, kind);\012\012 // Record presence of an inner function scope\012    function_state_-&gt;RecordFunctionOrEvalCall();\012\012 // TODO(verwaest): Move into the DeclarationScope constructor.\012 if (!IsArrowFunction(kind)) {\012      result-&gt;DeclareDefaultFunctionVariables(ast_value_factory());\012 }\012 return result;\012 }\012\012  V8_INLINE DeclarationScope* GetDeclarationScope() const {\012 return scope()-&gt;GetDeclarationScope();\012 }\012  V8_INLINE DeclarationScope* GetClosureScope() const {\012 return scope()-&gt;GetClosureScope();\012 }\012\012 Scanner* scanner() const { return scanner_; }\012 AstValueFactory* ast_value_factory() const { return ast_value_factory_; }\012 int position() const { return scanner_-&gt;location().beg_pos; }\012 int peek_position() const { return scanner_-&gt;peek_location().beg_pos; }\012 bool stack_overflow() const {\012 return pending_error_handler()-&gt;stack_overflow();\012 }\012 void set_stack_overflow() { pending_error_handler()-&gt;set_stack_overflow(); }\012 int script_id() { return script_id_; }\012 void set_script_id(int id) { script_id_ = id; }\012\012  V8_INLINE Token::Value peek() {\012 if (stack_overflow()) return Token::ILLEGAL;\012 return scanner()-&gt;peek();\012 }\012\012 // Returns the position past the following semicolon (if it exists), and the\012 // position past the end of the current token otherwise.\012 int PositionAfterSemicolon() {\012 return (peek() == Token::SEMICOLON) ? scanner_-&gt;peek_location().end_pos\012 : scanner_-&gt;location().end_pos;\012 }\012\012  V8_INLINE Token::Value PeekAhead() {\012 if (stack_overflow()) return Token::ILLEGAL;\012 return scanner()-&gt;PeekAhead();\012 }\012\012  V8_INLINE Token::Value Next() {\012 if (stack_overflow()) return Token::ILLEGAL;\012 {\012 if (GetCurrentStackPosition() &lt; stack_limit_) {\012 // Any further calls to Next or peek will return the illegal token.\012 // The current call must return the next token, which might already\012 // have been peek'ed.\012        set_stack_overflow();\012 }\012 }\012 return scanner()-&gt;Next();\012 }\012\012 void Consume(Token::Value token) {\012 Token::Value next = Next();\012    USE(next);\012    USE(token);\012    DCHECK(next == token);\012 }\012\012 bool Check(Token::Value token) {\012 Token::Value next = peek();\012 if (next == token) {\012 Consume(next);\012 return true;\012 }\012 return false;\012 }\012\012 void Expect(Token::Value token, bool* ok) {\012 Token::Value next = Next();\012 if (next != token) {\012 ReportUnexpectedToken(next);\012 *ok = false;\012 }\012 }\012\012 void ExpectSemicolon(bool* ok) {\012 // Check for automatic semicolon insertion according to\012 // the rules given in ECMA-262, section 7.9, page 21.\012 Token::Value tok = peek();\012 if (tok == Token::SEMICOLON) {\012 Next();\012 return;\012 }\012 if (scanner()-&gt;HasLineTerminatorBeforeNext() || tok == Token::RBRACE ||\012        tok == Token::EOS) {\012 return;\012 }\012\012 Token::Value current = scanner()-&gt;current_token();\012 Scanner::Location current_location = scanner()-&gt;location();\012 Token::Value next = Next();\012\012 if (next == Token::SEMICOLON) {\012 return;\012 }\012\012 *ok = false;\012 if (current == Token::AWAIT &amp;&amp; !is_async_function()) {\012 ReportMessageAt(current_location,\012 MessageTemplate::kAwaitNotInAsyncFunction, kSyntaxError);\012 return;\012 }\012\012 ReportUnexpectedToken(next);\012 }\012\012 // Dummy functions, just useful as arguments to CHECK_OK_CUSTOM.\012 static void Void() {}\012 template &lt;typename T&gt;\012 static T Return(T result) {\012 return result;\012 }\012\012 bool is_any_identifier(Token::Value token) {\012 return token == Token::IDENTIFIER || token == Token::ENUM ||\012           token == Token::AWAIT || token == Token::ASYNC ||\012           token == Token::ESCAPED_STRICT_RESERVED_WORD ||\012           token == Token::FUTURE_STRICT_RESERVED_WORD || token == Token::LET ||\012           token == Token::STATIC || token == Token::YIELD;\012 }\012 bool peek_any_identifier() { return is_any_identifier(peek()); }\012\012 bool CheckContextualKeyword(Token::Value token) {\012 if (PeekContextualKeyword(token)) {\012 Consume(Token::IDENTIFIER);\012 return true;\012 }\012 return false;\012 }\012\012 bool PeekContextualKeyword(Token::Value token) {\012    DCHECK(Token::IsContextualKeyword(token));\012 return peek() == Token::IDENTIFIER &amp;&amp;\012           scanner()-&gt;next_contextual_token() == token;\012 }\012\012 void ExpectMetaProperty(Token::Value property_name, const char* full_name,\012 int pos, bool* ok);\012\012 void ExpectContextualKeyword(Token::Value token, bool* ok) {\012    DCHECK(Token::IsContextualKeyword(token));\012 Expect(Token::IDENTIFIER, CHECK_OK_CUSTOM(Void));\012 if (scanner()-&gt;current_contextual_token() != token) {\012 ReportUnexpectedToken(scanner()-&gt;current_token());\012 *ok = false;\012 }\012 }\012\012 bool CheckInOrOf(ForEachStatement::VisitMode* visit_mode) {\012 if (Check(Token::IN)) {\012 *visit_mode = ForEachStatement::ENUMERATE;\012 return true;\012 } else if (CheckContextualKeyword(Token::OF)) {\012 *visit_mode = ForEachStatement::ITERATE;\012 return true;\012 }\012 return false;\012 }\012\012 bool PeekInOrOf() {\012 return peek() == Token::IN || PeekContextualKeyword(Token::OF);\012 }\012\012 // Checks whether an octal literal was last seen between beg_pos and end_pos.\012 // Only called for strict mode strings.\012 void CheckStrictOctalLiteral(int beg_pos, int end_pos, bool* ok) {\012 Scanner::Location octal = scanner()-&gt;octal_position();\012 if (octal.IsValid() &amp;&amp; beg_pos &lt;= octal.beg_pos &amp;&amp;\012        octal.end_pos &lt;= end_pos) {\012 MessageTemplate::Template message = scanner()-&gt;octal_message();\012      DCHECK_NE(message, MessageTemplate::kNone);\012      impl()-&gt;ReportMessageAt(octal, message);\012      scanner()-&gt;clear_octal_position();\012 if (message == MessageTemplate::kStrictDecimalWithLeadingZero) {\012        impl()-&gt;CountUsage(v8::Isolate::kDecimalWithLeadingZeroInStrictMode);\012 }\012 *ok = false;\012 }\012 }\012\012 // Checks if an octal literal or an invalid hex or unicode escape sequence\012 // appears in the current template literal token. In the presence of such,\012 // either returns false or reports an error, depending on should_throw.\012 // Otherwise returns true.\012 inline bool CheckTemplateEscapes(bool should_throw, bool* ok) {\012    DCHECK(scanner()-&gt;current_token() == Token::TEMPLATE_SPAN ||\012           scanner()-&gt;current_token() == Token::TEMPLATE_TAIL);\012 if (!scanner()-&gt;has_invalid_template_escape()) {\012 return true;\012 }\012\012 // Handle error case(s)\012 if (should_throw) {\012      impl()-&gt;ReportMessageAt(scanner()-&gt;invalid_template_escape_location(),\012                              scanner()-&gt;invalid_template_escape_message());\012 *ok = false;\012 }\012 return false;\012 }\012\012 void CheckDestructuringElement(ExpressionT element, int beg_pos, int end_pos);\012\012 // Checking the name of a function literal. This has to be done after parsing\012 // the function, since the function can declare itself strict.\012 void CheckFunctionName(LanguageMode language_mode, IdentifierT function_name,\012 FunctionNameValidity function_name_validity,\012 const Scanner::Location&amp; function_name_loc, bool* ok) {\012 if (impl()-&gt;IsNull(function_name)) return;\012 if (function_name_validity == kSkipFunctionNameCheck) return;\012 // The function name needs to be checked in strict mode.\012 if (is_sloppy(language_mode)) return;\012\012 if (impl()-&gt;IsEvalOrArguments(function_name)) {\012      impl()-&gt;ReportMessageAt(function_name_loc,\012 MessageTemplate::kStrictEvalArguments);\012 *ok = false;\012 return;\012 }\012 if (function_name_validity == kFunctionNameIsStrictReserved) {\012      impl()-&gt;ReportMessageAt(function_name_loc,\012 MessageTemplate::kUnexpectedStrictReserved);\012 *ok = false;\012 return;\012 }\012 }\012\012 // Determine precedence of given token.\012 static int Precedence(Token::Value token, bool accept_IN) {\012 if (token == Token::IN &amp;&amp; !accept_IN)\012 return 0; // 0 precedence will terminate binary expression parsing\012 return Token::Precedence(token);\012 }\012\012 typename Types::Factory* factory() { return &amp;ast_node_factory_; }\012\012 DeclarationScope* GetReceiverScope() const {\012 return scope()-&gt;GetReceiverScope();\012 }\012 LanguageMode language_mode() { return scope()-&gt;language_mode(); }\012 void RaiseLanguageMode(LanguageMode mode) {\012 LanguageMode old = scope()-&gt;language_mode();\012    impl()-&gt;SetLanguageMode(scope(), old &gt; mode ? old : mode);\012 }\012 bool is_generator() const {\012 return IsGeneratorFunction(function_state_-&gt;kind());\012 }\012 bool is_async_function() const {\012 return IsAsyncFunction(function_state_-&gt;kind());\012 }\012 bool is_async_generator() const {\012 return IsAsyncGeneratorFunction(function_state_-&gt;kind());\012 }\012 bool is_resumable() const {\012 return IsResumableFunction(function_state_-&gt;kind());\012 }\012\012 const PendingCompilationErrorHandler* pending_error_handler() const {\012 return pending_error_handler_;\012 }\012 PendingCompilationErrorHandler* pending_error_handler() {\012 return pending_error_handler_;\012 }\012\012 // Report syntax errors.\012 void ReportMessage(MessageTemplate::Template message) {\012 Scanner::Location source_location = scanner()-&gt;location();\012    impl()-&gt;ReportMessageAt(source_location, message,\012 static_cast&lt;const char*&gt;(nullptr), kSyntaxError);\012 }\012\012 template &lt;typename T&gt;\012 void ReportMessage(MessageTemplate::Template message, T arg,\012 ParseErrorType error_type = kSyntaxError) {\012 Scanner::Location source_location = scanner()-&gt;location();\012    impl()-&gt;ReportMessageAt(source_location, message, arg, error_type);\012 }\012\012 void ReportMessageAt(Scanner::Location location,\012 MessageTemplate::Template message,\012 ParseErrorType error_type) {\012    impl()-&gt;ReportMessageAt(location, message,\012 static_cast&lt;const char*&gt;(nullptr), error_type);\012 }\012\012 void GetUnexpectedTokenMessage(\012 Token::Value token, MessageTemplate::Template* message,\012 Scanner::Location* location, const char** arg,\012 MessageTemplate::Template default_ = MessageTemplate::kUnexpectedToken);\012\012 void ReportUnexpectedToken(Token::Value token);\012 void ReportUnexpectedTokenAt(\012 Scanner::Location location, Token::Value token,\012 MessageTemplate::Template message = MessageTemplate::kUnexpectedToken);\012\012 void ReportClassifierError(\012 const typename ExpressionClassifier::Error&amp; error) {\012    impl()-&gt;ReportMessageAt(error.location, error.message, error.arg);\012 }\012\012 void ValidateExpression(bool* ok) {\012 if (!classifier()-&gt;is_valid_expression()) {\012 ReportClassifierError(classifier()-&gt;expression_error());\012 *ok = false;\012 }\012 }\012\012 void ValidateFormalParameterInitializer(bool* ok) {\012 if (!classifier()-&gt;is_valid_formal_parameter_initializer()) {\012 ReportClassifierError(classifier()-&gt;formal_parameter_initializer_error());\012 *ok = false;\012 }\012 }\012\012 void ValidateBindingPattern(bool* ok) {\012 if (!classifier()-&gt;is_valid_binding_pattern()) {\012 ReportClassifierError(classifier()-&gt;binding_pattern_error());\012 *ok = false;\012 }\012 }\012\012 void ValidateAssignmentPattern(bool* ok) {\012 if (!classifier()-&gt;is_valid_assignment_pattern()) {\012 ReportClassifierError(classifier()-&gt;assignment_pattern_error());\012 *ok = false;\012 }\012 }\012\012 void ValidateFormalParameters(LanguageMode language_mode,\012 bool allow_duplicates, bool* ok) {\012 if (!allow_duplicates &amp;&amp;\012 !classifier()-&gt;is_valid_formal_parameter_list_without_duplicates()) {\012 ReportClassifierError(classifier()-&gt;duplicate_formal_parameter_error());\012 *ok = false;\012 } else if (is_strict(language_mode) &amp;&amp;\012 !classifier()-&gt;is_valid_strict_mode_formal_parameters()) {\012 ReportClassifierError(classifier()-&gt;strict_mode_formal_parameter_error());\012 *ok = false;\012 }\012 }\012\012 bool IsValidArrowFormalParametersStart(Token::Value token) {\012 return is_any_identifier(token) || token == Token::LPAREN;\012 }\012\012 void ValidateArrowFormalParameters(ExpressionT expr,\012 bool parenthesized_formals, bool is_async,\012 bool* ok) {\012 if (classifier()-&gt;is_valid_binding_pattern()) {\012 // A simple arrow formal parameter: IDENTIFIER =&gt; BODY.\012 if (!impl()-&gt;IsIdentifier(expr)) {\012        impl()-&gt;ReportMessageAt(scanner()-&gt;location(),\012 MessageTemplate::kUnexpectedToken,\012 Token::String(scanner()-&gt;current_token()));\012 *ok = false;\012 }\012 } else if (!classifier()-&gt;is_valid_arrow_formal_parameters()) {\012 // If after parsing the expr, we see an error but the expression is\012 // neither a valid binding pattern nor a valid parenthesized formal\012 // parameter list, show the &quot;arrow formal parameters&quot; error if the formals\012 // started with a parenthesis, and the binding pattern error otherwise.\012 const typename ExpressionClassifier::Error&amp; error =\012          parenthesized_formals ? classifier()-&gt;arrow_formal_parameters_error()\012 : classifier()-&gt;binding_pattern_error();\012 ReportClassifierError(error);\012 *ok = false;\012 }\012 if (is_async &amp;&amp; !classifier()-&gt;is_valid_async_arrow_formal_parameters()) {\012 const typename ExpressionClassifier::Error&amp; error =\012          classifier()-&gt;async_arrow_formal_parameters_error();\012 ReportClassifierError(error);\012 *ok = false;\012 }\012 }\012\012 void ValidateLetPattern(bool* ok) {\012 if (!classifier()-&gt;is_valid_let_pattern()) {\012 ReportClassifierError(classifier()-&gt;let_pattern_error());\012 *ok = false;\012 }\012 }\012\012 void BindingPatternUnexpectedToken() {\012 MessageTemplate::Template message = MessageTemplate::kUnexpectedToken;\012 const char* arg;\012 Scanner::Location location = scanner()-&gt;peek_location();\012 GetUnexpectedTokenMessage(peek(), &amp;message, &amp;location, &amp;arg);\012    classifier()-&gt;RecordBindingPatternError(location, message, arg);\012 }\012\012 void ArrowFormalParametersUnexpectedToken() {\012 MessageTemplate::Template message = MessageTemplate::kUnexpectedToken;\012 const char* arg;\012 Scanner::Location location = scanner()-&gt;peek_location();\012 GetUnexpectedTokenMessage(peek(), &amp;message, &amp;location, &amp;arg);\012    classifier()-&gt;RecordArrowFormalParametersError(location, message, arg);\012 }\012\012 // Recursive descent functions.\012 // All ParseXXX functions take as the last argument an *ok parameter\012 // which is set to false if parsing failed; it is unchanged otherwise.\012 // By making the 'exception handling' explicit, we are forced to check\012 // for failure at the call sites. The family of CHECK_OK* macros can\012 // be useful for this.\012\012 // Parses an identifier that is valid for the current scope, in particular it\012 // fails on strict mode future reserved keywords in a strict scope. If\012 // allow_eval_or_arguments is kAllowEvalOrArguments, we allow &quot;eval&quot; or\012 // &quot;arguments&quot; as identifier even in strict mode (this is needed in cases like\012 // &quot;var foo = eval;&quot;).\012 IdentifierT ParseIdentifier(AllowRestrictedIdentifiers, bool* ok);\012 IdentifierT ParseAndClassifyIdentifier(bool* ok);\012 // Parses an identifier or a strict mode future reserved word, and indicate\012 // whether it is strict mode future reserved. Allows passing in function_kind\012 // for the case of parsing the identifier in a function expression, where the\012 // relevant &quot;function_kind&quot; bit is of the function being parsed, not the\012 // containing function.\012 IdentifierT ParseIdentifierOrStrictReservedWord(FunctionKind function_kind,\012 bool* is_strict_reserved,\012 bool* is_await, bool* ok);\012 IdentifierT ParseIdentifierOrStrictReservedWord(bool* is_strict_reserved,\012 bool* is_await, bool* ok) {\012 return ParseIdentifierOrStrictReservedWord(\012        function_state_-&gt;kind(), is_strict_reserved, is_await, ok);\012 }\012\012  V8_INLINE IdentifierT ParseIdentifierName(bool* ok);\012\012 ExpressionT ParseIdentifierNameOrPrivateName(bool* ok);\012\012 ExpressionT ParseRegExpLiteral(bool* ok);\012\012 ExpressionT ParsePrimaryExpression(bool* is_async, bool* ok);\012 ExpressionT ParsePrimaryExpression(bool* ok) {\012 bool is_async;\012 return ParsePrimaryExpression(&amp;is_async, ok);\012 }\012\012 // Use when parsing an expression that is known to not be a pattern or part\012 // of a pattern.\012  V8_INLINE ExpressionT ParseExpression(bool accept_IN, bool* ok);\012\012 // This method does not wrap the parsing of the expression inside a\012 // new expression classifier; it uses the top-level classifier instead.\012 // It should be used whenever we're parsing something with the &quot;cover&quot;\012 // grammar that recognizes both patterns and non-patterns (which roughly\012 // corresponds to what's inside the parentheses generated by the symbol\012 // &quot;CoverParenthesizedExpressionAndArrowParameterList&quot; in the ES 2017\012 // specification).\012 ExpressionT ParseExpressionCoverGrammar(bool accept_IN, bool* ok);\012\012 ExpressionT ParseArrayLiteral(bool* ok);\012\012 enum class PropertyKind {\012    kAccessorProperty,\012    kValueProperty,\012    kShorthandProperty,\012    kMethodProperty,\012    kClassField,\012    kSpreadProperty,\012    kNotSet\012 };\012\012 bool SetPropertyKindFromToken(Token::Value token, PropertyKind* kind);\012 ExpressionT ParsePropertyName(IdentifierT* name, PropertyKind* kind,\012 bool* is_generator, bool* is_get, bool* is_set,\012 bool* is_async, bool* is_computed_name,\012 bool* ok);\012 ExpressionT ParseObjectLiteral(bool* ok);\012 ClassLiteralPropertyT ParseClassPropertyDefinition(\012 ClassLiteralChecker* checker, ClassInfo* class_info,\012 IdentifierT* property_name, bool has_extends, bool* is_computed_name,\012 ClassLiteralProperty::Kind* property_kind, bool* is_static, bool* ok);\012 ExpressionT ParseClassFieldInitializer(ClassInfo* class_info, bool is_static,\012 bool* ok);\012 ObjectLiteralPropertyT ParseObjectPropertyDefinition(\012 ObjectLiteralChecker* checker, bool* is_computed_name,\012 bool* is_rest_property, bool* ok);\012 ExpressionListT ParseArguments(Scanner::Location* first_spread_pos,\012 bool maybe_arrow,\012 bool* is_simple_parameter_list, bool* ok);\012 ExpressionListT ParseArguments(Scanner::Location* first_spread_pos,\012 bool* ok) {\012 return ParseArguments(first_spread_pos, false, nullptr, ok);\012 }\012\012 ExpressionT ParseAssignmentExpression(bool accept_IN, bool* ok);\012 ExpressionT ParseYieldExpression(bool accept_IN, bool* ok);\012  V8_INLINE ExpressionT ParseConditionalExpression(bool accept_IN, bool* ok);\012 ExpressionT ParseBinaryExpression(int prec, bool accept_IN, bool* ok);\012 ExpressionT ParseUnaryExpression(bool* ok);\012  V8_INLINE ExpressionT ParsePostfixExpression(bool* ok);\012  V8_INLINE ExpressionT ParseLeftHandSideExpression(bool* ok);\012 ExpressionT ParseMemberWithNewPrefixesExpression(bool* is_async, bool* ok);\012  V8_INLINE ExpressionT ParseMemberExpression(bool* is_async, bool* ok);\012  V8_INLINE ExpressionT ParseMemberExpressionContinuation(\012 ExpressionT expression, bool* is_async, bool* ok);\012\012 // `rewritable_length`: length of the destructuring_assignments_to_rewrite()\012 // queue in the parent function state, prior to parsing of formal parameters.\012 // If the arrow function is lazy, any items added during formal parameter\012 // parsing are removed from the queue.\012 ExpressionT ParseArrowFunctionLiteral(bool accept_IN,\012 const FormalParametersT&amp; parameters,\012 int rewritable_length, bool* ok);\012 void ParseSingleExpressionFunctionBody(StatementListT body, bool is_async,\012 bool accept_IN, bool* ok);\012 void ParseAsyncFunctionBody(Scope* scope, StatementListT body, bool* ok);\012 ExpressionT ParseAsyncFunctionLiteral(bool* ok);\012 ExpressionT ParseClassLiteral(IdentifierT name,\012 Scanner::Location class_name_location,\012 bool name_is_strict_reserved,\012 int class_token_pos, bool* ok);\012 ExpressionT ParseTemplateLiteral(ExpressionT tag, int start, bool tagged,\012 bool* ok);\012 ExpressionT ParseSuperExpression(bool is_new, bool* ok);\012 ExpressionT ParseImportExpressions(bool* ok);\012 ExpressionT ParseNewTargetExpression(bool* ok);\012\012  V8_INLINE void ParseFormalParameter(FormalParametersT* parameters, bool* ok);\012 void ParseFormalParameterList(FormalParametersT* parameters, bool* ok);\012 void CheckArityRestrictions(int param_count, FunctionKind function_type,\012 bool has_rest, int formals_start_pos,\012 int formals_end_pos, bool* ok);\012\012 BlockT ParseVariableDeclarations(VariableDeclarationContext var_context,\012 DeclarationParsingResult* parsing_result,\012 ZonePtrList&lt;const AstRawString&gt;* names,\012 bool* ok);\012 StatementT ParseAsyncFunctionDeclaration(\012 ZonePtrList&lt;const AstRawString&gt;* names, bool default_export, bool* ok);\012 StatementT ParseFunctionDeclaration(bool* ok);\012 StatementT ParseHoistableDeclaration(ZonePtrList&lt;const AstRawString&gt;* names,\012 bool default_export, bool* ok);\012 StatementT ParseHoistableDeclaration(int pos, ParseFunctionFlags flags,\012 ZonePtrList&lt;const AstRawString&gt;* names,\012 bool default_export, bool* ok);\012 StatementT ParseClassDeclaration(ZonePtrList&lt;const AstRawString&gt;* names,\012 bool default_export, bool* ok);\012 StatementT ParseNativeDeclaration(bool* ok);\012\012 // Consumes the ending }.\012 void ParseFunctionBody(StatementListT result, IdentifierT function_name,\012 int pos, const FormalParametersT&amp; parameters,\012 FunctionKind kind,\012 FunctionLiteral::FunctionType function_type, bool* ok);\012\012 // Under some circumstances, we allow preparsing to abort if the preparsed\012 // function is &quot;long and trivial&quot;, and fully parse instead. Our current\012 // definition of &quot;long and trivial&quot; is:\012 // - over kLazyParseTrialLimit statements\012 // - all starting with an identifier (i.e., no if, for, while, etc.)\012 static const int kLazyParseTrialLimit = 200;\012\012 // TODO(nikolaos, marja): The first argument should not really be passed\012 // by value. The method is expected to add the parsed statements to the\012 // list. This works because in the case of the parser, StatementListT is\012 // a pointer whereas the preparser does not really modify the body.\012  V8_INLINE void ParseStatementList(StatementListT body, Token::Value end_token,\012 bool* ok) {\012 LazyParsingResult result = ParseStatementList(body, end_token, false, ok);\012    USE(result);\012    DCHECK_EQ(result, kLazyParsingComplete);\012 }\012  V8_INLINE LazyParsingResult ParseStatementList(StatementListT body,\012 Token::Value end_token,\012 bool may_abort, bool* ok);\012 StatementT ParseStatementListItem(bool* ok);\012\012 StatementT ParseStatement(ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels,\012 bool* ok) {\012 return ParseStatement(labels, own_labels,\012                          kDisallowLabelledFunctionStatement, ok);\012 }\012 StatementT ParseStatement(ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels,\012 AllowLabelledFunctionStatement allow_function,\012 bool* ok);\012 BlockT ParseBlock(ZonePtrList&lt;const AstRawString&gt;* labels, bool* ok);\012\012 // Parse a SubStatement in strict mode, or with an extra block scope in\012 // sloppy mode to handle\012 // ES#sec-functiondeclarations-in-ifstatement-statement-clauses\012 StatementT ParseScopedStatement(ZonePtrList&lt;const AstRawString&gt;* labels,\012 bool* ok);\012\012 StatementT ParseVariableStatement(VariableDeclarationContext var_context,\012 ZonePtrList&lt;const AstRawString&gt;* names,\012 bool* ok);\012\012 // Magical syntax support.\012 ExpressionT ParseV8Intrinsic(bool* ok);\012\012 ExpressionT ParseDoExpression(bool* ok);\012\012 StatementT ParseDebuggerStatement(bool* ok);\012\012 StatementT ParseExpressionOrLabelledStatement(\012 ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels,\012 AllowLabelledFunctionStatement allow_function, bool* ok);\012 StatementT ParseIfStatement(ZonePtrList&lt;const AstRawString&gt;* labels,\012 bool* ok);\012 StatementT ParseContinueStatement(bool* ok);\012 StatementT ParseBreakStatement(ZonePtrList&lt;const AstRawString&gt;* labels,\012 bool* ok);\012 StatementT ParseReturnStatement(bool* ok);\012 StatementT ParseWithStatement(ZonePtrList&lt;const AstRawString&gt;* labels,\012 bool* ok);\012 StatementT ParseDoWhileStatement(ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels,\012 bool* ok);\012 StatementT ParseWhileStatement(ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels,\012 bool* ok);\012 StatementT ParseThrowStatement(bool* ok);\012 StatementT ParseSwitchStatement(ZonePtrList&lt;const AstRawString&gt;* labels,\012 bool* ok);\012  V8_INLINE StatementT ParseTryStatement(bool* ok);\012 StatementT ParseForStatement(ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels,\012 bool* ok);\012 StatementT ParseForEachStatementWithDeclarations(\012 int stmt_pos, ForInfo* for_info, ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels, Scope* inner_block_scope,\012 bool* ok);\012 StatementT ParseForEachStatementWithoutDeclarations(\012 int stmt_pos, ExpressionT expression, int lhs_beg_pos, int lhs_end_pos,\012 ForInfo* for_info, ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels, bool* ok);\012\012 // Parse a C-style for loop: 'for (&lt;init&gt;; &lt;cond&gt;; &lt;next&gt;) { ... }'\012 // &quot;for (&lt;init&gt;;&quot; is assumed to have been parser already.\012 ForStatementT ParseStandardForLoop(\012 int stmt_pos, ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels, ExpressionT* cond,\012 StatementT* next, StatementT* body, bool* ok);\012 // Same as the above, but handles those cases where &lt;init&gt; is a\012 // lexical variable declaration.\012 StatementT ParseStandardForLoopWithLexicalDeclarations(\012 int stmt_pos, StatementT init, ForInfo* for_info,\012 ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels, bool* ok);\012 StatementT ParseForAwaitStatement(ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels,\012 bool* ok);\012\012 bool IsNextLetKeyword();\012 bool IsTrivialExpression();\012\012 // Checks if the expression is a valid reference expression (e.g., on the\012 // left-hand side of assignments). Although ruled out by ECMA as early errors,\012 // we allow calls for web compatibility and rewrite them to a runtime throw.\012 ExpressionT CheckAndRewriteReferenceExpression(\012 ExpressionT expression, int beg_pos, int end_pos,\012 MessageTemplate::Template message, bool* ok);\012 ExpressionT CheckAndRewriteReferenceExpression(\012 ExpressionT expression, int beg_pos, int end_pos,\012 MessageTemplate::Template message, ParseErrorType type, bool* ok);\012\012 bool IsValidReferenceExpression(ExpressionT expression);\012\012 bool IsAssignableIdentifier(ExpressionT expression) {\012 if (!impl()-&gt;IsIdentifier(expression)) return false;\012 if (is_strict(language_mode()) &amp;&amp;\012        impl()-&gt;IsEvalOrArguments(impl()-&gt;AsIdentifier(expression))) {\012 return false;\012 }\012 return true;\012 }\012\012 bool IsValidPattern(ExpressionT expression) {\012 return expression-&gt;IsObjectLiteral() || expression-&gt;IsArrayLiteral();\012 }\012\012 // Due to hoisting, the value of a 'var'-declared variable may actually change\012 // even if the code contains only the &quot;initial&quot; assignment, namely when that\012 // assignment occurs inside a loop.  For example:\012 //\012 //   let i = 10;\012 //   do { var x = i } while (i--):\012 //\012 // As a simple and very conservative approximation of this, we explicitly mark\012 // as maybe-assigned any non-lexical variable whose initializing &quot;declaration&quot;\012 // does not syntactically occur in the function scope.  (In the example above,\012 // it occurs in a block scope.)\012 //\012 // Note that non-lexical variables include temporaries, which may also get\012 // assigned inside a loop due to the various rewritings that the parser\012 // performs.\012 //\012 // This also handles marking of loop variables in for-in and for-of loops,\012 // as determined by declaration_kind.\012 //\012 static void MarkLoopVariableAsAssigned(\012 Scope* scope, Variable* var,\012 typename DeclarationDescriptor::Kind declaration_kind);\012\012 FunctionKind FunctionKindForImpl(bool is_method, bool is_generator,\012 bool is_async) {\012 static const FunctionKind kFunctionKinds[][2][2] = {\012 {\012 // is_method=false\012 {// is_generator=false\012 FunctionKind::kNormalFunction, FunctionKind::kAsyncFunction},\012 {// is_generator=true\012 FunctionKind::kGeneratorFunction,\012 FunctionKind::kAsyncGeneratorFunction},\012 },\012 {\012 // is_method=true\012 {// is_generator=false\012 FunctionKind::kConciseMethod, FunctionKind::kAsyncConciseMethod},\012 {// is_generator=true\012 FunctionKind::kConciseGeneratorMethod,\012 FunctionKind::kAsyncConciseGeneratorMethod},\012 }};\012 return kFunctionKinds[is_method][is_generator][is_async];\012 }\012\012 inline FunctionKind FunctionKindFor(bool is_generator, bool is_async) {\012 const bool kIsMethod = false;\012 return FunctionKindForImpl(kIsMethod, is_generator, is_async);\012 }\012\012 inline FunctionKind MethodKindFor(bool is_generator, bool is_async) {\012 const bool kIsMethod = true;\012 return FunctionKindForImpl(kIsMethod, is_generator, is_async);\012 }\012\012 // Keep track of eval() calls since they disable all local variable\012 // optimizations. This checks if expression is an eval call, and if yes,\012 // forwards the information to scope.\012 Call::PossiblyEval CheckPossibleEvalCall(ExpressionT expression,\012 Scope* scope) {\012 if (impl()-&gt;IsIdentifier(expression) &amp;&amp;\012        impl()-&gt;IsEval(impl()-&gt;AsIdentifier(expression))) {\012      scope-&gt;RecordInnerScopeEvalCall();\012      function_state_-&gt;RecordFunctionOrEvalCall();\012 if (is_sloppy(scope-&gt;language_mode())) {\012 // For sloppy scopes we also have to record the call at function level,\012 // in case it includes declarations that will be hoisted.\012        scope-&gt;GetDeclarationScope()-&gt;RecordEvalCall();\012 }\012\012 // This call is only necessary to track evals that may be\012 // inside arrow function parameter lists. In that case,\012 // Scope::Snapshot::Reparent will move this bit down into\012 // the arrow function's scope.\012      scope-&gt;RecordEvalCall();\012\012 return Call::IS_POSSIBLY_EVAL;\012 }\012 return Call::NOT_EVAL;\012 }\012\012 // Convenience method which determines the type of return statement to emit\012 // depending on the current function type.\012 inline StatementT BuildReturnStatement(ExpressionT expr, int pos,\012 int end_pos = kNoSourcePosition) {\012 if (impl()-&gt;IsNull(expr)) {\012      expr = factory()-&gt;NewUndefinedLiteral(kNoSourcePosition);\012 } else if (is_async_generator()) {\012 // In async generators, if there is an explicit operand to the return\012 // statement, await the operand.\012      expr = factory()-&gt;NewAwait(expr, kNoSourcePosition);\012      function_state_-&gt;AddSuspend();\012 }\012 if (is_async_function()) {\012 return factory()-&gt;NewAsyncReturnStatement(expr, pos, end_pos);\012 }\012 return factory()-&gt;NewReturnStatement(expr, pos, end_pos);\012 }\012\012 // Validation per ES6 object literals.\012 class ObjectLiteralChecker {\012 public:\012 explicit ObjectLiteralChecker(ParserBase* parser)\012 : parser_(parser), has_seen_proto_(false) {}\012\012 void CheckDuplicateProto(Token::Value property);\012\012 private:\012 bool IsProto() const {\012 return this-&gt;scanner()-&gt;CurrentMatchesContextualEscaped(\012 Token::PROTO_UNDERSCORED);\012 }\012\012 ParserBase* parser() const { return parser_; }\012 Scanner* scanner() const { return parser_-&gt;scanner(); }\012\012 ParserBase* parser_;\012 bool has_seen_proto_;\012 };\012\012 // Validation per ES6 class literals.\012 class ClassLiteralChecker {\012 public:\012 explicit ClassLiteralChecker(ParserBase* parser)\012 : parser_(parser), has_seen_constructor_(false) {}\012\012 void CheckClassMethodName(Token::Value property, PropertyKind type,\012 bool is_generator, bool is_async, bool is_static,\012 bool* ok);\012 void CheckClassFieldName(bool is_static, bool* ok);\012\012 private:\012 bool IsConstructor() {\012 return this-&gt;scanner()-&gt;CurrentMatchesContextualEscaped(\012 Token::CONSTRUCTOR);\012 }\012 bool IsPrivateConstructor() {\012 return this-&gt;scanner()-&gt;CurrentMatchesContextualEscaped(\012 Token::PRIVATE_CONSTRUCTOR);\012 }\012 bool IsPrototype() {\012 return this-&gt;scanner()-&gt;CurrentMatchesContextualEscaped(Token::PROTOTYPE);\012 }\012\012 ParserBase* parser() const { return parser_; }\012 Scanner* scanner() const { return parser_-&gt;scanner(); }\012\012 ParserBase* parser_;\012 bool has_seen_constructor_;\012 };\012\012 ModuleDescriptor* module() const {\012 return scope()-&gt;AsModuleScope()-&gt;module();\012 }\012 Scope* scope() const { return scope_; }\012\012 // Stack of expression classifiers.\012 // The top of the stack is always pointed to by classifier().\012  V8_INLINE ExpressionClassifier* classifier() const {\012    DCHECK_NOT_NULL(classifier_);\012 return classifier_;\012 }\012\012 // Accumulates the classifier that is on top of the stack (inner) to\012 // the one that is right below (outer) and pops the inner.\012  V8_INLINE void Accumulate(unsigned productions) {\012    DCHECK_NOT_NULL(classifier_);\012 ExpressionClassifier* previous = classifier_-&gt;previous();\012    DCHECK_NOT_NULL(previous);\012    previous-&gt;Accumulate(classifier_, productions);\012    classifier_ = previous;\012 }\012\012  V8_INLINE void AccumulateNonBindingPatternErrors() {\012 this-&gt;Accumulate(ExpressionClassifier::AllProductions &amp;\012 ~(ExpressionClassifier::BindingPatternProduction |\012 ExpressionClassifier::LetPatternProduction));\012 }\012\012 // Pops and discards the classifier that is on top of the stack\012 // without accumulating.\012  V8_INLINE void DiscardExpressionClassifier() {\012    DCHECK_NOT_NULL(classifier_);\012    classifier_-&gt;Discard();\012    classifier_ = classifier_-&gt;previous();\012 }\012\012 // Accumulate errors that can be arbitrarily deep in an expression.\012 // These correspond to the ECMAScript spec's 'Contains' operation\012 // on productions. This includes:\012 //\012 // - YieldExpression is disallowed in arrow parameters in a generator.\012 // - AwaitExpression is disallowed in arrow parameters in an async function.\012 // - AwaitExpression is disallowed in async arrow parameters.\012 //\012  V8_INLINE void AccumulateFormalParameterContainmentErrors() {\012 Accumulate(ExpressionClassifier::FormalParameterInitializerProduction |\012 ExpressionClassifier::AsyncArrowFormalParametersProduction);\012 }\012\012 // Parser base's protected field members.\012\012 Scope* scope_; // Scope stack.\012 Scope* original_scope_; // The top scope for the current parsing item.\012 FunctionState* function_state_; // Function state stack.\012  v8::Extension* extension_;\012 FuncNameInferrer* fni_;\012 AstValueFactory* ast_value_factory_; // Not owned.\012 typename Types::Factory ast_node_factory_;\012 RuntimeCallStats* runtime_call_stats_;\012 internal::Logger* logger_;\012 bool parsing_on_main_thread_;\012 const bool parsing_module_;\012 uintptr_t stack_limit_;\012 PendingCompilationErrorHandler* pending_error_handler_;\012\012 // Parser base's private field members.\012\012 private:\012 Zone* zone_;\012 ExpressionClassifier* classifier_;\012\012 Scanner* scanner_;\012\012 FunctionLiteral::EagerCompileHint default_eager_compile_hint_;\012\012 int function_literal_id_;\012 int script_id_;\012\012 bool allow_natives_;\012 bool allow_harmony_do_expressions_;\012 bool allow_harmony_public_fields_;\012 bool allow_harmony_static_fields_;\012 bool allow_harmony_dynamic_import_;\012 bool allow_harmony_import_meta_;\012 bool allow_harmony_private_fields_;\012 bool allow_eval_cache_;\012\012 friend class DiscardableZoneScope;\012};\012\012template &lt;typename Impl&gt;\012ParserBase&lt;Impl&gt;::FunctionState::FunctionState(\012 FunctionState** function_state_stack, Scope** scope_stack,\012 DeclarationScope* scope)\012 : BlockState(scope_stack, scope),\012      expected_property_count_(0),\012      suspend_count_(0),\012      function_state_stack_(function_state_stack),\012      outer_function_state_(*function_state_stack),\012      scope_(scope),\012      destructuring_assignments_to_rewrite_(scope-&gt;zone()),\012      reported_errors_(scope_-&gt;zone()),\012      dont_optimize_reason_(BailoutReason::kNoReason),\012      next_function_is_likely_called_(false),\012      previous_function_was_likely_called_(false),\012      contains_function_or_eval_(false) {\012 *function_state_stack = this;\012  reported_errors_.reserve(16);\012 if (outer_function_state_) {\012    outer_function_state_-&gt;previous_function_was_likely_called_ =\012        outer_function_state_-&gt;next_function_is_likely_called_;\012    outer_function_state_-&gt;next_function_is_likely_called_ = false;\012 }\012}\012\012template &lt;typename Impl&gt;\012ParserBase&lt;Impl&gt;::FunctionState::~FunctionState() {\012 *function_state_stack_ = outer_function_state_;\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::GetUnexpectedTokenMessage(\012 Token::Value token, MessageTemplate::Template* message,\012 Scanner::Location* location, const char** arg,\012 MessageTemplate::Template default_) {\012 *arg = nullptr;\012 switch (token) {\012 case Token::EOS:\012 *message = MessageTemplate::kUnexpectedEOS;\012 break;\012 case Token::SMI:\012 case Token::NUMBER:\012 case Token::BIGINT:\012 *message = MessageTemplate::kUnexpectedTokenNumber;\012 break;\012 case Token::STRING:\012 *message = MessageTemplate::kUnexpectedTokenString;\012 break;\012 case Token::PRIVATE_NAME:\012 case Token::IDENTIFIER:\012 *message = MessageTemplate::kUnexpectedTokenIdentifier;\012 break;\012 case Token::AWAIT:\012 case Token::ENUM:\012 *message = MessageTemplate::kUnexpectedReserved;\012 break;\012 case Token::LET:\012 case Token::STATIC:\012 case Token::YIELD:\012 case Token::FUTURE_STRICT_RESERVED_WORD:\012 *message = is_strict(language_mode())\012 ? MessageTemplate::kUnexpectedStrictReserved\012 : MessageTemplate::kUnexpectedTokenIdentifier;\012 break;\012 case Token::TEMPLATE_SPAN:\012 case Token::TEMPLATE_TAIL:\012 *message = MessageTemplate::kUnexpectedTemplateString;\012 break;\012 case Token::ESCAPED_STRICT_RESERVED_WORD:\012 case Token::ESCAPED_KEYWORD:\012 *message = MessageTemplate::kInvalidEscapedReservedWord;\012 break;\012 case Token::ILLEGAL:\012 if (scanner()-&gt;has_error()) {\012 *message = scanner()-&gt;error();\012 *location = scanner()-&gt;error_location();\012 } else {\012 *message = MessageTemplate::kInvalidOrUnexpectedToken;\012 }\012 break;\012 case Token::REGEXP_LITERAL:\012 *message = MessageTemplate::kUnexpectedTokenRegExp;\012 break;\012 default:\012 const char* name = Token::String(token);\012      DCHECK_NOT_NULL(name);\012 *arg = name;\012 break;\012 }\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::ReportUnexpectedToken(Token::Value token) {\012 return ReportUnexpectedTokenAt(scanner_-&gt;location(), token);\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::ReportUnexpectedTokenAt(\012 Scanner::Location source_location, Token::Value token,\012 MessageTemplate::Template message) {\012 const char* arg;\012 GetUnexpectedTokenMessage(token, &amp;message, &amp;source_location, &amp;arg);\012  impl()-&gt;ReportMessageAt(source_location, message, arg);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::IdentifierT ParserBase&lt;Impl&gt;::ParseIdentifier(\012 AllowRestrictedIdentifiers allow_restricted_identifiers, bool* ok) {\012 ExpressionClassifier classifier(this);\012 auto result = ParseAndClassifyIdentifier(CHECK_OK_CUSTOM(NullIdentifier));\012\012 if (allow_restricted_identifiers == kDontAllowRestrictedIdentifiers) {\012 ValidateAssignmentPattern(CHECK_OK_CUSTOM(NullIdentifier));\012 ValidateBindingPattern(CHECK_OK_CUSTOM(NullIdentifier));\012 }\012\012 return result;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::IdentifierT\012ParserBase&lt;Impl&gt;::ParseAndClassifyIdentifier(bool* ok) {\012 Token::Value next = Next();\012 if (next == Token::IDENTIFIER || next == Token::ASYNC ||\012 (next == Token::AWAIT &amp;&amp; !parsing_module_ &amp;&amp; !is_async_function())) {\012 IdentifierT name = impl()-&gt;GetSymbol();\012\012 if (impl()-&gt;IsArguments(name) &amp;&amp; scope()-&gt;ShouldBanArguments()) {\012 ReportMessage(MessageTemplate::kArgumentsDisallowedInInitializer);\012 *ok = false;\012 return impl()-&gt;NullIdentifier();\012 }\012\012 // When this function is used to read a formal parameter, we don't always\012 // know whether the function is going to be strict or sloppy.  Indeed for\012 // arrow functions we don't always know that the identifier we are reading\012 // is actually a formal parameter.  Therefore besides the errors that we\012 // must detect because we know we're in strict mode, we also record any\012 // error that we might make in the future once we know the language mode.\012 if (impl()-&gt;IsEvalOrArguments(name)) {\012      classifier()-&gt;RecordStrictModeFormalParameterError(\012          scanner()-&gt;location(), MessageTemplate::kStrictEvalArguments);\012 if (is_strict(language_mode())) {\012        classifier()-&gt;RecordBindingPatternError(\012            scanner()-&gt;location(), MessageTemplate::kStrictEvalArguments);\012 }\012 } else if (next == Token::AWAIT) {\012      classifier()-&gt;RecordAsyncArrowFormalParametersError(\012          scanner()-&gt;location(), MessageTemplate::kAwaitBindingIdentifier);\012 }\012\012 if (classifier()-&gt;duplicate_finder() != nullptr &amp;&amp;\012        scanner()-&gt;IsDuplicateSymbol(classifier()-&gt;duplicate_finder(),\012                                     ast_value_factory())) {\012      classifier()-&gt;RecordDuplicateFormalParameterError(scanner()-&gt;location());\012 }\012 return name;\012 } else if (is_sloppy(language_mode()) &amp;&amp;\012 (next == Token::FUTURE_STRICT_RESERVED_WORD ||\012 next == Token::ESCAPED_STRICT_RESERVED_WORD ||\012 next == Token::LET || next == Token::STATIC ||\012 (next == Token::YIELD &amp;&amp; !is_generator()))) {\012    classifier()-&gt;RecordStrictModeFormalParameterError(\012        scanner()-&gt;location(), MessageTemplate::kUnexpectedStrictReserved);\012 if (next == Token::ESCAPED_STRICT_RESERVED_WORD &amp;&amp;\012        is_strict(language_mode())) {\012 ReportUnexpectedToken(next);\012 *ok = false;\012 return impl()-&gt;NullIdentifier();\012 }\012 if (scanner()-&gt;IsLet()) {\012      classifier()-&gt;RecordLetPatternError(\012          scanner()-&gt;location(), MessageTemplate::kLetInLexicalBinding);\012 }\012 return impl()-&gt;GetSymbol();\012 } else {\012 ReportUnexpectedToken(next);\012 *ok = false;\012 return impl()-&gt;NullIdentifier();\012 }\012}\012\012template &lt;class Impl&gt;\012typename ParserBase&lt;Impl&gt;::IdentifierT\012ParserBase&lt;Impl&gt;::ParseIdentifierOrStrictReservedWord(\012 FunctionKind function_kind, bool* is_strict_reserved, bool* is_await,\012 bool* ok) {\012 Token::Value next = Next();\012 if (next == Token::IDENTIFIER || (next == Token::AWAIT &amp;&amp; !parsing_module_ &amp;&amp;\012 !IsAsyncFunction(function_kind)) ||\012 next == Token::ASYNC) {\012 *is_strict_reserved = false;\012 *is_await = next == Token::AWAIT;\012 } else if (next == Token::ESCAPED_STRICT_RESERVED_WORD ||\012 next == Token::FUTURE_STRICT_RESERVED_WORD || next == Token::LET ||\012 next == Token::STATIC ||\012 (next == Token::YIELD &amp;&amp; !IsGeneratorFunction(function_kind))) {\012 *is_strict_reserved = true;\012 } else {\012 ReportUnexpectedToken(next);\012 *ok = false;\012 return impl()-&gt;NullIdentifier();\012 }\012\012 return impl()-&gt;GetSymbol();\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::IdentifierT ParserBase&lt;Impl&gt;::ParseIdentifierName(\012 bool* ok) {\012 Token::Value next = Next();\012 if (next != Token::IDENTIFIER &amp;&amp; next != Token::ASYNC &amp;&amp;\012 next != Token::ENUM &amp;&amp; next != Token::AWAIT &amp;&amp; next != Token::LET &amp;&amp;\012 next != Token::STATIC &amp;&amp; next != Token::YIELD &amp;&amp;\012 next != Token::FUTURE_STRICT_RESERVED_WORD &amp;&amp;\012 next != Token::ESCAPED_KEYWORD &amp;&amp;\012 next != Token::ESCAPED_STRICT_RESERVED_WORD &amp;&amp; !Token::IsKeyword(next)) {\012 ReportUnexpectedToken(next);\012 *ok = false;\012 return impl()-&gt;NullIdentifier();\012 }\012\012 return impl()-&gt;GetSymbol();\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT\012ParserBase&lt;Impl&gt;::ParseIdentifierNameOrPrivateName(bool* ok) {\012 int pos = position();\012 IdentifierT name;\012 ExpressionT key;\012 if (allow_harmony_private_fields() &amp;&amp; peek() == Token::PRIVATE_NAME) {\012 Consume(Token::PRIVATE_NAME);\012    name = impl()-&gt;GetSymbol();\012 auto key_proxy =\012        impl()-&gt;ExpressionFromIdentifier(name, pos, InferName::kNo);\012    key_proxy-&gt;set_is_private_field();\012    key = key_proxy;\012 } else {\012    name = ParseIdentifierName(CHECK_OK);\012    key = factory()-&gt;NewStringLiteral(name, pos);\012 }\012  impl()-&gt;PushLiteralName(name);\012 return key;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParseRegExpLiteral(\012 bool* ok) {\012 int pos = peek_position();\012 if (!scanner()-&gt;ScanRegExpPattern()) {\012 Next();\012 ReportMessage(MessageTemplate::kUnterminatedRegExp);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012\012 IdentifierT js_pattern = impl()-&gt;GetNextSymbol();\012 Maybe&lt;RegExp::Flags&gt; flags = scanner()-&gt;ScanRegExpFlags();\012 if (flags.IsNothing()) {\012 Next();\012 ReportMessage(MessageTemplate::kMalformedRegExpFlags);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012 int js_flags = flags.FromJust();\012 Next();\012 return factory()-&gt;NewRegExpLiteral(js_pattern, js_flags, pos);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParsePrimaryExpression(\012 bool* is_async, bool* ok) {\012 // PrimaryExpression ::\012 //   'this'\012 //   'null'\012 //   'true'\012 //   'false'\012 //   Identifier\012 //   Number\012 //   String\012 //   ArrayLiteral\012 //   ObjectLiteral\012 //   RegExpLiteral\012 //   ClassLiteral\012 //   '(' Expression ')'\012 //   TemplateLiteral\012 //   do Block\012 //   AsyncFunctionLiteral\012\012 int beg_pos = peek_position();\012 switch (peek()) {\012 case Token::THIS: {\012 BindingPatternUnexpectedToken();\012 Consume(Token::THIS);\012 return impl()-&gt;ThisExpression(beg_pos);\012 }\012\012 case Token::NULL_LITERAL:\012 case Token::TRUE_LITERAL:\012 case Token::FALSE_LITERAL:\012 case Token::SMI:\012 case Token::NUMBER:\012 case Token::BIGINT:\012 BindingPatternUnexpectedToken();\012 return impl()-&gt;ExpressionFromLiteral(Next(), beg_pos);\012\012 case Token::ASYNC:\012 if (!scanner()-&gt;HasLineTerminatorAfterNext() &amp;&amp;\012 PeekAhead() == Token::FUNCTION) {\012 BindingPatternUnexpectedToken();\012 Consume(Token::ASYNC);\012 return ParseAsyncFunctionLiteral(CHECK_OK);\012 }\012 // CoverCallExpressionAndAsyncArrowHead\012 *is_async = true;\012      V8_FALLTHROUGH;\012 case Token::IDENTIFIER:\012 case Token::LET:\012 case Token::STATIC:\012 case Token::YIELD:\012 case Token::AWAIT:\012 case Token::ESCAPED_STRICT_RESERVED_WORD:\012 case Token::FUTURE_STRICT_RESERVED_WORD: {\012 // Using eval or arguments in this context is OK even in strict mode.\012 IdentifierT name = ParseAndClassifyIdentifier(CHECK_OK);\012 return impl()-&gt;ExpressionFromIdentifier(name, beg_pos);\012 }\012\012 case Token::STRING: {\012 BindingPatternUnexpectedToken();\012 Consume(Token::STRING);\012 return impl()-&gt;ExpressionFromString(beg_pos);\012 }\012\012 case Token::ASSIGN_DIV:\012 case Token::DIV:\012      classifier()-&gt;RecordBindingPatternError(\012          scanner()-&gt;peek_location(), MessageTemplate::kUnexpectedTokenRegExp);\012 return ParseRegExpLiteral(ok);\012\012 case Token::LBRACK:\012 return ParseArrayLiteral(ok);\012\012 case Token::LBRACE:\012 return ParseObjectLiteral(ok);\012\012 case Token::LPAREN: {\012 // Arrow function formal parameters are either a single identifier or a\012 // list of BindingPattern productions enclosed in parentheses.\012 // Parentheses are not valid on the LHS of a BindingPattern, so we use the\012 // is_valid_binding_pattern() check to detect multiple levels of\012 // parenthesization.\012 bool pattern_error = !classifier()-&gt;is_valid_binding_pattern();\012      classifier()-&gt;RecordPatternError(scanner()-&gt;peek_location(),\012 MessageTemplate::kUnexpectedToken,\012 Token::String(Token::LPAREN));\012 if (pattern_error) ArrowFormalParametersUnexpectedToken();\012 Consume(Token::LPAREN);\012 if (Check(Token::RPAREN)) {\012 // ()=&gt;x.  The continuation that looks for the =&gt; is in\012 // ParseAssignmentExpression.\012        classifier()-&gt;RecordExpressionError(scanner()-&gt;location(),\012 MessageTemplate::kUnexpectedToken,\012 Token::String(Token::RPAREN));\012 return factory()-&gt;NewEmptyParentheses(beg_pos);\012 }\012 // Heuristically try to detect immediately called functions before\012 // seeing the call parentheses.\012 if (peek() == Token::FUNCTION ||\012 (peek() == Token::ASYNC &amp;&amp; PeekAhead() == Token::FUNCTION)) {\012        function_state_-&gt;set_next_function_is_likely_called();\012 }\012 ExpressionT expr = ParseExpressionCoverGrammar(true, CHECK_OK);\012 Expect(Token::RPAREN, CHECK_OK);\012 return expr;\012 }\012\012 case Token::CLASS: {\012 BindingPatternUnexpectedToken();\012 Consume(Token::CLASS);\012 int class_token_pos = position();\012 IdentifierT name = impl()-&gt;NullIdentifier();\012 bool is_strict_reserved_name = false;\012 Scanner::Location class_name_location = Scanner::Location::invalid();\012 if (peek_any_identifier()) {\012 bool is_await = false;\012        name = ParseIdentifierOrStrictReservedWord(&amp;is_strict_reserved_name,\012 &amp;is_await, CHECK_OK);\012        class_name_location = scanner()-&gt;location();\012 if (is_await) {\012          classifier()-&gt;RecordAsyncArrowFormalParametersError(\012              scanner()-&gt;location(), MessageTemplate::kAwaitBindingIdentifier);\012 }\012 }\012 return ParseClassLiteral(name, class_name_location,\012                               is_strict_reserved_name, class_token_pos, ok);\012 }\012\012 case Token::TEMPLATE_SPAN:\012 case Token::TEMPLATE_TAIL:\012 BindingPatternUnexpectedToken();\012 return ParseTemplateLiteral(impl()-&gt;NullExpression(), beg_pos, false, ok);\012\012 case Token::MOD:\012 if (allow_natives() || extension_ != nullptr) {\012 BindingPatternUnexpectedToken();\012 return ParseV8Intrinsic(ok);\012 }\012 break;\012\012 case Token::DO:\012 if (allow_harmony_do_expressions()) {\012 BindingPatternUnexpectedToken();\012 return ParseDoExpression(ok);\012 }\012 break;\012\012 default:\012 break;\012 }\012\012 ReportUnexpectedToken(Next());\012 *ok = false;\012 return impl()-&gt;NullExpression();\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParseExpression(\012 bool accept_IN, bool* ok) {\012 ExpressionClassifier classifier(this);\012 ExpressionT result = ParseExpressionCoverGrammar(accept_IN, CHECK_OK);\012 ValidateExpression(CHECK_OK);\012 return result;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT\012ParserBase&lt;Impl&gt;::ParseExpressionCoverGrammar(bool accept_IN, bool* ok) {\012 // Expression ::\012 //   AssignmentExpression\012 //   Expression ',' AssignmentExpression\012\012 ExpressionT result = impl()-&gt;NullExpression();\012 while (true) {\012 int comma_pos = position();\012 ExpressionClassifier binding_classifier(this);\012 ExpressionT right;\012 if (Check(Token::ELLIPSIS)) {\012 // 'x, y, ...z' in CoverParenthesizedExpressionAndArrowParameterList only\012 // as the formal parameters of'(x, y, ...z) =&gt; foo', and is not itself a\012 // valid expression.\012      classifier()-&gt;RecordExpressionError(scanner()-&gt;location(),\012 MessageTemplate::kUnexpectedToken,\012 Token::String(Token::ELLIPSIS));\012 int ellipsis_pos = position();\012 int pattern_pos = peek_position();\012 ExpressionT pattern = ParsePrimaryExpression(CHECK_OK);\012 if (peek() == Token::ASSIGN) {\012 ReportMessage(MessageTemplate::kRestDefaultInitializer);\012 *ok = false;\012 return result;\012 }\012 ValidateBindingPattern(CHECK_OK);\012      right = factory()-&gt;NewSpread(pattern, ellipsis_pos, pattern_pos);\012 } else {\012      right = ParseAssignmentExpression(accept_IN, CHECK_OK);\012 }\012 // No need to accumulate binding pattern-related errors, since\012 // an Expression can't be a binding pattern anyway.\012 AccumulateNonBindingPatternErrors();\012 if (!impl()-&gt;IsIdentifier(right)) classifier()-&gt;RecordNonSimpleParameter();\012 if (impl()-&gt;IsNull(result)) {\012 // First time through the loop.\012      result = right;\012 } else if (impl()-&gt;CollapseNaryExpression(&amp;result, right, Token::COMMA,\012                                              comma_pos,\012 SourceRange::Empty())) {\012 // Do nothing, &quot;result&quot; is already updated.\012 } else {\012      result =\012          factory()-&gt;NewBinaryOperation(Token::COMMA, result, right, comma_pos);\012 }\012\012 if (!Check(Token::COMMA)) break;\012\012 if (right-&gt;IsSpread()) {\012      classifier()-&gt;RecordArrowFormalParametersError(\012          scanner()-&gt;location(), MessageTemplate::kParamAfterRest);\012 }\012\012 if (peek() == Token::RPAREN &amp;&amp; PeekAhead() == Token::ARROW) {\012 // a trailing comma is allowed at the end of an arrow parameter list\012 break;\012 }\012\012 // Pass on the 'set_next_function_is_likely_called' flag if we have\012 // several function literals separated by comma.\012 if (peek() == Token::FUNCTION &amp;&amp;\012        function_state_-&gt;previous_function_was_likely_called()) {\012      function_state_-&gt;set_next_function_is_likely_called();\012 }\012 }\012\012 return result;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParseArrayLiteral(\012 bool* ok) {\012 // ArrayLiteral ::\012 //   '[' Expression? (',' Expression?)* ']'\012\012 int pos = peek_position();\012 ExpressionListT values = impl()-&gt;NewExpressionList(4);\012 int first_spread_index = -1;\012 Expect(Token::LBRACK, CHECK_OK);\012 while (peek() != Token::RBRACK) {\012 ExpressionT elem;\012 if (peek() == Token::COMMA) {\012      elem = factory()-&gt;NewTheHoleLiteral();\012 } else if (peek() == Token::ELLIPSIS) {\012 int start_pos = peek_position();\012 Consume(Token::ELLIPSIS);\012 int expr_pos = peek_position();\012 ExpressionT argument = ParseAssignmentExpression(true, CHECK_OK);\012      elem = factory()-&gt;NewSpread(argument, start_pos, expr_pos);\012\012 if (first_spread_index &lt; 0) {\012        first_spread_index = values-&gt;length();\012 }\012\012 if (argument-&gt;IsAssignment()) {\012        classifier()-&gt;RecordPatternError(\012 Scanner::Location(start_pos, scanner()-&gt;location().end_pos),\012 MessageTemplate::kInvalidDestructuringTarget);\012 } else {\012 CheckDestructuringElement(argument, start_pos,\012                                  scanner()-&gt;location().end_pos);\012 }\012\012 if (peek() == Token::COMMA) {\012        classifier()-&gt;RecordPatternError(\012 Scanner::Location(start_pos, scanner()-&gt;location().end_pos),\012 MessageTemplate::kElementAfterRest);\012 }\012 } else {\012 int beg_pos = peek_position();\012      elem = ParseAssignmentExpression(true, CHECK_OK);\012 CheckDestructuringElement(elem, beg_pos, scanner()-&gt;location().end_pos);\012 }\012    values-&gt;Add(elem, zone_);\012 if (peek() != Token::RBRACK) {\012 Expect(Token::COMMA, CHECK_OK);\012 }\012 }\012 Expect(Token::RBRACK, CHECK_OK);\012\012 return factory()-&gt;NewArrayLiteral(values, first_spread_index, pos);\012}\012\012template &lt;class Impl&gt;\012bool ParserBase&lt;Impl&gt;::SetPropertyKindFromToken(Token::Value token,\012 PropertyKind* kind) {\012 // This returns true, setting the property kind, iff the given token is one\012 // which must occur after a property name, indicating that the previous token\012 // was in fact a name and not a modifier (like the &quot;get&quot; in &quot;get x&quot;).\012 switch (token) {\012 case Token::COLON:\012 *kind = PropertyKind::kValueProperty;\012 return true;\012 case Token::COMMA:\012 case Token::RBRACE:\012 case Token::ASSIGN:\012 *kind = PropertyKind::kShorthandProperty;\012 return true;\012 case Token::LPAREN:\012 *kind = PropertyKind::kMethodProperty;\012 return true;\012 case Token::MUL:\012 case Token::SEMICOLON:\012 *kind = PropertyKind::kClassField;\012 return true;\012 case Token::PRIVATE_NAME:\012 *kind = PropertyKind::kClassField;\012 return true;\012 default:\012 break;\012 }\012 return false;\012}\012\012template &lt;class Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParsePropertyName(\012 IdentifierT* name, PropertyKind* kind, bool* is_generator, bool* is_get,\012 bool* is_set, bool* is_async, bool* is_computed_name, bool* ok) {\012  DCHECK_EQ(*kind, PropertyKind::kNotSet);\012  DCHECK(!*is_generator);\012  DCHECK(!*is_get);\012  DCHECK(!*is_set);\012  DCHECK(!*is_async);\012  DCHECK(!*is_computed_name);\012\012 *is_generator = Check(Token::MUL);\012 if (*is_generator) {\012 *kind = PropertyKind::kMethodProperty;\012 }\012\012 Token::Value token = peek();\012 int pos = peek_position();\012\012 if (!*is_generator &amp;&amp; token == Token::ASYNC &amp;&amp;\012 !scanner()-&gt;HasLineTerminatorAfterNext()) {\012 Consume(Token::ASYNC);\012    token = peek();\012 if (token == Token::MUL &amp;&amp; !scanner()-&gt;HasLineTerminatorBeforeNext()) {\012 Consume(Token::MUL);\012      token = peek();\012 *is_generator = true;\012 } else if (SetPropertyKindFromToken(token, kind)) {\012 *name = impl()-&gt;GetSymbol(); // TODO(bakkot) specialize on 'async'\012      impl()-&gt;PushLiteralName(*name);\012 return factory()-&gt;NewStringLiteral(*name, pos);\012 }\012 *kind = PropertyKind::kMethodProperty;\012 *is_async = true;\012    pos = peek_position();\012 }\012\012 if (token == Token::IDENTIFIER &amp;&amp; !*is_generator &amp;&amp; !*is_async) {\012 // This is checking for 'get' and 'set' in particular.\012 Consume(Token::IDENTIFIER);\012    token = peek();\012 if (SetPropertyKindFromToken(token, kind) ||\012 !scanner()-&gt;IsGetOrSet(is_get, is_set)) {\012 *name = impl()-&gt;GetSymbol();\012      impl()-&gt;PushLiteralName(*name);\012 return factory()-&gt;NewStringLiteral(*name, pos);\012 }\012 *kind = PropertyKind::kAccessorProperty;\012    pos = peek_position();\012 }\012\012 // For non computed property names we normalize the name a bit:\012 //\012 //   &quot;12&quot; -&gt; 12\012 //   12.3 -&gt; &quot;12.3&quot;\012 //   12.30 -&gt; &quot;12.3&quot;\012 //   identifier -&gt; &quot;identifier&quot;\012 //\012 // This is important because we use the property name as a key in a hash\012 // table when we compute constant properties.\012 ExpressionT expression = impl()-&gt;NullExpression();\012 switch (token) {\012 case Token::STRING:\012 Consume(Token::STRING);\012 *name = impl()-&gt;GetSymbol();\012 break;\012\012 case Token::SMI:\012 Consume(Token::SMI);\012 *name = impl()-&gt;GetNumberAsSymbol();\012 break;\012\012 case Token::NUMBER:\012 Consume(Token::NUMBER);\012 *name = impl()-&gt;GetNumberAsSymbol();\012 break;\012\012 case Token::LBRACK: {\012 *name = impl()-&gt;NullIdentifier();\012 *is_computed_name = true;\012 Consume(Token::LBRACK);\012 ExpressionClassifier computed_name_classifier(this);\012      expression = ParseAssignmentExpression(true, CHECK_OK);\012 ValidateExpression(CHECK_OK);\012 AccumulateFormalParameterContainmentErrors();\012 Expect(Token::RBRACK, CHECK_OK);\012 break;\012 }\012\012 case Token::ELLIPSIS:\012 if (!*is_generator &amp;&amp; !*is_async &amp;&amp; !*is_get &amp;&amp; !*is_set) {\012 *name = impl()-&gt;NullIdentifier();\012 Consume(Token::ELLIPSIS);\012        expression = ParseAssignmentExpression(true, CHECK_OK);\012 *kind = PropertyKind::kSpreadProperty;\012\012 if (!impl()-&gt;IsIdentifier(expression)) {\012          classifier()-&gt;RecordBindingPatternError(\012              scanner()-&gt;location(),\012 MessageTemplate::kInvalidRestBindingPattern);\012 }\012\012 if (!expression-&gt;IsValidReferenceExpression()) {\012          classifier()-&gt;RecordAssignmentPatternError(\012              scanner()-&gt;location(),\012 MessageTemplate::kInvalidRestAssignmentPattern);\012 }\012\012 if (peek() != Token::RBRACE) {\012          classifier()-&gt;RecordPatternError(scanner()-&gt;location(),\012 MessageTemplate::kElementAfterRest);\012 }\012 return expression;\012 }\012      V8_FALLTHROUGH;\012\012 default:\012 *name = ParseIdentifierName(CHECK_OK);\012 break;\012 }\012\012 if (*kind == PropertyKind::kNotSet) {\012 SetPropertyKindFromToken(peek(), kind);\012 }\012\012 if (*is_computed_name) {\012 return expression;\012 }\012\012  impl()-&gt;PushLiteralName(*name);\012\012 uint32_t index;\012 return impl()-&gt;IsArrayIndex(*name, &amp;index)\012 ? factory()-&gt;NewNumberLiteral(index, pos)\012 : factory()-&gt;NewStringLiteral(*name, pos);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ClassLiteralPropertyT\012ParserBase&lt;Impl&gt;::ParseClassPropertyDefinition(\012 ClassLiteralChecker* checker, ClassInfo* class_info, IdentifierT* name,\012 bool has_extends, bool* is_computed_name,\012 ClassLiteralProperty::Kind* property_kind, bool* is_static, bool* ok) {\012  DCHECK_NOT_NULL(class_info);\012 bool is_get = false;\012 bool is_set = false;\012 bool is_generator = false;\012 bool is_async = false;\012 *is_static = false;\012 *property_kind = ClassLiteralProperty::METHOD;\012 PropertyKind kind = PropertyKind::kNotSet;\012\012 Token::Value name_token = peek();\012  DCHECK_IMPLIES(name_token == Token::PRIVATE_NAME,\012                 allow_harmony_private_fields());\012\012 int name_token_position = scanner()-&gt;peek_location().beg_pos;\012 *name = impl()-&gt;NullIdentifier();\012 ExpressionT name_expression;\012 if (name_token == Token::STATIC) {\012 Consume(Token::STATIC);\012    name_token_position = scanner()-&gt;peek_location().beg_pos;\012 if (peek() == Token::LPAREN) {\012      kind = PropertyKind::kMethodProperty;\012 *name = impl()-&gt;GetSymbol(); // TODO(bakkot) specialize on 'static'\012      name_expression = factory()-&gt;NewStringLiteral(*name, position());\012 } else if (peek() == Token::ASSIGN || peek() == Token::SEMICOLON ||\012               peek() == Token::RBRACE) {\012 *name = impl()-&gt;GetSymbol(); // TODO(bakkot) specialize on 'static'\012      name_expression = factory()-&gt;NewStringLiteral(*name, position());\012 } else if (peek() == Token::PRIVATE_NAME) {\012      DCHECK(allow_harmony_private_fields());\012 // TODO(gsathya): Make a better error message for this.\012 ReportUnexpectedToken(Next());\012 *ok = false;\012 return impl()-&gt;NullLiteralProperty();\012 } else {\012 *is_static = true;\012      name_expression = ParsePropertyName(name, &amp;kind, &amp;is_generator, &amp;is_get,\012 &amp;is_set, &amp;is_async, is_computed_name,\012                                          CHECK_OK_CUSTOM(NullLiteralProperty));\012 }\012 } else if (name_token == Token::PRIVATE_NAME) {\012 Consume(Token::PRIVATE_NAME);\012 *name = impl()-&gt;GetSymbol();\012    name_expression = factory()-&gt;NewStringLiteral(*name, position());\012 } else {\012    name_expression = ParsePropertyName(name, &amp;kind, &amp;is_generator, &amp;is_get,\012 &amp;is_set, &amp;is_async, is_computed_name,\012                                        CHECK_OK_CUSTOM(NullLiteralProperty));\012 }\012\012 if (!class_info-&gt;has_name_static_property &amp;&amp; *is_static &amp;&amp;\012      impl()-&gt;IsName(*name)) {\012    class_info-&gt;has_name_static_property = true;\012 }\012\012 switch (kind) {\012 case PropertyKind::kClassField:\012 case PropertyKind::kNotSet: // This case is a name followed by a name or\012 // other property. Here we have to assume\012 // that's an uninitialized field followed by a\012 // linebreak followed by a property, with ASI\012 // adding the semicolon. If not, there will be\012 // a syntax error after parsing the first name\012 // as an uninitialized field.\012 case PropertyKind::kShorthandProperty:\012 case PropertyKind::kValueProperty:\012 if (allow_harmony_public_fields() || allow_harmony_private_fields()) {\012 *property_kind = name_token == Token::PRIVATE_NAME\012 ? ClassLiteralProperty::PRIVATE_FIELD\012 : ClassLiteralProperty::PUBLIC_FIELD;\012 if (*is_static &amp;&amp; !allow_harmony_static_fields()) {\012 ReportUnexpectedToken(Next());\012 *ok = false;\012 return impl()-&gt;NullLiteralProperty();\012 }\012 if (!*is_computed_name) {\012          checker-&gt;CheckClassFieldName(*is_static,\012                                       CHECK_OK_CUSTOM(NullLiteralProperty));\012 }\012 ExpressionT initializer = ParseClassFieldInitializer(\012            class_info, *is_static, CHECK_OK_CUSTOM(NullLiteralProperty));\012 ExpectSemicolon(CHECK_OK_CUSTOM(NullLiteralProperty));\012 ClassLiteralPropertyT result = factory()-&gt;NewClassLiteralProperty(\012            name_expression, initializer, *property_kind, *is_static,\012 *is_computed_name);\012        impl()-&gt;SetFunctionNameFromPropertyName(result, *name);\012 return result;\012\012 } else {\012 ReportUnexpectedToken(Next());\012 *ok = false;\012 return impl()-&gt;NullLiteralProperty();\012 }\012\012 case PropertyKind::kMethodProperty: {\012      DCHECK(!is_get &amp;&amp; !is_set);\012\012 // MethodDefinition\012 //    PropertyName '(' StrictFormalParameters ')' '{' FunctionBody '}'\012 //    '*' PropertyName '(' StrictFormalParameters ')' '{' FunctionBody '}'\012 //    async PropertyName '(' StrictFormalParameters ')'\012 //        '{' FunctionBody '}'\012 //    async '*' PropertyName '(' StrictFormalParameters ')'\012 //        '{' FunctionBody '}'\012\012 if (!*is_computed_name) {\012        checker-&gt;CheckClassMethodName(name_token, PropertyKind::kMethodProperty,\012                                      is_generator, is_async, *is_static,\012                                      CHECK_OK_CUSTOM(NullLiteralProperty));\012 }\012\012 FunctionKind kind = MethodKindFor(is_generator, is_async);\012\012 if (!*is_static &amp;&amp; impl()-&gt;IsConstructor(*name)) {\012        class_info-&gt;has_seen_constructor = true;\012        kind = has_extends ? FunctionKind::kDerivedConstructor\012 : FunctionKind::kBaseConstructor;\012 }\012\012 ExpressionT value = impl()-&gt;ParseFunctionLiteral(\012 *name, scanner()-&gt;location(), kSkipFunctionNameCheck, kind,\012          FLAG_harmony_function_tostring ? name_token_position\012 : kNoSourcePosition,\012 FunctionLiteral::kAccessorOrMethod, language_mode(), nullptr,\012          CHECK_OK_CUSTOM(NullLiteralProperty));\012\012 *property_kind = ClassLiteralProperty::METHOD;\012 ClassLiteralPropertyT result = factory()-&gt;NewClassLiteralProperty(\012          name_expression, value, *property_kind, *is_static,\012 *is_computed_name);\012      impl()-&gt;SetFunctionNameFromPropertyName(result, *name);\012 return result;\012 }\012\012 case PropertyKind::kAccessorProperty: {\012      DCHECK((is_get || is_set) &amp;&amp; !is_generator &amp;&amp; !is_async);\012\012 if (!*is_computed_name) {\012        checker-&gt;CheckClassMethodName(\012            name_token, PropertyKind::kAccessorProperty, false, false,\012 *is_static, CHECK_OK_CUSTOM(NullLiteralProperty));\012 // Make sure the name expression is a string since we need a Name for\012 // Runtime_DefineAccessorPropertyUnchecked and since we can determine\012 // this statically we can skip the extra runtime check.\012        name_expression =\012            factory()-&gt;NewStringLiteral(*name, name_expression-&gt;position());\012 }\012\012 FunctionKind kind = is_get ? FunctionKind::kGetterFunction\012 : FunctionKind::kSetterFunction;\012\012 FunctionLiteralT value = impl()-&gt;ParseFunctionLiteral(\012 *name, scanner()-&gt;location(), kSkipFunctionNameCheck, kind,\012          FLAG_harmony_function_tostring ? name_token_position\012 : kNoSourcePosition,\012 FunctionLiteral::kAccessorOrMethod, language_mode(), nullptr,\012          CHECK_OK_CUSTOM(NullLiteralProperty));\012\012 *property_kind =\012          is_get ? ClassLiteralProperty::GETTER : ClassLiteralProperty::SETTER;\012 ClassLiteralPropertyT result = factory()-&gt;NewClassLiteralProperty(\012          name_expression, value, *property_kind, *is_static,\012 *is_computed_name);\012 const AstRawString* prefix =\012          is_get ? ast_value_factory()-&gt;get_space_string()\012 : ast_value_factory()-&gt;set_space_string();\012      impl()-&gt;SetFunctionNameFromPropertyName(result, *name, prefix);\012 return result;\012 }\012 case PropertyKind::kSpreadProperty:\012 ReportUnexpectedTokenAt(\012 Scanner::Location(name_token_position, name_expression-&gt;position()),\012          name_token);\012 *ok = false;\012 return impl()-&gt;NullLiteralProperty();\012 }\012  UNREACHABLE();\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT\012ParserBase&lt;Impl&gt;::ParseClassFieldInitializer(ClassInfo* class_info,\012 bool is_static, bool* ok) {\012 DeclarationScope* initializer_scope = is_static\012 ? class_info-&gt;static_fields_scope\012 : class_info-&gt;instance_fields_scope;\012\012 if (initializer_scope == nullptr) {\012    initializer_scope =\012 NewFunctionScope(FunctionKind::kClassFieldsInitializerFunction);\012 // TODO(gsathya): Make scopes be non contiguous.\012    initializer_scope-&gt;set_start_position(scanner()-&gt;location().end_pos);\012    initializer_scope-&gt;SetLanguageMode(LanguageMode::kStrict);\012 }\012\012 ExpressionT initializer;\012 if (Check(Token::ASSIGN)) {\012 FunctionState initializer_state(&amp;function_state_, &amp;scope_,\012                                    initializer_scope);\012 ExpressionClassifier expression_classifier(this);\012\012    initializer =\012 ParseAssignmentExpression(true, CHECK_OK_CUSTOM(NullExpression));\012 ValidateExpression(CHECK_OK_CUSTOM(NullExpression));\012 } else {\012    initializer = factory()-&gt;NewUndefinedLiteral(kNoSourcePosition);\012 }\012\012  initializer_scope-&gt;set_end_position(scanner()-&gt;location().end_pos);\012 if (is_static) {\012    class_info-&gt;static_fields_scope = initializer_scope;\012    class_info-&gt;has_static_class_fields = true;\012 } else {\012    class_info-&gt;instance_fields_scope = initializer_scope;\012    class_info-&gt;has_instance_class_fields = true;\012 }\012\012 return initializer;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ObjectLiteralPropertyT\012ParserBase&lt;Impl&gt;::ParseObjectPropertyDefinition(ObjectLiteralChecker* checker,\012 bool* is_computed_name,\012 bool* is_rest_property,\012 bool* ok) {\012 bool is_get = false;\012 bool is_set = false;\012 bool is_generator = false;\012 bool is_async = false;\012 PropertyKind kind = PropertyKind::kNotSet;\012\012 IdentifierT name = impl()-&gt;NullIdentifier();\012 Token::Value name_token = peek();\012 int next_beg_pos = scanner()-&gt;peek_location().beg_pos;\012 int next_end_pos = scanner()-&gt;peek_location().end_pos;\012\012 ExpressionT name_expression = ParsePropertyName(\012 &amp;name, &amp;kind, &amp;is_generator, &amp;is_get, &amp;is_set, &amp;is_async,\012      is_computed_name, CHECK_OK_CUSTOM(NullLiteralProperty));\012\012 switch (kind) {\012 case PropertyKind::kSpreadProperty:\012      DCHECK(!is_get &amp;&amp; !is_set &amp;&amp; !is_generator &amp;&amp; !is_async &amp;&amp;\012 !*is_computed_name);\012      DCHECK(name_token == Token::ELLIPSIS);\012\012 *is_computed_name = true;\012 *is_rest_property = true;\012\012 return factory()-&gt;NewObjectLiteralProperty(\012          factory()-&gt;NewTheHoleLiteral(), name_expression,\012 ObjectLiteralProperty::SPREAD, true);\012\012 case PropertyKind::kValueProperty: {\012      DCHECK(!is_get &amp;&amp; !is_set &amp;&amp; !is_generator &amp;&amp; !is_async);\012\012 if (!*is_computed_name) {\012        checker-&gt;CheckDuplicateProto(name_token);\012 }\012 Consume(Token::COLON);\012 int beg_pos = peek_position();\012 ExpressionT value =\012 ParseAssignmentExpression(true, CHECK_OK_CUSTOM(NullLiteralProperty));\012 CheckDestructuringElement(value, beg_pos, scanner()-&gt;location().end_pos);\012\012 ObjectLiteralPropertyT result = factory()-&gt;NewObjectLiteralProperty(\012          name_expression, value, *is_computed_name);\012      impl()-&gt;SetFunctionNameFromPropertyName(result, name);\012 return result;\012 }\012\012 case PropertyKind::kShorthandProperty: {\012 // PropertyDefinition\012 //    IdentifierReference\012 //    CoverInitializedName\012 //\012 // CoverInitializedName\012 //    IdentifierReference Initializer?\012      DCHECK(!is_get &amp;&amp; !is_set &amp;&amp; !is_generator &amp;&amp; !is_async);\012\012 if (!Token::IsIdentifier(name_token, language_mode(),\012 this-&gt;is_generator(),\012                               parsing_module_ || is_async_function())) {\012 ReportUnexpectedToken(Next());\012 *ok = false;\012 return impl()-&gt;NullLiteralProperty();\012 }\012\012      DCHECK(!*is_computed_name);\012\012 if (classifier()-&gt;duplicate_finder() != nullptr &amp;&amp;\012          scanner()-&gt;IsDuplicateSymbol(classifier()-&gt;duplicate_finder(),\012                                       ast_value_factory())) {\012        classifier()-&gt;RecordDuplicateFormalParameterError(\012            scanner()-&gt;location());\012 }\012\012 if (impl()-&gt;IsEvalOrArguments(name) &amp;&amp; is_strict(language_mode())) {\012        classifier()-&gt;RecordBindingPatternError(\012            scanner()-&gt;location(), MessageTemplate::kStrictEvalArguments);\012 }\012\012 if (name_token == Token::LET) {\012        classifier()-&gt;RecordLetPatternError(\012            scanner()-&gt;location(), MessageTemplate::kLetInLexicalBinding);\012 }\012 if (name_token == Token::AWAIT) {\012        DCHECK(!is_async_function());\012        classifier()-&gt;RecordAsyncArrowFormalParametersError(\012 Scanner::Location(next_beg_pos, next_end_pos),\012 MessageTemplate::kAwaitBindingIdentifier);\012 }\012 ExpressionT lhs = impl()-&gt;ExpressionFromIdentifier(name, next_beg_pos);\012 CheckDestructuringElement(lhs, next_beg_pos, next_end_pos);\012\012 ExpressionT value;\012 if (peek() == Token::ASSIGN) {\012 Consume(Token::ASSIGN);\012 ExpressionClassifier rhs_classifier(this);\012 ExpressionT rhs = ParseAssignmentExpression(\012 true, CHECK_OK_CUSTOM(NullLiteralProperty));\012 ValidateExpression(CHECK_OK_CUSTOM(NullLiteralProperty));\012 AccumulateFormalParameterContainmentErrors();\012        value = factory()-&gt;NewAssignment(Token::ASSIGN, lhs, rhs,\012                                         kNoSourcePosition);\012        classifier()-&gt;RecordExpressionError(\012 Scanner::Location(next_beg_pos, scanner()-&gt;location().end_pos),\012 MessageTemplate::kInvalidCoverInitializedName);\012\012        impl()-&gt;SetFunctionNameFromIdentifierRef(rhs, lhs);\012 } else {\012        value = lhs;\012 }\012\012 ObjectLiteralPropertyT result = factory()-&gt;NewObjectLiteralProperty(\012          name_expression, value, ObjectLiteralProperty::COMPUTED, false);\012      impl()-&gt;SetFunctionNameFromPropertyName(result, name);\012 return result;\012 }\012\012 case PropertyKind::kMethodProperty: {\012      DCHECK(!is_get &amp;&amp; !is_set);\012\012 // MethodDefinition\012 //    PropertyName '(' StrictFormalParameters ')' '{' FunctionBody '}'\012 //    '*' PropertyName '(' StrictFormalParameters ')' '{' FunctionBody '}'\012\012      classifier()-&gt;RecordPatternError(\012 Scanner::Location(next_beg_pos, scanner()-&gt;location().end_pos),\012 MessageTemplate::kInvalidDestructuringTarget);\012\012 FunctionKind kind = MethodKindFor(is_generator, is_async);\012\012 ExpressionT value = impl()-&gt;ParseFunctionLiteral(\012          name, scanner()-&gt;location(), kSkipFunctionNameCheck, kind,\012          FLAG_harmony_function_tostring ? next_beg_pos : kNoSourcePosition,\012 FunctionLiteral::kAccessorOrMethod, language_mode(), nullptr,\012          CHECK_OK_CUSTOM(NullLiteralProperty));\012\012 ObjectLiteralPropertyT result = factory()-&gt;NewObjectLiteralProperty(\012          name_expression, value, ObjectLiteralProperty::COMPUTED,\012 *is_computed_name);\012      impl()-&gt;SetFunctionNameFromPropertyName(result, name);\012 return result;\012 }\012\012 case PropertyKind::kAccessorProperty: {\012      DCHECK((is_get || is_set) &amp;&amp; !(is_set &amp;&amp; is_get) &amp;&amp; !is_generator &amp;&amp;\012 !is_async);\012\012      classifier()-&gt;RecordPatternError(\012 Scanner::Location(next_beg_pos, scanner()-&gt;location().end_pos),\012 MessageTemplate::kInvalidDestructuringTarget);\012\012 if (!*is_computed_name) {\012 // Make sure the name expression is a string since we need a Name for\012 // Runtime_DefineAccessorPropertyUnchecked and since we can determine\012 // this statically we can skip the extra runtime check.\012        name_expression =\012            factory()-&gt;NewStringLiteral(name, name_expression-&gt;position());\012 }\012\012 FunctionKind kind = is_get ? FunctionKind::kGetterFunction\012 : FunctionKind::kSetterFunction;\012\012 FunctionLiteralT value = impl()-&gt;ParseFunctionLiteral(\012          name, scanner()-&gt;location(), kSkipFunctionNameCheck, kind,\012          FLAG_harmony_function_tostring ? next_beg_pos : kNoSourcePosition,\012 FunctionLiteral::kAccessorOrMethod, language_mode(), nullptr,\012          CHECK_OK_CUSTOM(NullLiteralProperty));\012\012 ObjectLiteralPropertyT result = factory()-&gt;NewObjectLiteralProperty(\012          name_expression, value,\012          is_get ? ObjectLiteralProperty::GETTER\012 : ObjectLiteralProperty::SETTER,\012 *is_computed_name);\012 const AstRawString* prefix =\012          is_get ? ast_value_factory()-&gt;get_space_string()\012 : ast_value_factory()-&gt;set_space_string();\012      impl()-&gt;SetFunctionNameFromPropertyName(result, name, prefix);\012 return result;\012 }\012\012 case PropertyKind::kClassField:\012 case PropertyKind::kNotSet:\012 ReportUnexpectedToken(Next());\012 *ok = false;\012 return impl()-&gt;NullLiteralProperty();\012 }\012  UNREACHABLE();\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParseObjectLiteral(\012 bool* ok) {\012 // ObjectLiteral ::\012 // '{' (PropertyDefinition (',' PropertyDefinition)* ','? )? '}'\012\012 int pos = peek_position();\012 typename Types::ObjectPropertyList properties =\012      impl()-&gt;NewObjectPropertyList(4);\012 int number_of_boilerplate_properties = 0;\012\012 bool has_computed_names = false;\012 bool has_rest_property = false;\012 ObjectLiteralChecker checker(this);\012\012 Expect(Token::LBRACE, CHECK_OK);\012\012 while (peek() != Token::RBRACE) {\012 FuncNameInferrer::State fni_state(fni_);\012\012 bool is_computed_name = false;\012 bool is_rest_property = false;\012 ObjectLiteralPropertyT property = ParseObjectPropertyDefinition(\012 &amp;checker, &amp;is_computed_name, &amp;is_rest_property, CHECK_OK);\012\012 if (is_computed_name) {\012      has_computed_names = true;\012 }\012\012 if (is_rest_property) {\012      has_rest_property = true;\012 }\012\012 if (impl()-&gt;IsBoilerplateProperty(property) &amp;&amp; !has_computed_names) {\012 // Count CONSTANT or COMPUTED properties to maintain the enumeration\012 // order.\012      number_of_boilerplate_properties++;\012 }\012\012    properties-&gt;Add(property, zone());\012\012 if (peek() != Token::RBRACE) {\012 // Need {} because of the CHECK_OK macro.\012 Expect(Token::COMMA, CHECK_OK);\012 }\012\012 if (fni_ != nullptr) fni_-&gt;Infer();\012 }\012 Expect(Token::RBRACE, CHECK_OK);\012\012 // In pattern rewriter, we rewrite rest property to call out to a\012 // runtime function passing all the other properties as arguments to\012 // this runtime function. Here, we make sure that the number of\012 // properties is less than number of arguments allowed for a runtime\012 // call.\012 if (has_rest_property &amp;&amp; properties-&gt;length() &gt; Code::kMaxArguments) {\012 this-&gt;classifier()-&gt;RecordPatternError(Scanner::Location(pos, position()),\012 MessageTemplate::kTooManyArguments);\012 }\012\012 return impl()-&gt;InitializeObjectLiteral(factory()-&gt;NewObjectLiteral(\012      properties, number_of_boilerplate_properties, pos, has_rest_property));\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionListT ParserBase&lt;Impl&gt;::ParseArguments(\012 Scanner::Location* first_spread_arg_loc, bool maybe_arrow,\012 bool* is_simple_parameter_list, bool* ok) {\012 // Arguments ::\012 //   '(' (AssignmentExpression)*[','] ')'\012\012 Scanner::Location spread_arg = Scanner::Location::invalid();\012 ExpressionListT result = impl()-&gt;NewExpressionList(4);\012 Expect(Token::LPAREN, CHECK_OK_CUSTOM(NullExpressionList));\012 bool done = (peek() == Token::RPAREN);\012 while (!done) {\012 int start_pos = peek_position();\012 bool is_spread = Check(Token::ELLIPSIS);\012 int expr_pos = peek_position();\012\012 ExpressionT argument =\012 ParseAssignmentExpression(true, CHECK_OK_CUSTOM(NullExpressionList));\012 if (!impl()-&gt;IsIdentifier(argument) &amp;&amp;\012        is_simple_parameter_list != nullptr) {\012 *is_simple_parameter_list = false;\012 }\012 if (!maybe_arrow) {\012 ValidateExpression(CHECK_OK_CUSTOM(NullExpressionList));\012 }\012 if (is_spread) {\012 if (is_simple_parameter_list != nullptr) {\012 *is_simple_parameter_list = false;\012 }\012 if (!spread_arg.IsValid()) {\012        spread_arg.beg_pos = start_pos;\012        spread_arg.end_pos = peek_position();\012 }\012 if (argument-&gt;IsAssignment()) {\012        classifier()-&gt;RecordAsyncArrowFormalParametersError(\012            scanner()-&gt;location(), MessageTemplate::kRestDefaultInitializer);\012 }\012      argument = factory()-&gt;NewSpread(argument, start_pos, expr_pos);\012 }\012    result-&gt;Add(argument, zone_);\012\012 if (result-&gt;length() &gt; Code::kMaxArguments) {\012 ReportMessage(MessageTemplate::kTooManyArguments);\012 *ok = false;\012 return impl()-&gt;NullExpressionList();\012 }\012 done = (peek() != Token::COMMA);\012 if (!done) {\012 Next();\012 if (argument-&gt;IsSpread()) {\012        classifier()-&gt;RecordAsyncArrowFormalParametersError(\012            scanner()-&gt;location(), MessageTemplate::kParamAfterRest);\012 }\012 if (peek() == Token::RPAREN) {\012 // allow trailing comma\012 done = true;\012 }\012 }\012 }\012 Scanner::Location location = scanner_-&gt;location();\012 if (Token::RPAREN != Next()) {\012    impl()-&gt;ReportMessageAt(location, MessageTemplate::kUnterminatedArgList);\012 *ok = false;\012 return impl()-&gt;NullExpressionList();\012 }\012 *first_spread_arg_loc = spread_arg;\012\012 if (!maybe_arrow || peek() != Token::ARROW) {\012 if (maybe_arrow) {\012 ValidateExpression(CHECK_OK_CUSTOM(NullExpressionList));\012 }\012 }\012\012 return result;\012}\012\012// Precedence = 2\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT\012ParserBase&lt;Impl&gt;::ParseAssignmentExpression(bool accept_IN, bool* ok) {\012 // AssignmentExpression ::\012 //   ConditionalExpression\012 //   ArrowFunction\012 //   YieldExpression\012 //   LeftHandSideExpression AssignmentOperator AssignmentExpression\012 int lhs_beg_pos = peek_position();\012\012 if (peek() == Token::YIELD &amp;&amp; is_generator()) {\012 return ParseYieldExpression(accept_IN, ok);\012 }\012\012 FuncNameInferrer::State fni_state(fni_);\012 ExpressionClassifier arrow_formals_classifier(\012 this, classifier()-&gt;duplicate_finder());\012\012 Scope::Snapshot scope_snapshot(scope());\012 int rewritable_length = static_cast&lt;int&gt;(\012      function_state_-&gt;destructuring_assignments_to_rewrite().size());\012\012 bool is_async = peek() == Token::ASYNC &amp;&amp;\012 !scanner()-&gt;HasLineTerminatorAfterNext() &amp;&amp;\012 IsValidArrowFormalParametersStart(PeekAhead());\012\012 bool parenthesized_formals = peek() == Token::LPAREN;\012 if (!is_async &amp;&amp; !parenthesized_formals) {\012 ArrowFormalParametersUnexpectedToken();\012 }\012\012 // Parse a simple, faster sub-grammar (primary expression) if it's evident\012 // that we have only a trivial expression to parse.\012 ExpressionT expression;\012 if (IsTrivialExpression()) {\012    expression = ParsePrimaryExpression(&amp;is_async, CHECK_OK);\012 } else {\012    expression = ParseConditionalExpression(accept_IN, CHECK_OK);\012 }\012\012 if (is_async &amp;&amp; impl()-&gt;IsIdentifier(expression) &amp;&amp; peek_any_identifier() &amp;&amp;\012 PeekAhead() == Token::ARROW) {\012 // async Identifier =&gt; AsyncConciseBody\012 IdentifierT name = ParseAndClassifyIdentifier(CHECK_OK);\012    expression =\012        impl()-&gt;ExpressionFromIdentifier(name, position(), InferName::kNo);\012 if (fni_) {\012 // Remove `async` keyword from inferred name stack.\012      fni_-&gt;RemoveAsyncKeywordFromEnd();\012 }\012 }\012\012 if (peek() == Token::ARROW) {\012 Scanner::Location arrow_loc = scanner()-&gt;peek_location();\012 ValidateArrowFormalParameters(expression, parenthesized_formals, is_async,\012                                  CHECK_OK);\012 // This reads strangely, but is correct: it checks whether any\012 // sub-expression of the parameter list failed to be a valid formal\012 // parameter initializer. Since YieldExpressions are banned anywhere\012 // in an arrow parameter list, this is correct.\012 // TODO(adamk): Rename &quot;FormalParameterInitializerError&quot; to refer to\012 // &quot;YieldExpression&quot;, which is its only use.\012 ValidateFormalParameterInitializer(ok);\012\012 Scanner::Location loc(lhs_beg_pos, scanner()-&gt;location().end_pos);\012 DeclarationScope* scope =\012 NewFunctionScope(is_async ? FunctionKind::kAsyncArrowFunction\012 : FunctionKind::kArrowFunction);\012\012 // Because the arrow's parameters were parsed in the outer scope,\012 // we need to fix up the scope chain appropriately.\012    scope_snapshot.Reparent(scope);\012\012 FormalParametersT parameters(scope);\012 if (!classifier()-&gt;is_simple_parameter_list()) {\012      scope-&gt;SetHasNonSimpleParameters();\012      parameters.is_simple = false;\012 }\012\012    scope-&gt;set_start_position(lhs_beg_pos);\012 Scanner::Location duplicate_loc = Scanner::Location::invalid();\012    impl()-&gt;DeclareArrowFunctionFormalParameters(&amp;parameters, expression, loc,\012 &amp;duplicate_loc, CHECK_OK);\012 if (duplicate_loc.IsValid()) {\012      classifier()-&gt;RecordDuplicateFormalParameterError(duplicate_loc);\012 }\012    expression = ParseArrowFunctionLiteral(accept_IN, parameters,\012                                           rewritable_length, CHECK_OK);\012 Accumulate(ExpressionClassifier::AsyncArrowFormalParametersProduction);\012    classifier()-&gt;RecordPatternError(arrow_loc,\012 MessageTemplate::kUnexpectedToken,\012 Token::String(Token::ARROW));\012\012 if (fni_ != nullptr) fni_-&gt;Infer();\012\012 return expression;\012 }\012\012 // &quot;expression&quot; was not itself an arrow function parameter list, but it might\012 // form part of one.  Propagate speculative formal parameter error locations\012 // (including those for binding patterns, since formal parameters can\012 // themselves contain binding patterns).\012 unsigned productions = ExpressionClassifier::AllProductions &amp;\012 ~ExpressionClassifier::ArrowFormalParametersProduction;\012\012 // Parenthesized identifiers and property references are allowed as part\012 // of a larger assignment pattern, even though parenthesized patterns\012 // themselves are not allowed, e.g., &quot;[(x)] = []&quot;. Only accumulate\012 // assignment pattern errors if the parsed expression is more complex.\012 if (IsValidReferenceExpression(expression)) {\012    productions &amp;= ~ExpressionClassifier::AssignmentPatternProduction;\012 }\012\012 const bool is_destructuring_assignment =\012 IsValidPattern(expression) &amp;&amp; peek() == Token::ASSIGN;\012 if (is_destructuring_assignment) {\012 // This is definitely not an expression so don't accumulate\012 // expression-related errors.\012    productions &amp;= ~ExpressionClassifier::ExpressionProduction;\012 }\012\012 Accumulate(productions);\012 if (!Token::IsAssignmentOp(peek())) return expression;\012\012 if (is_destructuring_assignment) {\012 ValidateAssignmentPattern(CHECK_OK);\012 } else {\012    expression = CheckAndRewriteReferenceExpression(\012        expression, lhs_beg_pos, scanner()-&gt;location().end_pos,\012 MessageTemplate::kInvalidLhsInAssignment, CHECK_OK);\012 }\012\012  impl()-&gt;MarkExpressionAsAssigned(expression);\012\012 Token::Value op = Next(); // Get assignment operator.\012 if (op != Token::ASSIGN) {\012    classifier()-&gt;RecordPatternError(scanner()-&gt;location(),\012 MessageTemplate::kUnexpectedToken,\012 Token::String(op));\012 }\012 int pos = position();\012\012 ExpressionClassifier rhs_classifier(this);\012\012 ExpressionT right = ParseAssignmentExpression(accept_IN, CHECK_OK);\012 ValidateExpression(CHECK_OK);\012 AccumulateFormalParameterContainmentErrors();\012\012 // We try to estimate the set of properties set by constructors. We define a\012 // new property whenever there is an assignment to a property of 'this'. We\012 // should probably only add properties if we haven't seen them\012 // before. Otherwise we'll probably overestimate the number of properties.\012 if (op == Token::ASSIGN &amp;&amp; impl()-&gt;IsThisProperty(expression)) {\012    function_state_-&gt;AddProperty();\012 }\012\012  impl()-&gt;CheckAssigningFunctionLiteralToProperty(expression, right);\012\012 if (fni_ != nullptr) {\012 // Check if the right hand side is a call to avoid inferring a\012 // name if we're dealing with &quot;a = function(){...}();&quot;-like\012 // expression.\012 if (op == Token::ASSIGN &amp;&amp; !right-&gt;IsCall() &amp;&amp; !right-&gt;IsCallNew()) {\012      fni_-&gt;Infer();\012 } else {\012      fni_-&gt;RemoveLastFunction();\012 }\012 }\012\012 if (op == Token::ASSIGN) {\012    impl()-&gt;SetFunctionNameFromIdentifierRef(right, expression);\012 }\012\012  DCHECK_NE(op, Token::INIT);\012 ExpressionT result = factory()-&gt;NewAssignment(op, expression, right, pos);\012\012 if (is_destructuring_assignment) {\012    DCHECK_NE(op, Token::ASSIGN_EXP);\012 auto rewritable = factory()-&gt;NewRewritableExpression(result, scope());\012    impl()-&gt;QueueDestructuringAssignmentForRewriting(rewritable);\012    result = rewritable;\012 }\012\012 return result;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParseYieldExpression(\012 bool accept_IN, bool* ok) {\012 // YieldExpression ::\012 //   'yield' ([no line terminator] '*'? AssignmentExpression)?\012 int pos = peek_position();\012  classifier()-&gt;RecordPatternError(\012      scanner()-&gt;peek_location(), MessageTemplate::kInvalidDestructuringTarget);\012  classifier()-&gt;RecordFormalParameterInitializerError(\012      scanner()-&gt;peek_location(), MessageTemplate::kYieldInParameter);\012 Expect(Token::YIELD, CHECK_OK);\012 // The following initialization is necessary.\012 ExpressionT expression = impl()-&gt;NullExpression();\012 bool delegating = false; // yield*\012 if (!scanner()-&gt;HasLineTerminatorBeforeNext()) {\012 if (Check(Token::MUL)) delegating = true;\012 switch (peek()) {\012 case Token::EOS:\012 case Token::SEMICOLON:\012 case Token::RBRACE:\012 case Token::RBRACK:\012 case Token::RPAREN:\012 case Token::COLON:\012 case Token::COMMA:\012 case Token::IN:\012 // The above set of tokens is the complete set of tokens that can appear\012 // after an AssignmentExpression, and none of them can start an\012 // AssignmentExpression.  This allows us to avoid looking for an RHS for\012 // a regular yield, given only one look-ahead token.\012 if (!delegating) break;\012 // Delegating yields require an RHS; fall through.\012        V8_FALLTHROUGH;\012 default:\012        expression = ParseAssignmentExpression(accept_IN, CHECK_OK);\012 ValidateExpression(CHECK_OK);\012 break;\012 }\012 }\012\012 if (delegating) {\012 ExpressionT yieldstar = factory()-&gt;NewYieldStar(expression, pos);\012    impl()-&gt;RecordSuspendSourceRange(yieldstar, PositionAfterSemicolon());\012    function_state_-&gt;AddSuspend();\012 if (IsAsyncGeneratorFunction(function_state_-&gt;kind())) {\012 // iterator_close and delegated_iterator_output suspend ids.\012      function_state_-&gt;AddSuspend();\012      function_state_-&gt;AddSuspend();\012 }\012 return yieldstar;\012 }\012\012 // Hackily disambiguate o from o.next and o [Symbol.iterator]().\012 // TODO(verwaest): Come up with a better solution.\012 ExpressionT yield =\012      factory()-&gt;NewYield(expression, pos, Suspend::kOnExceptionThrow);\012  impl()-&gt;RecordSuspendSourceRange(yield, PositionAfterSemicolon());\012  function_state_-&gt;AddSuspend();\012 return yield;\012}\012\012// Precedence = 3\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT\012ParserBase&lt;Impl&gt;::ParseConditionalExpression(bool accept_IN,\012 bool* ok) {\012 // ConditionalExpression ::\012 //   LogicalOrExpression\012 //   LogicalOrExpression '?' AssignmentExpression ':' AssignmentExpression\012\012 SourceRange then_range, else_range;\012 int pos = peek_position();\012 // We start using the binary expression parser for prec &gt;= 4 only!\012 ExpressionT expression = ParseBinaryExpression(4, accept_IN, CHECK_OK);\012 if (peek() != Token::CONDITIONAL) return expression;\012 ValidateExpression(CHECK_OK);\012 BindingPatternUnexpectedToken();\012 ArrowFormalParametersUnexpectedToken();\012\012 ExpressionT left;\012 {\012 SourceRangeScope range_scope(scanner(), &amp;then_range);\012 Consume(Token::CONDITIONAL);\012 ExpressionClassifier classifier(this);\012 // In parsing the first assignment expression in conditional\012 // expressions we always accept the 'in' keyword; see ECMA-262,\012 // section 11.12, page 58.\012    left = ParseAssignmentExpression(true, CHECK_OK);\012 AccumulateNonBindingPatternErrors();\012 }\012 ValidateExpression(CHECK_OK);\012 ExpressionT right;\012 {\012 SourceRangeScope range_scope(scanner(), &amp;else_range);\012 Expect(Token::COLON, CHECK_OK);\012 ExpressionClassifier classifier(this);\012    right = ParseAssignmentExpression(accept_IN, CHECK_OK);\012 AccumulateNonBindingPatternErrors();\012 }\012 ValidateExpression(CHECK_OK);\012 ExpressionT expr = factory()-&gt;NewConditional(expression, left, right, pos);\012  impl()-&gt;RecordConditionalSourceRange(expr, then_range, else_range);\012 return expr;\012}\012\012\012// Precedence &gt;= 4\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParseBinaryExpression(\012 int prec, bool accept_IN, bool* ok) {\012  DCHECK_GE(prec, 4);\012 SourceRange right_range;\012 ExpressionT x = ParseUnaryExpression(CHECK_OK);\012 for (int prec1 = Precedence(peek(), accept_IN); prec1 &gt;= prec; prec1--) {\012 // prec1 &gt;= 4\012 while (Precedence(peek(), accept_IN) == prec1) {\012 ValidateExpression(CHECK_OK);\012 BindingPatternUnexpectedToken();\012 ArrowFormalParametersUnexpectedToken();\012\012 SourceRangeScope right_range_scope(scanner(), &amp;right_range);\012 Token::Value op = Next();\012 int pos = position();\012\012 const bool is_right_associative = op == Token::EXP;\012 const int next_prec = is_right_associative ? prec1 : prec1 + 1;\012 ExpressionT y = ParseBinaryExpression(next_prec, accept_IN, CHECK_OK);\012      right_range_scope.Finalize();\012 ValidateExpression(CHECK_OK);\012\012 if (impl()-&gt;ShortcutNumericLiteralBinaryExpression(&amp;x, y, op, pos)) {\012 continue;\012 }\012\012 // For now we distinguish between comparisons and other binary\012 // operations.  (We could combine the two and get rid of this\012 // code and AST node eventually.)\012 if (Token::IsCompareOp(op)) {\012 // We have a comparison.\012 Token::Value cmp = op;\012 switch (op) {\012 case Token::NE: cmp = Token::EQ; break;\012 case Token::NE_STRICT: cmp = Token::EQ_STRICT; break;\012 default: break;\012 }\012        x = factory()-&gt;NewCompareOperation(cmp, x, y, pos);\012 if (cmp != op) {\012 // The comparison was negated - add a NOT.\012          x = factory()-&gt;NewUnaryOperation(Token::NOT, x, pos);\012 }\012 } else if (impl()-&gt;CollapseNaryExpression(&amp;x, y, op, pos, right_range)) {\012 continue;\012 } else {\012 // We have a &quot;normal&quot; binary operation.\012        x = factory()-&gt;NewBinaryOperation(op, x, y, pos);\012 if (op == Token::OR || op == Token::AND) {\012          impl()-&gt;RecordBinaryOperationSourceRange(x, right_range);\012 }\012 }\012 }\012 }\012 return x;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParseUnaryExpression(\012 bool* ok) {\012 // UnaryExpression ::\012 //   PostfixExpression\012 //   'delete' UnaryExpression\012 //   'void' UnaryExpression\012 //   'typeof' UnaryExpression\012 //   '++' UnaryExpression\012 //   '--' UnaryExpression\012 //   '+' UnaryExpression\012 //   '-' UnaryExpression\012 //   '~' UnaryExpression\012 //   '!' UnaryExpression\012 //   [+Await] AwaitExpression[?Yield]\012\012 Token::Value op = peek();\012 if (Token::IsUnaryOp(op)) {\012 BindingPatternUnexpectedToken();\012 ArrowFormalParametersUnexpectedToken();\012\012    op = Next();\012 int pos = position();\012\012 // Assume &quot;! function ...&quot; indicates the function is likely to be called.\012 if (op == Token::NOT &amp;&amp; peek() == Token::FUNCTION) {\012      function_state_-&gt;set_next_function_is_likely_called();\012 }\012\012 ExpressionT expression = ParseUnaryExpression(CHECK_OK);\012 ValidateExpression(CHECK_OK);\012\012 if (op == Token::DELETE) {\012 if (impl()-&gt;IsIdentifier(expression) &amp;&amp; is_strict(language_mode())) {\012 // &quot;delete identifier&quot; is a syntax error in strict mode.\012 ReportMessage(MessageTemplate::kStrictDelete);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012\012 if (impl()-&gt;IsPropertyWithPrivateFieldKey(expression)) {\012 ReportMessage(MessageTemplate::kDeletePrivateField);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012 }\012\012 if (peek() == Token::EXP) {\012 ReportUnexpectedToken(Next());\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012\012 // Allow the parser's implementation to rewrite the expression.\012 return impl()-&gt;BuildUnaryExpression(expression, op, pos);\012 } else if (Token::IsCountOp(op)) {\012 BindingPatternUnexpectedToken();\012 ArrowFormalParametersUnexpectedToken();\012    op = Next();\012 int beg_pos = peek_position();\012 ExpressionT expression = ParseUnaryExpression(CHECK_OK);\012    expression = CheckAndRewriteReferenceExpression(\012        expression, beg_pos, scanner()-&gt;location().end_pos,\012 MessageTemplate::kInvalidLhsInPrefixOp, CHECK_OK);\012    impl()-&gt;MarkExpressionAsAssigned(expression);\012 ValidateExpression(CHECK_OK);\012\012 return factory()-&gt;NewCountOperation(op,\012 true /* prefix */,\012                                        expression,\012                                        position());\012\012 } else if (is_async_function() &amp;&amp; peek() == Token::AWAIT) {\012    classifier()-&gt;RecordFormalParameterInitializerError(\012        scanner()-&gt;peek_location(),\012 MessageTemplate::kAwaitExpressionFormalParameter);\012 int await_pos = peek_position();\012 Consume(Token::AWAIT);\012\012 ExpressionT value = ParseUnaryExpression(CHECK_OK);\012\012    classifier()-&gt;RecordBindingPatternError(\012 Scanner::Location(await_pos, scanner()-&gt;location().end_pos),\012 MessageTemplate::kInvalidDestructuringTarget);\012\012 ExpressionT expr = factory()-&gt;NewAwait(value, await_pos);\012    function_state_-&gt;AddSuspend();\012    impl()-&gt;RecordSuspendSourceRange(expr, PositionAfterSemicolon());\012 return expr;\012 } else {\012 return ParsePostfixExpression(ok);\012 }\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParsePostfixExpression(\012 bool* ok) {\012 // PostfixExpression ::\012 //   LeftHandSideExpression ('++' | '--')?\012\012 int lhs_beg_pos = peek_position();\012 ExpressionT expression = ParseLeftHandSideExpression(CHECK_OK);\012 if (!scanner()-&gt;HasLineTerminatorBeforeNext() &amp;&amp; Token::IsCountOp(peek())) {\012 BindingPatternUnexpectedToken();\012 ArrowFormalParametersUnexpectedToken();\012\012    expression = CheckAndRewriteReferenceExpression(\012        expression, lhs_beg_pos, scanner()-&gt;location().end_pos,\012 MessageTemplate::kInvalidLhsInPostfixOp, CHECK_OK);\012    impl()-&gt;MarkExpressionAsAssigned(expression);\012 ValidateExpression(CHECK_OK);\012\012 Token::Value next = Next();\012    expression =\012        factory()-&gt;NewCountOperation(next,\012 false /* postfix */,\012                                     expression,\012                                     position());\012 }\012 return expression;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT\012ParserBase&lt;Impl&gt;::ParseLeftHandSideExpression(bool* ok) {\012 // LeftHandSideExpression ::\012 //   (NewExpression | MemberExpression) ...\012\012 bool is_async = false;\012 ExpressionT result =\012 ParseMemberWithNewPrefixesExpression(&amp;is_async, CHECK_OK);\012\012 while (true) {\012 switch (peek()) {\012 case Token::LBRACK: {\012 ValidateExpression(CHECK_OK);\012 BindingPatternUnexpectedToken();\012 ArrowFormalParametersUnexpectedToken();\012 Consume(Token::LBRACK);\012 int pos = position();\012 ExpressionT index = ParseExpressionCoverGrammar(true, CHECK_OK);\012 ValidateExpression(CHECK_OK);\012        result = factory()-&gt;NewProperty(result, index, pos);\012 Expect(Token::RBRACK, CHECK_OK);\012 break;\012 }\012\012 case Token::LPAREN: {\012 int pos;\012 ValidateExpression(CHECK_OK);\012 BindingPatternUnexpectedToken();\012 if (scanner()-&gt;current_token() == Token::IDENTIFIER ||\012            scanner()-&gt;current_token() == Token::SUPER ||\012            scanner()-&gt;current_token() == Token::ASYNC) {\012 // For call of an identifier we want to report position of\012 // the identifier as position of the call in the stack trace.\012          pos = position();\012 } else {\012 // For other kinds of calls we record position of the parenthesis as\012 // position of the call. Note that this is extremely important for\012 // expressions of the form function(){...}() for which call position\012 // should not point to the closing brace otherwise it will intersect\012 // with positions recorded for function literal and confuse debugger.\012          pos = peek_position();\012 // Also the trailing parenthesis are a hint that the function will\012 // be called immediately. If we happen to have parsed a preceding\012 // function literal eagerly, we can also compile it eagerly.\012 if (result-&gt;IsFunctionLiteral()) {\012            result-&gt;AsFunctionLiteral()-&gt;SetShouldEagerCompile();\012            result-&gt;AsFunctionLiteral()-&gt;mark_as_iife();\012 }\012 }\012 Scanner::Location spread_pos;\012 ExpressionListT args;\012 if (V8_UNLIKELY(is_async &amp;&amp; impl()-&gt;IsIdentifier(result))) {\012 ExpressionClassifier async_classifier(this);\012 bool is_simple_parameter_list = true;\012          args = ParseArguments(&amp;spread_pos, true, &amp;is_simple_parameter_list,\012                                CHECK_OK);\012 if (peek() == Token::ARROW) {\012 if (fni_) {\012              fni_-&gt;RemoveAsyncKeywordFromEnd();\012 }\012 ValidateBindingPattern(CHECK_OK);\012 ValidateFormalParameterInitializer(CHECK_OK);\012 if (!classifier()-&gt;is_valid_async_arrow_formal_parameters()) {\012 ReportClassifierError(\012                  classifier()-&gt;async_arrow_formal_parameters_error());\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012 if (args-&gt;length()) {\012 // async ( Arguments ) =&gt; ...\012 if (!is_simple_parameter_list) {\012                async_classifier.previous()-&gt;RecordNonSimpleParameter();\012 }\012 return impl()-&gt;ExpressionListToExpression(args);\012 }\012 // async () =&gt; ...\012 return factory()-&gt;NewEmptyParentheses(pos);\012 } else {\012 AccumulateFormalParameterContainmentErrors();\012 }\012 } else {\012          args = ParseArguments(&amp;spread_pos, CHECK_OK);\012 }\012\012 ArrowFormalParametersUnexpectedToken();\012\012 // Keep track of eval() calls since they disable all local variable\012 // optimizations.\012 // The calls that need special treatment are the\012 // direct eval calls. These calls are all of the form eval(...), with\012 // no explicit receiver.\012 // These calls are marked as potentially direct eval calls. Whether\012 // they are actually direct calls to eval is determined at run time.\012 Call::PossiblyEval is_possibly_eval =\012 CheckPossibleEvalCall(result, scope());\012\012 if (spread_pos.IsValid()) {\012          result = impl()-&gt;SpreadCall(result, args, pos, is_possibly_eval);\012 } else {\012          result = factory()-&gt;NewCall(result, args, pos, is_possibly_eval);\012 }\012\012 if (fni_ != nullptr) fni_-&gt;RemoveLastFunction();\012 break;\012 }\012\012 case Token::PERIOD: {\012 ValidateExpression(CHECK_OK);\012 BindingPatternUnexpectedToken();\012 ArrowFormalParametersUnexpectedToken();\012 Consume(Token::PERIOD);\012 int pos = position();\012 ExpressionT key = ParseIdentifierNameOrPrivateName(CHECK_OK);\012        result = factory()-&gt;NewProperty(result, key, pos);\012 break;\012 }\012\012 case Token::TEMPLATE_SPAN:\012 case Token::TEMPLATE_TAIL: {\012 ValidateExpression(CHECK_OK);\012 BindingPatternUnexpectedToken();\012 ArrowFormalParametersUnexpectedToken();\012        result = ParseTemplateLiteral(result, position(), true, CHECK_OK);\012 break;\012 }\012\012 default:\012 return result;\012 }\012 }\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT\012ParserBase&lt;Impl&gt;::ParseMemberWithNewPrefixesExpression(bool* is_async,\012 bool* ok) {\012 // NewExpression ::\012 //   ('new')+ MemberExpression\012 //\012 // NewTarget ::\012 //   'new' '.' 'target'\012\012 // The grammar for new expressions is pretty warped. We can have several 'new'\012 // keywords following each other, and then a MemberExpression. When we see '('\012 // after the MemberExpression, it's associated with the rightmost unassociated\012 // 'new' to create a NewExpression with arguments. However, a NewExpression\012 // can also occur without arguments.\012\012 // Examples of new expression:\012 // new foo.bar().baz means (new (foo.bar)()).baz\012 // new foo()() means (new foo())()\012 // new new foo()() means (new (new foo())())\012 // new new foo means new (new foo)\012 // new new foo() means new (new foo())\012 // new new foo().bar().baz means (new (new foo()).bar()).baz\012\012 if (peek() == Token::NEW) {\012 BindingPatternUnexpectedToken();\012 ArrowFormalParametersUnexpectedToken();\012 Consume(Token::NEW);\012 int new_pos = position();\012 ExpressionT result;\012 if (peek() == Token::SUPER) {\012 const bool is_new = true;\012      result = ParseSuperExpression(is_new, CHECK_OK);\012 } else if (allow_harmony_dynamic_import() &amp;&amp; peek() == Token::IMPORT &amp;&amp;\012 (!allow_harmony_import_meta() || PeekAhead() == Token::LPAREN)) {\012      impl()-&gt;ReportMessageAt(scanner()-&gt;peek_location(),\012 MessageTemplate::kImportCallNotNewExpression);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 } else if (peek() == Token::PERIOD) {\012 *is_async = false;\012      result = ParseNewTargetExpression(CHECK_OK);\012 return ParseMemberExpressionContinuation(result, is_async, CHECK_OK);\012 } else {\012      result = ParseMemberWithNewPrefixesExpression(is_async, CHECK_OK);\012 }\012 ValidateExpression(CHECK_OK);\012 if (peek() == Token::LPAREN) {\012 // NewExpression with arguments.\012 Scanner::Location spread_pos;\012 ExpressionListT args = ParseArguments(&amp;spread_pos, CHECK_OK);\012\012 if (spread_pos.IsValid()) {\012        result = impl()-&gt;SpreadCallNew(result, args, new_pos);\012 } else {\012        result = factory()-&gt;NewCallNew(result, args, new_pos);\012 }\012 // The expression can still continue with . or [ after the arguments.\012      result = ParseMemberExpressionContinuation(result, is_async, CHECK_OK);\012 return result;\012 }\012 // NewExpression without arguments.\012 return factory()-&gt;NewCallNew(result, impl()-&gt;NewExpressionList(0), new_pos);\012 }\012 // No 'new' or 'super' keyword.\012 return ParseMemberExpression(is_async, ok);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParseMemberExpression(\012 bool* is_async, bool* ok) {\012 // MemberExpression ::\012 //   (PrimaryExpression | FunctionLiteral | ClassLiteral)\012 //     ('[' Expression ']' | '.' Identifier | Arguments | TemplateLiteral)*\012 //\012 // CallExpression ::\012 //   (SuperCall | ImportCall)\012 //     ('[' Expression ']' | '.' Identifier | Arguments | TemplateLiteral)*\012 //\012 // The '[' Expression ']' and '.' Identifier parts are parsed by\012 // ParseMemberExpressionContinuation, and the Arguments part is parsed by the\012 // caller.\012\012 // Parse the initial primary or function expression.\012 ExpressionT result;\012 if (peek() == Token::FUNCTION) {\012 BindingPatternUnexpectedToken();\012 ArrowFormalParametersUnexpectedToken();\012\012 Consume(Token::FUNCTION);\012 int function_token_position = position();\012\012 FunctionKind function_kind = Check(Token::MUL)\012 ? FunctionKind::kGeneratorFunction\012 : FunctionKind::kNormalFunction;\012 IdentifierT name = impl()-&gt;NullIdentifier();\012 bool is_strict_reserved_name = false;\012 Scanner::Location function_name_location = Scanner::Location::invalid();\012 FunctionLiteral::FunctionType function_type =\012 FunctionLiteral::kAnonymousExpression;\012 if (impl()-&gt;ParsingDynamicFunctionDeclaration()) {\012 // We don't want dynamic functions to actually declare their name\012 // &quot;anonymous&quot;. We just want that name in the toString().\012 if (stack_overflow()) {\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012 Consume(Token::IDENTIFIER);\012      DCHECK(scanner()-&gt;CurrentMatchesContextual(Token::ANONYMOUS));\012 } else if (peek_any_identifier()) {\012 bool is_await = false;\012      name = ParseIdentifierOrStrictReservedWord(\012          function_kind, &amp;is_strict_reserved_name, &amp;is_await, CHECK_OK);\012      function_name_location = scanner()-&gt;location();\012      function_type = FunctionLiteral::kNamedExpression;\012 }\012    result = impl()-&gt;ParseFunctionLiteral(\012        name, function_name_location,\012        is_strict_reserved_name ? kFunctionNameIsStrictReserved\012 : kFunctionNameValidityUnknown,\012        function_kind, function_token_position, function_type, language_mode(),\012 nullptr, CHECK_OK);\012 } else if (peek() == Token::SUPER) {\012 const bool is_new = false;\012    result = ParseSuperExpression(is_new, CHECK_OK);\012 } else if (allow_harmony_dynamic_import() &amp;&amp; peek() == Token::IMPORT) {\012    result = ParseImportExpressions(CHECK_OK);\012 } else {\012    result = ParsePrimaryExpression(is_async, CHECK_OK);\012 }\012\012  result = ParseMemberExpressionContinuation(result, is_async, CHECK_OK);\012 return result;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParseImportExpressions(\012 bool* ok) {\012  DCHECK(allow_harmony_dynamic_import());\012\012  classifier()-&gt;RecordPatternError(scanner()-&gt;peek_location(),\012 MessageTemplate::kUnexpectedToken,\012 Token::String(Token::IMPORT));\012\012 Consume(Token::IMPORT);\012 int pos = position();\012 if (allow_harmony_import_meta() &amp;&amp; peek() == Token::PERIOD) {\012 ExpectMetaProperty(Token::META, &quot;import.meta&quot;, pos, CHECK_OK);\012 if (!parsing_module_) {\012      impl()-&gt;ReportMessageAt(scanner()-&gt;location(),\012 MessageTemplate::kImportMetaOutsideModule);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012\012 return impl()-&gt;ImportMetaExpression(pos);\012 }\012 Expect(Token::LPAREN, CHECK_OK);\012 if (peek() == Token::RPAREN) {\012    impl()-&gt;ReportMessageAt(scanner()-&gt;location(),\012 MessageTemplate::kImportMissingSpecifier);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012 ExpressionT arg = ParseAssignmentExpression(true, CHECK_OK);\012 Expect(Token::RPAREN, CHECK_OK);\012 return factory()-&gt;NewImportCallExpression(arg, pos);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParseSuperExpression(\012 bool is_new, bool* ok) {\012 Expect(Token::SUPER, CHECK_OK);\012 int pos = position();\012\012 DeclarationScope* scope = GetReceiverScope();\012 FunctionKind kind = scope-&gt;function_kind();\012 if (IsConciseMethod(kind) || IsAccessorFunction(kind) ||\012 IsClassConstructor(kind)) {\012 if (peek() == Token::PERIOD || peek() == Token::LBRACK) {\012      scope-&gt;RecordSuperPropertyUsage();\012 return impl()-&gt;NewSuperPropertyReference(pos);\012 }\012 // new super() is never allowed.\012 // super() is only allowed in derived constructor\012 if (!is_new &amp;&amp; peek() == Token::LPAREN &amp;&amp; IsDerivedConstructor(kind)) {\012 // TODO(rossberg): This might not be the correct FunctionState for the\012 // method here.\012 return impl()-&gt;NewSuperCallReference(pos);\012 }\012 }\012\012  impl()-&gt;ReportMessageAt(scanner()-&gt;location(),\012 MessageTemplate::kUnexpectedSuper);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::ExpectMetaProperty(Token::Value property_name,\012 const char* full_name, int pos,\012 bool* ok) {\012 Consume(Token::PERIOD);\012 ExpectContextualKeyword(property_name, CHECK_OK_CUSTOM(Void));\012 if (scanner()-&gt;literal_contains_escapes()) {\012    impl()-&gt;ReportMessageAt(\012 Scanner::Location(pos, scanner()-&gt;location().end_pos),\012 MessageTemplate::kInvalidEscapedMetaProperty, full_name);\012 *ok = false;\012 }\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT\012ParserBase&lt;Impl&gt;::ParseNewTargetExpression(bool* ok) {\012 int pos = position();\012 ExpectMetaProperty(Token::TARGET, &quot;new.target&quot;, pos, CHECK_OK);\012\012  classifier()-&gt;RecordAssignmentPatternError(\012 Scanner::Location(pos, scanner()-&gt;location().end_pos),\012 MessageTemplate::kInvalidDestructuringTarget);\012\012 if (!GetReceiverScope()-&gt;is_function_scope()) {\012    impl()-&gt;ReportMessageAt(scanner()-&gt;location(),\012 MessageTemplate::kUnexpectedNewTarget);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012\012 return impl()-&gt;NewTargetExpression(pos);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT\012ParserBase&lt;Impl&gt;::ParseMemberExpressionContinuation(ExpressionT expression,\012 bool* is_async, bool* ok) {\012 // Parses this part of MemberExpression:\012 // ('[' Expression ']' | '.' Identifier | TemplateLiteral)*\012 while (true) {\012 switch (peek()) {\012 case Token::LBRACK: {\012 *is_async = false;\012 ValidateExpression(CHECK_OK);\012 BindingPatternUnexpectedToken();\012 ArrowFormalParametersUnexpectedToken();\012\012 Consume(Token::LBRACK);\012 int pos = position();\012 ExpressionT index = ParseExpressionCoverGrammar(true, CHECK_OK);\012 ValidateExpression(CHECK_OK);\012        expression = factory()-&gt;NewProperty(expression, index, pos);\012        impl()-&gt;PushPropertyName(index);\012 Expect(Token::RBRACK, CHECK_OK);\012 break;\012 }\012 case Token::PERIOD: {\012 *is_async = false;\012 ValidateExpression(CHECK_OK);\012 BindingPatternUnexpectedToken();\012 ArrowFormalParametersUnexpectedToken();\012\012 Consume(Token::PERIOD);\012 int pos = peek_position();\012 ExpressionT key = ParseIdentifierNameOrPrivateName(CHECK_OK);\012        expression = factory()-&gt;NewProperty(expression, key, pos);\012 break;\012 }\012 case Token::TEMPLATE_SPAN:\012 case Token::TEMPLATE_TAIL: {\012 *is_async = false;\012 ValidateExpression(CHECK_OK);\012 BindingPatternUnexpectedToken();\012 ArrowFormalParametersUnexpectedToken();\012 int pos;\012 if (scanner()-&gt;current_token() == Token::IDENTIFIER) {\012          pos = position();\012 } else {\012          pos = peek_position();\012 if (expression-&gt;IsFunctionLiteral()) {\012 // If the tag function looks like an IIFE, set_parenthesized() to\012 // force eager compilation.\012            expression-&gt;AsFunctionLiteral()-&gt;SetShouldEagerCompile();\012 }\012 }\012        expression = ParseTemplateLiteral(expression, pos, true, CHECK_OK);\012 break;\012 }\012 case Token::ILLEGAL: {\012 ReportUnexpectedTokenAt(scanner()-&gt;peek_location(), Token::ILLEGAL);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012 default:\012 return expression;\012 }\012 }\012  DCHECK(false);\012 return impl()-&gt;NullExpression();\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::ParseFormalParameter(FormalParametersT* parameters,\012 bool* ok) {\012 // FormalParameter[Yield,GeneratorParameter] :\012 //   BindingElement[?Yield, ?GeneratorParameter]\012 bool is_rest = parameters-&gt;has_rest;\012\012 FuncNameInferrer::State fni_state(fni_);\012 ExpressionT pattern = ParsePrimaryExpression(CHECK_OK_CUSTOM(Void));\012 ValidateBindingPattern(CHECK_OK_CUSTOM(Void));\012\012 if (!impl()-&gt;IsIdentifier(pattern)) {\012    parameters-&gt;is_simple = false;\012 ValidateFormalParameterInitializer(CHECK_OK_CUSTOM(Void));\012    classifier()-&gt;RecordNonSimpleParameter();\012 }\012\012 ExpressionT initializer = impl()-&gt;NullExpression();\012 if (Check(Token::ASSIGN)) {\012 if (is_rest) {\012 ReportMessage(MessageTemplate::kRestDefaultInitializer);\012 *ok = false;\012 return;\012 }\012 ExpressionClassifier init_classifier(this);\012    initializer = ParseAssignmentExpression(true, CHECK_OK_CUSTOM(Void));\012 ValidateExpression(CHECK_OK_CUSTOM(Void));\012 ValidateFormalParameterInitializer(CHECK_OK_CUSTOM(Void));\012    parameters-&gt;is_simple = false;\012 DiscardExpressionClassifier();\012    classifier()-&gt;RecordNonSimpleParameter();\012\012    impl()-&gt;SetFunctionNameFromIdentifierRef(initializer, pattern);\012 }\012\012  impl()-&gt;AddFormalParameter(parameters, pattern, initializer,\012                             scanner()-&gt;location().end_pos, is_rest);\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::ParseFormalParameterList(FormalParametersT* parameters,\012 bool* ok) {\012 // FormalParameters[Yield] :\012 //   [empty]\012 //   FunctionRestParameter[?Yield]\012 //   FormalParameterList[?Yield]\012 //   FormalParameterList[?Yield] ,\012 //   FormalParameterList[?Yield] , FunctionRestParameter[?Yield]\012 //\012 // FormalParameterList[Yield] :\012 //   FormalParameter[?Yield]\012 //   FormalParameterList[?Yield] , FormalParameter[?Yield]\012\012  DCHECK_EQ(0, parameters-&gt;arity);\012\012 if (peek() != Token::RPAREN) {\012 while (true) {\012 if (parameters-&gt;arity &gt; Code::kMaxArguments) {\012 ReportMessage(MessageTemplate::kTooManyParameters);\012 *ok = false;\012 return;\012 }\012      parameters-&gt;has_rest = Check(Token::ELLIPSIS);\012 ParseFormalParameter(parameters, CHECK_OK_CUSTOM(Void));\012\012 if (parameters-&gt;has_rest) {\012        parameters-&gt;is_simple = false;\012        classifier()-&gt;RecordNonSimpleParameter();\012 if (peek() == Token::COMMA) {\012          impl()-&gt;ReportMessageAt(scanner()-&gt;peek_location(),\012 MessageTemplate::kParamAfterRest);\012 *ok = false;\012 return;\012 }\012 break;\012 }\012 if (!Check(Token::COMMA)) break;\012 if (peek() == Token::RPAREN) {\012 // allow the trailing comma\012 break;\012 }\012 }\012 }\012\012  impl()-&gt;DeclareFormalParameters(parameters-&gt;scope, parameters-&gt;params,\012                                  parameters-&gt;is_simple);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::BlockT ParserBase&lt;Impl&gt;::ParseVariableDeclarations(\012 VariableDeclarationContext var_context,\012 DeclarationParsingResult* parsing_result,\012 ZonePtrList&lt;const AstRawString&gt;* names, bool* ok) {\012 // VariableDeclarations ::\012 //   ('var' | 'const' | 'let') (Identifier ('=' AssignmentExpression)?)+[',']\012 //\012 // ES6:\012 // FIXME(marja, nikolaos): Add an up-to-date comment about ES6 variable\012 // declaration syntax.\012\012  DCHECK_NOT_NULL(parsing_result);\012  parsing_result-&gt;descriptor.declaration_kind = DeclarationDescriptor::NORMAL;\012  parsing_result-&gt;descriptor.declaration_pos = peek_position();\012  parsing_result-&gt;descriptor.initialization_pos = peek_position();\012\012 BlockT init_block = impl()-&gt;NullStatement();\012 if (var_context != kForStatement) {\012    init_block = factory()-&gt;NewBlock(1, true);\012 }\012\012 switch (peek()) {\012 case Token::VAR:\012      parsing_result-&gt;descriptor.mode = VariableMode::kVar;\012 Consume(Token::VAR);\012 break;\012 case Token::CONST:\012 Consume(Token::CONST);\012      DCHECK_NE(var_context, kStatement);\012      parsing_result-&gt;descriptor.mode = VariableMode::kConst;\012 break;\012 case Token::LET:\012 Consume(Token::LET);\012      DCHECK_NE(var_context, kStatement);\012      parsing_result-&gt;descriptor.mode = VariableMode::kLet;\012 break;\012 default:\012      UNREACHABLE(); // by current callers\012 break;\012 }\012\012  parsing_result-&gt;descriptor.scope = scope();\012\012 int bindings_start = peek_position();\012 do {\012 // Parse binding pattern.\012 FuncNameInferrer::State fni_state(fni_);\012\012 ExpressionT pattern = impl()-&gt;NullExpression();\012 int decl_pos = peek_position();\012 {\012 ExpressionClassifier pattern_classifier(this);\012      pattern = ParsePrimaryExpression(CHECK_OK_CUSTOM(NullStatement));\012\012 ValidateBindingPattern(CHECK_OK_CUSTOM(NullStatement));\012 if (IsLexicalVariableMode(parsing_result-&gt;descriptor.mode)) {\012 ValidateLetPattern(CHECK_OK_CUSTOM(NullStatement));\012 }\012 }\012\012 Scanner::Location variable_loc = scanner()-&gt;location();\012 bool single_name = impl()-&gt;IsIdentifier(pattern);\012\012 if (single_name) {\012      impl()-&gt;PushVariableName(impl()-&gt;AsIdentifier(pattern));\012 }\012\012 ExpressionT value = impl()-&gt;NullExpression();\012 int initializer_position = kNoSourcePosition;\012 int value_beg_position = kNoSourcePosition;\012 if (Check(Token::ASSIGN)) {\012      value_beg_position = peek_position();\012\012 ExpressionClassifier classifier(this);\012      value = ParseAssignmentExpression(var_context != kForStatement,\012                                        CHECK_OK_CUSTOM(NullStatement));\012 ValidateExpression(CHECK_OK_CUSTOM(NullStatement));\012      variable_loc.end_pos = scanner()-&gt;location().end_pos;\012\012 if (!parsing_result-&gt;first_initializer_loc.IsValid()) {\012        parsing_result-&gt;first_initializer_loc = variable_loc;\012 }\012\012 // Don't infer if it is &quot;a = function(){...}();&quot;-like expression.\012 if (single_name &amp;&amp; fni_ != nullptr) {\012 if (!value-&gt;IsCall() &amp;&amp; !value-&gt;IsCallNew()) {\012          fni_-&gt;Infer();\012 } else {\012          fni_-&gt;RemoveLastFunction();\012 }\012 }\012\012      impl()-&gt;SetFunctionNameFromIdentifierRef(value, pattern);\012\012 // End position of the initializer is after the assignment expression.\012      initializer_position = scanner()-&gt;location().end_pos;\012 } else {\012 if (var_context != kForStatement || !PeekInOrOf()) {\012 // ES6 'const' and binding patterns require initializers.\012 if (parsing_result-&gt;descriptor.mode == VariableMode::kConst ||\012 !impl()-&gt;IsIdentifier(pattern)) {\012          impl()-&gt;ReportMessageAt(\012 Scanner::Location(decl_pos, scanner()-&gt;location().end_pos),\012 MessageTemplate::kDeclarationMissingInitializer,\012 !impl()-&gt;IsIdentifier(pattern) ? &quot;destructuring&quot; : &quot;const&quot;);\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 }\012 // 'let x' initializes 'x' to undefined.\012 if (parsing_result-&gt;descriptor.mode == VariableMode::kLet) {\012          value = factory()-&gt;NewUndefinedLiteral(position());\012 }\012 }\012\012 // End position of the initializer is after the variable.\012      initializer_position = position();\012 }\012\012 typename DeclarationParsingResult::Declaration decl(\012        pattern, initializer_position, value);\012    decl.value_beg_position = value_beg_position;\012 if (var_context == kForStatement) {\012 // Save the declaration for further handling in ParseForStatement.\012      parsing_result-&gt;declarations.push_back(decl);\012 } else {\012 // Immediately declare the variable otherwise. This avoids O(N^2)\012 // behavior (where N is the number of variables in a single\012 // declaration) in the PatternRewriter having to do with removing\012 // and adding VariableProxies to the Scope (see bug 4699).\012      impl()-&gt;DeclareAndInitializeVariables(\012          init_block, &amp;parsing_result-&gt;descriptor, &amp;decl, names,\012          CHECK_OK_CUSTOM(NullStatement));\012 }\012 } while (Check(Token::COMMA));\012\012  parsing_result-&gt;bindings_loc =\012 Scanner::Location(bindings_start, scanner()-&gt;location().end_pos);\012\012  DCHECK(*ok);\012 return init_block;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT\012ParserBase&lt;Impl&gt;::ParseFunctionDeclaration(bool* ok) {\012 Consume(Token::FUNCTION);\012 int pos = position();\012 ParseFunctionFlags flags = ParseFunctionFlags::kIsNormal;\012 if (Check(Token::MUL)) {\012    impl()-&gt;ReportMessageAt(\012        scanner()-&gt;location(),\012 MessageTemplate::kGeneratorInSingleStatementContext);\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 }\012 return ParseHoistableDeclaration(pos, flags, nullptr, false, ok);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT\012ParserBase&lt;Impl&gt;::ParseHoistableDeclaration(\012 ZonePtrList&lt;const AstRawString&gt;* names, bool default_export, bool* ok) {\012 Expect(Token::FUNCTION, CHECK_OK_CUSTOM(NullStatement));\012 int pos = position();\012 ParseFunctionFlags flags = ParseFunctionFlags::kIsNormal;\012 if (Check(Token::MUL)) {\012    flags |= ParseFunctionFlags::kIsGenerator;\012 }\012 return ParseHoistableDeclaration(pos, flags, names, default_export, ok);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT\012ParserBase&lt;Impl&gt;::ParseHoistableDeclaration(\012 int pos, ParseFunctionFlags flags, ZonePtrList&lt;const AstRawString&gt;* names,\012 bool default_export, bool* ok) {\012 // FunctionDeclaration ::\012 //   'function' Identifier '(' FormalParameters ')' '{' FunctionBody '}'\012 //   'function' '(' FormalParameters ')' '{' FunctionBody '}'\012 // GeneratorDeclaration ::\012 //   'function' '*' Identifier '(' FormalParameters ')' '{' FunctionBody '}'\012 //   'function' '*' '(' FormalParameters ')' '{' FunctionBody '}'\012 //\012 // The anonymous forms are allowed iff [default_export] is true.\012 //\012 // 'function' and '*' (if present) have been consumed by the caller.\012\012 bool is_generator = flags &amp; ParseFunctionFlags::kIsGenerator;\012 const bool is_async = flags &amp; ParseFunctionFlags::kIsAsync;\012  DCHECK(!is_generator || !is_async);\012\012 if (is_async &amp;&amp; Check(Token::MUL)) {\012 // Async generator\012    is_generator = true;\012 }\012\012 IdentifierT name;\012 FunctionNameValidity name_validity;\012 IdentifierT variable_name;\012 if (default_export &amp;&amp; peek() == Token::LPAREN) {\012    impl()-&gt;GetDefaultStrings(&amp;name, &amp;variable_name);\012    name_validity = kSkipFunctionNameCheck;\012 } else {\012 bool is_strict_reserved;\012 bool is_await = false;\012    name = ParseIdentifierOrStrictReservedWord(&amp;is_strict_reserved, &amp;is_await,\012                                               CHECK_OK_CUSTOM(NullStatement));\012    name_validity = is_strict_reserved ? kFunctionNameIsStrictReserved\012 : kFunctionNameValidityUnknown;\012    variable_name = name;\012 }\012\012 FuncNameInferrer::State fni_state(fni_);\012  impl()-&gt;PushEnclosingName(name);\012\012 FunctionKind kind = FunctionKindFor(is_generator, is_async);\012\012 FunctionLiteralT function = impl()-&gt;ParseFunctionLiteral(\012      name, scanner()-&gt;location(), name_validity, kind, pos,\012 FunctionLiteral::kDeclaration, language_mode(), nullptr,\012      CHECK_OK_CUSTOM(NullStatement));\012\012 // In ES6, a function behaves as a lexical binding, except in\012 // a script scope, or the initial scope of eval or another function.\012 VariableMode mode =\012 (!scope()-&gt;is_declaration_scope() || scope()-&gt;is_module_scope())\012 ? VariableMode::kLet\012 : VariableMode::kVar;\012 // Async functions don't undergo sloppy mode block scoped hoisting, and don't\012 // allow duplicates in a block. Both are represented by the\012 // sloppy_block_function_map. Don't add them to the map for async functions.\012 // Generators are also supposed to be prohibited; currently doing this behind\012 // a flag and UseCounting violations to assess web compatibility.\012 bool is_sloppy_block_function = is_sloppy(language_mode()) &amp;&amp;\012 !scope()-&gt;is_declaration_scope() &amp;&amp;\012 !is_async &amp;&amp; !is_generator;\012\012 return impl()-&gt;DeclareFunction(variable_name, function, mode, pos,\012                                 is_sloppy_block_function, names, ok);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseClassDeclaration(\012 ZonePtrList&lt;const AstRawString&gt;* names, bool default_export, bool* ok) {\012 // ClassDeclaration ::\012 //   'class' Identifier ('extends' LeftHandExpression)? '{' ClassBody '}'\012 //   'class' ('extends' LeftHandExpression)? '{' ClassBody '}'\012 //\012 // The anonymous form is allowed iff [default_export] is true.\012 //\012 // 'class' is expected to be consumed by the caller.\012 //\012 // A ClassDeclaration\012 //\012 //   class C { ... }\012 //\012 // has the same semantics as:\012 //\012 //   let C = class C { ... };\012 //\012 // so rewrite it as such.\012\012 int class_token_pos = position();\012 IdentifierT name = impl()-&gt;NullIdentifier();\012 bool is_strict_reserved = false;\012 IdentifierT variable_name = impl()-&gt;NullIdentifier();\012 if (default_export &amp;&amp; (peek() == Token::EXTENDS || peek() == Token::LBRACE)) {\012    impl()-&gt;GetDefaultStrings(&amp;name, &amp;variable_name);\012 } else {\012 bool is_await = false;\012    name = ParseIdentifierOrStrictReservedWord(&amp;is_strict_reserved, &amp;is_await,\012                                               CHECK_OK_CUSTOM(NullStatement));\012    variable_name = name;\012 }\012\012 ExpressionClassifier no_classifier(this);\012 ExpressionT value =\012 ParseClassLiteral(name, scanner()-&gt;location(), is_strict_reserved,\012                        class_token_pos, CHECK_OK_CUSTOM(NullStatement));\012 int end_pos = position();\012 return impl()-&gt;DeclareClass(variable_name, value, names, class_token_pos,\012                              end_pos, ok);\012}\012\012// Language extension which is only enabled for source files loaded\012// through the API's extension mechanism.  A native function\012// declaration is resolved by looking up the function through a\012// callback provided by the extension.\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseNativeDeclaration(\012 bool* ok) {\012  function_state_-&gt;DisableOptimization(BailoutReason::kNativeFunctionLiteral);\012\012 int pos = peek_position();\012 Expect(Token::FUNCTION, CHECK_OK_CUSTOM(NullStatement));\012 // Allow &quot;eval&quot; or &quot;arguments&quot; for backward compatibility.\012 IdentifierT name = ParseIdentifier(kAllowRestrictedIdentifiers,\012                                     CHECK_OK_CUSTOM(NullStatement));\012 Expect(Token::LPAREN, CHECK_OK_CUSTOM(NullStatement));\012 if (peek() != Token::RPAREN) {\012 do {\012 ParseIdentifier(kAllowRestrictedIdentifiers,\012                      CHECK_OK_CUSTOM(NullStatement));\012 } while (Check(Token::COMMA));\012 }\012 Expect(Token::RPAREN, CHECK_OK_CUSTOM(NullStatement));\012 Expect(Token::SEMICOLON, CHECK_OK_CUSTOM(NullStatement));\012 return impl()-&gt;DeclareNative(name, pos, ok);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT\012ParserBase&lt;Impl&gt;::ParseAsyncFunctionDeclaration(\012 ZonePtrList&lt;const AstRawString&gt;* names, bool default_export, bool* ok) {\012 // AsyncFunctionDeclaration ::\012 //   async [no LineTerminator here] function BindingIdentifier[Await]\012 //       ( FormalParameters[Await] ) { AsyncFunctionBody }\012  DCHECK_EQ(scanner()-&gt;current_token(), Token::ASYNC);\012 int pos = position();\012 if (scanner()-&gt;HasLineTerminatorBeforeNext()) {\012 *ok = false;\012    impl()-&gt;ReportUnexpectedToken(scanner()-&gt;current_token());\012 return impl()-&gt;NullStatement();\012 }\012 Expect(Token::FUNCTION, CHECK_OK_CUSTOM(NullStatement));\012 ParseFunctionFlags flags = ParseFunctionFlags::kIsAsync;\012 return ParseHoistableDeclaration(pos, flags, names, default_export, ok);\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::ParseFunctionBody(\012 typename ParserBase&lt;Impl&gt;::StatementListT result, IdentifierT function_name,\012 int pos, const FormalParametersT&amp; parameters, FunctionKind kind,\012 FunctionLiteral::FunctionType function_type, bool* ok) {\012 DeclarationScope* function_scope = scope()-&gt;AsDeclarationScope();\012 DeclarationScope* inner_scope = function_scope;\012 BlockT inner_block = impl()-&gt;NullStatement();\012\012 StatementListT body = result;\012 if (!parameters.is_simple) {\012    inner_scope = NewVarblockScope();\012    inner_scope-&gt;set_start_position(scanner()-&gt;location().beg_pos);\012    inner_block = factory()-&gt;NewBlock(8, true);\012    inner_block-&gt;set_scope(inner_scope);\012    body = inner_block-&gt;statements();\012 }\012\012 // If we are parsing the source as if it is wrapped in a function, the source\012 // ends without a closing brace.\012 Token::Value closing_token =\012      function_type == FunctionLiteral::kWrapped ? Token::EOS : Token::RBRACE;\012\012 {\012 BlockState block_state(&amp;scope_, inner_scope);\012\012 if (IsResumableFunction(kind)) impl()-&gt;PrepareGeneratorVariables();\012\012 if (IsAsyncGeneratorFunction(kind)) {\012      impl()-&gt;ParseAndRewriteAsyncGeneratorFunctionBody(pos, kind, body, ok);\012 } else if (IsGeneratorFunction(kind)) {\012      impl()-&gt;ParseAndRewriteGeneratorFunctionBody(pos, kind, body, ok);\012 } else if (IsAsyncFunction(kind)) {\012 ParseAsyncFunctionBody(inner_scope, body, CHECK_OK_VOID);\012 } else {\012 ParseStatementList(body, closing_token, CHECK_OK_VOID);\012 }\012\012 if (IsDerivedConstructor(kind)) {\012      body-&gt;Add(factory()-&gt;NewReturnStatement(impl()-&gt;ThisExpression(),\012                                              kNoSourcePosition),\012                zone());\012 }\012 }\012\012 Expect(closing_token, CHECK_OK_VOID);\012  scope()-&gt;set_end_position(scanner()-&gt;location().end_pos);\012\012 if (!parameters.is_simple) {\012    DCHECK_NOT_NULL(inner_scope);\012    DCHECK_EQ(function_scope, scope());\012    DCHECK_EQ(function_scope, inner_scope-&gt;outer_scope());\012    impl()-&gt;SetLanguageMode(function_scope, inner_scope-&gt;language_mode());\012 BlockT init_block =\012        impl()-&gt;BuildParameterInitializationBlock(parameters, CHECK_OK_VOID);\012\012 if (is_sloppy(inner_scope-&gt;language_mode())) {\012      impl()-&gt;InsertSloppyBlockFunctionVarBindings(inner_scope);\012 }\012\012 // TODO(littledan): Merge the two rejection blocks into one\012 if (IsAsyncFunction(kind) &amp;&amp; !IsAsyncGeneratorFunction(kind)) {\012      init_block = impl()-&gt;BuildRejectPromiseOnException(init_block);\012 }\012\012    inner_scope-&gt;set_end_position(scanner()-&gt;location().end_pos);\012 if (inner_scope-&gt;FinalizeBlockScope() != nullptr) {\012      impl()-&gt;CheckConflictingVarDeclarations(inner_scope, CHECK_OK_VOID);\012      impl()-&gt;InsertShadowingVarBindingInitializers(inner_block);\012 } else {\012      inner_block-&gt;set_scope(nullptr);\012 }\012    inner_scope = nullptr;\012\012    result-&gt;Add(init_block, zone());\012    result-&gt;Add(inner_block, zone());\012 } else {\012    DCHECK_EQ(inner_scope, function_scope);\012 if (is_sloppy(function_scope-&gt;language_mode())) {\012      impl()-&gt;InsertSloppyBlockFunctionVarBindings(function_scope);\012 }\012 }\012\012 if (!IsArrowFunction(kind)) {\012 // Declare arguments after parsing the function since lexical 'arguments'\012 // masks the arguments object. Declare arguments before declaring the\012 // function var since the arguments object masks 'function arguments'.\012    function_scope-&gt;DeclareArguments(ast_value_factory());\012 }\012\012  impl()-&gt;DeclareFunctionNameVar(function_name, function_type, function_scope);\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::CheckArityRestrictions(int param_count,\012 FunctionKind function_kind,\012 bool has_rest,\012 int formals_start_pos,\012 int formals_end_pos, bool* ok) {\012 if (IsGetterFunction(function_kind)) {\012 if (param_count != 0) {\012      impl()-&gt;ReportMessageAt(\012 Scanner::Location(formals_start_pos, formals_end_pos),\012 MessageTemplate::kBadGetterArity);\012 *ok = false;\012 }\012 } else if (IsSetterFunction(function_kind)) {\012 if (param_count != 1) {\012      impl()-&gt;ReportMessageAt(\012 Scanner::Location(formals_start_pos, formals_end_pos),\012 MessageTemplate::kBadSetterArity);\012 *ok = false;\012 }\012 if (has_rest) {\012      impl()-&gt;ReportMessageAt(\012 Scanner::Location(formals_start_pos, formals_end_pos),\012 MessageTemplate::kBadSetterRestParameter);\012 *ok = false;\012 }\012 }\012}\012\012template &lt;typename Impl&gt;\012bool ParserBase&lt;Impl&gt;::IsNextLetKeyword() {\012  DCHECK(peek() == Token::LET);\012 Token::Value next_next = PeekAhead();\012 switch (next_next) {\012 case Token::LBRACE:\012 case Token::LBRACK:\012 case Token::IDENTIFIER:\012 case Token::STATIC:\012 case Token::LET: // `let let;` is disallowed by static semantics, but the\012 // token must be first interpreted as a keyword in order\012 // for those semantics to apply. This ensures that ASI is\012 // not honored when a LineTerminator separates the\012 // tokens.\012 case Token::YIELD:\012 case Token::AWAIT:\012 case Token::ASYNC:\012 return true;\012 case Token::FUTURE_STRICT_RESERVED_WORD:\012 return is_sloppy(language_mode());\012 default:\012 return false;\012 }\012}\012\012template &lt;typename Impl&gt;\012bool ParserBase&lt;Impl&gt;::IsTrivialExpression() {\012 Token::Value peek_token = peek();\012 if (peek_token == Token::SMI || peek_token == Token::NUMBER ||\012      peek_token == Token::BIGINT || peek_token == Token::NULL_LITERAL ||\012      peek_token == Token::TRUE_LITERAL || peek_token == Token::FALSE_LITERAL ||\012      peek_token == Token::STRING || peek_token == Token::IDENTIFIER ||\012      peek_token == Token::THIS) {\012 // PeekAhead() is expensive &amp; may not always be called, so we only call it\012 // after checking peek().\012 Token::Value peek_ahead = PeekAhead();\012 if (peek_ahead == Token::COMMA || peek_ahead == Token::RPAREN ||\012        peek_ahead == Token::SEMICOLON || peek_ahead == Token::RBRACK) {\012 return true;\012 }\012 }\012 return false;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT\012ParserBase&lt;Impl&gt;::ParseArrowFunctionLiteral(\012 bool accept_IN, const FormalParametersT&amp; formal_parameters,\012 int rewritable_length, bool* ok) {\012 const RuntimeCallCounterId counters[2][2] = {\012 {RuntimeCallCounterId::kParseBackgroundArrowFunctionLiteral,\012 RuntimeCallCounterId::kParseArrowFunctionLiteral},\012 {RuntimeCallCounterId::kPreParseBackgroundArrowFunctionLiteral,\012 RuntimeCallCounterId::kPreParseArrowFunctionLiteral}};\012 RuntimeCallTimerScope runtime_timer(\012      runtime_call_stats_,\012      counters[Impl::IsPreParser()][parsing_on_main_thread_]);\012 base::ElapsedTimer timer;\012 if (V8_UNLIKELY(FLAG_log_function_events)) timer.Start();\012\012 if (peek() == Token::ARROW &amp;&amp; scanner_-&gt;HasLineTerminatorBeforeNext()) {\012 // ASI inserts `;` after arrow parameters if a line terminator is found.\012 // `=&gt; ...` is never a valid expression, so report as syntax error.\012 // If next token is not `=&gt;`, it's a syntax error anyways.\012 ReportUnexpectedTokenAt(scanner_-&gt;peek_location(), Token::ARROW);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012\012 StatementListT body = impl()-&gt;NullStatementList();\012 int expected_property_count = -1;\012 int suspend_count = 0;\012 int function_literal_id = GetNextFunctionLiteralId();\012\012 FunctionKind kind = formal_parameters.scope-&gt;function_kind();\012 FunctionLiteral::EagerCompileHint eager_compile_hint =\012      default_eager_compile_hint_;\012 bool can_preparse = impl()-&gt;parse_lazily() &amp;&amp;\012                      eager_compile_hint == FunctionLiteral::kShouldLazyCompile;\012 // TODO(marja): consider lazy-parsing inner arrow functions too. is_this\012 // handling in Scope::ResolveVariable needs to change.\012 bool is_lazy_top_level_function =\012      can_preparse &amp;&amp; impl()-&gt;AllowsLazyParsingWithoutUnresolvedVariables();\012 bool has_braces = true;\012 ProducedPreParsedScopeData* produced_preparsed_scope_data = nullptr;\012 {\012 FunctionState function_state(&amp;function_state_, &amp;scope_,\012                                 formal_parameters.scope);\012\012 // Move any queued destructuring assignments which appeared\012 // in this function's parameter list into its own function_state.\012    function_state.AdoptDestructuringAssignmentsFromParentState(\012        rewritable_length);\012\012 Expect(Token::ARROW, CHECK_OK);\012\012 if (peek() == Token::LBRACE) {\012 // Multiple statement body\012      DCHECK_EQ(scope(), formal_parameters.scope);\012 if (is_lazy_top_level_function) {\012 // FIXME(marja): Arrow function parameters will be parsed even if the\012 // body is preparsed; move relevant parts of parameter handling to\012 // simulate consistent parameter handling.\012\012 // For arrow functions, we don't need to retrieve data about function\012 // parameters.\012 int dummy_num_parameters = -1;\012        DCHECK_NE(kind &amp; FunctionKind::kArrowFunction, 0);\012 LazyParsingResult result = impl()-&gt;SkipFunction(\012 nullptr, kind, FunctionLiteral::kAnonymousExpression,\012            formal_parameters.scope, &amp;dummy_num_parameters,\012 &amp;produced_preparsed_scope_data, false, false, CHECK_OK);\012        DCHECK_NE(result, kLazyParsingAborted);\012        DCHECK_NULL(produced_preparsed_scope_data);\012        USE(result);\012        formal_parameters.scope-&gt;ResetAfterPreparsing(ast_value_factory_,\012 false);\012 // Discard any queued destructuring assignments which appeared\012 // in this function's parameter list, and which were adopted\012 // into this function state, above.\012        function_state.RewindDestructuringAssignments(0);\012 } else {\012 Consume(Token::LBRACE);\012        body = impl()-&gt;NewStatementList(8);\012 ParseFunctionBody(body, impl()-&gt;NullIdentifier(), kNoSourcePosition,\012                          formal_parameters, kind,\012 FunctionLiteral::kAnonymousExpression, CHECK_OK);\012        expected_property_count = function_state.expected_property_count();\012 }\012 } else {\012 // Single-expression body\012      has_braces = false;\012 const bool is_async = IsAsyncFunction(kind);\012      body = impl()-&gt;NewStatementList(1);\012      impl()-&gt;AddParameterInitializationBlock(formal_parameters, body, is_async,\012                                              CHECK_OK);\012 ParseSingleExpressionFunctionBody(body, is_async, accept_IN, CHECK_OK);\012      expected_property_count = function_state.expected_property_count();\012 }\012\012    formal_parameters.scope-&gt;set_end_position(scanner()-&gt;location().end_pos);\012\012 // Arrow function formal parameters are parsed as StrictFormalParameterList,\012 // which is not the same as &quot;parameters of a strict function&quot;; it only means\012 // that duplicates are not allowed.  Of course, the arrow function may\012 // itself be strict as well.\012 const bool allow_duplicate_parameters = false;\012 ValidateFormalParameters(language_mode(), allow_duplicate_parameters,\012                             CHECK_OK);\012\012 // Validate strict mode.\012 if (is_strict(language_mode())) {\012 CheckStrictOctalLiteral(formal_parameters.scope-&gt;start_position(),\012                              scanner()-&gt;location().end_pos, CHECK_OK);\012 }\012    impl()-&gt;CheckConflictingVarDeclarations(formal_parameters.scope, CHECK_OK);\012\012    impl()-&gt;RewriteDestructuringAssignments();\012    suspend_count = function_state.suspend_count();\012 }\012\012 FunctionLiteralT function_literal = factory()-&gt;NewFunctionLiteral(\012      impl()-&gt;EmptyIdentifierString(), formal_parameters.scope, body,\012      expected_property_count, formal_parameters.num_parameters(),\012      formal_parameters.function_length,\012 FunctionLiteral::kNoDuplicateParameters,\012 FunctionLiteral::kAnonymousExpression, eager_compile_hint,\012      formal_parameters.scope-&gt;start_position(), has_braces,\012      function_literal_id, produced_preparsed_scope_data);\012\012  function_literal-&gt;set_suspend_count(suspend_count);\012  function_literal-&gt;set_function_token_position(\012      formal_parameters.scope-&gt;start_position());\012\012  impl()-&gt;AddFunctionForNameInference(function_literal);\012\012 if (V8_UNLIKELY((FLAG_log_function_events))) {\012 Scope* scope = formal_parameters.scope;\012 double ms = timer.Elapsed().InMillisecondsF();\012 const char* event_name =\012        is_lazy_top_level_function ? &quot;preparse-no-resolution&quot; : &quot;parse&quot;;\012 const char* name = &quot;arrow function&quot;;\012    logger_-&gt;FunctionEvent(event_name, script_id(), ms, scope-&gt;start_position(),\012                           scope-&gt;end_position(), name, strlen(name));\012 }\012\012 return function_literal;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParseClassLiteral(\012 IdentifierT name, Scanner::Location class_name_location,\012 bool name_is_strict_reserved, int class_token_pos, bool* ok) {\012 bool is_anonymous = impl()-&gt;IsNull(name);\012\012 // All parts of a ClassDeclaration and ClassExpression are strict code.\012 if (!is_anonymous) {\012 if (name_is_strict_reserved) {\012      impl()-&gt;ReportMessageAt(class_name_location,\012 MessageTemplate::kUnexpectedStrictReserved);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012 if (impl()-&gt;IsEvalOrArguments(name)) {\012      impl()-&gt;ReportMessageAt(class_name_location,\012 MessageTemplate::kStrictEvalArguments);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012 }\012\012 Scope* block_scope = NewScope(BLOCK_SCOPE);\012 BlockState block_state(&amp;scope_, block_scope);\012 RaiseLanguageMode(LanguageMode::kStrict);\012\012 ClassInfo class_info(this);\012  class_info.is_anonymous = is_anonymous;\012  impl()-&gt;DeclareClassVariable(name, &amp;class_info, class_token_pos, CHECK_OK);\012\012  scope()-&gt;set_start_position(scanner()-&gt;location().end_pos);\012 if (Check(Token::EXTENDS)) {\012 FuncNameInferrer::State fni_state(fni_);\012 ExpressionClassifier extends_classifier(this);\012    class_info.extends = ParseLeftHandSideExpression(CHECK_OK);\012 ValidateExpression(CHECK_OK);\012 AccumulateFormalParameterContainmentErrors();\012 }\012\012 ClassLiteralChecker checker(this);\012\012 Expect(Token::LBRACE, CHECK_OK);\012\012 const bool has_extends = !impl()-&gt;IsNull(class_info.extends);\012 while (peek() != Token::RBRACE) {\012 if (Check(Token::SEMICOLON)) continue;\012 FuncNameInferrer::State fni_state(fni_);\012 bool is_computed_name = false; // Classes do not care about computed\012 // property names here.\012 bool is_static;\012 ClassLiteralProperty::Kind property_kind;\012 ExpressionClassifier property_classifier(this);\012 IdentifierT property_name;\012 // If we haven't seen the constructor yet, it potentially is the next\012 // property.\012 bool is_constructor = !class_info.has_seen_constructor;\012 ClassLiteralPropertyT property = ParseClassPropertyDefinition(\012 &amp;checker, &amp;class_info, &amp;property_name, has_extends, &amp;is_computed_name,\012 &amp;property_kind, &amp;is_static, CHECK_OK);\012 if (!class_info.has_static_computed_names &amp;&amp; is_static &amp;&amp;\012        is_computed_name) {\012      class_info.has_static_computed_names = true;\012 }\012 if (is_computed_name &amp;&amp;\012        property_kind == ClassLiteralProperty::PUBLIC_FIELD) {\012      class_info.computed_field_count++;\012 }\012    is_constructor &amp;= class_info.has_seen_constructor;\012 ValidateExpression(CHECK_OK);\012 AccumulateFormalParameterContainmentErrors();\012\012    impl()-&gt;DeclareClassProperty(name, property, property_name, property_kind,\012                                 is_static, is_constructor, is_computed_name,\012 &amp;class_info, CHECK_OK);\012    impl()-&gt;InferFunctionName();\012 }\012\012 Expect(Token::RBRACE, CHECK_OK);\012 int end_pos = scanner()-&gt;location().end_pos;\012  block_scope-&gt;set_end_position(end_pos);\012 return impl()-&gt;RewriteClassLiteral(block_scope, name, &amp;class_info,\012                                     class_token_pos, end_pos, ok);\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::ParseSingleExpressionFunctionBody(StatementListT body,\012 bool is_async,\012 bool accept_IN,\012 bool* ok) {\012 if (is_async) impl()-&gt;PrepareGeneratorVariables();\012\012 ExpressionClassifier classifier(this);\012 ExpressionT expression = ParseAssignmentExpression(accept_IN, CHECK_OK_VOID);\012 ValidateExpression(CHECK_OK_VOID);\012\012 if (is_async) {\012 BlockT block = factory()-&gt;NewBlock(1, true);\012    impl()-&gt;RewriteAsyncFunctionBody(body, block, expression, CHECK_OK_VOID);\012 } else {\012    body-&gt;Add(BuildReturnStatement(expression, expression-&gt;position()), zone());\012 }\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::ParseAsyncFunctionBody(Scope* scope, StatementListT body,\012 bool* ok) {\012 BlockT block = factory()-&gt;NewBlock(8, true);\012\012 ParseStatementList(block-&gt;statements(), Token::RBRACE, CHECK_OK_VOID);\012  impl()-&gt;RewriteAsyncFunctionBody(\012      body, block, factory()-&gt;NewUndefinedLiteral(kNoSourcePosition),\012      CHECK_OK_VOID);\012  scope-&gt;set_end_position(scanner()-&gt;location().end_pos);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT\012ParserBase&lt;Impl&gt;::ParseAsyncFunctionLiteral(bool* ok) {\012 // AsyncFunctionLiteral ::\012 //   async [no LineTerminator here] function ( FormalParameters[Await] )\012 //       { AsyncFunctionBody }\012 //\012 //   async [no LineTerminator here] function BindingIdentifier[Await]\012 //       ( FormalParameters[Await] ) { AsyncFunctionBody }\012  DCHECK_EQ(scanner()-&gt;current_token(), Token::ASYNC);\012 int pos = position();\012 Expect(Token::FUNCTION, CHECK_OK);\012 bool is_strict_reserved = false;\012 IdentifierT name = impl()-&gt;NullIdentifier();\012 FunctionLiteral::FunctionType type = FunctionLiteral::kAnonymousExpression;\012\012 bool is_generator = Check(Token::MUL);\012 const bool kIsAsync = true;\012 const FunctionKind kind = FunctionKindFor(is_generator, kIsAsync);\012\012 if (impl()-&gt;ParsingDynamicFunctionDeclaration()) {\012 // We don't want dynamic functions to actually declare their name\012 // &quot;anonymous&quot;. We just want that name in the toString().\012 if (stack_overflow()) {\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012 Consume(Token::IDENTIFIER);\012    DCHECK(scanner()-&gt;CurrentMatchesContextual(Token::ANONYMOUS));\012 } else if (peek_any_identifier()) {\012    type = FunctionLiteral::kNamedExpression;\012 bool is_await = false;\012    name = ParseIdentifierOrStrictReservedWord(kind, &amp;is_strict_reserved,\012 &amp;is_await, CHECK_OK);\012 // If the function name is &quot;await&quot;, ParseIdentifierOrStrictReservedWord\012 // recognized the error.\012    DCHECK(!is_await);\012 }\012 return impl()-&gt;ParseFunctionLiteral(\012      name, scanner()-&gt;location(),\012      is_strict_reserved ? kFunctionNameIsStrictReserved\012 : kFunctionNameValidityUnknown,\012      kind, pos, type, language_mode(), nullptr, CHECK_OK);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParseTemplateLiteral(\012 ExpressionT tag, int start, bool tagged, bool* ok) {\012 // A TemplateLiteral is made up of 0 or more TEMPLATE_SPAN tokens (literal\012 // text followed by a substitution expression), finalized by a single\012 // TEMPLATE_TAIL.\012 //\012 // In terms of draft language, TEMPLATE_SPAN may be either the TemplateHead or\012 // TemplateMiddle productions, while TEMPLATE_TAIL is either TemplateTail, or\012 // NoSubstitutionTemplate.\012 //\012 // When parsing a TemplateLiteral, we must have scanned either an initial\012 // TEMPLATE_SPAN, or a TEMPLATE_TAIL.\012  DCHECK(peek() == Token::TEMPLATE_SPAN || peek() == Token::TEMPLATE_TAIL);\012\012 if (tagged) {\012 // TaggedTemplate expressions prevent the eval compilation cache from being\012 // used. This flag is only used if an eval is being parsed.\012    set_allow_eval_cache(false);\012 }\012\012 bool forbid_illegal_escapes = !tagged;\012\012 // If we reach a TEMPLATE_TAIL first, we are parsing a NoSubstitutionTemplate.\012 // In this case we may simply consume the token and build a template with a\012 // single TEMPLATE_SPAN and no expressions.\012 if (peek() == Token::TEMPLATE_TAIL) {\012 Consume(Token::TEMPLATE_TAIL);\012 int pos = position();\012 typename Impl::TemplateLiteralState ts = impl()-&gt;OpenTemplateLiteral(pos);\012 bool is_valid = CheckTemplateEscapes(forbid_illegal_escapes, CHECK_OK);\012    impl()-&gt;AddTemplateSpan(&amp;ts, is_valid, true);\012 return impl()-&gt;CloseTemplateLiteral(&amp;ts, start, tag);\012 }\012\012 Consume(Token::TEMPLATE_SPAN);\012 int pos = position();\012 typename Impl::TemplateLiteralState ts = impl()-&gt;OpenTemplateLiteral(pos);\012 bool is_valid = CheckTemplateEscapes(forbid_illegal_escapes, CHECK_OK);\012  impl()-&gt;AddTemplateSpan(&amp;ts, is_valid, false);\012 Token::Value next;\012\012 // If we open with a TEMPLATE_SPAN, we must scan the subsequent expression,\012 // and repeat if the following token is a TEMPLATE_SPAN as well (in this\012 // case, representing a TemplateMiddle).\012\012 do {\012 next = peek();\012 if (next == Token::EOS) {\012      impl()-&gt;ReportMessageAt(Scanner::Location(start, peek_position()),\012 MessageTemplate::kUnterminatedTemplate);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 } else if (next == Token::ILLEGAL) {\012      impl()-&gt;ReportMessageAt(\012 Scanner::Location(position() + 1, peek_position()),\012 MessageTemplate::kUnexpectedToken, &quot;ILLEGAL&quot;, kSyntaxError);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012\012 int expr_pos = peek_position();\012 ExpressionT expression = ParseExpressionCoverGrammar(true, CHECK_OK);\012 ValidateExpression(CHECK_OK);\012    impl()-&gt;AddTemplateExpression(&amp;ts, expression);\012\012 if (peek() != Token::RBRACE) {\012      impl()-&gt;ReportMessageAt(Scanner::Location(expr_pos, peek_position()),\012 MessageTemplate::kUnterminatedTemplateExpr);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012\012 // If we didn't die parsing that expression, our next token should be a\012 // TEMPLATE_SPAN or TEMPLATE_TAIL.\012 next = scanner()-&gt;ScanTemplateContinuation();\012 Next();\012    pos = position();\012\012 if (next == Token::EOS) {\012      impl()-&gt;ReportMessageAt(Scanner::Location(start, pos),\012 MessageTemplate::kUnterminatedTemplate);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 } else if (next == Token::ILLEGAL) {\012      impl()-&gt;ReportMessageAt(\012 Scanner::Location(position() + 1, peek_position()),\012 MessageTemplate::kUnexpectedToken, &quot;ILLEGAL&quot;, kSyntaxError);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012\012 bool is_valid = CheckTemplateEscapes(forbid_illegal_escapes, CHECK_OK);\012    impl()-&gt;AddTemplateSpan(&amp;ts, is_valid, next == Token::TEMPLATE_TAIL);\012 } while (next == Token::TEMPLATE_SPAN);\012\012  DCHECK_EQ(next, Token::TEMPLATE_TAIL);\012 // Once we've reached a TEMPLATE_TAIL, we can close the TemplateLiteral.\012 return impl()-&gt;CloseTemplateLiteral(&amp;ts, start, tag);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT\012ParserBase&lt;Impl&gt;::CheckAndRewriteReferenceExpression(\012 ExpressionT expression, int beg_pos, int end_pos,\012 MessageTemplate::Template message, bool* ok) {\012 return CheckAndRewriteReferenceExpression(expression, beg_pos, end_pos,\012                                            message, kReferenceError, ok);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT\012ParserBase&lt;Impl&gt;::CheckAndRewriteReferenceExpression(\012 ExpressionT expression, int beg_pos, int end_pos,\012 MessageTemplate::Template message, ParseErrorType type, bool* ok) {\012 if (impl()-&gt;IsIdentifier(expression) &amp;&amp; is_strict(language_mode()) &amp;&amp;\012      impl()-&gt;IsEvalOrArguments(impl()-&gt;AsIdentifier(expression))) {\012 ReportMessageAt(Scanner::Location(beg_pos, end_pos),\012 MessageTemplate::kStrictEvalArguments, kSyntaxError);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012 }\012 if (expression-&gt;IsValidReferenceExpression()) {\012 return expression;\012 }\012 if (expression-&gt;IsCall() &amp;&amp; !expression-&gt;AsCall()-&gt;is_tagged_template()) {\012 // If it is a call, make it a runtime error for legacy web compatibility.\012 // Bug: https://bugs.chromium.org/p/v8/issues/detail?id=4480\012 // Rewrite `expr' to `expr[throw ReferenceError]'.\012    impl()-&gt;CountUsage(\012        is_strict(language_mode())\012 ? v8::Isolate::kAssigmentExpressionLHSIsCallInStrict\012 : v8::Isolate::kAssigmentExpressionLHSIsCallInSloppy);\012 ExpressionT error = impl()-&gt;NewThrowReferenceError(message, beg_pos);\012 return factory()-&gt;NewProperty(expression, error, beg_pos);\012 }\012 ReportMessageAt(Scanner::Location(beg_pos, end_pos), message, type);\012 *ok = false;\012 return impl()-&gt;NullExpression();\012}\012\012template &lt;typename Impl&gt;\012bool ParserBase&lt;Impl&gt;::IsValidReferenceExpression(ExpressionT expression) {\012 return IsAssignableIdentifier(expression) || expression-&gt;IsProperty();\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::CheckDestructuringElement(ExpressionT expression,\012 int begin, int end) {\012 if (!IsValidPattern(expression) &amp;&amp; !expression-&gt;IsAssignment() &amp;&amp;\012 !IsValidReferenceExpression(expression)) {\012    classifier()-&gt;RecordAssignmentPatternError(\012 Scanner::Location(begin, end),\012 MessageTemplate::kInvalidDestructuringTarget);\012 }\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParseV8Intrinsic(\012 bool* ok) {\012 // CallRuntime ::\012 //   '%' Identifier Arguments\012\012 int pos = peek_position();\012 Expect(Token::MOD, CHECK_OK);\012 // Allow &quot;eval&quot; or &quot;arguments&quot; for backward compatibility.\012 IdentifierT name = ParseIdentifier(kAllowRestrictedIdentifiers, CHECK_OK);\012 Scanner::Location spread_pos;\012 ExpressionClassifier classifier(this);\012 ExpressionListT args = ParseArguments(&amp;spread_pos, CHECK_OK);\012\012 if (spread_pos.IsValid()) {\012 *ok = false;\012 ReportMessageAt(spread_pos, MessageTemplate::kIntrinsicWithSpread,\012                    kSyntaxError);\012 return impl()-&gt;NullExpression();\012 }\012\012 return impl()-&gt;NewV8Intrinsic(name, args, pos, ok);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ExpressionT ParserBase&lt;Impl&gt;::ParseDoExpression(\012 bool* ok) {\012 // AssignmentExpression ::\012 //     do '{' StatementList '}'\012\012 int pos = peek_position();\012 Expect(Token::DO, CHECK_OK);\012 BlockT block = ParseBlock(nullptr, CHECK_OK);\012 return impl()-&gt;RewriteDoExpression(block, pos, ok);\012}\012\012// Redefinition of CHECK_OK for parsing statements.\012#undef CHECK_OK\012#define CHECK_OK CHECK_OK_CUSTOM(NullStatement)\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::LazyParsingResult\012ParserBase&lt;Impl&gt;::ParseStatementList(StatementListT body,\012 Token::Value end_token, bool may_abort,\012 bool* ok) {\012 // StatementList ::\012 //   (StatementListItem)* &lt;end_token&gt;\012\012 // Allocate a target stack to use for this set of source\012 // elements. This way, all scripts and functions get their own\012 // target stack thus avoiding illegal breaks and continues across\012 // functions.\012 typename Types::TargetScope target_scope(this);\012 int count_statements = 0;\012\012  DCHECK(!impl()-&gt;IsNull(body));\012 bool directive_prologue = true; // Parsing directive prologue.\012\012 while (peek() != end_token) {\012 if (directive_prologue &amp;&amp; peek() != Token::STRING) {\012      directive_prologue = false;\012 }\012\012 bool starts_with_identifier = peek() == Token::IDENTIFIER;\012 Scanner::Location token_loc = scanner()-&gt;peek_location();\012 StatementT stat =\012 ParseStatementListItem(CHECK_OK_CUSTOM(Return, kLazyParsingComplete));\012\012 if (impl()-&gt;IsNull(stat) || stat-&gt;IsEmptyStatement()) {\012      directive_prologue = false; // End of directive prologue.\012 continue;\012 }\012\012 if (directive_prologue) {\012 // The length of the token is used to distinguish between strings literals\012 // that evaluate equal to directives but contain either escape sequences\012 // (e.g., &quot;use \x73trict&quot;) or line continuations (e.g., &quot;use \(newline)\012 // strict&quot;).\012 if (impl()-&gt;IsUseStrictDirective(stat) &amp;&amp;\012          token_loc.end_pos - token_loc.beg_pos == sizeof(&quot;use strict&quot;) + 1) {\012 // Directive &quot;use strict&quot; (ES5 14.1).\012 RaiseLanguageMode(LanguageMode::kStrict);\012 if (!scope()-&gt;HasSimpleParameters()) {\012 // TC39 deemed &quot;use strict&quot; directives to be an error when occurring\012 // in the body of a function with non-simple parameter list, on\012 // 29/7/2015. https://goo.gl/ueA7Ln\012          impl()-&gt;ReportMessageAt(\012              token_loc, MessageTemplate::kIllegalLanguageModeDirective,\012 &quot;use strict&quot;);\012 *ok = false;\012 return kLazyParsingComplete;\012 }\012 } else if (impl()-&gt;IsUseAsmDirective(stat) &amp;&amp;\012                 token_loc.end_pos - token_loc.beg_pos ==\012 sizeof(&quot;use asm&quot;) + 1) {\012 // Directive &quot;use asm&quot;.\012        impl()-&gt;SetAsmModule();\012 } else if (impl()-&gt;IsStringLiteral(stat)) {\012 // Possibly an unknown directive.\012 // Should not change mode, but will increment usage counters\012 // as appropriate. Ditto usages below.\012 RaiseLanguageMode(LanguageMode::kSloppy);\012 } else {\012 // End of the directive prologue.\012        directive_prologue = false;\012 RaiseLanguageMode(LanguageMode::kSloppy);\012 }\012 } else {\012 RaiseLanguageMode(LanguageMode::kSloppy);\012 }\012\012 // If we're allowed to abort, we will do so when we see a &quot;long and\012 // trivial&quot; function. Our current definition of &quot;long and trivial&quot; is:\012 // - over kLazyParseTrialLimit statements\012 // - all starting with an identifier (i.e., no if, for, while, etc.)\012 if (may_abort) {\012 if (!starts_with_identifier) {\012        may_abort = false;\012 } else if (++count_statements &gt; kLazyParseTrialLimit) {\012 return kLazyParsingAborted;\012 }\012 }\012\012    body-&gt;Add(stat, zone());\012 }\012 return kLazyParsingComplete;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseStatementListItem(\012 bool* ok) {\012 // ECMA 262 6th Edition\012 // StatementListItem[Yield, Return] :\012 //   Statement[?Yield, ?Return]\012 //   Declaration[?Yield]\012 //\012 // Declaration[Yield] :\012 //   HoistableDeclaration[?Yield]\012 //   ClassDeclaration[?Yield]\012 //   LexicalDeclaration[In, ?Yield]\012 //\012 // HoistableDeclaration[Yield, Default] :\012 //   FunctionDeclaration[?Yield, ?Default]\012 //   GeneratorDeclaration[?Yield, ?Default]\012 //\012 // LexicalDeclaration[In, Yield] :\012 //   LetOrConst BindingList[?In, ?Yield] ;\012\012 switch (peek()) {\012 case Token::FUNCTION:\012 return ParseHoistableDeclaration(nullptr, false, ok);\012 case Token::CLASS:\012 Consume(Token::CLASS);\012 return ParseClassDeclaration(nullptr, false, ok);\012 case Token::VAR:\012 case Token::CONST:\012 return ParseVariableStatement(kStatementListItem, nullptr, ok);\012 case Token::LET:\012 if (IsNextLetKeyword()) {\012 return ParseVariableStatement(kStatementListItem, nullptr, ok);\012 }\012 break;\012 case Token::ASYNC:\012 if (PeekAhead() == Token::FUNCTION &amp;&amp;\012 !scanner()-&gt;HasLineTerminatorAfterNext()) {\012 Consume(Token::ASYNC);\012 return ParseAsyncFunctionDeclaration(nullptr, false, ok);\012 }\012 break;\012 default:\012 break;\012 }\012 return ParseStatement(nullptr, nullptr, kAllowLabelledFunctionStatement, ok);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseStatement(\012 ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels,\012 AllowLabelledFunctionStatement allow_function, bool* ok) {\012 // Statement ::\012 //   Block\012 //   VariableStatement\012 //   EmptyStatement\012 //   ExpressionStatement\012 //   IfStatement\012 //   IterationStatement\012 //   ContinueStatement\012 //   BreakStatement\012 //   ReturnStatement\012 //   WithStatement\012 //   LabelledStatement\012 //   SwitchStatement\012 //   ThrowStatement\012 //   TryStatement\012 //   DebuggerStatement\012\012 // {own_labels} is always a subset of {labels}.\012  DCHECK_IMPLIES(labels == nullptr, own_labels == nullptr);\012\012 // Note: Since labels can only be used by 'break' and 'continue'\012 // statements, which themselves are only valid within blocks,\012 // iterations or 'switch' statements (i.e., BreakableStatements),\012 // labels can be simply ignored in all other cases; except for\012 // trivial labeled break statements 'label: break label' which is\012 // parsed into an empty statement.\012 switch (peek()) {\012 case Token::LBRACE:\012 return ParseBlock(labels, ok);\012 case Token::SEMICOLON:\012 Next();\012 return factory()-&gt;NewEmptyStatement(kNoSourcePosition);\012 case Token::IF:\012 return ParseIfStatement(labels, ok);\012 case Token::DO:\012 return ParseDoWhileStatement(labels, own_labels, ok);\012 case Token::WHILE:\012 return ParseWhileStatement(labels, own_labels, ok);\012 case Token::FOR:\012 if (V8_UNLIKELY(is_async_function() &amp;&amp; PeekAhead() == Token::AWAIT)) {\012 return ParseForAwaitStatement(labels, own_labels, ok);\012 }\012 return ParseForStatement(labels, own_labels, ok);\012 case Token::CONTINUE:\012 return ParseContinueStatement(ok);\012 case Token::BREAK:\012 return ParseBreakStatement(labels, ok);\012 case Token::RETURN:\012 return ParseReturnStatement(ok);\012 case Token::THROW:\012 return ParseThrowStatement(ok);\012 case Token::TRY: {\012 // It is somewhat complicated to have labels on try-statements.\012 // When breaking out of a try-finally statement, one must take\012 // great care not to treat it as a fall-through. It is much easier\012 // just to wrap the entire try-statement in a statement block and\012 // put the labels there.\012 if (labels == nullptr) return ParseTryStatement(ok);\012 BlockT result = factory()-&gt;NewBlock(1, false, labels);\012 typename Types::Target target(this, result);\012 StatementT statement = ParseTryStatement(CHECK_OK);\012      result-&gt;statements()-&gt;Add(statement, zone());\012 return result;\012 }\012 case Token::WITH:\012 return ParseWithStatement(labels, ok);\012 case Token::SWITCH:\012 return ParseSwitchStatement(labels, ok);\012 case Token::FUNCTION:\012 // FunctionDeclaration only allowed as a StatementListItem, not in\012 // an arbitrary Statement position. Exceptions such as\012 // ES#sec-functiondeclarations-in-ifstatement-statement-clauses\012 // are handled by calling ParseScopedStatement rather than\012 // ParseStatement directly.\012      impl()-&gt;ReportMessageAt(scanner()-&gt;peek_location(),\012                              is_strict(language_mode())\012 ? MessageTemplate::kStrictFunction\012 : MessageTemplate::kSloppyFunction);\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 case Token::DEBUGGER:\012 return ParseDebuggerStatement(ok);\012 case Token::VAR:\012 return ParseVariableStatement(kStatement, nullptr, ok);\012 case Token::ASYNC:\012 if (!scanner()-&gt;HasLineTerminatorAfterNext() &amp;&amp;\012 PeekAhead() == Token::FUNCTION) {\012        impl()-&gt;ReportMessageAt(\012            scanner()-&gt;peek_location(),\012 MessageTemplate::kAsyncFunctionInSingleStatementContext);\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 }\012      V8_FALLTHROUGH;\012 default:\012 return ParseExpressionOrLabelledStatement(labels, own_labels,\012                                                allow_function, ok);\012 }\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::BlockT ParserBase&lt;Impl&gt;::ParseBlock(\012 ZonePtrList&lt;const AstRawString&gt;* labels, bool* ok) {\012 // Block ::\012 //   '{' StatementList '}'\012\012 // Construct block expecting 16 statements.\012 BlockT body = factory()-&gt;NewBlock(16, false, labels);\012\012 // Parse the statements and collect escaping labels.\012 Expect(Token::LBRACE, CHECK_OK_CUSTOM(NullStatement));\012 {\012 BlockState block_state(zone(), &amp;scope_);\012    scope()-&gt;set_start_position(scanner()-&gt;location().beg_pos);\012 typename Types::Target target(this, body);\012\012 while (peek() != Token::RBRACE) {\012 StatementT stat = ParseStatementListItem(CHECK_OK_CUSTOM(NullStatement));\012 if (!impl()-&gt;IsNull(stat) &amp;&amp; !stat-&gt;IsEmptyStatement()) {\012        body-&gt;statements()-&gt;Add(stat, zone());\012 }\012 }\012\012 Expect(Token::RBRACE, CHECK_OK_CUSTOM(NullStatement));\012 int end_pos = scanner()-&gt;location().end_pos;\012    scope()-&gt;set_end_position(end_pos);\012    impl()-&gt;RecordBlockSourceRange(body, end_pos);\012    body-&gt;set_scope(scope()-&gt;FinalizeBlockScope());\012 }\012 return body;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseScopedStatement(\012 ZonePtrList&lt;const AstRawString&gt;* labels, bool* ok) {\012 if (is_strict(language_mode()) || peek() != Token::FUNCTION) {\012 return ParseStatement(labels, nullptr, ok);\012 } else {\012 // Make a block around the statement for a lexical binding\012 // is introduced by a FunctionDeclaration.\012 BlockState block_state(zone(), &amp;scope_);\012    scope()-&gt;set_start_position(scanner()-&gt;location().beg_pos);\012 BlockT block = factory()-&gt;NewBlock(1, false);\012 StatementT body = ParseFunctionDeclaration(CHECK_OK);\012    block-&gt;statements()-&gt;Add(body, zone());\012    scope()-&gt;set_end_position(scanner()-&gt;location().end_pos);\012    block-&gt;set_scope(scope()-&gt;FinalizeBlockScope());\012 return block;\012 }\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseVariableStatement(\012 VariableDeclarationContext var_context,\012 ZonePtrList&lt;const AstRawString&gt;* names, bool* ok) {\012 // VariableStatement ::\012 //   VariableDeclarations ';'\012\012 // The scope of a var declared variable anywhere inside a function\012 // is the entire function (ECMA-262, 3rd, 10.1.3, and 12.2). Thus we can\012 // transform a source-level var declaration into a (Function) Scope\012 // declaration, and rewrite the source-level initialization into an assignment\012 // statement. We use a block to collect multiple assignments.\012 //\012 // We mark the block as initializer block because we don't want the\012 // rewriter to add a '.result' assignment to such a block (to get compliant\012 // behavior for code such as print(eval('var x = 7')), and for cosmetic\012 // reasons when pretty-printing. Also, unless an assignment (initialization)\012 // is inside an initializer block, it is ignored.\012\012 DeclarationParsingResult parsing_result;\012 StatementT result =\012 ParseVariableDeclarations(var_context, &amp;parsing_result, names, CHECK_OK);\012 ExpectSemicolon(CHECK_OK);\012 return result;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseDebuggerStatement(\012 bool* ok) {\012 // In ECMA-262 'debugger' is defined as a reserved keyword. In some browser\012 // contexts this is used as a statement which invokes the debugger as i a\012 // break point is present.\012 // DebuggerStatement ::\012 //   'debugger' ';'\012\012 int pos = peek_position();\012 Expect(Token::DEBUGGER, CHECK_OK);\012 ExpectSemicolon(CHECK_OK);\012 return factory()-&gt;NewDebuggerStatement(pos);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT\012ParserBase&lt;Impl&gt;::ParseExpressionOrLabelledStatement(\012 ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels,\012 AllowLabelledFunctionStatement allow_function, bool* ok) {\012 // ExpressionStatement | LabelledStatement ::\012 //   Expression ';'\012 //   Identifier ':' Statement\012 //\012 // ExpressionStatement[Yield] :\012 //   [lookahead notin {{, function, class, let [}] Expression[In, ?Yield] ;\012\012 int pos = peek_position();\012\012 switch (peek()) {\012 case Token::FUNCTION:\012 case Token::LBRACE:\012      UNREACHABLE(); // Always handled by the callers.\012 case Token::CLASS:\012 ReportUnexpectedToken(Next());\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 case Token::LET: {\012 Token::Value next_next = PeekAhead();\012 // &quot;let&quot; followed by either &quot;[&quot;, &quot;{&quot; or an identifier means a lexical\012 // declaration, which should not appear here.\012 // However, ASI may insert a line break before an identifier or a brace.\012 if (next_next != Token::LBRACK &amp;&amp;\012 ((next_next != Token::LBRACE &amp;&amp; next_next != Token::IDENTIFIER) ||\012           scanner_-&gt;HasLineTerminatorAfterNext())) {\012 break;\012 }\012      impl()-&gt;ReportMessageAt(scanner()-&gt;peek_location(),\012 MessageTemplate::kUnexpectedLexicalDeclaration);\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 }\012 default:\012 break;\012 }\012\012 bool starts_with_identifier = peek_any_identifier();\012 ExpressionT expr = ParseExpression(true, CHECK_OK);\012 if (peek() == Token::COLON &amp;&amp; starts_with_identifier &amp;&amp;\012      impl()-&gt;IsIdentifier(expr)) {\012 // The whole expression was a single identifier, and not, e.g.,\012 // something starting with an identifier or a parenthesized identifier.\012    impl()-&gt;DeclareLabel(&amp;labels, &amp;own_labels,\012                         impl()-&gt;AsIdentifierExpression(expr), CHECK_OK);\012 Consume(Token::COLON);\012 // ES#sec-labelled-function-declarations Labelled Function Declarations\012 if (peek() == Token::FUNCTION &amp;&amp; is_sloppy(language_mode()) &amp;&amp;\012        allow_function == kAllowLabelledFunctionStatement) {\012 return ParseFunctionDeclaration(ok);\012 }\012 return ParseStatement(labels, own_labels, allow_function, ok);\012 }\012\012 // If we have an extension, we allow a native function declaration.\012 // A native function declaration starts with &quot;native function&quot; with\012 // no line-terminator between the two words.\012 if (extension_ != nullptr &amp;&amp; peek() == Token::FUNCTION &amp;&amp;\012 !scanner()-&gt;HasLineTerminatorBeforeNext() &amp;&amp; impl()-&gt;IsNative(expr) &amp;&amp;\012 !scanner()-&gt;literal_contains_escapes()) {\012 return ParseNativeDeclaration(ok);\012 }\012\012 // Parsed expression statement, followed by semicolon.\012 ExpectSemicolon(CHECK_OK);\012 return factory()-&gt;NewExpressionStatement(expr, pos);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseIfStatement(\012 ZonePtrList&lt;const AstRawString&gt;* labels, bool* ok) {\012 // IfStatement ::\012 //   'if' '(' Expression ')' Statement ('else' Statement)?\012\012 int pos = peek_position();\012 Expect(Token::IF, CHECK_OK);\012 Expect(Token::LPAREN, CHECK_OK);\012 ExpressionT condition = ParseExpression(true, CHECK_OK);\012 Expect(Token::RPAREN, CHECK_OK);\012\012 SourceRange then_range, else_range;\012 StatementT then_statement = impl()-&gt;NullStatement();\012 {\012 SourceRangeScope range_scope(scanner(), &amp;then_range);\012    then_statement = ParseScopedStatement(labels, CHECK_OK);\012 }\012\012 StatementT else_statement = impl()-&gt;NullStatement();\012 if (Check(Token::ELSE)) {\012    else_range = SourceRange::ContinuationOf(then_range);\012    else_statement = ParseScopedStatement(labels, CHECK_OK);\012    else_range.end = scanner_-&gt;location().end_pos;\012 } else {\012    else_statement = factory()-&gt;NewEmptyStatement(kNoSourcePosition);\012 }\012 StatementT stmt =\012      factory()-&gt;NewIfStatement(condition, then_statement, else_statement, pos);\012  impl()-&gt;RecordIfStatementSourceRange(stmt, then_range, else_range);\012 return stmt;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseContinueStatement(\012 bool* ok) {\012 // ContinueStatement ::\012 //   'continue' Identifier? ';'\012\012 int pos = peek_position();\012 Expect(Token::CONTINUE, CHECK_OK);\012 IdentifierT label = impl()-&gt;NullIdentifier();\012 Token::Value tok = peek();\012 if (!scanner()-&gt;HasLineTerminatorBeforeNext() &amp;&amp; tok != Token::SEMICOLON &amp;&amp;\012      tok != Token::RBRACE &amp;&amp; tok != Token::EOS) {\012 // ECMA allows &quot;eval&quot; or &quot;arguments&quot; as labels even in strict mode.\012    label = ParseIdentifier(kAllowRestrictedIdentifiers, CHECK_OK);\012 }\012 typename Types::IterationStatement target =\012      impl()-&gt;LookupContinueTarget(label, CHECK_OK);\012 if (impl()-&gt;IsNull(target)) {\012 // Illegal continue statement.\012 MessageTemplate::Template message = MessageTemplate::kIllegalContinue;\012 typename Types::BreakableStatement breakable_target =\012        impl()-&gt;LookupBreakTarget(label, CHECK_OK);\012 if (impl()-&gt;IsNull(label)) {\012      message = MessageTemplate::kNoIterationStatement;\012 } else if (impl()-&gt;IsNull(breakable_target)) {\012      message = MessageTemplate::kUnknownLabel;\012 }\012 ReportMessage(message, label);\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 }\012 ExpectSemicolon(CHECK_OK);\012 StatementT stmt = factory()-&gt;NewContinueStatement(target, pos);\012  impl()-&gt;RecordJumpStatementSourceRange(stmt, scanner_-&gt;location().end_pos);\012 return stmt;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseBreakStatement(\012 ZonePtrList&lt;const AstRawString&gt;* labels, bool* ok) {\012 // BreakStatement ::\012 //   'break' Identifier? ';'\012\012 int pos = peek_position();\012 Expect(Token::BREAK, CHECK_OK);\012 IdentifierT label = impl()-&gt;NullIdentifier();\012 Token::Value tok = peek();\012 if (!scanner()-&gt;HasLineTerminatorBeforeNext() &amp;&amp; tok != Token::SEMICOLON &amp;&amp;\012      tok != Token::RBRACE &amp;&amp; tok != Token::EOS) {\012 // ECMA allows &quot;eval&quot; or &quot;arguments&quot; as labels even in strict mode.\012    label = ParseIdentifier(kAllowRestrictedIdentifiers, CHECK_OK);\012 }\012 // Parse labeled break statements that target themselves into\012 // empty statements, e.g. 'l1: l2: l3: break l2;'\012 if (!impl()-&gt;IsNull(label) &amp;&amp; impl()-&gt;ContainsLabel(labels, label)) {\012 ExpectSemicolon(CHECK_OK);\012 return factory()-&gt;NewEmptyStatement(pos);\012 }\012 typename Types::BreakableStatement target =\012      impl()-&gt;LookupBreakTarget(label, CHECK_OK);\012 if (impl()-&gt;IsNull(target)) {\012 // Illegal break statement.\012 MessageTemplate::Template message = MessageTemplate::kIllegalBreak;\012 if (!impl()-&gt;IsNull(label)) {\012      message = MessageTemplate::kUnknownLabel;\012 }\012 ReportMessage(message, label);\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 }\012 ExpectSemicolon(CHECK_OK);\012 StatementT stmt = factory()-&gt;NewBreakStatement(target, pos);\012  impl()-&gt;RecordJumpStatementSourceRange(stmt, scanner_-&gt;location().end_pos);\012 return stmt;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseReturnStatement(\012 bool* ok) {\012 // ReturnStatement ::\012 //   'return' [no line terminator] Expression? ';'\012\012 // Consume the return token. It is necessary to do that before\012 // reporting any errors on it, because of the way errors are\012 // reported (underlining).\012 Expect(Token::RETURN, CHECK_OK);\012 Scanner::Location loc = scanner()-&gt;location();\012\012 switch (GetDeclarationScope()-&gt;scope_type()) {\012 case SCRIPT_SCOPE:\012 case EVAL_SCOPE:\012 case MODULE_SCOPE:\012      impl()-&gt;ReportMessageAt(loc, MessageTemplate::kIllegalReturn);\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 default:\012 break;\012 }\012\012 Token::Value tok = peek();\012 ExpressionT return_value = impl()-&gt;NullExpression();\012 if (scanner()-&gt;HasLineTerminatorBeforeNext() || tok == Token::SEMICOLON ||\012      tok == Token::RBRACE || tok == Token::EOS) {\012 if (IsDerivedConstructor(function_state_-&gt;kind())) {\012      return_value = impl()-&gt;ThisExpression(loc.beg_pos);\012 }\012 } else {\012    return_value = ParseExpression(true, CHECK_OK);\012 }\012 ExpectSemicolon(CHECK_OK);\012  return_value = impl()-&gt;RewriteReturn(return_value, loc.beg_pos);\012 int continuation_pos = scanner_-&gt;location().end_pos;\012 StatementT stmt =\012 BuildReturnStatement(return_value, loc.beg_pos, continuation_pos);\012  impl()-&gt;RecordJumpStatementSourceRange(stmt, scanner_-&gt;location().end_pos);\012 return stmt;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseWithStatement(\012 ZonePtrList&lt;const AstRawString&gt;* labels, bool* ok) {\012 // WithStatement ::\012 //   'with' '(' Expression ')' Statement\012\012 Expect(Token::WITH, CHECK_OK);\012 int pos = position();\012\012 if (is_strict(language_mode())) {\012 ReportMessage(MessageTemplate::kStrictWith);\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 }\012\012 Expect(Token::LPAREN, CHECK_OK);\012 ExpressionT expr = ParseExpression(true, CHECK_OK);\012 Expect(Token::RPAREN, CHECK_OK);\012\012 Scope* with_scope = NewScope(WITH_SCOPE);\012 StatementT body = impl()-&gt;NullStatement();\012 {\012 BlockState block_state(&amp;scope_, with_scope);\012    with_scope-&gt;set_start_position(scanner()-&gt;peek_location().beg_pos);\012    body = ParseStatement(labels, nullptr, CHECK_OK);\012    with_scope-&gt;set_end_position(scanner()-&gt;location().end_pos);\012 }\012 return factory()-&gt;NewWithStatement(with_scope, expr, body, pos);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseDoWhileStatement(\012 ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels, bool* ok) {\012 // DoStatement ::\012 //   'do' Statement 'while' '(' Expression ')' ';'\012\012 auto loop =\012      factory()-&gt;NewDoWhileStatement(labels, own_labels, peek_position());\012 typename Types::Target target(this, loop);\012\012 SourceRange body_range;\012 StatementT body = impl()-&gt;NullStatement();\012\012 Expect(Token::DO, CHECK_OK);\012 {\012 SourceRangeScope range_scope(scanner(), &amp;body_range);\012    body = ParseStatement(nullptr, nullptr, CHECK_OK);\012 }\012 Expect(Token::WHILE, CHECK_OK);\012 Expect(Token::LPAREN, CHECK_OK);\012\012 ExpressionT cond = ParseExpression(true, CHECK_OK);\012 Expect(Token::RPAREN, CHECK_OK);\012\012 // Allow do-statements to be terminated with and without\012 // semi-colons. This allows code such as 'do;while(0)return' to\012 // parse, which would not be the case if we had used the\012 // ExpectSemicolon() functionality here.\012 Check(Token::SEMICOLON);\012\012  loop-&gt;Initialize(cond, body);\012  impl()-&gt;RecordIterationStatementSourceRange(loop, body_range);\012\012 return loop;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseWhileStatement(\012 ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels, bool* ok) {\012 // WhileStatement ::\012 //   'while' '(' Expression ')' Statement\012\012 auto loop = factory()-&gt;NewWhileStatement(labels, own_labels, peek_position());\012 typename Types::Target target(this, loop);\012\012 SourceRange body_range;\012 StatementT body = impl()-&gt;NullStatement();\012\012 Expect(Token::WHILE, CHECK_OK);\012 Expect(Token::LPAREN, CHECK_OK);\012 ExpressionT cond = ParseExpression(true, CHECK_OK);\012 Expect(Token::RPAREN, CHECK_OK);\012 {\012 SourceRangeScope range_scope(scanner(), &amp;body_range);\012    body = ParseStatement(nullptr, nullptr, CHECK_OK);\012 }\012\012  loop-&gt;Initialize(cond, body);\012  impl()-&gt;RecordIterationStatementSourceRange(loop, body_range);\012\012 return loop;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseThrowStatement(\012 bool* ok) {\012 // ThrowStatement ::\012 //   'throw' Expression ';'\012\012 Expect(Token::THROW, CHECK_OK);\012 int pos = position();\012 if (scanner()-&gt;HasLineTerminatorBeforeNext()) {\012 ReportMessage(MessageTemplate::kNewlineAfterThrow);\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 }\012 ExpressionT exception = ParseExpression(true, CHECK_OK);\012 ExpectSemicolon(CHECK_OK);\012\012 StatementT stmt = impl()-&gt;NewThrowStatement(exception, pos);\012  impl()-&gt;RecordThrowSourceRange(stmt, scanner_-&gt;location().end_pos);\012\012 return stmt;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseSwitchStatement(\012 ZonePtrList&lt;const AstRawString&gt;* labels, bool* ok) {\012 // SwitchStatement ::\012 //   'switch' '(' Expression ')' '{' CaseClause* '}'\012 // CaseClause ::\012 //   'case' Expression ':' StatementList\012 //   'default' ':' StatementList\012\012 int switch_pos = peek_position();\012\012 Expect(Token::SWITCH, CHECK_OK);\012 Expect(Token::LPAREN, CHECK_OK);\012 ExpressionT tag = ParseExpression(true, CHECK_OK);\012 Expect(Token::RPAREN, CHECK_OK);\012\012 auto switch_statement =\012      factory()-&gt;NewSwitchStatement(labels, tag, switch_pos);\012\012 {\012 BlockState cases_block_state(zone(), &amp;scope_);\012    scope()-&gt;set_start_position(switch_pos);\012    scope()-&gt;SetNonlinear();\012 typename Types::Target target(this, switch_statement);\012\012 bool default_seen = false;\012 Expect(Token::LBRACE, CHECK_OK);\012 while (peek() != Token::RBRACE) {\012 // An empty label indicates the default case.\012 ExpressionT label = impl()-&gt;NullExpression();\012 SourceRange clause_range;\012 SourceRangeScope range_scope(scanner(), &amp;clause_range);\012 if (Check(Token::CASE)) {\012        label = ParseExpression(true, CHECK_OK);\012 } else {\012 Expect(Token::DEFAULT, CHECK_OK);\012 if (default_seen) {\012 ReportMessage(MessageTemplate::kMultipleDefaultsInSwitch);\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 }\012        default_seen = true;\012 }\012 Expect(Token::COLON, CHECK_OK);\012 StatementListT statements = impl()-&gt;NewStatementList(5);\012 while (peek() != Token::CASE &amp;&amp; peek() != Token::DEFAULT &amp;&amp;\012             peek() != Token::RBRACE) {\012 StatementT stat = ParseStatementListItem(CHECK_OK);\012        statements-&gt;Add(stat, zone());\012 }\012 auto clause = factory()-&gt;NewCaseClause(label, statements);\012      impl()-&gt;RecordCaseClauseSourceRange(clause, range_scope.Finalize());\012      switch_statement-&gt;cases()-&gt;Add(clause, zone());\012 }\012 Expect(Token::RBRACE, CHECK_OK);\012\012 int end_position = scanner()-&gt;location().end_pos;\012    scope()-&gt;set_end_position(end_position);\012    impl()-&gt;RecordSwitchStatementSourceRange(switch_statement, end_position);\012 Scope* switch_scope = scope()-&gt;FinalizeBlockScope();\012 if (switch_scope != nullptr) {\012 return impl()-&gt;RewriteSwitchStatement(switch_statement, switch_scope);\012 }\012 return switch_statement;\012 }\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseTryStatement(\012 bool* ok) {\012 // TryStatement ::\012 //   'try' Block Catch\012 //   'try' Block Finally\012 //   'try' Block Catch Finally\012 //\012 // Catch ::\012 //   'catch' '(' Identifier ')' Block\012 //\012 // Finally ::\012 //   'finally' Block\012\012 Expect(Token::TRY, CHECK_OK);\012 int pos = position();\012\012 BlockT try_block = ParseBlock(nullptr, CHECK_OK);\012\012 CatchInfo catch_info(this);\012\012 if (peek() != Token::CATCH &amp;&amp; peek() != Token::FINALLY) {\012 ReportMessage(MessageTemplate::kNoCatchOrFinally);\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 }\012\012 SourceRange catch_range, finally_range;\012\012 BlockT catch_block = impl()-&gt;NullStatement();\012 {\012 SourceRangeScope catch_range_scope(scanner(), &amp;catch_range);\012 if (Check(Token::CATCH)) {\012 bool has_binding;\012      has_binding = Check(Token::LPAREN);\012\012 if (has_binding) {\012        catch_info.scope = NewScope(CATCH_SCOPE);\012        catch_info.scope-&gt;set_start_position(scanner()-&gt;location().beg_pos);\012\012 {\012 BlockState catch_block_state(&amp;scope_, catch_info.scope);\012\012          catch_block = factory()-&gt;NewBlock(16, false);\012\012 // Create a block scope to hold any lexical declarations created\012 // as part of destructuring the catch parameter.\012 {\012 BlockState catch_variable_block_state(zone(), &amp;scope_);\012            scope()-&gt;set_start_position(scanner()-&gt;location().beg_pos);\012\012 // This does not simply call ParsePrimaryExpression to avoid\012 // ExpressionFromIdentifier from being called in the first\012 // branch, which would introduce an unresolved symbol and mess\012 // with arrow function names.\012 if (peek_any_identifier()) {\012              catch_info.name =\012 ParseIdentifier(kDontAllowRestrictedIdentifiers, CHECK_OK);\012 } else {\012 ExpressionClassifier pattern_classifier(this);\012              catch_info.pattern = ParsePrimaryExpression(CHECK_OK);\012 ValidateBindingPattern(CHECK_OK);\012 }\012\012 Expect(Token::RPAREN, CHECK_OK);\012            impl()-&gt;RewriteCatchPattern(&amp;catch_info, CHECK_OK);\012 if (!impl()-&gt;IsNull(catch_info.init_block)) {\012              catch_block-&gt;statements()-&gt;Add(catch_info.init_block, zone());\012 }\012\012            catch_info.inner_block = ParseBlock(nullptr, CHECK_OK);\012            catch_block-&gt;statements()-&gt;Add(catch_info.inner_block, zone());\012            impl()-&gt;ValidateCatchBlock(catch_info, CHECK_OK);\012            scope()-&gt;set_end_position(scanner()-&gt;location().end_pos);\012            catch_block-&gt;set_scope(scope()-&gt;FinalizeBlockScope());\012 }\012 }\012\012        catch_info.scope-&gt;set_end_position(scanner()-&gt;location().end_pos);\012 } else {\012        catch_block = ParseBlock(nullptr, CHECK_OK);\012 }\012 }\012 }\012\012 BlockT finally_block = impl()-&gt;NullStatement();\012  DCHECK(peek() == Token::FINALLY || !impl()-&gt;IsNull(catch_block));\012 {\012 SourceRangeScope range_scope(scanner(), &amp;finally_range);\012 if (Check(Token::FINALLY)) {\012      finally_block = ParseBlock(nullptr, CHECK_OK);\012 }\012 }\012\012 return impl()-&gt;RewriteTryStatement(try_block, catch_block, catch_range,\012                                     finally_block, finally_range, catch_info,\012                                     pos);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseForStatement(\012 ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels, bool* ok) {\012 // Either a standard for loop\012 //   for (&lt;init&gt;; &lt;cond&gt;; &lt;next&gt;) { ... }\012 // or a for-each loop\012 //   for (&lt;each&gt; of|in &lt;iterable&gt;) { ... }\012 //\012 // We parse a declaration/expression after the 'for (' and then read the first\012 // expression/declaration before we know if this is a for or a for-each.\012\012 int stmt_pos = peek_position();\012 ForInfo for_info(this);\012\012 Expect(Token::FOR, CHECK_OK);\012 Expect(Token::LPAREN, CHECK_OK);\012\012 if (peek() == Token::CONST || (peek() == Token::LET &amp;&amp; IsNextLetKeyword())) {\012 // The initializer contains lexical declarations,\012 // so create an in-between scope.\012 BlockState for_state(zone(), &amp;scope_);\012    scope()-&gt;set_start_position(scanner()-&gt;location().beg_pos);\012\012 // Also record whether inner functions or evals are found inside\012 // this loop, as this information is used to simplify the desugaring\012 // if none are found.\012 typename FunctionState::FunctionOrEvalRecordingScope recording_scope(\012        function_state_);\012\012 // Create an inner block scope which will be the parent scope of scopes\012 // possibly created by ParseVariableDeclarations.\012 Scope* inner_block_scope = NewScope(BLOCK_SCOPE);\012 {\012 BlockState inner_state(&amp;scope_, inner_block_scope);\012 ParseVariableDeclarations(kForStatement, &amp;for_info.parsing_result,\012 nullptr, CHECK_OK);\012 }\012    DCHECK(IsLexicalVariableMode(for_info.parsing_result.descriptor.mode));\012    for_info.position = scanner()-&gt;location().beg_pos;\012\012 if (CheckInOrOf(&amp;for_info.mode)) {\012      scope()-&gt;set_is_hidden();\012 return ParseForEachStatementWithDeclarations(\012          stmt_pos, &amp;for_info, labels, own_labels, inner_block_scope, ok);\012 }\012\012 Expect(Token::SEMICOLON, CHECK_OK);\012\012 StatementT init = impl()-&gt;BuildInitializationBlock(\012 &amp;for_info.parsing_result, &amp;for_info.bound_names, CHECK_OK);\012\012 Scope* finalized = inner_block_scope-&gt;FinalizeBlockScope();\012 // No variable declarations will have been created in inner_block_scope.\012    DCHECK_NULL(finalized);\012    USE(finalized);\012 return ParseStandardForLoopWithLexicalDeclarations(\012        stmt_pos, init, &amp;for_info, labels, own_labels, ok);\012 }\012\012 StatementT init = impl()-&gt;NullStatement();\012 if (peek() == Token::VAR) {\012 ParseVariableDeclarations(kForStatement, &amp;for_info.parsing_result, nullptr,\012                              CHECK_OK);\012    DCHECK_EQ(for_info.parsing_result.descriptor.mode, VariableMode::kVar);\012    for_info.position = scanner()-&gt;location().beg_pos;\012\012 if (CheckInOrOf(&amp;for_info.mode)) {\012 return ParseForEachStatementWithDeclarations(stmt_pos, &amp;for_info, labels,\012                                                   own_labels, nullptr, ok);\012 }\012\012    init = impl()-&gt;BuildInitializationBlock(&amp;for_info.parsing_result, nullptr,\012                                            CHECK_OK);\012 } else if (peek() != Token::SEMICOLON) {\012 // The initializer does not contain declarations.\012 int lhs_beg_pos = peek_position();\012 ExpressionClassifier classifier(this);\012 ExpressionT expression = ParseExpressionCoverGrammar(false, CHECK_OK);\012 int lhs_end_pos = scanner()-&gt;location().end_pos;\012\012 bool is_for_each = CheckInOrOf(&amp;for_info.mode);\012 bool is_destructuring = is_for_each &amp;&amp; (expression-&gt;IsArrayLiteral() ||\012                                            expression-&gt;IsObjectLiteral());\012\012 if (is_destructuring) {\012 ValidateAssignmentPattern(CHECK_OK);\012 } else {\012 ValidateExpression(CHECK_OK);\012 }\012\012 if (is_for_each) {\012 return ParseForEachStatementWithoutDeclarations(\012          stmt_pos, expression, lhs_beg_pos, lhs_end_pos, &amp;for_info, labels,\012          own_labels, ok);\012 }\012 // Initializer is just an expression.\012    init = factory()-&gt;NewExpressionStatement(expression, lhs_beg_pos);\012 }\012\012 Expect(Token::SEMICOLON, CHECK_OK);\012\012 // Standard 'for' loop, we have parsed the initializer at this point.\012 ExpressionT cond = impl()-&gt;NullExpression();\012 StatementT next = impl()-&gt;NullStatement();\012 StatementT body = impl()-&gt;NullStatement();\012 ForStatementT loop = ParseStandardForLoop(stmt_pos, labels, own_labels, &amp;cond,\012 &amp;next, &amp;body, CHECK_OK);\012  loop-&gt;Initialize(init, cond, next, body);\012 return loop;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT\012ParserBase&lt;Impl&gt;::ParseForEachStatementWithDeclarations(\012 int stmt_pos, ForInfo* for_info, ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels, Scope* inner_block_scope,\012 bool* ok) {\012 // Just one declaration followed by in/of.\012 if (for_info-&gt;parsing_result.declarations.size() != 1) {\012    impl()-&gt;ReportMessageAt(for_info-&gt;parsing_result.bindings_loc,\012 MessageTemplate::kForInOfLoopMultiBindings,\012 ForEachStatement::VisitModeString(for_info-&gt;mode));\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 }\012 if (for_info-&gt;parsing_result.first_initializer_loc.IsValid() &amp;&amp;\012 (is_strict(language_mode()) ||\012       for_info-&gt;mode == ForEachStatement::ITERATE ||\012 IsLexicalVariableMode(for_info-&gt;parsing_result.descriptor.mode) ||\012 !impl()-&gt;IsIdentifier(\012           for_info-&gt;parsing_result.declarations[0].pattern))) {\012    impl()-&gt;ReportMessageAt(for_info-&gt;parsing_result.first_initializer_loc,\012 MessageTemplate::kForInOfLoopInitializer,\012 ForEachStatement::VisitModeString(for_info-&gt;mode));\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 }\012\012 // Reset the declaration_kind to ensure proper processing during declaration.\012  for_info-&gt;parsing_result.descriptor.declaration_kind =\012 DeclarationDescriptor::FOR_EACH;\012\012 BlockT init_block = impl()-&gt;RewriteForVarInLegacy(*for_info);\012\012 auto loop = factory()-&gt;NewForEachStatement(for_info-&gt;mode, labels, own_labels,\012                                             stmt_pos);\012 typename Types::Target target(this, loop);\012\012 ExpressionT enumerable = impl()-&gt;NullExpression();\012 if (for_info-&gt;mode == ForEachStatement::ITERATE) {\012 ExpressionClassifier classifier(this);\012    enumerable = ParseAssignmentExpression(true, CHECK_OK);\012 ValidateExpression(CHECK_OK);\012 } else {\012    enumerable = ParseExpression(true, CHECK_OK);\012 }\012\012 Expect(Token::RPAREN, CHECK_OK);\012\012 Scope* for_scope = nullptr;\012 if (inner_block_scope != nullptr) {\012    for_scope = inner_block_scope-&gt;outer_scope();\012    DCHECK(for_scope == scope());\012    inner_block_scope-&gt;set_start_position(scanner()-&gt;location().beg_pos);\012 }\012\012 ExpressionT each_variable = impl()-&gt;NullExpression();\012 BlockT body_block = impl()-&gt;NullStatement();\012 {\012 BlockState block_state(\012 &amp;scope_, inner_block_scope != nullptr ? inner_block_scope : scope_);\012\012 SourceRange body_range;\012 SourceRangeScope range_scope(scanner(), &amp;body_range);\012\012 StatementT body = ParseStatement(nullptr, nullptr, CHECK_OK);\012    impl()-&gt;RecordIterationStatementSourceRange(loop, range_scope.Finalize());\012\012    impl()-&gt;DesugarBindingInForEachStatement(for_info, &amp;body_block,\012 &amp;each_variable, CHECK_OK);\012    body_block-&gt;statements()-&gt;Add(body, zone());\012\012 if (inner_block_scope != nullptr) {\012      inner_block_scope-&gt;set_end_position(scanner()-&gt;location().end_pos);\012      body_block-&gt;set_scope(inner_block_scope-&gt;FinalizeBlockScope());\012 }\012 }\012\012 StatementT final_loop = impl()-&gt;InitializeForEachStatement(\012      loop, each_variable, enumerable, body_block);\012\012  init_block = impl()-&gt;CreateForEachStatementTDZ(init_block, *for_info, ok);\012\012 if (for_scope != nullptr) {\012    for_scope-&gt;set_end_position(scanner()-&gt;location().end_pos);\012    for_scope = for_scope-&gt;FinalizeBlockScope();\012 }\012\012 // Parsed for-in loop w/ variable declarations.\012 if (!impl()-&gt;IsNull(init_block)) {\012    init_block-&gt;statements()-&gt;Add(final_loop, zone());\012    init_block-&gt;set_scope(for_scope);\012 return init_block;\012 }\012\012  DCHECK_NULL(for_scope);\012 return final_loop;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT\012ParserBase&lt;Impl&gt;::ParseForEachStatementWithoutDeclarations(\012 int stmt_pos, ExpressionT expression, int lhs_beg_pos, int lhs_end_pos,\012 ForInfo* for_info, ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels, bool* ok) {\012 // Initializer is reference followed by in/of.\012 if (!expression-&gt;IsArrayLiteral() &amp;&amp; !expression-&gt;IsObjectLiteral()) {\012    expression = CheckAndRewriteReferenceExpression(\012        expression, lhs_beg_pos, lhs_end_pos, MessageTemplate::kInvalidLhsInFor,\012        kSyntaxError, CHECK_OK);\012 }\012\012 auto loop = factory()-&gt;NewForEachStatement(for_info-&gt;mode, labels, own_labels,\012                                             stmt_pos);\012 typename Types::Target target(this, loop);\012\012 ExpressionT enumerable = impl()-&gt;NullExpression();\012 if (for_info-&gt;mode == ForEachStatement::ITERATE) {\012 ExpressionClassifier classifier(this);\012    enumerable = ParseAssignmentExpression(true, CHECK_OK);\012 ValidateExpression(CHECK_OK);\012 } else {\012    enumerable = ParseExpression(true, CHECK_OK);\012 }\012\012 Expect(Token::RPAREN, CHECK_OK);\012\012 StatementT body = impl()-&gt;NullStatement();\012 {\012 SourceRange body_range;\012 SourceRangeScope range_scope(scanner(), &amp;body_range);\012\012    body = ParseStatement(nullptr, nullptr, CHECK_OK);\012    impl()-&gt;RecordIterationStatementSourceRange(loop, range_scope.Finalize());\012 }\012 return impl()-&gt;InitializeForEachStatement(loop, expression, enumerable, body);\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT\012ParserBase&lt;Impl&gt;::ParseStandardForLoopWithLexicalDeclarations(\012 int stmt_pos, StatementT init, ForInfo* for_info,\012 ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels, bool* ok) {\012 // The condition and the next statement of the for loop must be parsed\012 // in a new scope.\012 Scope* inner_scope = NewScope(BLOCK_SCOPE);\012 ForStatementT loop = impl()-&gt;NullStatement();\012 ExpressionT cond = impl()-&gt;NullExpression();\012 StatementT next = impl()-&gt;NullStatement();\012 StatementT body = impl()-&gt;NullStatement();\012 {\012 BlockState block_state(&amp;scope_, inner_scope);\012    scope()-&gt;set_start_position(scanner()-&gt;location().beg_pos);\012    loop = ParseStandardForLoop(stmt_pos, labels, own_labels, &amp;cond, &amp;next,\012 &amp;body, CHECK_OK);\012    scope()-&gt;set_end_position(scanner()-&gt;location().end_pos);\012 }\012\012  scope()-&gt;set_end_position(scanner()-&gt;location().end_pos);\012 if (for_info-&gt;bound_names.length() &gt; 0 &amp;&amp;\012      function_state_-&gt;contains_function_or_eval()) {\012    scope()-&gt;set_is_hidden();\012 return impl()-&gt;DesugarLexicalBindingsInForStatement(\012        loop, init, cond, next, body, inner_scope, *for_info, ok);\012 } else {\012    inner_scope = inner_scope-&gt;FinalizeBlockScope();\012    DCHECK_NULL(inner_scope);\012    USE(inner_scope);\012 }\012\012 Scope* for_scope = scope()-&gt;FinalizeBlockScope();\012 if (for_scope != nullptr) {\012 // Rewrite a for statement of the form\012 //   for (const x = i; c; n) b\012 //\012 // into\012 //\012 //   {\012 //     const x = i;\012 //     for (; c; n) b\012 //   }\012 //\012    DCHECK(!impl()-&gt;IsNull(init));\012 BlockT block = factory()-&gt;NewBlock(2, false);\012    block-&gt;statements()-&gt;Add(init, zone());\012    block-&gt;statements()-&gt;Add(loop, zone());\012    block-&gt;set_scope(for_scope);\012    loop-&gt;Initialize(impl()-&gt;NullStatement(), cond, next, body);\012 return block;\012 }\012\012  loop-&gt;Initialize(init, cond, next, body);\012 return loop;\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::ForStatementT ParserBase&lt;Impl&gt;::ParseStandardForLoop(\012 int stmt_pos, ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels, ExpressionT* cond,\012 StatementT* next, StatementT* body, bool* ok) {\012 ForStatementT loop = factory()-&gt;NewForStatement(labels, own_labels, stmt_pos);\012 typename Types::Target target(this, loop);\012\012 if (peek() != Token::SEMICOLON) {\012 *cond = ParseExpression(true, CHECK_OK);\012 }\012 Expect(Token::SEMICOLON, CHECK_OK);\012\012 if (peek() != Token::RPAREN) {\012 ExpressionT exp = ParseExpression(true, CHECK_OK);\012 *next = factory()-&gt;NewExpressionStatement(exp, exp-&gt;position());\012 }\012 Expect(Token::RPAREN, CHECK_OK);\012\012 SourceRange body_range;\012 {\012 SourceRangeScope range_scope(scanner(), &amp;body_range);\012 *body = ParseStatement(nullptr, nullptr, CHECK_OK);\012 }\012  impl()-&gt;RecordIterationStatementSourceRange(loop, body_range);\012\012 return loop;\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::MarkLoopVariableAsAssigned(\012 Scope* scope, Variable* var,\012 typename DeclarationDescriptor::Kind declaration_kind) {\012 if (!IsLexicalVariableMode(var-&gt;mode()) &amp;&amp;\012 (!scope-&gt;is_function_scope() ||\012       declaration_kind == DeclarationDescriptor::FOR_EACH)) {\012 var-&gt;set_maybe_assigned();\012 }\012}\012\012template &lt;typename Impl&gt;\012typename ParserBase&lt;Impl&gt;::StatementT ParserBase&lt;Impl&gt;::ParseForAwaitStatement(\012 ZonePtrList&lt;const AstRawString&gt;* labels,\012 ZonePtrList&lt;const AstRawString&gt;* own_labels, bool* ok) {\012 // for await '(' ForDeclaration of AssignmentExpression ')'\012  DCHECK(is_async_function());\012\012 int stmt_pos = peek_position();\012\012 ForInfo for_info(this);\012  for_info.mode = ForEachStatement::ITERATE;\012\012 // Create an in-between scope for let-bound iteration variables.\012 BlockState for_state(zone(), &amp;scope_);\012 Expect(Token::FOR, CHECK_OK);\012 Expect(Token::AWAIT, CHECK_OK);\012 Expect(Token::LPAREN, CHECK_OK);\012  scope()-&gt;set_start_position(scanner()-&gt;location().beg_pos);\012  scope()-&gt;set_is_hidden();\012\012 auto loop = factory()-&gt;NewForOfStatement(labels, own_labels, stmt_pos);\012 typename Types::Target target(this, loop);\012\012 ExpressionT each_variable = impl()-&gt;NullExpression();\012\012 bool has_declarations = false;\012 Scope* inner_block_scope = NewScope(BLOCK_SCOPE);\012\012 if (peek() == Token::VAR || peek() == Token::CONST ||\012 (peek() == Token::LET &amp;&amp; IsNextLetKeyword())) {\012 // The initializer contains declarations\012 // 'for' 'await' '(' ForDeclaration 'of' AssignmentExpression ')'\012 //     Statement\012 // 'for' 'await' '(' 'var' ForBinding 'of' AssignmentExpression ')'\012 //     Statement\012    has_declarations = true;\012\012 {\012 BlockState inner_state(&amp;scope_, inner_block_scope);\012 ParseVariableDeclarations(kForStatement, &amp;for_info.parsing_result,\012 nullptr, CHECK_OK);\012 }\012    for_info.position = scanner()-&gt;location().beg_pos;\012\012 // Only a single declaration is allowed in for-await-of loops\012 if (for_info.parsing_result.declarations.size() != 1) {\012      impl()-&gt;ReportMessageAt(for_info.parsing_result.bindings_loc,\012 MessageTemplate::kForInOfLoopMultiBindings,\012 &quot;for-await-of&quot;);\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 }\012\012 // for-await-of's declarations do not permit initializers.\012 if (for_info.parsing_result.first_initializer_loc.IsValid()) {\012      impl()-&gt;ReportMessageAt(for_info.parsing_result.first_initializer_loc,\012 MessageTemplate::kForInOfLoopInitializer,\012 &quot;for-await-of&quot;);\012 *ok = false;\012 return impl()-&gt;NullStatement();\012 }\012 } else {\012 // The initializer does not contain declarations.\012 // 'for' 'await' '(' LeftHandSideExpression 'of' AssignmentExpression ')'\012 //     Statement\012 int lhs_beg_pos = peek_position();\012 BlockState inner_state(&amp;scope_, inner_block_scope);\012 ExpressionClassifier classifier(this);\012 ExpressionT lhs = each_variable = ParseLeftHandSideExpression(CHECK_OK);\012 int lhs_end_pos = scanner()-&gt;location().end_pos;\012\012 if (lhs-&gt;IsArrayLiteral() || lhs-&gt;IsObjectLiteral()) {\012 ValidateAssignmentPattern(CHECK_OK);\012 } else {\012 ValidateExpression(CHECK_OK);\012      each_variable = CheckAndRewriteReferenceExpression(\012          lhs, lhs_beg_pos, lhs_end_pos, MessageTemplate::kInvalidLhsInFor,\012          kSyntaxError, CHECK_OK);\012 }\012 }\012\012 ExpectContextualKeyword(Token::OF, CHECK_OK);\012 int each_keyword_pos = scanner()-&gt;location().beg_pos;\012\012 const bool kAllowIn = true;\012 ExpressionT iterable = impl()-&gt;NullExpression();\012\012 {\012 ExpressionClassifier classifier(this);\012    iterable = ParseAssignmentExpression(kAllowIn, CHECK_OK);\012 ValidateExpression(CHECK_OK);\012 }\012\012 Expect(Token::RPAREN, CHECK_OK);\012\012 StatementT body = impl()-&gt;NullStatement();\012 {\012 BlockState block_state(&amp;scope_, inner_block_scope);\012    scope()-&gt;set_start_position(scanner()-&gt;location().beg_pos);\012\012 SourceRange body_range;\012 SourceRangeScope range_scope(scanner(), &amp;body_range);\012\012    body = ParseStatement(nullptr, nullptr, CHECK_OK);\012    scope()-&gt;set_end_position(scanner()-&gt;location().end_pos);\012    impl()-&gt;RecordIterationStatementSourceRange(loop, range_scope.Finalize());\012\012 if (has_declarations) {\012 BlockT body_block = impl()-&gt;NullStatement();\012      impl()-&gt;DesugarBindingInForEachStatement(&amp;for_info, &amp;body_block,\012 &amp;each_variable, CHECK_OK);\012      body_block-&gt;statements()-&gt;Add(body, zone());\012      body_block-&gt;set_scope(scope()-&gt;FinalizeBlockScope());\012      body = body_block;\012 } else {\012 Scope* block_scope = scope()-&gt;FinalizeBlockScope();\012      DCHECK_NULL(block_scope);\012      USE(block_scope);\012 }\012 }\012 const bool finalize = true;\012 StatementT final_loop = impl()-&gt;InitializeForOfStatement(\012      loop, each_variable, iterable, body, finalize, IteratorType::kAsync,\012      each_keyword_pos);\012\012 if (!has_declarations) {\012 Scope* for_scope = scope()-&gt;FinalizeBlockScope();\012    DCHECK_NULL(for_scope);\012    USE(for_scope);\012 return final_loop;\012 }\012\012 BlockT init_block =\012      impl()-&gt;CreateForEachStatementTDZ(impl()-&gt;NullStatement(), for_info, ok);\012\012  scope()-&gt;set_end_position(scanner()-&gt;location().end_pos);\012 Scope* for_scope = scope()-&gt;FinalizeBlockScope();\012 // Parsed for-in loop w/ variable declarations.\012 if (!impl()-&gt;IsNull(init_block)) {\012    init_block-&gt;statements()-&gt;Add(final_loop, zone());\012    init_block-&gt;set_scope(for_scope);\012 return init_block;\012 }\012  DCHECK_NULL(for_scope);\012 return final_loop;\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::ObjectLiteralChecker::CheckDuplicateProto(\012 Token::Value property) {\012 if (property == Token::SMI || property == Token::NUMBER) return;\012\012 if (IsProto()) {\012 if (has_seen_proto_) {\012 this-&gt;parser()-&gt;classifier()-&gt;RecordExpressionError(\012 this-&gt;scanner()-&gt;location(), MessageTemplate::kDuplicateProto);\012 return;\012 }\012    has_seen_proto_ = true;\012 }\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::ClassLiteralChecker::CheckClassMethodName(\012 Token::Value property, PropertyKind type, bool is_generator, bool is_async,\012 bool is_static, bool* ok) {\012  DCHECK(type == PropertyKind::kMethodProperty ||\012         type == PropertyKind::kAccessorProperty);\012\012 if (property == Token::SMI || property == Token::NUMBER) return;\012\012 if (is_static) {\012 if (IsPrototype()) {\012 this-&gt;parser()-&gt;ReportMessage(MessageTemplate::kStaticPrototype);\012 *ok = false;\012 return;\012 }\012 } else if (IsConstructor()) {\012 if (is_generator || is_async || type == PropertyKind::kAccessorProperty) {\012 MessageTemplate::Template msg =\012          is_generator ? MessageTemplate::kConstructorIsGenerator\012 : is_async ? MessageTemplate::kConstructorIsAsync\012 : MessageTemplate::kConstructorIsAccessor;\012 this-&gt;parser()-&gt;ReportMessage(msg);\012 *ok = false;\012 return;\012 }\012 if (has_seen_constructor_) {\012 this-&gt;parser()-&gt;ReportMessage(MessageTemplate::kDuplicateConstructor);\012 *ok = false;\012 return;\012 }\012    has_seen_constructor_ = true;\012 return;\012 }\012}\012\012template &lt;typename Impl&gt;\012void ParserBase&lt;Impl&gt;::ClassLiteralChecker::CheckClassFieldName(bool is_static,\012 bool* ok) {\012 if (is_static &amp;&amp; IsPrototype()) {\012 this-&gt;parser()-&gt;ReportMessage(MessageTemplate::kStaticPrototype);\012 *ok = false;\012 return;\012 }\012\012 if (IsConstructor() || IsPrivateConstructor()) {\012 this-&gt;parser()-&gt;ReportMessage(MessageTemplate::kConstructorClassField);\012 *ok = false;\012 return;\012 }\012}\012\012#undef CHECK_OK\012#undef CHECK_OK_CUSTOM\012#undef CHECK_OK_VOID\012\012} // namespace internal\012})<SUB>26</SUB>> ]
 "12" [label = <(METHOD,&lt;global&gt;)<SUB>1</SUB>> ]
 "15" [label = <(METHOD_RETURN,ANY)<SUB>1</SUB>> ]
   "14" -> "15" 
diff -bur /home/mrt3acher/thesis-implementation/.avuln-workdir/code/CVE-2021-0396_1/secure/out/2-cfg.dot /home/mrt3acher/thesis-implementation/.avuln-workdir/code/CVE-2021-0396_1/vulnerable/out/2-cfg.dot
--- /home/mrt3acher/thesis-implementation/.avuln-workdir/code/CVE-2021-0396_1/secure/out/2-cfg.dot	2023-06-07 19:36:12.337380745 +0330
+++ /home/mrt3acher/thesis-implementation/.avuln-workdir/code/CVE-2021-0396_1/vulnerable/out/2-cfg.dot	2023-06-07 19:36:15.797380509 +0330
@@ -1,5 +1,5 @@
 digraph "&lt;global&gt;" {  
-"9" [label = <(UNKNOWN,namespace v8 {\012namespace internal {\012namespace wasm {\012class WasmCode;\012}\012\012// Forward declarations.\012class AbstractCode;\012class FrameArray;\012class JSMessageObject;\012class LookupIterator;\012class SharedFunctionInfo;\012class SourceInfo;\012class WasmInstanceObject;\012\012class MessageLocation {\012 public:\012 MessageLocation(Handle&lt;Script&gt; script, int start_pos, int end_pos);\012 MessageLocation(Handle&lt;Script&gt; script, int start_pos, int end_pos,\012 Handle&lt;SharedFunctionInfo&gt; shared);\012 MessageLocation();\012\012 Handle&lt;Script&gt; script() const { return script_; }\012 int start_pos() const { return start_pos_; }\012 int end_pos() const { return end_pos_; }\012 Handle&lt;SharedFunctionInfo&gt; shared() const { return shared_; }\012\012 private:\012 Handle&lt;Script&gt; script_;\012 int start_pos_;\012 int end_pos_;\012 Handle&lt;SharedFunctionInfo&gt; shared_;\012};\012\012class StackFrameBase {\012 public:\012 virtual ~StackFrameBase() {}\012\012 virtual Handle&lt;Object&gt; GetReceiver() const = 0;\012 virtual Handle&lt;Object&gt; GetFunction() const = 0;\012\012 virtual Handle&lt;Object&gt; GetFileName() = 0;\012 virtual Handle&lt;Object&gt; GetFunctionName() = 0;\012 virtual Handle&lt;Object&gt; GetScriptNameOrSourceUrl() = 0;\012 virtual Handle&lt;Object&gt; GetMethodName() = 0;\012 virtual Handle&lt;Object&gt; GetTypeName() = 0;\012 virtual Handle&lt;Object&gt; GetEvalOrigin();\012\012 virtual int GetPosition() const = 0;\012 // Return 1-based line number, including line offset.\012 virtual int GetLineNumber() = 0;\012 // Return 1-based column number, including column offset if first line.\012 virtual int GetColumnNumber() = 0;\012\012 virtual bool IsNative() = 0;\012 virtual bool IsToplevel() = 0;\012 virtual bool IsEval();\012 virtual bool IsConstructor() = 0;\012 virtual bool IsStrict() const = 0;\012\012 virtual MaybeHandle&lt;String&gt; ToString() = 0;\012\012 protected:\012 StackFrameBase() {}\012 explicit StackFrameBase(Isolate* isolate) : isolate_(isolate) {}\012 Isolate* isolate_;\012\012 private:\012 virtual bool HasScript() const = 0;\012 virtual Handle&lt;Script&gt; GetScript() const = 0;\012};\012\012class JSStackFrame : public StackFrameBase {\012 public:\012 JSStackFrame(Isolate* isolate, Handle&lt;Object&gt; receiver,\012 Handle&lt;JSFunction&gt; function, Handle&lt;AbstractCode&gt; code,\012 int offset);\012 virtual ~JSStackFrame() {}\012\012 Handle&lt;Object&gt; GetReceiver() const override { return receiver_; }\012 Handle&lt;Object&gt; GetFunction() const override;\012\012 Handle&lt;Object&gt; GetFileName() override;\012 Handle&lt;Object&gt; GetFunctionName() override;\012 Handle&lt;Object&gt; GetScriptNameOrSourceUrl() override;\012 Handle&lt;Object&gt; GetMethodName() override;\012 Handle&lt;Object&gt; GetTypeName() override;\012\012 int GetPosition() const override;\012 int GetLineNumber() override;\012 int GetColumnNumber() override;\012\012 bool IsNative() override;\012 bool IsToplevel() override;\012 bool IsConstructor() override { return is_constructor_; }\012 bool IsStrict() const override { return is_strict_; }\012\012 MaybeHandle&lt;String&gt; ToString() override;\012\012 private:\012 JSStackFrame();\012 void FromFrameArray(Isolate* isolate, Handle&lt;FrameArray&gt; array, int frame_ix);\012\012 bool HasScript() const override;\012 Handle&lt;Script&gt; GetScript() const override;\012\012 Handle&lt;Object&gt; receiver_;\012 Handle&lt;JSFunction&gt; function_;\012 Handle&lt;AbstractCode&gt; code_;\012 int offset_;\012\012 bool is_constructor_;\012 bool is_strict_;\012\012 friend class FrameArrayIterator;\012};\012\012class WasmStackFrame : public StackFrameBase {\012 public:\012 virtual ~WasmStackFrame() {}\012\012 Handle&lt;Object&gt; GetReceiver() const override;\012 Handle&lt;Object&gt; GetFunction() const override;\012\012 Handle&lt;Object&gt; GetFileName() override { return Null(); }\012 Handle&lt;Object&gt; GetFunctionName() override;\012 Handle&lt;Object&gt; GetScriptNameOrSourceUrl() override { return Null(); }\012 Handle&lt;Object&gt; GetMethodName() override { return Null(); }\012 Handle&lt;Object&gt; GetTypeName() override { return Null(); }\012\012 int GetPosition() const override;\012 int GetLineNumber() override { return wasm_func_index_; }\012 int GetColumnNumber() override { return -1; }\012\012 bool IsNative() override { return false; }\012 bool IsToplevel() override { return false; }\012 bool IsConstructor() override { return false; }\012 bool IsStrict() const override { return false; }\012 bool IsInterpreted() const { return code_ == nullptr; }\012\012 MaybeHandle&lt;String&gt; ToString() override;\012\012 protected:\012 Handle&lt;Object&gt; Null() const;\012\012 bool HasScript() const override;\012 Handle&lt;Script&gt; GetScript() const override;\012\012 Handle&lt;WasmInstanceObject&gt; wasm_instance_;\012 uint32_t wasm_func_index_;\012  wasm::WasmCode* code_; // null for interpreted frames.\012 int offset_;\012\012 private:\012 WasmStackFrame();\012 void FromFrameArray(Isolate* isolate, Handle&lt;FrameArray&gt; array, int frame_ix);\012\012 friend class FrameArrayIterator;\012 friend class AsmJsWasmStackFrame;\012};\012\012class AsmJsWasmStackFrame : public WasmStackFrame {\012 public:\012 virtual ~AsmJsWasmStackFrame() {}\012\012 Handle&lt;Object&gt; GetReceiver() const override;\012 Handle&lt;Object&gt; GetFunction() const override;\012\012 Handle&lt;Object&gt; GetFileName() override;\012 Handle&lt;Object&gt; GetScriptNameOrSourceUrl() override;\012\012 int GetPosition() const override;\012 int GetLineNumber() override;\012 int GetColumnNumber() override;\012\012 MaybeHandle&lt;String&gt; ToString() override;\012\012 private:\012 friend class FrameArrayIterator;\012 AsmJsWasmStackFrame();\012 void FromFrameArray(Isolate* isolate, Handle&lt;FrameArray&gt; array, int frame_ix);\012\012 bool is_at_number_conversion_;\012};\012\012class FrameArrayIterator {\012 public:\012 FrameArrayIterator(Isolate* isolate, Handle&lt;FrameArray&gt; array,\012 int frame_ix = 0);\012\012 StackFrameBase* Frame();\012\012 bool HasNext() const;\012 void Next();\012\012 private:\012 Isolate* isolate_;\012\012 Handle&lt;FrameArray&gt; array_;\012 int next_frame_ix_;\012\012 WasmStackFrame wasm_frame_;\012 AsmJsWasmStackFrame asm_wasm_frame_;\012 JSStackFrame js_frame_;\012};\012\012// Determines how stack trace collection skips frames.\012enum FrameSkipMode {\012 // Unconditionally skips the first frame. Used e.g. when the Error constructor\012 // is called, in which case the first frame is always a BUILTIN_EXIT frame.\012  SKIP_FIRST,\012 // Skip all frames until a specified caller function is seen.\012  SKIP_UNTIL_SEEN,\012  SKIP_NONE,\012};\012\012class ErrorUtils : public AllStatic {\012 public:\012 static MaybeHandle&lt;Object&gt; Construct(\012 Isolate* isolate, Handle&lt;JSFunction&gt; target, Handle&lt;Object&gt; new_target,\012 Handle&lt;Object&gt; message, FrameSkipMode mode, Handle&lt;Object&gt; caller,\012 bool suppress_detailed_trace);\012\012 static MaybeHandle&lt;String&gt; ToString(Isolate* isolate, Handle&lt;Object&gt; recv);\012\012 static MaybeHandle&lt;Object&gt; MakeGenericError(\012 Isolate* isolate, Handle&lt;JSFunction&gt; constructor, int template_index,\012 Handle&lt;Object&gt; arg0, Handle&lt;Object&gt; arg1, Handle&lt;Object&gt; arg2,\012 FrameSkipMode mode);\012\012 // Formats a textual stack trace from the given structured stack trace.\012 // Note that this can call arbitrary JS code through Error.prepareStackTrace.\012 static MaybeHandle&lt;Object&gt; FormatStackTrace(Isolate* isolate,\012 Handle&lt;JSObject&gt; error,\012 Handle&lt;Object&gt; stack_trace);\012};\012\012#define MESSAGE_TEMPLATES(T)                                                   \\012 /* Error */                                                                  \\012  T(None, &quot;&quot;)                                                                  \\012  T(CyclicProto, &quot;Cyclic __proto__ value&quot;)                                     \\012  T(Debugger, &quot;Debugger: %&quot;)                                                   \\012  T(DebuggerLoading, &quot;Error loading debugger&quot;)                                 \\012  T(DefaultOptionsMissing, &quot;Internal % error. Default options are missing.&quot;)   \\012  T(DeletePrivateField, &quot;Private fields can not be deleted&quot;)                   \\012  T(UncaughtException, &quot;Uncaught %&quot;)                                           \\012  T(Unsupported, &quot;Not supported&quot;)                                              \\012  T(WrongServiceType, &quot;Internal error, wrong service type: %&quot;)                 \\012  T(WrongValueType, &quot;Internal error. Wrong value type.&quot;)                       \\012  T(IcuError, &quot;Internal error. Icu error.&quot;)                                    \\012 /* TypeError */                                                              \\012  T(ApplyNonFunction,                                                          \\012 &quot;Function.prototype.apply was called on %, which is a % and not a &quot;        \\012 &quot;function&quot;)                                                                \\012  T(ArgumentsDisallowedInInitializer,                                          \\012 &quot;'arguments' is not allowed in class field initializer&quot;)                   \\012  T(ArrayBufferTooShort,                                                       \\012 &quot;Derived ArrayBuffer constructor created a buffer which was too small&quot;)    \\012  T(ArrayBufferSpeciesThis,                                                    \\012 &quot;ArrayBuffer subclass returned this from species constructor&quot;)             \\012  T(ArrayItemNotType, &quot;array %[%] is not type %&quot;)                              \\012  T(AwaitNotInAsyncFunction, &quot;await is only valid in async function&quot;)          \\012  T(AtomicsWaitNotAllowed, &quot;Atomics.wait cannot be called in this context&quot;)    \\012  T(BadSortComparisonFunction,                                                 \\012 &quot;The comparison function must be either a function or undefined&quot;)          \\012  T(BigIntFromNumber,                                                          \\012 &quot;The number % cannot be converted to a BigInt because it is not an &quot;       \\012 &quot;integer&quot;)                                                                 \\012  T(BigIntFromObject, &quot;Cannot convert % to a BigInt&quot;)                          \\012  T(BigIntMixedTypes,                                                          \\012 &quot;Cannot mix BigInt and other types, use explicit conversions&quot;)             \\012  T(BigIntSerializeJSON, &quot;Do not know how to serialize a BigInt&quot;)              \\012  T(BigIntShr, &quot;BigInts have no unsigned right shift, use &gt;&gt; instead&quot;)         \\012  T(BigIntToNumber, &quot;Cannot convert a BigInt value to a number&quot;)               \\012  T(CalledNonCallable, &quot;% is not a function&quot;)                                  \\012  T(CalledOnNonObject, &quot;% called on non-object&quot;)                               \\012  T(CalledOnNullOrUndefined, &quot;% called on null or undefined&quot;)                  \\012  T(CallSiteExpectsFunction,                                                   \\012 &quot;CallSite expects wasm object as first or function as second argument, &quot;   \\012 &quot;got &lt;%, %&gt;&quot;)                                                              \\012  T(CallSiteMethod, &quot;CallSite method % expects CallSite as receiver&quot;)          \\012  T(CannotConvertToPrimitive, &quot;Cannot convert object to primitive value&quot;)      \\012  T(CannotPreventExt, &quot;Cannot prevent extensions&quot;)                             \\012  T(CannotFreeze, &quot;Cannot freeze&quot;)                                             \\012  T(CannotFreezeArrayBufferView,                                               \\012 &quot;Cannot freeze array buffer views with elements&quot;)                          \\012  T(CannotSeal, &quot;Cannot seal&quot;)                                                 \\012  T(CircularStructure, &quot;Converting circular structure to JSON&quot;)                \\012  T(ConstructAbstractClass, &quot;Abstract class % not directly constructable&quot;)     \\012  T(ConstAssign, &quot;Assignment to constant variable.&quot;)                           \\012  T(ConstructorClassField, &quot;Classes may not have a field named 'constructor'&quot;) \\012  T(ConstructorNonCallable,                                                    \\012 &quot;Class constructor % cannot be invoked without 'new'&quot;)                     \\012  T(ConstructorNotFunction, &quot;Constructor % requires 'new'&quot;)                    \\012  T(ConstructorNotReceiver, &quot;The .constructor property is not an object&quot;)      \\012  T(CurrencyCode, &quot;Currency code is required with currency style.&quot;)            \\012  T(CyclicModuleDependency, &quot;Detected cycle while resolving name '%' in '%'&quot;)  \\012  T(DataViewNotArrayBuffer,                                                    \\012 &quot;First argument to DataView constructor must be an ArrayBuffer&quot;)           \\012  T(DateType, &quot;this is not a Date object.&quot;)                                    \\012  T(DebuggerFrame, &quot;Debugger: Invalid frame index.&quot;)                           \\012  T(DebuggerType, &quot;Debugger: Parameters have wrong types.&quot;)                    \\012  T(DeclarationMissingInitializer, &quot;Missing initializer in % declaration&quot;)     \\012  T(DefineDisallowed, &quot;Cannot define property %, object is not extensible&quot;)    \\012  T(DetachedOperation, &quot;Cannot perform % on a detached ArrayBuffer&quot;)           \\012  T(DuplicateTemplateProperty, &quot;Object template has duplicate property '%'&quot;)   \\012  T(ExtendsValueNotConstructor,                                                \\012 &quot;Class extends value % is not a constructor or null&quot;)                      \\012  T(FirstArgumentNotRegExp,                                                    \\012 &quot;First argument to % must not be a regular expression&quot;)                    \\012  T(FunctionBind, &quot;Bind must be called on a function&quot;)                         \\012  T(GeneratorRunning, &quot;Generator is already running&quot;)                          \\012  T(IllegalInvocation, &quot;Illegal invocation&quot;)                                   \\012  T(ImmutablePrototypeSet,                                                     \\012 &quot;Immutable prototype object '%' cannot have their prototype set&quot;)          \\012  T(ImportCallNotNewExpression, &quot;Cannot use new with import&quot;)                  \\012  T(ImportMetaOutsideModule, &quot;Cannot use 'import.meta' outside a module&quot;)      \\012  T(ImportMissingSpecifier, &quot;import() requires a specifier&quot;)                   \\012  T(IncompatibleMethodReceiver, &quot;Method % called on incompatible receiver %&quot;)  \\012  T(InstanceofNonobjectProto,                                                  \\012 &quot;Function has non-object prototype '%' in instanceof check&quot;)               \\012  T(InvalidArgument, &quot;invalid_argument&quot;)                                       \\012  T(InvalidInOperatorUse, &quot;Cannot use 'in' operator to search for '%' in %&quot;)   \\012  T(InvalidRegExpExecResult,                                                   \\012 &quot;RegExp exec method returned something other than an Object or null&quot;)      \\012  T(InvalidUnit, &quot;Invalid unit argument for %() '%'&quot;)                          \\012  T(IteratorResultNotAnObject, &quot;Iterator result % is not an object&quot;)           \\012  T(IteratorSymbolNonCallable, &quot;Found non-callable @@iterator&quot;)                \\012  T(IteratorValueNotAnObject, &quot;Iterator value % is not an entry object&quot;)       \\012  T(LanguageID, &quot;Language ID should be string or object.&quot;)                     \\012  T(LocaleNotEmpty,                                                            \\012 &quot;First argument to Intl.Locale constructor can't be empty or missing&quot;)     \\012  T(LocaleBadParameters, &quot;Incorrect locale information provided&quot;)              \\012  T(ListFormatBadParameters, &quot;Incorrect ListFormat information provided&quot;)      \\012  T(MapperFunctionNonCallable, &quot;flatMap mapper function is not callable&quot;)      \\012  T(MethodCalledOnWrongObject,                                                 \\012 &quot;Method % called on a non-object or on a wrong type of object.&quot;)           \\012  T(MethodInvokedOnNullOrUndefined,                                            \\012 &quot;Method invoked on undefined or null value.&quot;)                              \\012  T(MethodInvokedOnWrongType, &quot;Method invoked on an object that is not %.&quot;)    \\012  T(NoAccess, &quot;no access&quot;)                                                     \\012  T(NonCallableInInstanceOfCheck,                                              \\012 &quot;Right-hand side of 'instanceof' is not callable&quot;)                         \\012  T(NonCoercible, &quot;Cannot destructure 'undefined' or 'null'.&quot;)                 \\012  T(NonCoercibleWithProperty,                                                  \\012 &quot;Cannot destructure property `%` of 'undefined' or 'null'.&quot;)               \\012  T(NonExtensibleProto, &quot;% is not extensible&quot;)                                 \\012  T(NonObjectInInstanceOfCheck,                                                \\012 &quot;Right-hand side of 'instanceof' is not an object&quot;)                        \\012  T(NonObjectPropertyLoad, &quot;Cannot read property '%' of %&quot;)                    \\012  T(NonObjectPropertyStore, &quot;Cannot set property '%' of %&quot;)                    \\012  T(NoSetterInCallback, &quot;Cannot set property % of % which has only a getter&quot;)  \\012  T(NotAnIterator, &quot;% is not an iterator&quot;)                                     \\012  T(NotAPromise, &quot;% is not a promise&quot;)                                         \\012  T(NotConstructor, &quot;% is not a constructor&quot;)                                  \\012  T(NotDateObject, &quot;this is not a Date object.&quot;)                               \\012  T(NotGeneric, &quot;% requires that 'this' be a %&quot;)                               \\012  T(NotCallableOrIterable,                                                     \\012 &quot;% is not a function or its return value is not iterable&quot;)                 \\012  T(NotCallableOrAsyncIterable,                                                \\012 &quot;% is not a function or its return value is not async iterable&quot;)           \\012  T(NotFiniteNumber, &quot;Value need to be finite number for %()&quot;)                 \\012  T(NotIterable, &quot;% is not iterable&quot;)                                          \\012  T(NotAsyncIterable, &quot;% is not async iterable&quot;)                               \\012  T(NotPropertyName, &quot;% is not a valid property name&quot;)                         \\012  T(NotTypedArray, &quot;this is not a typed array.&quot;)                               \\012  T(NotSuperConstructor, &quot;Super constructor % of % is not a constructor&quot;)      \\012  T(NotSuperConstructorAnonymousClass,                                         \\012 &quot;Super constructor % of anonymous class is not a constructor&quot;)             \\012  T(NotIntegerSharedTypedArray, &quot;% is not an integer shared typed array.&quot;)     \\012  T(NotInt32SharedTypedArray, &quot;% is not an int32 shared typed array.&quot;)         \\012  T(ObjectGetterExpectingFunction,                                             \\012 &quot;Object.prototype.__defineGetter__: Expecting function&quot;)                   \\012  T(ObjectGetterCallable, &quot;Getter must be a function: %&quot;)                      \\012  T(ObjectNotExtensible, &quot;Cannot add property %, object is not extensible&quot;)    \\012  T(ObjectSetterExpectingFunction,                                             \\012 &quot;Object.prototype.__defineSetter__: Expecting function&quot;)                   \\012  T(ObjectSetterCallable, &quot;Setter must be a function: %&quot;)                      \\012  T(OrdinaryFunctionCalledAsConstructor,                                       \\012 &quot;Function object that's not a constructor was created with new&quot;)           \\012  T(PromiseCyclic, &quot;Chaining cycle detected for promise %&quot;)                    \\012  T(PromiseExecutorAlreadyInvoked,                                             \\012 &quot;Promise executor has already been invoked with non-undefined arguments&quot;)  \\012  T(PromiseNonCallable, &quot;Promise resolve or reject function is not callable&quot;)  \\012  T(PropertyDescObject, &quot;Property description must be an object: %&quot;)           \\012  T(PropertyNotFunction,                                                       \\012 &quot;'%' returned for property '%' of object '%' is not a function&quot;)           \\012  T(ProtoObjectOrNull, &quot;Object prototype may only be an Object or null: %&quot;)    \\012  T(PrototypeParentNotAnObject,                                                \\012 &quot;Class extends value does not have valid prototype property %&quot;)            \\012  T(ProxyConstructNonObject,                                                   \\012 &quot;'construct' on proxy: trap returned non-object ('%')&quot;)                    \\012  T(ProxyDefinePropertyNonConfigurable,                                        \\012 &quot;'defineProperty' on proxy: trap returned truish for defining &quot;            \\012 &quot;non-configurable property '%' which is either non-existant or &quot;           \\012 &quot;configurable in the proxy target&quot;)                                        \\012  T(ProxyDefinePropertyNonExtensible,                                          \\012 &quot;'defineProperty' on proxy: trap returned truish for adding property '%' &quot; \\012 &quot; to the non-extensible proxy target&quot;)                                     \\012  T(ProxyDefinePropertyIncompatible,                                           \\012 &quot;'defineProperty' on proxy: trap returned truish for adding property '%' &quot; \\012 &quot; that is incompatible with the existing property in the proxy target&quot;)    \\012  T(ProxyDeletePropertyNonConfigurable,                                        \\012 &quot;'deleteProperty' on proxy: trap returned truish for property '%' which &quot;  \\012 &quot;is non-configurable in the proxy target&quot;)                                 \\012  T(ProxyGetNonConfigurableData,                                               \\012 &quot;'get' on proxy: property '%' is a read-only and &quot;                         \\012 &quot;non-configurable data property on the proxy target but the proxy &quot;        \\012 &quot;did not return its actual value (expected '%' but got '%')&quot;)              \\012  T(ProxyGetNonConfigurableAccessor,                                           \\012 &quot;'get' on proxy: property '%' is a non-configurable accessor &quot;             \\012 &quot;property on the proxy target and does not have a getter function, but &quot;   \\012 &quot;the trap did not return 'undefined' (got '%')&quot;)                           \\012  T(ProxyGetOwnPropertyDescriptorIncompatible,                                 \\012 &quot;'getOwnPropertyDescriptor' on proxy: trap returned descriptor for &quot;       \\012 &quot;property '%' that is incompatible with the existing property in the &quot;     \\012 &quot;proxy target&quot;)                                                            \\012  T(ProxyGetOwnPropertyDescriptorInvalid,                                      \\012 &quot;'getOwnPropertyDescriptor' on proxy: trap returned neither object nor &quot;   \\012 &quot;undefined for property '%'&quot;)                                              \\012  T(ProxyGetOwnPropertyDescriptorNonConfigurable,                              \\012 &quot;'getOwnPropertyDescriptor' on proxy: trap reported non-configurability &quot;  \\012 &quot;for property '%' which is either non-existant or configurable in the &quot;    \\012 &quot;proxy target&quot;)                                                            \\012  T(ProxyGetOwnPropertyDescriptorNonExtensible,                                \\012 &quot;'getOwnPropertyDescriptor' on proxy: trap returned undefined for &quot;        \\012 &quot;property '%' which exists in the non-extensible proxy target&quot;)            \\012  T(ProxyGetOwnPropertyDescriptorUndefined,                                    \\012 &quot;'getOwnPropertyDescriptor' on proxy: trap returned undefined for &quot;        \\012 &quot;property '%' which is non-configurable in the proxy target&quot;)              \\012  T(ProxyGetPrototypeOfInvalid,                                                \\012 &quot;'getPrototypeOf' on proxy: trap returned neither object nor null&quot;)        \\012  T(ProxyGetPrototypeOfNonExtensible,                                          \\012 &quot;'getPrototypeOf' on proxy: proxy target is non-extensible but the &quot;       \\012 &quot;trap did not return its actual prototype&quot;)                                \\012  T(ProxyHandlerOrTargetRevoked,                                               \\012 &quot;Cannot create proxy with a revoked proxy as target or handler&quot;)           \\012  T(ProxyHasNonConfigurable,                                                   \\012 &quot;'has' on proxy: trap returned falsish for property '%' which exists in &quot;  \\012 &quot;the proxy target as non-configurable&quot;)                                    \\012  T(ProxyHasNonExtensible,                                                     \\012 &quot;'has' on proxy: trap returned falsish for property '%' but the proxy &quot;    \\012 &quot;target is not extensible&quot;)                                                \\012  T(ProxyIsExtensibleInconsistent,                                             \\012 &quot;'isExtensible' on proxy: trap result does not reflect extensibility of &quot;  \\012 &quot;proxy target (which is '%')&quot;)                                             \\012  T(ProxyNonObject,                                                            \\012 &quot;Cannot create proxy with a non-object as target or handler&quot;)              \\012  T(ProxyOwnKeysMissing,                                                       \\012 &quot;'ownKeys' on proxy: trap result did not include '%'&quot;)                     \\012  T(ProxyOwnKeysNonExtensible,                                                 \\012 &quot;'ownKeys' on proxy: trap returned extra keys but proxy target is &quot;        \\012 &quot;non-extensible&quot;)                                                          \\012  T(ProxyPreventExtensionsExtensible,                                          \\012 &quot;'preventExtensions' on proxy: trap returned truish but the proxy target &quot; \\012 &quot;is extensible&quot;)                                                           \\012  T(ProxyPrivate, &quot;Cannot pass private property name to proxy trap&quot;)           \\012  T(ProxyRevoked, &quot;Cannot perform '%' on a proxy that has been revoked&quot;)       \\012  T(ProxySetFrozenData,                                                        \\012 &quot;'set' on proxy: trap returned truish for property '%' which exists in &quot;   \\012 &quot;the proxy target as a non-configurable and non-writable data property &quot;   \\012 &quot;with a different value&quot;)                                                  \\012  T(ProxySetFrozenAccessor,                                                    \\012 &quot;'set' on proxy: trap returned truish for property '%' which exists in &quot;   \\012 &quot;the proxy target as a non-configurable and non-writable accessor &quot;        \\012 &quot;property without a setter&quot;)                                               \\012  T(ProxySetPrototypeOfNonExtensible,                                          \\012 &quot;'setPrototypeOf' on proxy: trap returned truish for setting a new &quot;       \\012 &quot;prototype on the non-extensible proxy target&quot;)                            \\012  T(ProxyTrapReturnedFalsish, &quot;'%' on proxy: trap returned falsish&quot;)           \\012  T(ProxyTrapReturnedFalsishFor,                                               \\012 &quot;'%' on proxy: trap returned falsish for property '%'&quot;)                    \\012  T(RedefineDisallowed, &quot;Cannot redefine property: %&quot;)                         \\012  T(RedefineExternalArray,                                                     \\012 &quot;Cannot redefine a property of an object with external array elements&quot;)    \\012  T(ReduceNoInitial, &quot;Reduce of empty array with no initial value&quot;)            \\012  T(RegExpFlags,                                                               \\012 &quot;Cannot supply flags when constructing one RegExp from another&quot;)           \\012  T(RegExpNonObject, &quot;% getter called on non-object %&quot;)                        \\012  T(RegExpNonRegExp, &quot;% getter called on non-RegExp object&quot;)                   \\012  T(RelativeDateTimeFormatterBadParameters,                                    \\012 &quot;Incorrect RelativeDateTimeFormatter provided&quot;)                            \\012  T(ResolverNotAFunction, &quot;Promise resolver % is not a function&quot;)              \\012  T(ReturnMethodNotCallable, &quot;The iterator's 'return' method is not callable&quot;) \\012  T(SharedArrayBufferTooShort,                                                 \\012 &quot;Derived SharedArrayBuffer constructor created a buffer which was too &quot;    \\012 &quot;small&quot;)                                                                   \\012  T(SharedArrayBufferSpeciesThis,                                              \\012 &quot;SharedArrayBuffer subclass returned this from species constructor&quot;)       \\012  T(StaticPrototype,                                                           \\012 &quot;Classes may not have a static property named 'prototype'&quot;)                \\012  T(StrictDeleteProperty, &quot;Cannot delete property '%' of %&quot;)                   \\012  T(StrictPoisonPill,                                                          \\012 &quot;'caller', 'callee', and 'arguments' properties may not be accessed on &quot;   \\012 &quot;strict mode functions or the arguments objects for calls to them&quot;)        \\012  T(StrictReadOnlyProperty,                                                    \\012 &quot;Cannot assign to read only property '%' of % '%'&quot;)                        \\012  T(StrictCannotCreateProperty, &quot;Cannot create property '%' on % '%'&quot;)         \\012  T(SymbolIteratorInvalid,                                                     \\012 &quot;Result of the Symbol.iterator method is not an object&quot;)                   \\012  T(SymbolAsyncIteratorInvalid,                                                \\012 &quot;Result of the Symbol.asyncIterator method is not an object&quot;)              \\012  T(SymbolKeyFor, &quot;% is not a symbol&quot;)                                         \\012  T(SymbolToNumber, &quot;Cannot convert a Symbol value to a number&quot;)               \\012  T(SymbolToString, &quot;Cannot convert a Symbol value to a string&quot;)               \\012  T(ThrowMethodMissing, &quot;The iterator does not provide a 'throw' method.&quot;)     \\012  T(UndefinedOrNullToObject, &quot;Cannot convert undefined or null to object&quot;)     \\012  T(ValueAndAccessor,                                                          \\012 &quot;Invalid property descriptor. Cannot both specify accessors and a value &quot;  \\012 &quot;or writable attribute, %&quot;)                                                \\012  T(VarRedeclaration, &quot;Identifier '%' has already been declared&quot;)              \\012  T(WrongArgs, &quot;%: Arguments list has wrong type&quot;)                             \\012 /* ReferenceError */                                                         \\012  T(NotDefined, &quot;% is not defined&quot;)                                            \\012  T(SuperAlreadyCalled, &quot;Super constructor may only be called once&quot;)           \\012  T(UnsupportedSuper, &quot;Unsupported reference to 'super'&quot;)                      \\012 /* RangeError */                                                             \\012  T(BigIntDivZero, &quot;Division by zero&quot;)                                         \\012  T(BigIntNegativeExponent, &quot;Exponent must be positive&quot;)                       \\012  T(BigIntTooBig, &quot;Maximum BigInt size exceeded&quot;)                              \\012  T(DateRange, &quot;Provided date is not in valid range.&quot;)                         \\012  T(ExpectedLocation,                                                          \\012 &quot;Expected letters optionally connected with underscores or hyphens for &quot;   \\012 &quot;a location, got %&quot;)                                                       \\012  T(InvalidArrayBufferLength, &quot;Invalid array buffer length&quot;)                   \\012  T(ArrayBufferAllocationFailed, &quot;Array buffer allocation failed&quot;)             \\012  T(InvalidArrayLength, &quot;Invalid array length&quot;)                                \\012  T(InvalidAtomicAccessIndex, &quot;Invalid atomic access index&quot;)                   \\012  T(InvalidCodePoint, &quot;Invalid code point %&quot;)                                  \\012  T(InvalidCountValue, &quot;Invalid count value&quot;)                                  \\012  T(InvalidCurrencyCode, &quot;Invalid currency code: %&quot;)                           \\012  T(InvalidDataViewAccessorOffset,                                             \\012 &quot;Offset is outside the bounds of the DataView&quot;)                            \\012  T(InvalidDataViewLength, &quot;Invalid DataView length %&quot;)                        \\012  T(InvalidOffset, &quot;Start offset % is outside the bounds of the buffer&quot;)       \\012  T(InvalidHint, &quot;Invalid hint: %&quot;)                                            \\012  T(InvalidIndex, &quot;Invalid value: not (convertible to) a safe integer&quot;)        \\012  T(InvalidLanguageTag, &quot;Invalid language tag: %&quot;)                             \\012  T(InvalidWeakMapKey, &quot;Invalid value used as weak map key&quot;)                   \\012  T(InvalidWeakSetValue, &quot;Invalid value used in weak set&quot;)                     \\012  T(InvalidStringLength, &quot;Invalid string length&quot;)                              \\012  T(InvalidTimeValue, &quot;Invalid time value&quot;)                                    \\012  T(InvalidTimeZone, &quot;Invalid time zone specified: %&quot;)                         \\012  T(InvalidTypedArrayAlignment, &quot;% of % should be a multiple of %&quot;)            \\012  T(InvalidTypedArrayIndex, &quot;Invalid typed array index&quot;)                       \\012  T(InvalidTypedArrayLength, &quot;Invalid typed array length: %&quot;)                  \\012  T(LetInLexicalBinding, &quot;let is disallowed as a lexically bound name&quot;)        \\012  T(LocaleMatcher, &quot;Illegal value for localeMatcher:%&quot;)                        \\012  T(NormalizationForm, &quot;The normalization form should be one of %.&quot;)           \\012  T(ZeroDigitNumericSeparator,                                                 \\012 &quot;Numeric separator can not be used after leading 0.&quot;)                      \\012  T(NumberFormatRange, &quot;% argument must be between 0 and 100&quot;)                 \\012  T(TrailingNumericSeparator,                                                  \\012 &quot;Numeric separators are not allowed at the end of numeric literals&quot;)       \\012  T(ContinuousNumericSeparator,                                                \\012 &quot;Only one underscore is allowed as numeric separator&quot;)                     \\012  T(PropertyValueOutOfRange, &quot;% value is out of range.&quot;)                       \\012  T(StackOverflow, &quot;Maximum call stack size exceeded&quot;)                         \\012  T(ToPrecisionFormatRange,                                                    \\012 &quot;toPrecision() argument must be between 1 and 100&quot;)                        \\012  T(ToRadixFormatRange, &quot;toString() radix argument must be between 2 and 36&quot;)  \\012  T(TypedArraySetOffsetOutOfBounds, &quot;offset is out of bounds&quot;)                 \\012  T(TypedArraySetSourceTooLarge, &quot;Source is too large&quot;)                        \\012  T(ValueOutOfRange, &quot;Value % out of range for % options property %&quot;)          \\012 /* SyntaxError */                                                            \\012  T(AmbiguousExport,                                                           \\012 &quot;The requested module '%' contains conflicting star exports for name '%'&quot;) \\012  T(BadGetterArity, &quot;Getter must not have any formal parameters.&quot;)             \\012  T(BadSetterArity, &quot;Setter must have exactly one formal parameter.&quot;)          \\012  T(BigIntInvalidString, &quot;Invalid BigInt string&quot;)                              \\012  T(ConstructorIsAccessor, &quot;Class constructor may not be an accessor&quot;)         \\012  T(ConstructorIsGenerator, &quot;Class constructor may not be a generator&quot;)        \\012  T(ConstructorIsAsync, &quot;Class constructor may not be an async method&quot;)        \\012  T(DerivedConstructorReturnedNonObject,                                       \\012 &quot;Derived constructors may only return object or undefined&quot;)                \\012  T(DuplicateConstructor, &quot;A class may only have one constructor&quot;)             \\012  T(DuplicateExport, &quot;Duplicate export of '%'&quot;)                                \\012  T(DuplicateProto,                                                            \\012 &quot;Duplicate __proto__ fields are not allowed in object literals&quot;)           \\012  T(ForInOfLoopInitializer,                                                    \\012 &quot;% loop variable declaration may not have an initializer.&quot;)                \\012  T(ForInOfLoopMultiBindings,                                                  \\012 &quot;Invalid left-hand side in % loop: Must have a single binding.&quot;)           \\012  T(GeneratorInSingleStatementContext,                                         \\012 &quot;Generators can only be declared at the top level or inside a block.&quot;)     \\012  T(AsyncFunctionInSingleStatementContext,                                     \\012 &quot;Async functions can only be declared at the top level or inside a &quot;       \\012 &quot;block.&quot;)                                                                  \\012  T(IllegalBreak, &quot;Illegal break statement&quot;)                                   \\012  T(NoIterationStatement,                                                      \\012 &quot;Illegal continue statement: no surrounding iteration statement&quot;)          \\012  T(IllegalContinue,                                                           \\012 &quot;Illegal continue statement: '%' does not denote an iteration statement&quot;)  \\012  T(IllegalLanguageModeDirective,                                              \\012 &quot;Illegal '%' directive in function with non-simple parameter list&quot;)        \\012  T(IllegalReturn, &quot;Illegal return statement&quot;)                                 \\012  T(IntrinsicWithSpread, &quot;Intrinsic calls do not support spread arguments&quot;)    \\012  T(InvalidRestBindingPattern,                                                 \\012 &quot;`...` must be followed by an identifier in declaration contexts&quot;)         \\012  T(InvalidRestAssignmentPattern,                                              \\012 &quot;`...` must be followed by an assignable reference in assignment &quot;         \\012 &quot;contexts&quot;)                                                                \\012  T(InvalidEscapedReservedWord, &quot;Keyword must not contain escaped characters&quot;) \\012  T(InvalidEscapedMetaProperty, &quot;'%' must not contain escaped characters&quot;)     \\012  T(InvalidLhsInAssignment, &quot;Invalid left-hand side in assignment&quot;)            \\012  T(InvalidCoverInitializedName, &quot;Invalid shorthand property initializer&quot;)     \\012  T(InvalidDestructuringTarget, &quot;Invalid destructuring assignment target&quot;)     \\012  T(InvalidLhsInFor, &quot;Invalid left-hand side in for-loop&quot;)                     \\012  T(InvalidLhsInPostfixOp,                                                     \\012 &quot;Invalid left-hand side expression in postfix operation&quot;)                  \\012  T(InvalidLhsInPrefixOp,                                                      \\012 &quot;Invalid left-hand side expression in prefix operation&quot;)                   \\012  T(InvalidRegExpFlags, &quot;Invalid flags supplied to RegExp constructor '%'&quot;)    \\012  T(InvalidOrUnexpectedToken, &quot;Invalid or unexpected token&quot;)                   \\012  T(InvalidPrivateFieldAccess, &quot;Invalid private field '%'&quot;)                    \\012  T(JsonParseUnexpectedEOS, &quot;Unexpected end of JSON input&quot;)                    \\012  T(JsonParseUnexpectedToken, &quot;Unexpected token % in JSON at position %&quot;)      \\012  T(JsonParseUnexpectedTokenNumber, &quot;Unexpected number in JSON at position %&quot;) \\012  T(JsonParseUnexpectedTokenString, &quot;Unexpected string in JSON at position %&quot;) \\012  T(LabelRedeclaration, &quot;Label '%' has already been declared&quot;)                 \\012  T(LabelledFunctionDeclaration,                                               \\012 &quot;Labelled function declaration not allowed as the body of a control flow &quot; \\012 &quot;structure&quot;)                                                               \\012  T(MalformedArrowFunParamList, &quot;Malformed arrow function parameter list&quot;)     \\012  T(MalformedRegExp, &quot;Invalid regular expression: /%/: %&quot;)                     \\012  T(MalformedRegExpFlags, &quot;Invalid regular expression flags&quot;)                  \\012  T(ModuleExportUndefined, &quot;Export '%' is not defined in module&quot;)              \\012  T(HtmlCommentInModule, &quot;HTML comments are not allowed in modules&quot;)           \\012  T(MultipleDefaultsInSwitch,                                                  \\012 &quot;More than one default clause in switch statement&quot;)                        \\012  T(NewlineAfterThrow, &quot;Illegal newline after throw&quot;)                          \\012  T(NoCatchOrFinally, &quot;Missing catch or finally after try&quot;)                    \\012  T(NotIsvar, &quot;builtin %%IS_VAR: not a variable&quot;)                              \\012  T(ParamAfterRest, &quot;Rest parameter must be last formal parameter&quot;)            \\012  T(FlattenPastSafeLength,                                                     \\012 &quot;Flattening % elements on an array-like of length % &quot;                      \\012 &quot;is disallowed, as the total surpasses 2**53-1&quot;)                           \\012  T(PushPastSafeLength,                                                        \\012 &quot;Pushing % elements on an array-like of length % &quot;                         \\012 &quot;is disallowed, as the total surpasses 2**53-1&quot;)                           \\012  T(ElementAfterRest, &quot;Rest element must be last element&quot;)                     \\012  T(BadSetterRestParameter,                                                    \\012 &quot;Setter function argument must not be a rest parameter&quot;)                   \\012  T(ParamDupe, &quot;Duplicate parameter name not allowed in this context&quot;)         \\012  T(ParenthesisInArgString, &quot;Function arg string contains parenthesis&quot;)        \\012  T(ArgStringTerminatesParametersEarly,                                        \\012 &quot;Arg string terminates parameters early&quot;)                                  \\012  T(UnexpectedEndOfArgString, &quot;Unexpected end of arg string&quot;)                  \\012  T(RestDefaultInitializer,                                                    \\012 &quot;Rest parameter may not have a default initializer&quot;)                       \\012  T(RuntimeWrongNumArgs, &quot;Runtime function given wrong number of arguments&quot;)   \\012  T(SuperNotCalled,                                                            \\012 &quot;Must call super constructor in derived class before accessing 'this' or &quot; \\012 &quot;returning from derived constructor&quot;)                                      \\012  T(SingleFunctionLiteral, &quot;Single function literal required&quot;)                 \\012  T(SloppyFunction,                                                            \\012 &quot;In non-strict mode code, functions can only be declared at top level, &quot;   \\012 &quot;inside a block, or as the body of an if statement.&quot;)                      \\012  T(SpeciesNotConstructor,                                                     \\012 &quot;object.constructor[Symbol.species] is not a constructor&quot;)                 \\012  T(StrictDelete, &quot;Delete of an unqualified identifier in strict mode.&quot;)       \\012  T(StrictEvalArguments, &quot;Unexpected eval or arguments in strict mode&quot;)        \\012  T(StrictFunction,                                                            \\012 &quot;In strict mode code, functions can only be declared at top level or &quot;     \\012 &quot;inside a block.&quot;)                                                         \\012  T(StrictOctalLiteral, &quot;Octal literals are not allowed in strict mode.&quot;)      \\012  T(StrictDecimalWithLeadingZero,                                              \\012 &quot;Decimals with leading zeros are not allowed in strict mode.&quot;)             \\012  T(StrictOctalEscape,                                                         \\012 &quot;Octal escape sequences are not allowed in strict mode.&quot;)                  \\012  T(StrictWith, &quot;Strict mode code may not include a with statement&quot;)           \\012  T(TemplateOctalLiteral,                                                      \\012 &quot;Octal escape sequences are not allowed in template strings.&quot;)             \\012  T(ThisFormalParameter, &quot;'this' is not a valid formal parameter name&quot;)        \\012  T(AwaitBindingIdentifier,                                                    \\012 &quot;'await' is not a valid identifier name in an async function&quot;)             \\012  T(AwaitExpressionFormalParameter,                                            \\012 &quot;Illegal await-expression in formal parameters of async function&quot;)         \\012  T(TooManyArguments,                                                          \\012 &quot;Too many arguments in function call (only 65535 allowed)&quot;)                \\012  T(TooManyParameters,                                                         \\012 &quot;Too many parameters in function definition (only 65534 allowed)&quot;)         \\012  T(TooManySpreads,                                                            \\012 &quot;Literal containing too many nested spreads (up to 65534 allowed)&quot;)        \\012  T(TooManyVariables, &quot;Too many variables declared (only 4194303 allowed)&quot;)    \\012  T(TooManyElementsInPromiseAll, &quot;Too many elements passed to Promise.all&quot;)    \\012  T(TypedArrayTooShort,                                                        \\012 &quot;Derived TypedArray constructor created an array which was too small&quot;)     \\012  T(UnexpectedEOS, &quot;Unexpected end of input&quot;)                                  \\012  T(UnexpectedReserved, &quot;Unexpected reserved word&quot;)                            \\012  T(UnexpectedStrictReserved, &quot;Unexpected strict mode reserved word&quot;)          \\012  T(UnexpectedSuper, &quot;'super' keyword unexpected here&quot;)                        \\012  T(UnexpectedNewTarget, &quot;new.target expression is not allowed here&quot;)          \\012  T(UnexpectedTemplateString, &quot;Unexpected template string&quot;)                    \\012  T(UnexpectedToken, &quot;Unexpected token %&quot;)                                     \\012  T(UnexpectedTokenIdentifier, &quot;Unexpected identifier&quot;)                        \\012  T(UnexpectedTokenNumber, &quot;Unexpected number&quot;)                                \\012  T(UnexpectedTokenString, &quot;Unexpected string&quot;)                                \\012  T(UnexpectedTokenRegExp, &quot;Unexpected regular expression&quot;)                    \\012  T(UnexpectedLexicalDeclaration,                                              \\012 &quot;Lexical declaration cannot appear in a single-statement context&quot;)         \\012  T(UnknownLabel, &quot;Undefined label '%'&quot;)                                       \\012  T(UnresolvableExport,                                                        \\012 &quot;The requested module '%' does not provide an export named '%'&quot;)           \\012  T(UnterminatedArgList, &quot;missing ) after argument list&quot;)                      \\012  T(UnterminatedRegExp, &quot;Invalid regular expression: missing /&quot;)               \\012  T(UnterminatedTemplate, &quot;Unterminated template literal&quot;)                     \\012  T(UnterminatedTemplateExpr, &quot;Missing } in template expression&quot;)              \\012  T(FoundNonCallableHasInstance, &quot;Found non-callable @@hasInstance&quot;)           \\012  T(InvalidHexEscapeSequence, &quot;Invalid hexadecimal escape sequence&quot;)           \\012  T(InvalidUnicodeEscapeSequence, &quot;Invalid Unicode escape sequence&quot;)           \\012  T(UndefinedUnicodeCodePoint, &quot;Undefined Unicode code-point&quot;)                 \\012  T(YieldInParameter, &quot;Yield expression not allowed in formal parameter&quot;)      \\012 /* EvalError */                                                              \\012  T(CodeGenFromStrings, &quot;%&quot;)                                                   \\012  T(NoSideEffectDebugEvaluate, &quot;Possible side-effect in debug-evaluate&quot;)       \\012 /* URIError */                                                               \\012  T(URIMalformed, &quot;URI malformed&quot;)                                             \\012 /* Wasm errors (currently Error) */                                          \\012  T(WasmTrapUnreachable, &quot;unreachable&quot;)                                        \\012  T(WasmTrapMemOutOfBounds, &quot;memory access out of bounds&quot;)                     \\012  T(WasmTrapUnalignedAccess, &quot;operation does not support unaligned accesses&quot;)  \\012  T(WasmTrapDivByZero, &quot;divide by zero&quot;)                                       \\012  T(WasmTrapDivUnrepresentable, &quot;divide result unrepresentable&quot;)               \\012  T(WasmTrapRemByZero, &quot;remainder by zero&quot;)                                    \\012  T(WasmTrapFloatUnrepresentable, &quot;float unrepresentable in integer range&quot;)    \\012  T(WasmTrapFuncInvalid, &quot;invalid index into function table&quot;)                  \\012  T(WasmTrapFuncSigMismatch, &quot;function signature mismatch&quot;)                    \\012  T(WasmTrapTypeError, &quot;wasm function signature contains illegal type&quot;)        \\012  T(WasmExceptionError, &quot;wasm exception&quot;)                                      \\012 /* Asm.js validation related */                                              \\012  T(AsmJsInvalid, &quot;Invalid asm.js: %&quot;)                                         \\012  T(AsmJsCompiled, &quot;Converted asm.js to WebAssembly: %&quot;)                       \\012  T(AsmJsInstantiated, &quot;Instantiated asm.js: %&quot;)                               \\012  T(AsmJsLinkingFailed, &quot;Linking failure in asm.js: %&quot;)                        \\012 /* DataCloneError messages */                                                \\012  T(DataCloneError, &quot;% could not be cloned.&quot;)                                  \\012  T(DataCloneErrorOutOfMemory, &quot;Data cannot be cloned, out of memory.&quot;)        \\012  T(DataCloneErrorNeuteredArrayBuffer,                                         \\012 &quot;An ArrayBuffer is neutered and could not be cloned.&quot;)                     \\012  T(DataCloneErrorSharedArrayBufferTransferred,                                \\012 &quot;A SharedArrayBuffer could not be cloned. SharedArrayBuffer must not be &quot;  \\012 &quot;transferred.&quot;)                                                            \\012  T(DataCloneDeserializationError, &quot;Unable to deserialize cloned data.&quot;)       \\012  T(DataCloneDeserializationVersionError,                                      \\012 &quot;Unable to deserialize cloned data due to invalid or unsupported &quot;         \\012 &quot;version.&quot;)                                                                \\012 /* Builtins-Trace Errors */                                                  \\012  T(TraceEventCategoryError, &quot;Trace event category must be a string.&quot;)         \\012  T(TraceEventNameError, &quot;Trace event name must be a string.&quot;)                 \\012  T(TraceEventNameLengthError,                                                 \\012 &quot;Trace event name must not be an empty string.&quot;)                           \\012  T(TraceEventPhaseError, &quot;Trace event phase must be a number.&quot;)               \\012  T(TraceEventIDError, &quot;Trace event id must be a number.&quot;)\012\012class MessageTemplate {\012 public:\012 enum Template {\012#define TEMPLATE(NAME, STRING) k##NAME,\012    MESSAGE_TEMPLATES(TEMPLATE)\012#undef TEMPLATE\012        kLastMessage\012 };\012\012 static const char* TemplateString(int template_index);\012\012 static MaybeHandle&lt;String&gt; FormatMessage(Isolate* isolate, int template_index,\012 Handle&lt;String&gt; arg0,\012 Handle&lt;String&gt; arg1,\012 Handle&lt;String&gt; arg2);\012\012 static Handle&lt;String&gt; FormatMessage(Isolate* isolate, int template_index,\012 Handle&lt;Object&gt; arg);\012};\012\012\012// A message handler is a convenience interface for accessing the list\012// of message listeners registered in an environment\012class MessageHandler {\012 public:\012 // Returns a message object for the API to use.\012 static Handle&lt;JSMessageObject&gt; MakeMessageObject(\012 Isolate* isolate, MessageTemplate::Template type,\012 const MessageLocation* location, Handle&lt;Object&gt; argument,\012 Handle&lt;FixedArray&gt; stack_frames);\012\012 // Report a formatted message (needs JS allocation).\012 static void ReportMessage(Isolate* isolate, const MessageLocation* loc,\012 Handle&lt;JSMessageObject&gt; message);\012\012 static void DefaultMessageReport(Isolate* isolate, const MessageLocation* loc,\012 Handle&lt;Object&gt; message_obj);\012 static Handle&lt;String&gt; GetMessage(Isolate* isolate, Handle&lt;Object&gt; data);\012 static std::unique_ptr&lt;char[]&gt; GetLocalizedMessage(Isolate* isolate,\012 Handle&lt;Object&gt; data);\012\012 private:\012 static void ReportMessageNoExceptions(Isolate* isolate,\012 const MessageLocation* loc,\012 Handle&lt;Object&gt; message_obj,\012                                        v8::Local&lt;v8::Value&gt; api_exception_obj);\012};\012\012\012} // namespace internal\012},namespace v8 {\012namespace internal {\012namespace wasm {\012class WasmCode;\012}\012\012// Forward declarations.\012class AbstractCode;\012class FrameArray;\012class JSMessageObject;\012class LookupIterator;\012class SharedFunctionInfo;\012class SourceInfo;\012class WasmInstanceObject;\012\012class MessageLocation {\012 public:\012 MessageLocation(Handle&lt;Script&gt; script, int start_pos, int end_pos);\012 MessageLocation(Handle&lt;Script&gt; script, int start_pos, int end_pos,\012 Handle&lt;SharedFunctionInfo&gt; shared);\012 MessageLocation();\012\012 Handle&lt;Script&gt; script() const { return script_; }\012 int start_pos() const { return start_pos_; }\012 int end_pos() const { return end_pos_; }\012 Handle&lt;SharedFunctionInfo&gt; shared() const { return shared_; }\012\012 private:\012 Handle&lt;Script&gt; script_;\012 int start_pos_;\012 int end_pos_;\012 Handle&lt;SharedFunctionInfo&gt; shared_;\012};\012\012class StackFrameBase {\012 public:\012 virtual ~StackFrameBase() {}\012\012 virtual Handle&lt;Object&gt; GetReceiver() const = 0;\012 virtual Handle&lt;Object&gt; GetFunction() const = 0;\012\012 virtual Handle&lt;Object&gt; GetFileName() = 0;\012 virtual Handle&lt;Object&gt; GetFunctionName() = 0;\012 virtual Handle&lt;Object&gt; GetScriptNameOrSourceUrl() = 0;\012 virtual Handle&lt;Object&gt; GetMethodName() = 0;\012 virtual Handle&lt;Object&gt; GetTypeName() = 0;\012 virtual Handle&lt;Object&gt; GetEvalOrigin();\012\012 virtual int GetPosition() const = 0;\012 // Return 1-based line number, including line offset.\012 virtual int GetLineNumber() = 0;\012 // Return 1-based column number, including column offset if first line.\012 virtual int GetColumnNumber() = 0;\012\012 virtual bool IsNative() = 0;\012 virtual bool IsToplevel() = 0;\012 virtual bool IsEval();\012 virtual bool IsConstructor() = 0;\012 virtual bool IsStrict() const = 0;\012\012 virtual MaybeHandle&lt;String&gt; ToString() = 0;\012\012 protected:\012 StackFrameBase() {}\012 explicit StackFrameBase(Isolate* isolate) : isolate_(isolate) {}\012 Isolate* isolate_;\012\012 private:\012 virtual bool HasScript() const = 0;\012 virtual Handle&lt;Script&gt; GetScript() const = 0;\012};\012\012class JSStackFrame : public StackFrameBase {\012 public:\012 JSStackFrame(Isolate* isolate, Handle&lt;Object&gt; receiver,\012 Handle&lt;JSFunction&gt; function, Handle&lt;AbstractCode&gt; code,\012 int offset);\012 virtual ~JSStackFrame() {}\012\012 Handle&lt;Object&gt; GetReceiver() const override { return receiver_; }\012 Handle&lt;Object&gt; GetFunction() const override;\012\012 Handle&lt;Object&gt; GetFileName() override;\012 Handle&lt;Object&gt; GetFunctionName() override;\012 Handle&lt;Object&gt; GetScriptNameOrSourceUrl() override;\012 Handle&lt;Object&gt; GetMethodName() override;\012 Handle&lt;Object&gt; GetTypeName() override;\012\012 int GetPosition() const override;\012 int GetLineNumber() override;\012 int GetColumnNumber() override;\012\012 bool IsNative() override;\012 bool IsToplevel() override;\012 bool IsConstructor() override { return is_constructor_; }\012 bool IsStrict() const override { return is_strict_; }\012\012 MaybeHandle&lt;String&gt; ToString() override;\012\012 private:\012 JSStackFrame();\012 void FromFrameArray(Isolate* isolate, Handle&lt;FrameArray&gt; array, int frame_ix);\012\012 bool HasScript() const override;\012 Handle&lt;Script&gt; GetScript() const override;\012\012 Handle&lt;Object&gt; receiver_;\012 Handle&lt;JSFunction&gt; function_;\012 Handle&lt;AbstractCode&gt; code_;\012 int offset_;\012\012 bool is_constructor_;\012 bool is_strict_;\012\012 friend class FrameArrayIterator;\012};\012\012class WasmStackFrame : public StackFrameBase {\012 public:\012 virtual ~WasmStackFrame() {}\012\012 Handle&lt;Object&gt; GetReceiver() const override;\012 Handle&lt;Object&gt; GetFunction() const override;\012\012 Handle&lt;Object&gt; GetFileName() override { return Null(); }\012 Handle&lt;Object&gt; GetFunctionName() override;\012 Handle&lt;Object&gt; GetScriptNameOrSourceUrl() override { return Null(); }\012 Handle&lt;Object&gt; GetMethodName() override { return Null(); }\012 Handle&lt;Object&gt; GetTypeName() override { return Null(); }\012\012 int GetPosition() const override;\012 int GetLineNumber() override { return wasm_func_index_; }\012 int GetColumnNumber() override { return -1; }\012\012 bool IsNative() override { return false; }\012 bool IsToplevel() override { return false; }\012 bool IsConstructor() override { return false; }\012 bool IsStrict() const override { return false; }\012 bool IsInterpreted() const { return code_ == nullptr; }\012\012 MaybeHandle&lt;String&gt; ToString() override;\012\012 protected:\012 Handle&lt;Object&gt; Null() const;\012\012 bool HasScript() const override;\012 Handle&lt;Script&gt; GetScript() const override;\012\012 Handle&lt;WasmInstanceObject&gt; wasm_instance_;\012 uint32_t wasm_func_index_;\012  wasm::WasmCode* code_; // null for interpreted frames.\012 int offset_;\012\012 private:\012 WasmStackFrame();\012 void FromFrameArray(Isolate* isolate, Handle&lt;FrameArray&gt; array, int frame_ix);\012\012 friend class FrameArrayIterator;\012 friend class AsmJsWasmStackFrame;\012};\012\012class AsmJsWasmStackFrame : public WasmStackFrame {\012 public:\012 virtual ~AsmJsWasmStackFrame() {}\012\012 Handle&lt;Object&gt; GetReceiver() const override;\012 Handle&lt;Object&gt; GetFunction() const override;\012\012 Handle&lt;Object&gt; GetFileName() override;\012 Handle&lt;Object&gt; GetScriptNameOrSourceUrl() override;\012\012 int GetPosition() const override;\012 int GetLineNumber() override;\012 int GetColumnNumber() override;\012\012 MaybeHandle&lt;String&gt; ToString() override;\012\012 private:\012 friend class FrameArrayIterator;\012 AsmJsWasmStackFrame();\012 void FromFrameArray(Isolate* isolate, Handle&lt;FrameArray&gt; array, int frame_ix);\012\012 bool is_at_number_conversion_;\012};\012\012class FrameArrayIterator {\012 public:\012 FrameArrayIterator(Isolate* isolate, Handle&lt;FrameArray&gt; array,\012 int frame_ix = 0);\012\012 StackFrameBase* Frame();\012\012 bool HasNext() const;\012 void Next();\012\012 private:\012 Isolate* isolate_;\012\012 Handle&lt;FrameArray&gt; array_;\012 int next_frame_ix_;\012\012 WasmStackFrame wasm_frame_;\012 AsmJsWasmStackFrame asm_wasm_frame_;\012 JSStackFrame js_frame_;\012};\012\012// Determines how stack trace collection skips frames.\012enum FrameSkipMode {\012 // Unconditionally skips the first frame. Used e.g. when the Error constructor\012 // is called, in which case the first frame is always a BUILTIN_EXIT frame.\012  SKIP_FIRST,\012 // Skip all frames until a specified caller function is seen.\012  SKIP_UNTIL_SEEN,\012  SKIP_NONE,\012};\012\012class ErrorUtils : public AllStatic {\012 public:\012 static MaybeHandle&lt;Object&gt; Construct(\012 Isolate* isolate, Handle&lt;JSFunction&gt; target, Handle&lt;Object&gt; new_target,\012 Handle&lt;Object&gt; message, FrameSkipMode mode, Handle&lt;Object&gt; caller,\012 bool suppress_detailed_trace);\012\012 static MaybeHandle&lt;String&gt; ToString(Isolate* isolate, Handle&lt;Object&gt; recv);\012\012 static MaybeHandle&lt;Object&gt; MakeGenericError(\012 Isolate* isolate, Handle&lt;JSFunction&gt; constructor, int template_index,\012 Handle&lt;Object&gt; arg0, Handle&lt;Object&gt; arg1, Handle&lt;Object&gt; arg2,\012 FrameSkipMode mode);\012\012 // Formats a textual stack trace from the given structured stack trace.\012 // Note that this can call arbitrary JS code through Error.prepareStackTrace.\012 static MaybeHandle&lt;Object&gt; FormatStackTrace(Isolate* isolate,\012 Handle&lt;JSObject&gt; error,\012 Handle&lt;Object&gt; stack_trace);\012};\012\012#define MESSAGE_TEMPLATES(T)                                                   \\012 /* Error */                                                                  \\012  T(None, &quot;&quot;)                                                                  \\012  T(CyclicProto, &quot;Cyclic __proto__ value&quot;)                                     \\012  T(Debugger, &quot;Debugger: %&quot;)                                                   \\012  T(DebuggerLoading, &quot;Error loading debugger&quot;)                                 \\012  T(DefaultOptionsMissing, &quot;Internal % error. Default options are missing.&quot;)   \\012  T(DeletePrivateField, &quot;Private fields can not be deleted&quot;)                   \\012  T(UncaughtException, &quot;Uncaught %&quot;)                                           \\012  T(Unsupported, &quot;Not supported&quot;)                                              \\012  T(WrongServiceType, &quot;Internal error, wrong service type: %&quot;)                 \\012  T(WrongValueType, &quot;Internal error. Wrong value type.&quot;)                       \\012  T(IcuError, &quot;Internal error. Icu error.&quot;)                                    \\012 /* TypeError */                                                              \\012  T(ApplyNonFunction,                                                          \\012 &quot;Function.prototype.apply was called on %, which is a % and not a &quot;        \\012 &quot;function&quot;)                                                                \\012  T(ArgumentsDisallowedInInitializer,                                          \\012 &quot;'arguments' is not allowed in class field initializer&quot;)                   \\012  T(ArrayBufferTooShort,                                                       \\012 &quot;Derived ArrayBuffer constructor created a buffer which was too small&quot;)    \\012  T(ArrayBufferSpeciesThis,                                                    \\012 &quot;ArrayBuffer subclass returned this from species constructor&quot;)             \\012  T(ArrayItemNotType, &quot;array %[%] is not type %&quot;)                              \\012  T(AwaitNotInAsyncFunction, &quot;await is only valid in async function&quot;)          \\012  T(AtomicsWaitNotAllowed, &quot;Atomics.wait cannot be called in this context&quot;)    \\012  T(BadSortComparisonFunction,                                                 \\012 &quot;The comparison function must be either a function or undefined&quot;)          \\012  T(BigIntFromNumber,                                                          \\012 &quot;The number % cannot be converted to a BigInt because it is not an &quot;       \\012 &quot;integer&quot;)                                                                 \\012  T(BigIntFromObject, &quot;Cannot convert % to a BigInt&quot;)                          \\012  T(BigIntMixedTypes,                                                          \\012 &quot;Cannot mix BigInt and other types, use explicit conversions&quot;)             \\012  T(BigIntSerializeJSON, &quot;Do not know how to serialize a BigInt&quot;)              \\012  T(BigIntShr, &quot;BigInts have no unsigned right shift, use &gt;&gt; instead&quot;)         \\012  T(BigIntToNumber, &quot;Cannot convert a BigInt value to a number&quot;)               \\012  T(CalledNonCallable, &quot;% is not a function&quot;)                                  \\012  T(CalledOnNonObject, &quot;% called on non-object&quot;)                               \\012  T(CalledOnNullOrUndefined, &quot;% called on null or undefined&quot;)                  \\012  T(CallSiteExpectsFunction,                                                   \\012 &quot;CallSite expects wasm object as first or function as second argument, &quot;   \\012 &quot;got &lt;%, %&gt;&quot;)                                                              \\012  T(CallSiteMethod, &quot;CallSite method % expects CallSite as receiver&quot;)          \\012  T(CannotConvertToPrimitive, &quot;Cannot convert object to primitive value&quot;)      \\012  T(CannotPreventExt, &quot;Cannot prevent extensions&quot;)                             \\012  T(CannotFreeze, &quot;Cannot freeze&quot;)                                             \\012  T(CannotFreezeArrayBufferView,                                               \\012 &quot;Cannot freeze array buffer views with elements&quot;)                          \\012  T(CannotSeal, &quot;Cannot seal&quot;)                                                 \\012  T(CircularStructure, &quot;Converting circular structure to JSON&quot;)                \\012  T(ConstructAbstractClass, &quot;Abstract class % not directly constructable&quot;)     \\012  T(ConstAssign, &quot;Assignment to constant variable.&quot;)                           \\012  T(ConstructorClassField, &quot;Classes may not have a field named 'constructor'&quot;) \\012  T(ConstructorNonCallable,                                                    \\012 &quot;Class constructor % cannot be invoked without 'new'&quot;)                     \\012  T(ConstructorNotFunction, &quot;Constructor % requires 'new'&quot;)                    \\012  T(ConstructorNotReceiver, &quot;The .constructor property is not an object&quot;)      \\012  T(CurrencyCode, &quot;Currency code is required with currency style.&quot;)            \\012  T(CyclicModuleDependency, &quot;Detected cycle while resolving name '%' in '%'&quot;)  \\012  T(DataViewNotArrayBuffer,                                                    \\012 &quot;First argument to DataView constructor must be an ArrayBuffer&quot;)           \\012  T(DateType, &quot;this is not a Date object.&quot;)                                    \\012  T(DebuggerFrame, &quot;Debugger: Invalid frame index.&quot;)                           \\012  T(DebuggerType, &quot;Debugger: Parameters have wrong types.&quot;)                    \\012  T(DeclarationMissingInitializer, &quot;Missing initializer in % declaration&quot;)     \\012  T(DefineDisallowed, &quot;Cannot define property %, object is not extensible&quot;)    \\012  T(DetachedOperation, &quot;Cannot perform % on a detached ArrayBuffer&quot;)           \\012  T(DuplicateTemplateProperty, &quot;Object template has duplicate property '%'&quot;)   \\012  T(ExtendsValueNotConstructor,                                                \\012 &quot;Class extends value % is not a constructor or null&quot;)                      \\012  T(FirstArgumentNotRegExp,                                                    \\012 &quot;First argument to % must not be a regular expression&quot;)                    \\012  T(FunctionBind, &quot;Bind must be called on a function&quot;)                         \\012  T(GeneratorRunning, &quot;Generator is already running&quot;)                          \\012  T(IllegalInvocation, &quot;Illegal invocation&quot;)                                   \\012  T(ImmutablePrototypeSet,                                                     \\012 &quot;Immutable prototype object '%' cannot have their prototype set&quot;)          \\012  T(ImportCallNotNewExpression, &quot;Cannot use new with import&quot;)                  \\012  T(ImportMetaOutsideModule, &quot;Cannot use 'import.meta' outside a module&quot;)      \\012  T(ImportMissingSpecifier, &quot;import() requires a specifier&quot;)                   \\012  T(IncompatibleMethodReceiver, &quot;Method % called on incompatible receiver %&quot;)  \\012  T(InstanceofNonobjectProto,                                                  \\012 &quot;Function has non-object prototype '%' in instanceof check&quot;)               \\012  T(InvalidArgument, &quot;invalid_argument&quot;)                                       \\012  T(InvalidInOperatorUse, &quot;Cannot use 'in' operator to search for '%' in %&quot;)   \\012  T(InvalidRegExpExecResult,                                                   \\012 &quot;RegExp exec method returned something other than an Object or null&quot;)      \\012  T(InvalidUnit, &quot;Invalid unit argument for %() '%'&quot;)                          \\012  T(IteratorResultNotAnObject, &quot;Iterator result % is not an object&quot;)           \\012  T(IteratorSymbolNonCallable, &quot;Found non-callable @@iterator&quot;)                \\012  T(IteratorValueNotAnObject, &quot;Iterator value % is not an entry object&quot;)       \\012  T(LanguageID, &quot;Language ID should be string or object.&quot;)                     \\012  T(LocaleNotEmpty,                                                            \\012 &quot;First argument to Intl.Locale constructor can't be empty or missing&quot;)     \\012  T(LocaleBadParameters, &quot;Incorrect locale information provided&quot;)              \\012  T(ListFormatBadParameters, &quot;Incorrect ListFormat information provided&quot;)      \\012  T(MapperFunctionNonCallable, &quot;flatMap mapper function is not callable&quot;)      \\012  T(MethodCalledOnWrongObject,                                                 \\012 &quot;Method % called on a non-object or on a wrong type of object.&quot;)           \\012  T(MethodInvokedOnNullOrUndefined,                                            \\012 &quot;Method invoked on undefined or null value.&quot;)                              \\012  T(MethodInvokedOnWrongType, &quot;Method invoked on an object that is not %.&quot;)    \\012  T(NoAccess, &quot;no access&quot;)                                                     \\012  T(NonCallableInInstanceOfCheck,                                              \\012 &quot;Right-hand side of 'instanceof' is not callable&quot;)                         \\012  T(NonCoercible, &quot;Cannot destructure 'undefined' or 'null'.&quot;)                 \\012  T(NonCoercibleWithProperty,                                                  \\012 &quot;Cannot destructure property `%` of 'undefined' or 'null'.&quot;)               \\012  T(NonExtensibleProto, &quot;% is not extensible&quot;)                                 \\012  T(NonObjectInInstanceOfCheck,                                                \\012 &quot;Right-hand side of 'instanceof' is not an object&quot;)                        \\012  T(NonObjectPropertyLoad, &quot;Cannot read property '%' of %&quot;)                    \\012  T(NonObjectPropertyStore, &quot;Cannot set property '%' of %&quot;)                    \\012  T(NoSetterInCallback, &quot;Cannot set property % of % which has only a getter&quot;)  \\012  T(NotAnIterator, &quot;% is not an iterator&quot;)                                     \\012  T(NotAPromise, &quot;% is not a promise&quot;)                                         \\012  T(NotConstructor, &quot;% is not a constructor&quot;)                                  \\012  T(NotDateObject, &quot;this is not a Date object.&quot;)                               \\012  T(NotGeneric, &quot;% requires that 'this' be a %&quot;)                               \\012  T(NotCallableOrIterable,                                                     \\012 &quot;% is not a function or its return value is not iterable&quot;)                 \\012  T(NotCallableOrAsyncIterable,                                                \\012 &quot;% is not a function or its return value is not async iterable&quot;)           \\012  T(NotFiniteNumber, &quot;Value need to be finite number for %()&quot;)                 \\012  T(NotIterable, &quot;% is not iterable&quot;)                                          \\012  T(NotAsyncIterable, &quot;% is not async iterable&quot;)                               \\012  T(NotPropertyName, &quot;% is not a valid property name&quot;)                         \\012  T(NotTypedArray, &quot;this is not a typed array.&quot;)                               \\012  T(NotSuperConstructor, &quot;Super constructor % of % is not a constructor&quot;)      \\012  T(NotSuperConstructorAnonymousClass,                                         \\012 &quot;Super constructor % of anonymous class is not a constructor&quot;)             \\012  T(NotIntegerSharedTypedArray, &quot;% is not an integer shared typed array.&quot;)     \\012  T(NotInt32SharedTypedArray, &quot;% is not an int32 shared typed array.&quot;)         \\012  T(ObjectGetterExpectingFunction,                                             \\012 &quot;Object.prototype.__defineGetter__: Expecting function&quot;)                   \\012  T(ObjectGetterCallable, &quot;Getter must be a function: %&quot;)                      \\012  T(ObjectNotExtensible, &quot;Cannot add property %, object is not extensible&quot;)    \\012  T(ObjectSetterExpectingFunction,                                             \\012 &quot;Object.prototype.__defineSetter__: Expecting function&quot;)                   \\012  T(ObjectSetterCallable, &quot;Setter must be a function: %&quot;)                      \\012  T(OrdinaryFunctionCalledAsConstructor,                                       \\012 &quot;Function object that's not a constructor was created with new&quot;)           \\012  T(PromiseCyclic, &quot;Chaining cycle detected for promise %&quot;)                    \\012  T(PromiseExecutorAlreadyInvoked,                                             \\012 &quot;Promise executor has already been invoked with non-undefined arguments&quot;)  \\012  T(PromiseNonCallable, &quot;Promise resolve or reject function is not callable&quot;)  \\012  T(PropertyDescObject, &quot;Property description must be an object: %&quot;)           \\012  T(PropertyNotFunction,                                                       \\012 &quot;'%' returned for property '%' of object '%' is not a function&quot;)           \\012  T(ProtoObjectOrNull, &quot;Object prototype may only be an Object or null: %&quot;)    \\012  T(PrototypeParentNotAnObject,                                                \\012 &quot;Class extends value does not have valid prototype property %&quot;)            \\012  T(ProxyConstructNonObject,                                                   \\012 &quot;'construct' on proxy: trap returned non-object ('%')&quot;)                    \\012  T(ProxyDefinePropertyNonConfigurable,                                        \\012 &quot;'defineProperty' on proxy: trap returned truish for defining &quot;            \\012 &quot;non-configurable property '%' which is either non-existant or &quot;           \\012 &quot;configurable in the proxy target&quot;)                                        \\012  T(ProxyDefinePropertyNonExtensible,                                          \\012 &quot;'defineProperty' on proxy: trap returned truish for adding property '%' &quot; \\012 &quot; to the non-extensible proxy target&quot;)                                     \\012  T(ProxyDefinePropertyIncompatible,                                           \\012 &quot;'defineProperty' on proxy: trap returned truish for adding property '%' &quot; \\012 &quot; that is incompatible with the existing property in the proxy target&quot;)    \\012  T(ProxyDeletePropertyNonConfigurable,                                        \\012 &quot;'deleteProperty' on proxy: trap returned truish for property '%' which &quot;  \\012 &quot;is non-configurable in the proxy target&quot;)                                 \\012  T(ProxyGetNonConfigurableData,                                               \\012 &quot;'get' on proxy: property '%' is a read-only and &quot;                         \\012 &quot;non-configurable data property on the proxy target but the proxy &quot;        \\012 &quot;did not return its actual value (expected '%' but got '%')&quot;)              \\012  T(ProxyGetNonConfigurableAccessor,                                           \\012 &quot;'get' on proxy: property '%' is a non-configurable accessor &quot;             \\012 &quot;property on the proxy target and does not have a getter function, but &quot;   \\012 &quot;the trap did not return 'undefined' (got '%')&quot;)                           \\012  T(ProxyGetOwnPropertyDescriptorIncompatible,                                 \\012 &quot;'getOwnPropertyDescriptor' on proxy: trap returned descriptor for &quot;       \\012 &quot;property '%' that is incompatible with the existing property in the &quot;     \\012 &quot;proxy target&quot;)                                                            \\012  T(ProxyGetOwnPropertyDescriptorInvalid,                                      \\012 &quot;'getOwnPropertyDescriptor' on proxy: trap returned neither object nor &quot;   \\012 &quot;undefined for property '%'&quot;)                                              \\012  T(ProxyGetOwnPropertyDescriptorNonConfigurable,                              \\012 &quot;'getOwnPropertyDescriptor' on proxy: trap reported non-configurability &quot;  \\012 &quot;for property '%' which is either non-existant or configurable in the &quot;    \\012 &quot;proxy target&quot;)                                                            \\012  T(ProxyGetOwnPropertyDescriptorNonExtensible,                                \\012 &quot;'getOwnPropertyDescriptor' on proxy: trap returned undefined for &quot;        \\012 &quot;property '%' which exists in the non-extensible proxy target&quot;)            \\012  T(ProxyGetOwnPropertyDescriptorUndefined,                                    \\012 &quot;'getOwnPropertyDescriptor' on proxy: trap returned undefined for &quot;        \\012 &quot;property '%' which is non-configurable in the proxy target&quot;)              \\012  T(ProxyGetPrototypeOfInvalid,                                                \\012 &quot;'getPrototypeOf' on proxy: trap returned neither object nor null&quot;)        \\012  T(ProxyGetPrototypeOfNonExtensible,                                          \\012 &quot;'getPrototypeOf' on proxy: proxy target is non-extensible but the &quot;       \\012 &quot;trap did not return its actual prototype&quot;)                                \\012  T(ProxyHandlerOrTargetRevoked,                                               \\012 &quot;Cannot create proxy with a revoked proxy as target or handler&quot;)           \\012  T(ProxyHasNonConfigurable,                                                   \\012 &quot;'has' on proxy: trap returned falsish for property '%' which exists in &quot;  \\012 &quot;the proxy target as non-configurable&quot;)                                    \\012  T(ProxyHasNonExtensible,                                                     \\012 &quot;'has' on proxy: trap returned falsish for property '%' but the proxy &quot;    \\012 &quot;target is not extensible&quot;)                                                \\012  T(ProxyIsExtensibleInconsistent,                                             \\012 &quot;'isExtensible' on proxy: trap result does not reflect extensibility of &quot;  \\012 &quot;proxy target (which is '%')&quot;)                                             \\012  T(ProxyNonObject,                                                            \\012 &quot;Cannot create proxy with a non-object as target or handler&quot;)              \\012  T(ProxyOwnKeysMissing,                                                       \\012 &quot;'ownKeys' on proxy: trap result did not include '%'&quot;)                     \\012  T(ProxyOwnKeysNonExtensible,                                                 \\012 &quot;'ownKeys' on proxy: trap returned extra keys but proxy target is &quot;        \\012 &quot;non-extensible&quot;)                                                          \\012  T(ProxyPreventExtensionsExtensible,                                          \\012 &quot;'preventExtensions' on proxy: trap returned truish but the proxy target &quot; \\012 &quot;is extensible&quot;)                                                           \\012  T(ProxyPrivate, &quot;Cannot pass private property name to proxy trap&quot;)           \\012  T(ProxyRevoked, &quot;Cannot perform '%' on a proxy that has been revoked&quot;)       \\012  T(ProxySetFrozenData,                                                        \\012 &quot;'set' on proxy: trap returned truish for property '%' which exists in &quot;   \\012 &quot;the proxy target as a non-configurable and non-writable data property &quot;   \\012 &quot;with a different value&quot;)                                                  \\012  T(ProxySetFrozenAccessor,                                                    \\012 &quot;'set' on proxy: trap returned truish for property '%' which exists in &quot;   \\012 &quot;the proxy target as a non-configurable and non-writable accessor &quot;        \\012 &quot;property without a setter&quot;)                                               \\012  T(ProxySetPrototypeOfNonExtensible,                                          \\012 &quot;'setPrototypeOf' on proxy: trap returned truish for setting a new &quot;       \\012 &quot;prototype on the non-extensible proxy target&quot;)                            \\012  T(ProxyTrapReturnedFalsish, &quot;'%' on proxy: trap returned falsish&quot;)           \\012  T(ProxyTrapReturnedFalsishFor,                                               \\012 &quot;'%' on proxy: trap returned falsish for property '%'&quot;)                    \\012  T(RedefineDisallowed, &quot;Cannot redefine property: %&quot;)                         \\012  T(RedefineExternalArray,                                                     \\012 &quot;Cannot redefine a property of an object with external array elements&quot;)    \\012  T(ReduceNoInitial, &quot;Reduce of empty array with no initial value&quot;)            \\012  T(RegExpFlags,                                                               \\012 &quot;Cannot supply flags when constructing one RegExp from another&quot;)           \\012  T(RegExpNonObject, &quot;% getter called on non-object %&quot;)                        \\012  T(RegExpNonRegExp, &quot;% getter called on non-RegExp object&quot;)                   \\012  T(RelativeDateTimeFormatterBadParameters,                                    \\012 &quot;Incorrect RelativeDateTimeFormatter provided&quot;)                            \\012  T(ResolverNotAFunction, &quot;Promise resolver % is not a function&quot;)              \\012  T(ReturnMethodNotCallable, &quot;The iterator's 'return' method is not callable&quot;) \\012  T(SharedArrayBufferTooShort,                                                 \\012 &quot;Derived SharedArrayBuffer constructor created a buffer which was too &quot;    \\012 &quot;small&quot;)                                                                   \\012  T(SharedArrayBufferSpeciesThis,                                              \\012 &quot;SharedArrayBuffer subclass returned this from species constructor&quot;)       \\012  T(StaticPrototype,                                                           \\012 &quot;Classes may not have a static property named 'prototype'&quot;)                \\012  T(StrictDeleteProperty, &quot;Cannot delete property '%' of %&quot;)                   \\012  T(StrictPoisonPill,                                                          \\012 &quot;'caller', 'callee', and 'arguments' properties may not be accessed on &quot;   \\012 &quot;strict mode functions or the arguments objects for calls to them&quot;)        \\012  T(StrictReadOnlyProperty,                                                    \\012 &quot;Cannot assign to read only property '%' of % '%'&quot;)                        \\012  T(StrictCannotCreateProperty, &quot;Cannot create property '%' on % '%'&quot;)         \\012  T(SymbolIteratorInvalid,                                                     \\012 &quot;Result of the Symbol.iterator method is not an object&quot;)                   \\012  T(SymbolAsyncIteratorInvalid,                                                \\012 &quot;Result of the Symbol.asyncIterator method is not an object&quot;)              \\012  T(SymbolKeyFor, &quot;% is not a symbol&quot;)                                         \\012  T(SymbolToNumber, &quot;Cannot convert a Symbol value to a number&quot;)               \\012  T(SymbolToString, &quot;Cannot convert a Symbol value to a string&quot;)               \\012  T(ThrowMethodMissing, &quot;The iterator does not provide a 'throw' method.&quot;)     \\012  T(UndefinedOrNullToObject, &quot;Cannot convert undefined or null to object&quot;)     \\012  T(ValueAndAccessor,                                                          \\012 &quot;Invalid property descriptor. Cannot both specify accessors and a value &quot;  \\012 &quot;or writable attribute, %&quot;)                                                \\012  T(VarRedeclaration, &quot;Identifier '%' has already been declared&quot;)              \\012  T(WrongArgs, &quot;%: Arguments list has wrong type&quot;)                             \\012 /* ReferenceError */                                                         \\012  T(NotDefined, &quot;% is not defined&quot;)                                            \\012  T(SuperAlreadyCalled, &quot;Super constructor may only be called once&quot;)           \\012  T(UnsupportedSuper, &quot;Unsupported reference to 'super'&quot;)                      \\012 /* RangeError */                                                             \\012  T(BigIntDivZero, &quot;Division by zero&quot;)                                         \\012  T(BigIntNegativeExponent, &quot;Exponent must be positive&quot;)                       \\012  T(BigIntTooBig, &quot;Maximum BigInt size exceeded&quot;)                              \\012  T(DateRange, &quot;Provided date is not in valid range.&quot;)                         \\012  T(ExpectedLocation,                                                          \\012 &quot;Expected letters optionally connected with underscores or hyphens for &quot;   \\012 &quot;a location, got %&quot;)                                                       \\012  T(InvalidArrayBufferLength, &quot;Invalid array buffer length&quot;)                   \\012  T(ArrayBufferAllocationFailed, &quot;Array buffer allocation failed&quot;)             \\012  T(InvalidArrayLength, &quot;Invalid array length&quot;)                                \\012  T(InvalidAtomicAccessIndex, &quot;Invalid atomic access index&quot;)                   \\012  T(InvalidCodePoint, &quot;Invalid code point %&quot;)                                  \\012  T(InvalidCountValue, &quot;Invalid count value&quot;)                                  \\012  T(InvalidCurrencyCode, &quot;Invalid currency code: %&quot;)                           \\012  T(InvalidDataViewAccessorOffset,                                             \\012 &quot;Offset is outside the bounds of the DataView&quot;)                            \\012  T(InvalidDataViewLength, &quot;Invalid DataView length %&quot;)                        \\012  T(InvalidOffset, &quot;Start offset % is outside the bounds of the buffer&quot;)       \\012  T(InvalidHint, &quot;Invalid hint: %&quot;)                                            \\012  T(InvalidIndex, &quot;Invalid value: not (convertible to) a safe integer&quot;)        \\012  T(InvalidLanguageTag, &quot;Invalid language tag: %&quot;)                             \\012  T(InvalidWeakMapKey, &quot;Invalid value used as weak map key&quot;)                   \\012  T(InvalidWeakSetValue, &quot;Invalid value used in weak set&quot;)                     \\012  T(InvalidStringLength, &quot;Invalid string length&quot;)                              \\012  T(InvalidTimeValue, &quot;Invalid time value&quot;)                                    \\012  T(InvalidTimeZone, &quot;Invalid time zone specified: %&quot;)                         \\012  T(InvalidTypedArrayAlignment, &quot;% of % should be a multiple of %&quot;)            \\012  T(InvalidTypedArrayIndex, &quot;Invalid typed array index&quot;)                       \\012  T(InvalidTypedArrayLength, &quot;Invalid typed array length: %&quot;)                  \\012  T(LetInLexicalBinding, &quot;let is disallowed as a lexically bound name&quot;)        \\012  T(LocaleMatcher, &quot;Illegal value for localeMatcher:%&quot;)                        \\012  T(NormalizationForm, &quot;The normalization form should be one of %.&quot;)           \\012  T(ZeroDigitNumericSeparator,                                                 \\012 &quot;Numeric separator can not be used after leading 0.&quot;)                      \\012  T(NumberFormatRange, &quot;% argument must be between 0 and 100&quot;)                 \\012  T(TrailingNumericSeparator,                                                  \\012 &quot;Numeric separators are not allowed at the end of numeric literals&quot;)       \\012  T(ContinuousNumericSeparator,                                                \\012 &quot;Only one underscore is allowed as numeric separator&quot;)                     \\012  T(PropertyValueOutOfRange, &quot;% value is out of range.&quot;)                       \\012  T(StackOverflow, &quot;Maximum call stack size exceeded&quot;)                         \\012  T(ToPrecisionFormatRange,                                                    \\012 &quot;toPrecision() argument must be between 1 and 100&quot;)                        \\012  T(ToRadixFormatRange, &quot;toString() radix argument must be between 2 and 36&quot;)  \\012  T(TypedArraySetOffsetOutOfBounds, &quot;offset is out of bounds&quot;)                 \\012  T(TypedArraySetSourceTooLarge, &quot;Source is too large&quot;)                        \\012  T(ValueOutOfRange, &quot;Value % out of range for % options property %&quot;)          \\012 /* SyntaxError */                                                            \\012  T(AmbiguousExport,                                                           \\012 &quot;The requested module '%' contains conflicting star exports for name '%'&quot;) \\012  T(BadGetterArity, &quot;Getter must not have any formal parameters.&quot;)             \\012  T(BadSetterArity, &quot;Setter must have exactly one formal parameter.&quot;)          \\012  T(BigIntInvalidString, &quot;Invalid BigInt string&quot;)                              \\012  T(ConstructorIsAccessor, &quot;Class constructor may not be an accessor&quot;)         \\012  T(ConstructorIsGenerator, &quot;Class constructor may not be a generator&quot;)        \\012  T(ConstructorIsAsync, &quot;Class constructor may not be an async method&quot;)        \\012  T(DerivedConstructorReturnedNonObject,                                       \\012 &quot;Derived constructors may only return object or undefined&quot;)                \\012  T(DuplicateConstructor, &quot;A class may only have one constructor&quot;)             \\012  T(DuplicateExport, &quot;Duplicate export of '%'&quot;)                                \\012  T(DuplicateProto,                                                            \\012 &quot;Duplicate __proto__ fields are not allowed in object literals&quot;)           \\012  T(ForInOfLoopInitializer,                                                    \\012 &quot;% loop variable declaration may not have an initializer.&quot;)                \\012  T(ForInOfLoopMultiBindings,                                                  \\012 &quot;Invalid left-hand side in % loop: Must have a single binding.&quot;)           \\012  T(GeneratorInSingleStatementContext,                                         \\012 &quot;Generators can only be declared at the top level or inside a block.&quot;)     \\012  T(AsyncFunctionInSingleStatementContext,                                     \\012 &quot;Async functions can only be declared at the top level or inside a &quot;       \\012 &quot;block.&quot;)                                                                  \\012  T(IllegalBreak, &quot;Illegal break statement&quot;)                                   \\012  T(NoIterationStatement,                                                      \\012 &quot;Illegal continue statement: no surrounding iteration statement&quot;)          \\012  T(IllegalContinue,                                                           \\012 &quot;Illegal continue statement: '%' does not denote an iteration statement&quot;)  \\012  T(IllegalLanguageModeDirective,                                              \\012 &quot;Illegal '%' directive in function with non-simple parameter list&quot;)        \\012  T(IllegalReturn, &quot;Illegal return statement&quot;)                                 \\012  T(IntrinsicWithSpread, &quot;Intrinsic calls do not support spread arguments&quot;)    \\012  T(InvalidRestBindingPattern,                                                 \\012 &quot;`...` must be followed by an identifier in declaration contexts&quot;)         \\012  T(InvalidRestAssignmentPattern,                                              \\012 &quot;`...` must be followed by an assignable reference in assignment &quot;         \\012 &quot;contexts&quot;)                                                                \\012  T(InvalidEscapedReservedWord, &quot;Keyword must not contain escaped characters&quot;) \\012  T(InvalidEscapedMetaProperty, &quot;'%' must not contain escaped characters&quot;)     \\012  T(InvalidLhsInAssignment, &quot;Invalid left-hand side in assignment&quot;)            \\012  T(InvalidCoverInitializedName, &quot;Invalid shorthand property initializer&quot;)     \\012  T(InvalidDestructuringTarget, &quot;Invalid destructuring assignment target&quot;)     \\012  T(InvalidLhsInFor, &quot;Invalid left-hand side in for-loop&quot;)                     \\012  T(InvalidLhsInPostfixOp,                                                     \\012 &quot;Invalid left-hand side expression in postfix operation&quot;)                  \\012  T(InvalidLhsInPrefixOp,                                                      \\012 &quot;Invalid left-hand side expression in prefix operation&quot;)                   \\012  T(InvalidRegExpFlags, &quot;Invalid flags supplied to RegExp constructor '%'&quot;)    \\012  T(InvalidOrUnexpectedToken, &quot;Invalid or unexpected token&quot;)                   \\012  T(InvalidPrivateFieldAccess, &quot;Invalid private field '%'&quot;)                    \\012  T(JsonParseUnexpectedEOS, &quot;Unexpected end of JSON input&quot;)                    \\012  T(JsonParseUnexpectedToken, &quot;Unexpected token % in JSON at position %&quot;)      \\012  T(JsonParseUnexpectedTokenNumber, &quot;Unexpected number in JSON at position %&quot;) \\012  T(JsonParseUnexpectedTokenString, &quot;Unexpected string in JSON at position %&quot;) \\012  T(LabelRedeclaration, &quot;Label '%' has already been declared&quot;)                 \\012  T(LabelledFunctionDeclaration,                                               \\012 &quot;Labelled function declaration not allowed as the body of a control flow &quot; \\012 &quot;structure&quot;)                                                               \\012  T(MalformedArrowFunParamList, &quot;Malformed arrow function parameter list&quot;)     \\012  T(MalformedRegExp, &quot;Invalid regular expression: /%/: %&quot;)                     \\012  T(MalformedRegExpFlags, &quot;Invalid regular expression flags&quot;)                  \\012  T(ModuleExportUndefined, &quot;Export '%' is not defined in module&quot;)              \\012  T(HtmlCommentInModule, &quot;HTML comments are not allowed in modules&quot;)           \\012  T(MultipleDefaultsInSwitch,                                                  \\012 &quot;More than one default clause in switch statement&quot;)                        \\012  T(NewlineAfterThrow, &quot;Illegal newline after throw&quot;)                          \\012  T(NoCatchOrFinally, &quot;Missing catch or finally after try&quot;)                    \\012  T(NotIsvar, &quot;builtin %%IS_VAR: not a variable&quot;)                              \\012  T(ParamAfterRest, &quot;Rest parameter must be last formal parameter&quot;)            \\012  T(FlattenPastSafeLength,                                                     \\012 &quot;Flattening % elements on an array-like of length % &quot;                      \\012 &quot;is disallowed, as the total surpasses 2**53-1&quot;)                           \\012  T(PushPastSafeLength,                                                        \\012 &quot;Pushing % elements on an array-like of length % &quot;                         \\012 &quot;is disallowed, as the total surpasses 2**53-1&quot;)                           \\012  T(ElementAfterRest, &quot;Rest element must be last element&quot;)                     \\012  T(BadSetterRestParameter,                                                    \\012 &quot;Setter function argument must not be a rest parameter&quot;)                   \\012  T(ParamDupe, &quot;Duplicate parameter name not allowed in this context&quot;)         \\012  T(ParenthesisInArgString, &quot;Function arg string contains parenthesis&quot;)        \\012  T(ArgStringTerminatesParametersEarly,                                        \\012 &quot;Arg string terminates parameters early&quot;)                                  \\012  T(UnexpectedEndOfArgString, &quot;Unexpected end of arg string&quot;)                  \\012  T(RestDefaultInitializer,                                                    \\012 &quot;Rest parameter may not have a default initializer&quot;)                       \\012  T(RuntimeWrongNumArgs, &quot;Runtime function given wrong number of arguments&quot;)   \\012  T(SuperNotCalled,                                                            \\012 &quot;Must call super constructor in derived class before accessing 'this' or &quot; \\012 &quot;returning from derived constructor&quot;)                                      \\012  T(SingleFunctionLiteral, &quot;Single function literal required&quot;)                 \\012  T(SloppyFunction,                                                            \\012 &quot;In non-strict mode code, functions can only be declared at top level, &quot;   \\012 &quot;inside a block, or as the body of an if statement.&quot;)                      \\012  T(SpeciesNotConstructor,                                                     \\012 &quot;object.constructor[Symbol.species] is not a constructor&quot;)                 \\012  T(StrictDelete, &quot;Delete of an unqualified identifier in strict mode.&quot;)       \\012  T(StrictEvalArguments, &quot;Unexpected eval or arguments in strict mode&quot;)        \\012  T(StrictFunction,                                                            \\012 &quot;In strict mode code, functions can only be declared at top level or &quot;     \\012 &quot;inside a block.&quot;)                                                         \\012  T(StrictOctalLiteral, &quot;Octal literals are not allowed in strict mode.&quot;)      \\012  T(StrictDecimalWithLeadingZero,                                              \\012 &quot;Decimals with leading zeros are not allowed in strict mode.&quot;)             \\012  T(StrictOctalEscape,                                                         \\012 &quot;Octal escape sequences are not allowed in strict mode.&quot;)                  \\012  T(StrictWith, &quot;Strict mode code may not include a with statement&quot;)           \\012  T(TemplateOctalLiteral,                                                      \\012 &quot;Octal escape sequences are not allowed in template strings.&quot;)             \\012  T(ThisFormalParameter, &quot;'this' is not a valid formal parameter name&quot;)        \\012  T(AwaitBindingIdentifier,                                                    \\012 &quot;'await' is not a valid identifier name in an async function&quot;)             \\012  T(AwaitExpressionFormalParameter,                                            \\012 &quot;Illegal await-expression in formal parameters of async function&quot;)         \\012  T(TooManyArguments,                                                          \\012 &quot;Too many arguments in function call (only 65535 allowed)&quot;)                \\012  T(TooManyParameters,                                                         \\012 &quot;Too many parameters in function definition (only 65534 allowed)&quot;)         \\012  T(TooManySpreads,                                                            \\012 &quot;Literal containing too many nested spreads (up to 65534 allowed)&quot;)        \\012  T(TooManyVariables, &quot;Too many variables declared (only 4194303 allowed)&quot;)    \\012  T(TooManyElementsInPromiseAll, &quot;Too many elements passed to Promise.all&quot;)    \\012  T(TypedArrayTooShort,                                                        \\012 &quot;Derived TypedArray constructor created an array which was too small&quot;)     \\012  T(UnexpectedEOS, &quot;Unexpected end of input&quot;)                                  \\012  T(UnexpectedReserved, &quot;Unexpected reserved word&quot;)                            \\012  T(UnexpectedStrictReserved, &quot;Unexpected strict mode reserved word&quot;)          \\012  T(UnexpectedSuper, &quot;'super' keyword unexpected here&quot;)                        \\012  T(UnexpectedNewTarget, &quot;new.target expression is not allowed here&quot;)          \\012  T(UnexpectedTemplateString, &quot;Unexpected template string&quot;)                    \\012  T(UnexpectedToken, &quot;Unexpected token %&quot;)                                     \\012  T(UnexpectedTokenIdentifier, &quot;Unexpected identifier&quot;)                        \\012  T(UnexpectedTokenNumber, &quot;Unexpected number&quot;)                                \\012  T(UnexpectedTokenString, &quot;Unexpected string&quot;)                                \\012  T(UnexpectedTokenRegExp, &quot;Unexpected regular expression&quot;)                    \\012  T(UnexpectedLexicalDeclaration,                                              \\012 &quot;Lexical declaration cannot appear in a single-statement context&quot;)         \\012  T(UnknownLabel, &quot;Undefined label '%'&quot;)                                       \\012  T(UnresolvableExport,                                                        \\012 &quot;The requested module '%' does not provide an export named '%'&quot;)           \\012  T(UnterminatedArgList, &quot;missing ) after argument list&quot;)                      \\012  T(UnterminatedRegExp, &quot;Invalid regular expression: missing /&quot;)               \\012  T(UnterminatedTemplate, &quot;Unterminated template literal&quot;)                     \\012  T(UnterminatedTemplateExpr, &quot;Missing } in template expression&quot;)              \\012  T(FoundNonCallableHasInstance, &quot;Found non-callable @@hasInstance&quot;)           \\012  T(InvalidHexEscapeSequence, &quot;Invalid hexadecimal escape sequence&quot;)           \\012  T(InvalidUnicodeEscapeSequence, &quot;Invalid Unicode escape sequence&quot;)           \\012  T(UndefinedUnicodeCodePoint, &quot;Undefined Unicode code-point&quot;)                 \\012  T(YieldInParameter, &quot;Yield expression not allowed in formal parameter&quot;)      \\012 /* EvalError */                                                              \\012  T(CodeGenFromStrings, &quot;%&quot;)                                                   \\012  T(NoSideEffectDebugEvaluate, &quot;Possible side-effect in debug-evaluate&quot;)       \\012 /* URIError */                                                               \\012  T(URIMalformed, &quot;URI malformed&quot;)                                             \\012 /* Wasm errors (currently Error) */                                          \\012  T(WasmTrapUnreachable, &quot;unreachable&quot;)                                        \\012  T(WasmTrapMemOutOfBounds, &quot;memory access out of bounds&quot;)                     \\012  T(WasmTrapUnalignedAccess, &quot;operation does not support unaligned accesses&quot;)  \\012  T(WasmTrapDivByZero, &quot;divide by zero&quot;)                                       \\012  T(WasmTrapDivUnrepresentable, &quot;divide result unrepresentable&quot;)               \\012  T(WasmTrapRemByZero, &quot;remainder by zero&quot;)                                    \\012  T(WasmTrapFloatUnrepresentable, &quot;float unrepresentable in integer range&quot;)    \\012  T(WasmTrapFuncInvalid, &quot;invalid index into function table&quot;)                  \\012  T(WasmTrapFuncSigMismatch, &quot;function signature mismatch&quot;)                    \\012  T(WasmTrapTypeError, &quot;wasm function signature contains illegal type&quot;)        \\012  T(WasmExceptionError, &quot;wasm exception&quot;)                                      \\012 /* Asm.js validation related */                                              \\012  T(AsmJsInvalid, &quot;Invalid asm.js: %&quot;)                                         \\012  T(AsmJsCompiled, &quot;Converted asm.js to WebAssembly: %&quot;)                       \\012  T(AsmJsInstantiated, &quot;Instantiated asm.js: %&quot;)                               \\012  T(AsmJsLinkingFailed, &quot;Linking failure in asm.js: %&quot;)                        \\012 /* DataCloneError messages */                                                \\012  T(DataCloneError, &quot;% could not be cloned.&quot;)                                  \\012  T(DataCloneErrorOutOfMemory, &quot;Data cannot be cloned, out of memory.&quot;)        \\012  T(DataCloneErrorNeuteredArrayBuffer,                                         \\012 &quot;An ArrayBuffer is neutered and could not be cloned.&quot;)                     \\012  T(DataCloneErrorSharedArrayBufferTransferred,                                \\012 &quot;A SharedArrayBuffer could not be cloned. SharedArrayBuffer must not be &quot;  \\012 &quot;transferred.&quot;)                                                            \\012  T(DataCloneDeserializationError, &quot;Unable to deserialize cloned data.&quot;)       \\012  T(DataCloneDeserializationVersionError,                                      \\012 &quot;Unable to deserialize cloned data due to invalid or unsupported &quot;         \\012 &quot;version.&quot;)                                                                \\012 /* Builtins-Trace Errors */                                                  \\012  T(TraceEventCategoryError, &quot;Trace event category must be a string.&quot;)         \\012  T(TraceEventNameError, &quot;Trace event name must be a string.&quot;)                 \\012  T(TraceEventNameLengthError,                                                 \\012 &quot;Trace event name must not be an empty string.&quot;)                           \\012  T(TraceEventPhaseError, &quot;Trace event phase must be a number.&quot;)               \\012  T(TraceEventIDError, &quot;Trace event id must be a number.&quot;)\012\012class MessageTemplate {\012 public:\012 enum Template {\012#define TEMPLATE(NAME, STRING) k##NAME,\012    MESSAGE_TEMPLATES(TEMPLATE)\012#undef TEMPLATE\012        kLastMessage\012 };\012\012 static const char* TemplateString(int template_index);\012\012 static MaybeHandle&lt;String&gt; FormatMessage(Isolate* isolate, int template_index,\012 Handle&lt;String&gt; arg0,\012 Handle&lt;String&gt; arg1,\012 Handle&lt;String&gt; arg2);\012\012 static Handle&lt;String&gt; FormatMessage(Isolate* isolate, int template_index,\012 Handle&lt;Object&gt; arg);\012};\012\012\012// A message handler is a convenience interface for accessing the list\012// of message listeners registered in an environment\012class MessageHandler {\012 public:\012 // Returns a message object for the API to use.\012 static Handle&lt;JSMessageObject&gt; MakeMessageObject(\012 Isolate* isolate, MessageTemplate::Template type,\012 const MessageLocation* location, Handle&lt;Object&gt; argument,\012 Handle&lt;FixedArray&gt; stack_frames);\012\012 // Report a formatted message (needs JS allocation).\012 static void ReportMessage(Isolate* isolate, const MessageLocation* loc,\012 Handle&lt;JSMessageObject&gt; message);\012\012 static void DefaultMessageReport(Isolate* isolate, const MessageLocation* loc,\012 Handle&lt;Object&gt; message_obj);\012 static Handle&lt;String&gt; GetMessage(Isolate* isolate, Handle&lt;Object&gt; data);\012 static std::unique_ptr&lt;char[]&gt; GetLocalizedMessage(Isolate* isolate,\012 Handle&lt;Object&gt; data);\012\012 private:\012 static void ReportMessageNoExceptions(Isolate* isolate,\012 const MessageLocation* loc,\012 Handle&lt;Object&gt; message_obj,\012                                        v8::Local&lt;v8::Value&gt; api_exception_obj);\012};\012\012\012} // namespace internal\012})<SUB>17</SUB>> ]
+"9" [label = <(UNKNOWN,namespace v8 {\012namespace internal {\012namespace wasm {\012class WasmCode;\012}\012\012// Forward declarations.\012class AbstractCode;\012class FrameArray;\012class JSMessageObject;\012class LookupIterator;\012class SharedFunctionInfo;\012class SourceInfo;\012class WasmInstanceObject;\012\012class MessageLocation {\012 public:\012 MessageLocation(Handle&lt;Script&gt; script, int start_pos, int end_pos);\012 MessageLocation(Handle&lt;Script&gt; script, int start_pos, int end_pos,\012 Handle&lt;SharedFunctionInfo&gt; shared);\012 MessageLocation();\012\012 Handle&lt;Script&gt; script() const { return script_; }\012 int start_pos() const { return start_pos_; }\012 int end_pos() const { return end_pos_; }\012 Handle&lt;SharedFunctionInfo&gt; shared() const { return shared_; }\012\012 private:\012 Handle&lt;Script&gt; script_;\012 int start_pos_;\012 int end_pos_;\012 Handle&lt;SharedFunctionInfo&gt; shared_;\012};\012\012class StackFrameBase {\012 public:\012 virtual ~StackFrameBase() {}\012\012 virtual Handle&lt;Object&gt; GetReceiver() const = 0;\012 virtual Handle&lt;Object&gt; GetFunction() const = 0;\012\012 virtual Handle&lt;Object&gt; GetFileName() = 0;\012 virtual Handle&lt;Object&gt; GetFunctionName() = 0;\012 virtual Handle&lt;Object&gt; GetScriptNameOrSourceUrl() = 0;\012 virtual Handle&lt;Object&gt; GetMethodName() = 0;\012 virtual Handle&lt;Object&gt; GetTypeName() = 0;\012 virtual Handle&lt;Object&gt; GetEvalOrigin();\012\012 virtual int GetPosition() const = 0;\012 // Return 1-based line number, including line offset.\012 virtual int GetLineNumber() = 0;\012 // Return 1-based column number, including column offset if first line.\012 virtual int GetColumnNumber() = 0;\012\012 virtual bool IsNative() = 0;\012 virtual bool IsToplevel() = 0;\012 virtual bool IsEval();\012 virtual bool IsConstructor() = 0;\012 virtual bool IsStrict() const = 0;\012\012 virtual MaybeHandle&lt;String&gt; ToString() = 0;\012\012 protected:\012 StackFrameBase() {}\012 explicit StackFrameBase(Isolate* isolate) : isolate_(isolate) {}\012 Isolate* isolate_;\012\012 private:\012 virtual bool HasScript() const = 0;\012 virtual Handle&lt;Script&gt; GetScript() const = 0;\012};\012\012class JSStackFrame : public StackFrameBase {\012 public:\012 JSStackFrame(Isolate* isolate, Handle&lt;Object&gt; receiver,\012 Handle&lt;JSFunction&gt; function, Handle&lt;AbstractCode&gt; code,\012 int offset);\012 virtual ~JSStackFrame() {}\012\012 Handle&lt;Object&gt; GetReceiver() const override { return receiver_; }\012 Handle&lt;Object&gt; GetFunction() const override;\012\012 Handle&lt;Object&gt; GetFileName() override;\012 Handle&lt;Object&gt; GetFunctionName() override;\012 Handle&lt;Object&gt; GetScriptNameOrSourceUrl() override;\012 Handle&lt;Object&gt; GetMethodName() override;\012 Handle&lt;Object&gt; GetTypeName() override;\012\012 int GetPosition() const override;\012 int GetLineNumber() override;\012 int GetColumnNumber() override;\012\012 bool IsNative() override;\012 bool IsToplevel() override;\012 bool IsConstructor() override { return is_constructor_; }\012 bool IsStrict() const override { return is_strict_; }\012\012 MaybeHandle&lt;String&gt; ToString() override;\012\012 private:\012 JSStackFrame();\012 void FromFrameArray(Isolate* isolate, Handle&lt;FrameArray&gt; array, int frame_ix);\012\012 bool HasScript() const override;\012 Handle&lt;Script&gt; GetScript() const override;\012\012 Handle&lt;Object&gt; receiver_;\012 Handle&lt;JSFunction&gt; function_;\012 Handle&lt;AbstractCode&gt; code_;\012 int offset_;\012\012 bool is_constructor_;\012 bool is_strict_;\012\012 friend class FrameArrayIterator;\012};\012\012class WasmStackFrame : public StackFrameBase {\012 public:\012 virtual ~WasmStackFrame() {}\012\012 Handle&lt;Object&gt; GetReceiver() const override;\012 Handle&lt;Object&gt; GetFunction() const override;\012\012 Handle&lt;Object&gt; GetFileName() override { return Null(); }\012 Handle&lt;Object&gt; GetFunctionName() override;\012 Handle&lt;Object&gt; GetScriptNameOrSourceUrl() override { return Null(); }\012 Handle&lt;Object&gt; GetMethodName() override { return Null(); }\012 Handle&lt;Object&gt; GetTypeName() override { return Null(); }\012\012 int GetPosition() const override;\012 int GetLineNumber() override { return wasm_func_index_; }\012 int GetColumnNumber() override { return -1; }\012\012 bool IsNative() override { return false; }\012 bool IsToplevel() override { return false; }\012 bool IsConstructor() override { return false; }\012 bool IsStrict() const override { return false; }\012 bool IsInterpreted() const { return code_ == nullptr; }\012\012 MaybeHandle&lt;String&gt; ToString() override;\012\012 protected:\012 Handle&lt;Object&gt; Null() const;\012\012 bool HasScript() const override;\012 Handle&lt;Script&gt; GetScript() const override;\012\012 Handle&lt;WasmInstanceObject&gt; wasm_instance_;\012 uint32_t wasm_func_index_;\012  wasm::WasmCode* code_; // null for interpreted frames.\012 int offset_;\012\012 private:\012 WasmStackFrame();\012 void FromFrameArray(Isolate* isolate, Handle&lt;FrameArray&gt; array, int frame_ix);\012\012 friend class FrameArrayIterator;\012 friend class AsmJsWasmStackFrame;\012};\012\012class AsmJsWasmStackFrame : public WasmStackFrame {\012 public:\012 virtual ~AsmJsWasmStackFrame() {}\012\012 Handle&lt;Object&gt; GetReceiver() const override;\012 Handle&lt;Object&gt; GetFunction() const override;\012\012 Handle&lt;Object&gt; GetFileName() override;\012 Handle&lt;Object&gt; GetScriptNameOrSourceUrl() override;\012\012 int GetPosition() const override;\012 int GetLineNumber() override;\012 int GetColumnNumber() override;\012\012 MaybeHandle&lt;String&gt; ToString() override;\012\012 private:\012 friend class FrameArrayIterator;\012 AsmJsWasmStackFrame();\012 void FromFrameArray(Isolate* isolate, Handle&lt;FrameArray&gt; array, int frame_ix);\012\012 bool is_at_number_conversion_;\012};\012\012class FrameArrayIterator {\012 public:\012 FrameArrayIterator(Isolate* isolate, Handle&lt;FrameArray&gt; array,\012 int frame_ix = 0);\012\012 StackFrameBase* Frame();\012\012 bool HasNext() const;\012 void Next();\012\012 private:\012 Isolate* isolate_;\012\012 Handle&lt;FrameArray&gt; array_;\012 int next_frame_ix_;\012\012 WasmStackFrame wasm_frame_;\012 AsmJsWasmStackFrame asm_wasm_frame_;\012 JSStackFrame js_frame_;\012};\012\012// Determines how stack trace collection skips frames.\012enum FrameSkipMode {\012 // Unconditionally skips the first frame. Used e.g. when the Error constructor\012 // is called, in which case the first frame is always a BUILTIN_EXIT frame.\012  SKIP_FIRST,\012 // Skip all frames until a specified caller function is seen.\012  SKIP_UNTIL_SEEN,\012  SKIP_NONE,\012};\012\012class ErrorUtils : public AllStatic {\012 public:\012 static MaybeHandle&lt;Object&gt; Construct(\012 Isolate* isolate, Handle&lt;JSFunction&gt; target, Handle&lt;Object&gt; new_target,\012 Handle&lt;Object&gt; message, FrameSkipMode mode, Handle&lt;Object&gt; caller,\012 bool suppress_detailed_trace);\012\012 static MaybeHandle&lt;String&gt; ToString(Isolate* isolate, Handle&lt;Object&gt; recv);\012\012 static MaybeHandle&lt;Object&gt; MakeGenericError(\012 Isolate* isolate, Handle&lt;JSFunction&gt; constructor, int template_index,\012 Handle&lt;Object&gt; arg0, Handle&lt;Object&gt; arg1, Handle&lt;Object&gt; arg2,\012 FrameSkipMode mode);\012\012 // Formats a textual stack trace from the given structured stack trace.\012 // Note that this can call arbitrary JS code through Error.prepareStackTrace.\012 static MaybeHandle&lt;Object&gt; FormatStackTrace(Isolate* isolate,\012 Handle&lt;JSObject&gt; error,\012 Handle&lt;Object&gt; stack_trace);\012};\012\012#define MESSAGE_TEMPLATES(T)                                                   \\012 /* Error */                                                                  \\012  T(None, &quot;&quot;)                                                                  \\012  T(CyclicProto, &quot;Cyclic __proto__ value&quot;)                                     \\012  T(Debugger, &quot;Debugger: %&quot;)                                                   \\012  T(DebuggerLoading, &quot;Error loading debugger&quot;)                                 \\012  T(DefaultOptionsMissing, &quot;Internal % error. Default options are missing.&quot;)   \\012  T(DeletePrivateField, &quot;Private fields can not be deleted&quot;)                   \\012  T(UncaughtException, &quot;Uncaught %&quot;)                                           \\012  T(Unsupported, &quot;Not supported&quot;)                                              \\012  T(WrongServiceType, &quot;Internal error, wrong service type: %&quot;)                 \\012  T(WrongValueType, &quot;Internal error. Wrong value type.&quot;)                       \\012  T(IcuError, &quot;Internal error. Icu error.&quot;)                                    \\012 /* TypeError */                                                              \\012  T(ApplyNonFunction,                                                          \\012 &quot;Function.prototype.apply was called on %, which is a % and not a &quot;        \\012 &quot;function&quot;)                                                                \\012  T(ArgumentsDisallowedInInitializer,                                          \\012 &quot;'arguments' is not allowed in class field initializer&quot;)                   \\012  T(ArrayBufferTooShort,                                                       \\012 &quot;Derived ArrayBuffer constructor created a buffer which was too small&quot;)    \\012  T(ArrayBufferSpeciesThis,                                                    \\012 &quot;ArrayBuffer subclass returned this from species constructor&quot;)             \\012  T(ArrayItemNotType, &quot;array %[%] is not type %&quot;)                              \\012  T(AwaitNotInAsyncFunction, &quot;await is only valid in async function&quot;)          \\012  T(AtomicsWaitNotAllowed, &quot;Atomics.wait cannot be called in this context&quot;)    \\012  T(BadSortComparisonFunction,                                                 \\012 &quot;The comparison function must be either a function or undefined&quot;)          \\012  T(BigIntFromNumber,                                                          \\012 &quot;The number % cannot be converted to a BigInt because it is not an &quot;       \\012 &quot;integer&quot;)                                                                 \\012  T(BigIntFromObject, &quot;Cannot convert % to a BigInt&quot;)                          \\012  T(BigIntMixedTypes,                                                          \\012 &quot;Cannot mix BigInt and other types, use explicit conversions&quot;)             \\012  T(BigIntSerializeJSON, &quot;Do not know how to serialize a BigInt&quot;)              \\012  T(BigIntShr, &quot;BigInts have no unsigned right shift, use &gt;&gt; instead&quot;)         \\012  T(BigIntToNumber, &quot;Cannot convert a BigInt value to a number&quot;)               \\012  T(CalledNonCallable, &quot;% is not a function&quot;)                                  \\012  T(CalledOnNonObject, &quot;% called on non-object&quot;)                               \\012  T(CalledOnNullOrUndefined, &quot;% called on null or undefined&quot;)                  \\012  T(CallSiteExpectsFunction,                                                   \\012 &quot;CallSite expects wasm object as first or function as second argument, &quot;   \\012 &quot;got &lt;%, %&gt;&quot;)                                                              \\012  T(CallSiteMethod, &quot;CallSite method % expects CallSite as receiver&quot;)          \\012  T(CannotConvertToPrimitive, &quot;Cannot convert object to primitive value&quot;)      \\012  T(CannotPreventExt, &quot;Cannot prevent extensions&quot;)                             \\012  T(CannotFreeze, &quot;Cannot freeze&quot;)                                             \\012  T(CannotFreezeArrayBufferView,                                               \\012 &quot;Cannot freeze array buffer views with elements&quot;)                          \\012  T(CannotSeal, &quot;Cannot seal&quot;)                                                 \\012  T(CircularStructure, &quot;Converting circular structure to JSON&quot;)                \\012  T(ConstructAbstractClass, &quot;Abstract class % not directly constructable&quot;)     \\012  T(ConstAssign, &quot;Assignment to constant variable.&quot;)                           \\012  T(ConstructorClassField, &quot;Classes may not have a field named 'constructor'&quot;) \\012  T(ConstructorNonCallable,                                                    \\012 &quot;Class constructor % cannot be invoked without 'new'&quot;)                     \\012  T(ConstructorNotFunction, &quot;Constructor % requires 'new'&quot;)                    \\012  T(ConstructorNotReceiver, &quot;The .constructor property is not an object&quot;)      \\012  T(CurrencyCode, &quot;Currency code is required with currency style.&quot;)            \\012  T(CyclicModuleDependency, &quot;Detected cycle while resolving name '%' in '%'&quot;)  \\012  T(DataViewNotArrayBuffer,                                                    \\012 &quot;First argument to DataView constructor must be an ArrayBuffer&quot;)           \\012  T(DateType, &quot;this is not a Date object.&quot;)                                    \\012  T(DebuggerFrame, &quot;Debugger: Invalid frame index.&quot;)                           \\012  T(DebuggerType, &quot;Debugger: Parameters have wrong types.&quot;)                    \\012  T(DeclarationMissingInitializer, &quot;Missing initializer in % declaration&quot;)     \\012  T(DefineDisallowed, &quot;Cannot define property %, object is not extensible&quot;)    \\012  T(DetachedOperation, &quot;Cannot perform % on a detached ArrayBuffer&quot;)           \\012  T(DuplicateTemplateProperty, &quot;Object template has duplicate property '%'&quot;)   \\012  T(ExtendsValueNotConstructor,                                                \\012 &quot;Class extends value % is not a constructor or null&quot;)                      \\012  T(FirstArgumentNotRegExp,                                                    \\012 &quot;First argument to % must not be a regular expression&quot;)                    \\012  T(FunctionBind, &quot;Bind must be called on a function&quot;)                         \\012  T(GeneratorRunning, &quot;Generator is already running&quot;)                          \\012  T(IllegalInvocation, &quot;Illegal invocation&quot;)                                   \\012  T(ImmutablePrototypeSet,                                                     \\012 &quot;Immutable prototype object '%' cannot have their prototype set&quot;)          \\012  T(ImportCallNotNewExpression, &quot;Cannot use new with import&quot;)                  \\012  T(ImportMetaOutsideModule, &quot;Cannot use 'import.meta' outside a module&quot;)      \\012  T(ImportMissingSpecifier, &quot;import() requires a specifier&quot;)                   \\012  T(IncompatibleMethodReceiver, &quot;Method % called on incompatible receiver %&quot;)  \\012  T(InstanceofNonobjectProto,                                                  \\012 &quot;Function has non-object prototype '%' in instanceof check&quot;)               \\012  T(InvalidArgument, &quot;invalid_argument&quot;)                                       \\012  T(InvalidInOperatorUse, &quot;Cannot use 'in' operator to search for '%' in %&quot;)   \\012  T(InvalidRegExpExecResult,                                                   \\012 &quot;RegExp exec method returned something other than an Object or null&quot;)      \\012  T(InvalidUnit, &quot;Invalid unit argument for %() '%'&quot;)                          \\012  T(IteratorResultNotAnObject, &quot;Iterator result % is not an object&quot;)           \\012  T(IteratorSymbolNonCallable, &quot;Found non-callable @@iterator&quot;)                \\012  T(IteratorValueNotAnObject, &quot;Iterator value % is not an entry object&quot;)       \\012  T(LanguageID, &quot;Language ID should be string or object.&quot;)                     \\012  T(LocaleNotEmpty,                                                            \\012 &quot;First argument to Intl.Locale constructor can't be empty or missing&quot;)     \\012  T(LocaleBadParameters, &quot;Incorrect locale information provided&quot;)              \\012  T(ListFormatBadParameters, &quot;Incorrect ListFormat information provided&quot;)      \\012  T(MapperFunctionNonCallable, &quot;flatMap mapper function is not callable&quot;)      \\012  T(MethodCalledOnWrongObject,                                                 \\012 &quot;Method % called on a non-object or on a wrong type of object.&quot;)           \\012  T(MethodInvokedOnNullOrUndefined,                                            \\012 &quot;Method invoked on undefined or null value.&quot;)                              \\012  T(MethodInvokedOnWrongType, &quot;Method invoked on an object that is not %.&quot;)    \\012  T(NoAccess, &quot;no access&quot;)                                                     \\012  T(NonCallableInInstanceOfCheck,                                              \\012 &quot;Right-hand side of 'instanceof' is not callable&quot;)                         \\012  T(NonCoercible, &quot;Cannot destructure 'undefined' or 'null'.&quot;)                 \\012  T(NonCoercibleWithProperty,                                                  \\012 &quot;Cannot destructure property `%` of 'undefined' or 'null'.&quot;)               \\012  T(NonExtensibleProto, &quot;% is not extensible&quot;)                                 \\012  T(NonObjectInInstanceOfCheck,                                                \\012 &quot;Right-hand side of 'instanceof' is not an object&quot;)                        \\012  T(NonObjectPropertyLoad, &quot;Cannot read property '%' of %&quot;)                    \\012  T(NonObjectPropertyStore, &quot;Cannot set property '%' of %&quot;)                    \\012  T(NoSetterInCallback, &quot;Cannot set property % of % which has only a getter&quot;)  \\012  T(NotAnIterator, &quot;% is not an iterator&quot;)                                     \\012  T(NotAPromise, &quot;% is not a promise&quot;)                                         \\012  T(NotConstructor, &quot;% is not a constructor&quot;)                                  \\012  T(NotDateObject, &quot;this is not a Date object.&quot;)                               \\012  T(NotGeneric, &quot;% requires that 'this' be a %&quot;)                               \\012  T(NotCallableOrIterable,                                                     \\012 &quot;% is not a function or its return value is not iterable&quot;)                 \\012  T(NotCallableOrAsyncIterable,                                                \\012 &quot;% is not a function or its return value is not async iterable&quot;)           \\012  T(NotFiniteNumber, &quot;Value need to be finite number for %()&quot;)                 \\012  T(NotIterable, &quot;% is not iterable&quot;)                                          \\012  T(NotAsyncIterable, &quot;% is not async iterable&quot;)                               \\012  T(NotPropertyName, &quot;% is not a valid property name&quot;)                         \\012  T(NotTypedArray, &quot;this is not a typed array.&quot;)                               \\012  T(NotSuperConstructor, &quot;Super constructor % of % is not a constructor&quot;)      \\012  T(NotSuperConstructorAnonymousClass,                                         \\012 &quot;Super constructor % of anonymous class is not a constructor&quot;)             \\012  T(NotIntegerSharedTypedArray, &quot;% is not an integer shared typed array.&quot;)     \\012  T(NotInt32SharedTypedArray, &quot;% is not an int32 shared typed array.&quot;)         \\012  T(ObjectGetterExpectingFunction,                                             \\012 &quot;Object.prototype.__defineGetter__: Expecting function&quot;)                   \\012  T(ObjectGetterCallable, &quot;Getter must be a function: %&quot;)                      \\012  T(ObjectNotExtensible, &quot;Cannot add property %, object is not extensible&quot;)    \\012  T(ObjectSetterExpectingFunction,                                             \\012 &quot;Object.prototype.__defineSetter__: Expecting function&quot;)                   \\012  T(ObjectSetterCallable, &quot;Setter must be a function: %&quot;)                      \\012  T(OrdinaryFunctionCalledAsConstructor,                                       \\012 &quot;Function object that's not a constructor was created with new&quot;)           \\012  T(PromiseCyclic, &quot;Chaining cycle detected for promise %&quot;)                    \\012  T(PromiseExecutorAlreadyInvoked,                                             \\012 &quot;Promise executor has already been invoked with non-undefined arguments&quot;)  \\012  T(PromiseNonCallable, &quot;Promise resolve or reject function is not callable&quot;)  \\012  T(PropertyDescObject, &quot;Property description must be an object: %&quot;)           \\012  T(PropertyNotFunction,                                                       \\012 &quot;'%' returned for property '%' of object '%' is not a function&quot;)           \\012  T(ProtoObjectOrNull, &quot;Object prototype may only be an Object or null: %&quot;)    \\012  T(PrototypeParentNotAnObject,                                                \\012 &quot;Class extends value does not have valid prototype property %&quot;)            \\012  T(ProxyConstructNonObject,                                                   \\012 &quot;'construct' on proxy: trap returned non-object ('%')&quot;)                    \\012  T(ProxyDefinePropertyNonConfigurable,                                        \\012 &quot;'defineProperty' on proxy: trap returned truish for defining &quot;            \\012 &quot;non-configurable property '%' which is either non-existant or &quot;           \\012 &quot;configurable in the proxy target&quot;)                                        \\012  T(ProxyDefinePropertyNonExtensible,                                          \\012 &quot;'defineProperty' on proxy: trap returned truish for adding property '%' &quot; \\012 &quot; to the non-extensible proxy target&quot;)                                     \\012  T(ProxyDefinePropertyIncompatible,                                           \\012 &quot;'defineProperty' on proxy: trap returned truish for adding property '%' &quot; \\012 &quot; that is incompatible with the existing property in the proxy target&quot;)    \\012  T(ProxyDeletePropertyNonConfigurable,                                        \\012 &quot;'deleteProperty' on proxy: trap returned truish for property '%' which &quot;  \\012 &quot;is non-configurable in the proxy target&quot;)                                 \\012  T(ProxyGetNonConfigurableData,                                               \\012 &quot;'get' on proxy: property '%' is a read-only and &quot;                         \\012 &quot;non-configurable data property on the proxy target but the proxy &quot;        \\012 &quot;did not return its actual value (expected '%' but got '%')&quot;)              \\012  T(ProxyGetNonConfigurableAccessor,                                           \\012 &quot;'get' on proxy: property '%' is a non-configurable accessor &quot;             \\012 &quot;property on the proxy target and does not have a getter function, but &quot;   \\012 &quot;the trap did not return 'undefined' (got '%')&quot;)                           \\012  T(ProxyGetOwnPropertyDescriptorIncompatible,                                 \\012 &quot;'getOwnPropertyDescriptor' on proxy: trap returned descriptor for &quot;       \\012 &quot;property '%' that is incompatible with the existing property in the &quot;     \\012 &quot;proxy target&quot;)                                                            \\012  T(ProxyGetOwnPropertyDescriptorInvalid,                                      \\012 &quot;'getOwnPropertyDescriptor' on proxy: trap returned neither object nor &quot;   \\012 &quot;undefined for property '%'&quot;)                                              \\012  T(ProxyGetOwnPropertyDescriptorNonConfigurable,                              \\012 &quot;'getOwnPropertyDescriptor' on proxy: trap reported non-configurability &quot;  \\012 &quot;for property '%' which is either non-existant or configurable in the &quot;    \\012 &quot;proxy target&quot;)                                                            \\012  T(ProxyGetOwnPropertyDescriptorNonExtensible,                                \\012 &quot;'getOwnPropertyDescriptor' on proxy: trap returned undefined for &quot;        \\012 &quot;property '%' which exists in the non-extensible proxy target&quot;)            \\012  T(ProxyGetOwnPropertyDescriptorUndefined,                                    \\012 &quot;'getOwnPropertyDescriptor' on proxy: trap returned undefined for &quot;        \\012 &quot;property '%' which is non-configurable in the proxy target&quot;)              \\012  T(ProxyGetPrototypeOfInvalid,                                                \\012 &quot;'getPrototypeOf' on proxy: trap returned neither object nor null&quot;)        \\012  T(ProxyGetPrototypeOfNonExtensible,                                          \\012 &quot;'getPrototypeOf' on proxy: proxy target is non-extensible but the &quot;       \\012 &quot;trap did not return its actual prototype&quot;)                                \\012  T(ProxyHandlerOrTargetRevoked,                                               \\012 &quot;Cannot create proxy with a revoked proxy as target or handler&quot;)           \\012  T(ProxyHasNonConfigurable,                                                   \\012 &quot;'has' on proxy: trap returned falsish for property '%' which exists in &quot;  \\012 &quot;the proxy target as non-configurable&quot;)                                    \\012  T(ProxyHasNonExtensible,                                                     \\012 &quot;'has' on proxy: trap returned falsish for property '%' but the proxy &quot;    \\012 &quot;target is not extensible&quot;)                                                \\012  T(ProxyIsExtensibleInconsistent,                                             \\012 &quot;'isExtensible' on proxy: trap result does not reflect extensibility of &quot;  \\012 &quot;proxy target (which is '%')&quot;)                                             \\012  T(ProxyNonObject,                                                            \\012 &quot;Cannot create proxy with a non-object as target or handler&quot;)              \\012  T(ProxyOwnKeysMissing,                                                       \\012 &quot;'ownKeys' on proxy: trap result did not include '%'&quot;)                     \\012  T(ProxyOwnKeysNonExtensible,                                                 \\012 &quot;'ownKeys' on proxy: trap returned extra keys but proxy target is &quot;        \\012 &quot;non-extensible&quot;)                                                          \\012  T(ProxyPreventExtensionsExtensible,                                          \\012 &quot;'preventExtensions' on proxy: trap returned truish but the proxy target &quot; \\012 &quot;is extensible&quot;)                                                           \\012  T(ProxyPrivate, &quot;Cannot pass private property name to proxy trap&quot;)           \\012  T(ProxyRevoked, &quot;Cannot perform '%' on a proxy that has been revoked&quot;)       \\012  T(ProxySetFrozenData,                                                        \\012 &quot;'set' on proxy: trap returned truish for property '%' which exists in &quot;   \\012 &quot;the proxy target as a non-configurable and non-writable data property &quot;   \\012 &quot;with a different value&quot;)                                                  \\012  T(ProxySetFrozenAccessor,                                                    \\012 &quot;'set' on proxy: trap returned truish for property '%' which exists in &quot;   \\012 &quot;the proxy target as a non-configurable and non-writable accessor &quot;        \\012 &quot;property without a setter&quot;)                                               \\012  T(ProxySetPrototypeOfNonExtensible,                                          \\012 &quot;'setPrototypeOf' on proxy: trap returned truish for setting a new &quot;       \\012 &quot;prototype on the non-extensible proxy target&quot;)                            \\012  T(ProxyTrapReturnedFalsish, &quot;'%' on proxy: trap returned falsish&quot;)           \\012  T(ProxyTrapReturnedFalsishFor,                                               \\012 &quot;'%' on proxy: trap returned falsish for property '%'&quot;)                    \\012  T(RedefineDisallowed, &quot;Cannot redefine property: %&quot;)                         \\012  T(RedefineExternalArray,                                                     \\012 &quot;Cannot redefine a property of an object with external array elements&quot;)    \\012  T(ReduceNoInitial, &quot;Reduce of empty array with no initial value&quot;)            \\012  T(RegExpFlags,                                                               \\012 &quot;Cannot supply flags when constructing one RegExp from another&quot;)           \\012  T(RegExpNonObject, &quot;% getter called on non-object %&quot;)                        \\012  T(RegExpNonRegExp, &quot;% getter called on non-RegExp object&quot;)                   \\012  T(RelativeDateTimeFormatterBadParameters,                                    \\012 &quot;Incorrect RelativeDateTimeFormatter provided&quot;)                            \\012  T(ResolverNotAFunction, &quot;Promise resolver % is not a function&quot;)              \\012  T(ReturnMethodNotCallable, &quot;The iterator's 'return' method is not callable&quot;) \\012  T(SharedArrayBufferTooShort,                                                 \\012 &quot;Derived SharedArrayBuffer constructor created a buffer which was too &quot;    \\012 &quot;small&quot;)                                                                   \\012  T(SharedArrayBufferSpeciesThis,                                              \\012 &quot;SharedArrayBuffer subclass returned this from species constructor&quot;)       \\012  T(StaticPrototype,                                                           \\012 &quot;Classes may not have a static property named 'prototype'&quot;)                \\012  T(StrictDeleteProperty, &quot;Cannot delete property '%' of %&quot;)                   \\012  T(StrictPoisonPill,                                                          \\012 &quot;'caller', 'callee', and 'arguments' properties may not be accessed on &quot;   \\012 &quot;strict mode functions or the arguments objects for calls to them&quot;)        \\012  T(StrictReadOnlyProperty,                                                    \\012 &quot;Cannot assign to read only property '%' of % '%'&quot;)                        \\012  T(StrictCannotCreateProperty, &quot;Cannot create property '%' on % '%'&quot;)         \\012  T(SymbolIteratorInvalid,                                                     \\012 &quot;Result of the Symbol.iterator method is not an object&quot;)                   \\012  T(SymbolAsyncIteratorInvalid,                                                \\012 &quot;Result of the Symbol.asyncIterator method is not an object&quot;)              \\012  T(SymbolKeyFor, &quot;% is not a symbol&quot;)                                         \\012  T(SymbolToNumber, &quot;Cannot convert a Symbol value to a number&quot;)               \\012  T(SymbolToString, &quot;Cannot convert a Symbol value to a string&quot;)               \\012  T(ThrowMethodMissing, &quot;The iterator does not provide a 'throw' method.&quot;)     \\012  T(UndefinedOrNullToObject, &quot;Cannot convert undefined or null to object&quot;)     \\012  T(ValueAndAccessor,                                                          \\012 &quot;Invalid property descriptor. Cannot both specify accessors and a value &quot;  \\012 &quot;or writable attribute, %&quot;)                                                \\012  T(VarRedeclaration, &quot;Identifier '%' has already been declared&quot;)              \\012  T(WrongArgs, &quot;%: Arguments list has wrong type&quot;)                             \\012 /* ReferenceError */                                                         \\012  T(NotDefined, &quot;% is not defined&quot;)                                            \\012  T(SuperAlreadyCalled, &quot;Super constructor may only be called once&quot;)           \\012  T(UnsupportedSuper, &quot;Unsupported reference to 'super'&quot;)                      \\012 /* RangeError */                                                             \\012  T(BigIntDivZero, &quot;Division by zero&quot;)                                         \\012  T(BigIntNegativeExponent, &quot;Exponent must be positive&quot;)                       \\012  T(BigIntTooBig, &quot;Maximum BigInt size exceeded&quot;)                              \\012  T(DateRange, &quot;Provided date is not in valid range.&quot;)                         \\012  T(ExpectedLocation,                                                          \\012 &quot;Expected letters optionally connected with underscores or hyphens for &quot;   \\012 &quot;a location, got %&quot;)                                                       \\012  T(InvalidArrayBufferLength, &quot;Invalid array buffer length&quot;)                   \\012  T(ArrayBufferAllocationFailed, &quot;Array buffer allocation failed&quot;)             \\012  T(InvalidArrayLength, &quot;Invalid array length&quot;)                                \\012  T(InvalidAtomicAccessIndex, &quot;Invalid atomic access index&quot;)                   \\012  T(InvalidCodePoint, &quot;Invalid code point %&quot;)                                  \\012  T(InvalidCountValue, &quot;Invalid count value&quot;)                                  \\012  T(InvalidCurrencyCode, &quot;Invalid currency code: %&quot;)                           \\012  T(InvalidDataViewAccessorOffset,                                             \\012 &quot;Offset is outside the bounds of the DataView&quot;)                            \\012  T(InvalidDataViewLength, &quot;Invalid DataView length %&quot;)                        \\012  T(InvalidOffset, &quot;Start offset % is outside the bounds of the buffer&quot;)       \\012  T(InvalidHint, &quot;Invalid hint: %&quot;)                                            \\012  T(InvalidIndex, &quot;Invalid value: not (convertible to) a safe integer&quot;)        \\012  T(InvalidLanguageTag, &quot;Invalid language tag: %&quot;)                             \\012  T(InvalidWeakMapKey, &quot;Invalid value used as weak map key&quot;)                   \\012  T(InvalidWeakSetValue, &quot;Invalid value used in weak set&quot;)                     \\012  T(InvalidStringLength, &quot;Invalid string length&quot;)                              \\012  T(InvalidTimeValue, &quot;Invalid time value&quot;)                                    \\012  T(InvalidTimeZone, &quot;Invalid time zone specified: %&quot;)                         \\012  T(InvalidTypedArrayAlignment, &quot;% of % should be a multiple of %&quot;)            \\012  T(InvalidTypedArrayIndex, &quot;Invalid typed array index&quot;)                       \\012  T(InvalidTypedArrayLength, &quot;Invalid typed array length: %&quot;)                  \\012  T(LetInLexicalBinding, &quot;let is disallowed as a lexically bound name&quot;)        \\012  T(LocaleMatcher, &quot;Illegal value for localeMatcher:%&quot;)                        \\012  T(NormalizationForm, &quot;The normalization form should be one of %.&quot;)           \\012  T(ZeroDigitNumericSeparator,                                                 \\012 &quot;Numeric separator can not be used after leading 0.&quot;)                      \\012  T(NumberFormatRange, &quot;% argument must be between 0 and 100&quot;)                 \\012  T(TrailingNumericSeparator,                                                  \\012 &quot;Numeric separators are not allowed at the end of numeric literals&quot;)       \\012  T(ContinuousNumericSeparator,                                                \\012 &quot;Only one underscore is allowed as numeric separator&quot;)                     \\012  T(PropertyValueOutOfRange, &quot;% value is out of range.&quot;)                       \\012  T(StackOverflow, &quot;Maximum call stack size exceeded&quot;)                         \\012  T(ToPrecisionFormatRange,                                                    \\012 &quot;toPrecision() argument must be between 1 and 100&quot;)                        \\012  T(ToRadixFormatRange, &quot;toString() radix argument must be between 2 and 36&quot;)  \\012  T(TypedArraySetOffsetOutOfBounds, &quot;offset is out of bounds&quot;)                 \\012  T(TypedArraySetSourceTooLarge, &quot;Source is too large&quot;)                        \\012  T(ValueOutOfRange, &quot;Value % out of range for % options property %&quot;)          \\012 /* SyntaxError */                                                            \\012  T(AmbiguousExport,                                                           \\012 &quot;The requested module '%' contains conflicting star exports for name '%'&quot;) \\012  T(BadGetterArity, &quot;Getter must not have any formal parameters.&quot;)             \\012  T(BadSetterArity, &quot;Setter must have exactly one formal parameter.&quot;)          \\012  T(BigIntInvalidString, &quot;Invalid BigInt string&quot;)                              \\012  T(ConstructorIsAccessor, &quot;Class constructor may not be an accessor&quot;)         \\012  T(ConstructorIsGenerator, &quot;Class constructor may not be a generator&quot;)        \\012  T(ConstructorIsAsync, &quot;Class constructor may not be an async method&quot;)        \\012  T(DerivedConstructorReturnedNonObject,                                       \\012 &quot;Derived constructors may only return object or undefined&quot;)                \\012  T(DuplicateConstructor, &quot;A class may only have one constructor&quot;)             \\012  T(DuplicateExport, &quot;Duplicate export of '%'&quot;)                                \\012  T(DuplicateProto,                                                            \\012 &quot;Duplicate __proto__ fields are not allowed in object literals&quot;)           \\012  T(ForInOfLoopInitializer,                                                    \\012 &quot;% loop variable declaration may not have an initializer.&quot;)                \\012  T(ForInOfLoopMultiBindings,                                                  \\012 &quot;Invalid left-hand side in % loop: Must have a single binding.&quot;)           \\012  T(GeneratorInSingleStatementContext,                                         \\012 &quot;Generators can only be declared at the top level or inside a block.&quot;)     \\012  T(AsyncFunctionInSingleStatementContext,                                     \\012 &quot;Async functions can only be declared at the top level or inside a &quot;       \\012 &quot;block.&quot;)                                                                  \\012  T(IllegalBreak, &quot;Illegal break statement&quot;)                                   \\012  T(NoIterationStatement,                                                      \\012 &quot;Illegal continue statement: no surrounding iteration statement&quot;)          \\012  T(IllegalContinue,                                                           \\012 &quot;Illegal continue statement: '%' does not denote an iteration statement&quot;)  \\012  T(IllegalLanguageModeDirective,                                              \\012 &quot;Illegal '%' directive in function with non-simple parameter list&quot;)        \\012  T(IllegalReturn, &quot;Illegal return statement&quot;)                                 \\012  T(IntrinsicWithSpread, &quot;Intrinsic calls do not support spread arguments&quot;)    \\012  T(InvalidRestBindingPattern,                                                 \\012 &quot;`...` must be followed by an identifier in declaration contexts&quot;)         \\012  T(InvalidRestAssignmentPattern,                                              \\012 &quot;`...` must be followed by an assignable reference in assignment &quot;         \\012 &quot;contexts&quot;)                                                                \\012  T(InvalidEscapedReservedWord, &quot;Keyword must not contain escaped characters&quot;) \\012  T(InvalidEscapedMetaProperty, &quot;'%' must not contain escaped characters&quot;)     \\012  T(InvalidLhsInAssignment, &quot;Invalid left-hand side in assignment&quot;)            \\012  T(InvalidCoverInitializedName, &quot;Invalid shorthand property initializer&quot;)     \\012  T(InvalidDestructuringTarget, &quot;Invalid destructuring assignment target&quot;)     \\012  T(InvalidLhsInFor, &quot;Invalid left-hand side in for-loop&quot;)                     \\012  T(InvalidLhsInPostfixOp,                                                     \\012 &quot;Invalid left-hand side expression in postfix operation&quot;)                  \\012  T(InvalidLhsInPrefixOp,                                                      \\012 &quot;Invalid left-hand side expression in prefix operation&quot;)                   \\012  T(InvalidRegExpFlags, &quot;Invalid flags supplied to RegExp constructor '%'&quot;)    \\012  T(InvalidOrUnexpectedToken, &quot;Invalid or unexpected token&quot;)                   \\012  T(InvalidPrivateFieldAccess, &quot;Invalid private field '%'&quot;)                    \\012  T(JsonParseUnexpectedEOS, &quot;Unexpected end of JSON input&quot;)                    \\012  T(JsonParseUnexpectedToken, &quot;Unexpected token % in JSON at position %&quot;)      \\012  T(JsonParseUnexpectedTokenNumber, &quot;Unexpected number in JSON at position %&quot;) \\012  T(JsonParseUnexpectedTokenString, &quot;Unexpected string in JSON at position %&quot;) \\012  T(LabelRedeclaration, &quot;Label '%' has already been declared&quot;)                 \\012  T(LabelledFunctionDeclaration,                                               \\012 &quot;Labelled function declaration not allowed as the body of a control flow &quot; \\012 &quot;structure&quot;)                                                               \\012  T(MalformedArrowFunParamList, &quot;Malformed arrow function parameter list&quot;)     \\012  T(MalformedRegExp, &quot;Invalid regular expression: /%/: %&quot;)                     \\012  T(MalformedRegExpFlags, &quot;Invalid regular expression flags&quot;)                  \\012  T(ModuleExportUndefined, &quot;Export '%' is not defined in module&quot;)              \\012  T(HtmlCommentInModule, &quot;HTML comments are not allowed in modules&quot;)           \\012  T(MultipleDefaultsInSwitch,                                                  \\012 &quot;More than one default clause in switch statement&quot;)                        \\012  T(NewlineAfterThrow, &quot;Illegal newline after throw&quot;)                          \\012  T(NoCatchOrFinally, &quot;Missing catch or finally after try&quot;)                    \\012  T(NotIsvar, &quot;builtin %%IS_VAR: not a variable&quot;)                              \\012  T(ParamAfterRest, &quot;Rest parameter must be last formal parameter&quot;)            \\012  T(FlattenPastSafeLength,                                                     \\012 &quot;Flattening % elements on an array-like of length % &quot;                      \\012 &quot;is disallowed, as the total surpasses 2**53-1&quot;)                           \\012  T(PushPastSafeLength,                                                        \\012 &quot;Pushing % elements on an array-like of length % &quot;                         \\012 &quot;is disallowed, as the total surpasses 2**53-1&quot;)                           \\012  T(ElementAfterRest, &quot;Rest element must be last element&quot;)                     \\012  T(BadSetterRestParameter,                                                    \\012 &quot;Setter function argument must not be a rest parameter&quot;)                   \\012  T(ParamDupe, &quot;Duplicate parameter name not allowed in this context&quot;)         \\012  T(ParenthesisInArgString, &quot;Function arg string contains parenthesis&quot;)        \\012  T(ArgStringTerminatesParametersEarly,                                        \\012 &quot;Arg string terminates parameters early&quot;)                                  \\012  T(UnexpectedEndOfArgString, &quot;Unexpected end of arg string&quot;)                  \\012  T(RestDefaultInitializer,                                                    \\012 &quot;Rest parameter may not have a default initializer&quot;)                       \\012  T(RuntimeWrongNumArgs, &quot;Runtime function given wrong number of arguments&quot;)   \\012  T(SuperNotCalled,                                                            \\012 &quot;Must call super constructor in derived class before accessing 'this' or &quot; \\012 &quot;returning from derived constructor&quot;)                                      \\012  T(SingleFunctionLiteral, &quot;Single function literal required&quot;)                 \\012  T(SloppyFunction,                                                            \\012 &quot;In non-strict mode code, functions can only be declared at top level, &quot;   \\012 &quot;inside a block, or as the body of an if statement.&quot;)                      \\012  T(SpeciesNotConstructor,                                                     \\012 &quot;object.constructor[Symbol.species] is not a constructor&quot;)                 \\012  T(StrictDelete, &quot;Delete of an unqualified identifier in strict mode.&quot;)       \\012  T(StrictEvalArguments, &quot;Unexpected eval or arguments in strict mode&quot;)        \\012  T(StrictFunction,                                                            \\012 &quot;In strict mode code, functions can only be declared at top level or &quot;     \\012 &quot;inside a block.&quot;)                                                         \\012  T(StrictOctalLiteral, &quot;Octal literals are not allowed in strict mode.&quot;)      \\012  T(StrictDecimalWithLeadingZero,                                              \\012 &quot;Decimals with leading zeros are not allowed in strict mode.&quot;)             \\012  T(StrictOctalEscape,                                                         \\012 &quot;Octal escape sequences are not allowed in strict mode.&quot;)                  \\012  T(StrictWith, &quot;Strict mode code may not include a with statement&quot;)           \\012  T(TemplateOctalLiteral,                                                      \\012 &quot;Octal escape sequences are not allowed in template strings.&quot;)             \\012  T(ThisFormalParameter, &quot;'this' is not a valid formal parameter name&quot;)        \\012  T(AwaitBindingIdentifier,                                                    \\012 &quot;'await' is not a valid identifier name in an async function&quot;)             \\012  T(AwaitExpressionFormalParameter,                                            \\012 &quot;Illegal await-expression in formal parameters of async function&quot;)         \\012  T(TooManyArguments,                                                          \\012 &quot;Too many arguments in function call (only 65535 allowed)&quot;)                \\012  T(TooManyParameters,                                                         \\012 &quot;Too many parameters in function definition (only 65535 allowed)&quot;)         \\012  T(TooManySpreads,                                                            \\012 &quot;Literal containing too many nested spreads (up to 65534 allowed)&quot;)        \\012  T(TooManyVariables, &quot;Too many variables declared (only 4194303 allowed)&quot;)    \\012  T(TooManyElementsInPromiseAll, &quot;Too many elements passed to Promise.all&quot;)    \\012  T(TypedArrayTooShort,                                                        \\012 &quot;Derived TypedArray constructor created an array which was too small&quot;)     \\012  T(UnexpectedEOS, &quot;Unexpected end of input&quot;)                                  \\012  T(UnexpectedReserved, &quot;Unexpected reserved word&quot;)                            \\012  T(UnexpectedStrictReserved, &quot;Unexpected strict mode reserved word&quot;)          \\012  T(UnexpectedSuper, &quot;'super' keyword unexpected here&quot;)                        \\012  T(UnexpectedNewTarget, &quot;new.target expression is not allowed here&quot;)          \\012  T(UnexpectedTemplateString, &quot;Unexpected template string&quot;)                    \\012  T(UnexpectedToken, &quot;Unexpected token %&quot;)                                     \\012  T(UnexpectedTokenIdentifier, &quot;Unexpected identifier&quot;)                        \\012  T(UnexpectedTokenNumber, &quot;Unexpected number&quot;)                                \\012  T(UnexpectedTokenString, &quot;Unexpected string&quot;)                                \\012  T(UnexpectedTokenRegExp, &quot;Unexpected regular expression&quot;)                    \\012  T(UnexpectedLexicalDeclaration,                                              \\012 &quot;Lexical declaration cannot appear in a single-statement context&quot;)         \\012  T(UnknownLabel, &quot;Undefined label '%'&quot;)                                       \\012  T(UnresolvableExport,                                                        \\012 &quot;The requested module '%' does not provide an export named '%'&quot;)           \\012  T(UnterminatedArgList, &quot;missing ) after argument list&quot;)                      \\012  T(UnterminatedRegExp, &quot;Invalid regular expression: missing /&quot;)               \\012  T(UnterminatedTemplate, &quot;Unterminated template literal&quot;)                     \\012  T(UnterminatedTemplateExpr, &quot;Missing } in template expression&quot;)              \\012  T(FoundNonCallableHasInstance, &quot;Found non-callable @@hasInstance&quot;)           \\012  T(InvalidHexEscapeSequence, &quot;Invalid hexadecimal escape sequence&quot;)           \\012  T(InvalidUnicodeEscapeSequence, &quot;Invalid Unicode escape sequence&quot;)           \\012  T(UndefinedUnicodeCodePoint, &quot;Undefined Unicode code-point&quot;)                 \\012  T(YieldInParameter, &quot;Yield expression not allowed in formal parameter&quot;)      \\012 /* EvalError */                                                              \\012  T(CodeGenFromStrings, &quot;%&quot;)                                                   \\012  T(NoSideEffectDebugEvaluate, &quot;Possible side-effect in debug-evaluate&quot;)       \\012 /* URIError */                                                               \\012  T(URIMalformed, &quot;URI malformed&quot;)                                             \\012 /* Wasm errors (currently Error) */                                          \\012  T(WasmTrapUnreachable, &quot;unreachable&quot;)                                        \\012  T(WasmTrapMemOutOfBounds, &quot;memory access out of bounds&quot;)                     \\012  T(WasmTrapUnalignedAccess, &quot;operation does not support unaligned accesses&quot;)  \\012  T(WasmTrapDivByZero, &quot;divide by zero&quot;)                                       \\012  T(WasmTrapDivUnrepresentable, &quot;divide result unrepresentable&quot;)               \\012  T(WasmTrapRemByZero, &quot;remainder by zero&quot;)                                    \\012  T(WasmTrapFloatUnrepresentable, &quot;float unrepresentable in integer range&quot;)    \\012  T(WasmTrapFuncInvalid, &quot;invalid index into function table&quot;)                  \\012  T(WasmTrapFuncSigMismatch, &quot;function signature mismatch&quot;)                    \\012  T(WasmTrapTypeError, &quot;wasm function signature contains illegal type&quot;)        \\012  T(WasmExceptionError, &quot;wasm exception&quot;)                                      \\012 /* Asm.js validation related */                                              \\012  T(AsmJsInvalid, &quot;Invalid asm.js: %&quot;)                                         \\012  T(AsmJsCompiled, &quot;Converted asm.js to WebAssembly: %&quot;)                       \\012  T(AsmJsInstantiated, &quot;Instantiated asm.js: %&quot;)                               \\012  T(AsmJsLinkingFailed, &quot;Linking failure in asm.js: %&quot;)                        \\012 /* DataCloneError messages */                                                \\012  T(DataCloneError, &quot;% could not be cloned.&quot;)                                  \\012  T(DataCloneErrorOutOfMemory, &quot;Data cannot be cloned, out of memory.&quot;)        \\012  T(DataCloneErrorNeuteredArrayBuffer,                                         \\012 &quot;An ArrayBuffer is neutered and could not be cloned.&quot;)                     \\012  T(DataCloneErrorSharedArrayBufferTransferred,                                \\012 &quot;A SharedArrayBuffer could not be cloned. SharedArrayBuffer must not be &quot;  \\012 &quot;transferred.&quot;)                                                            \\012  T(DataCloneDeserializationError, &quot;Unable to deserialize cloned data.&quot;)       \\012  T(DataCloneDeserializationVersionError,                                      \\012 &quot;Unable to deserialize cloned data due to invalid or unsupported &quot;         \\012 &quot;version.&quot;)                                                                \\012 /* Builtins-Trace Errors */                                                  \\012  T(TraceEventCategoryError, &quot;Trace event category must be a string.&quot;)         \\012  T(TraceEventNameError, &quot;Trace event name must be a string.&quot;)                 \\012  T(TraceEventNameLengthError,                                                 \\012 &quot;Trace event name must not be an empty string.&quot;)                           \\012  T(TraceEventPhaseError, &quot;Trace event phase must be a number.&quot;)               \\012  T(TraceEventIDError, &quot;Trace event id must be a number.&quot;)\012\012class MessageTemplate {\012 public:\012 enum Template {\012#define TEMPLATE(NAME, STRING) k##NAME,\012    MESSAGE_TEMPLATES(TEMPLATE)\012#undef TEMPLATE\012        kLastMessage\012 };\012\012 static const char* TemplateString(int template_index);\012\012 static MaybeHandle&lt;String&gt; FormatMessage(Isolate* isolate, int template_index,\012 Handle&lt;String&gt; arg0,\012 Handle&lt;String&gt; arg1,\012 Handle&lt;String&gt; arg2);\012\012 static Handle&lt;String&gt; FormatMessage(Isolate* isolate, int template_index,\012 Handle&lt;Object&gt; arg);\012};\012\012\012// A message handler is a convenience interface for accessing the list\012// of message listeners registered in an environment\012class MessageHandler {\012 public:\012 // Returns a message object for the API to use.\012 static Handle&lt;JSMessageObject&gt; MakeMessageObject(\012 Isolate* isolate, MessageTemplate::Template type,\012 const MessageLocation* location, Handle&lt;Object&gt; argument,\012 Handle&lt;FixedArray&gt; stack_frames);\012\012 // Report a formatted message (needs JS allocation).\012 static void ReportMessage(Isolate* isolate, const MessageLocation* loc,\012 Handle&lt;JSMessageObject&gt; message);\012\012 static void DefaultMessageReport(Isolate* isolate, const MessageLocation* loc,\012 Handle&lt;Object&gt; message_obj);\012 static Handle&lt;String&gt; GetMessage(Isolate* isolate, Handle&lt;Object&gt; data);\012 static std::unique_ptr&lt;char[]&gt; GetLocalizedMessage(Isolate* isolate,\012 Handle&lt;Object&gt; data);\012\012 private:\012 static void ReportMessageNoExceptions(Isolate* isolate,\012 const MessageLocation* loc,\012 Handle&lt;Object&gt; message_obj,\012                                        v8::Local&lt;v8::Value&gt; api_exception_obj);\012};\012\012\012} // namespace internal\012},namespace v8 {\012namespace internal {\012namespace wasm {\012class WasmCode;\012}\012\012// Forward declarations.\012class AbstractCode;\012class FrameArray;\012class JSMessageObject;\012class LookupIterator;\012class SharedFunctionInfo;\012class SourceInfo;\012class WasmInstanceObject;\012\012class MessageLocation {\012 public:\012 MessageLocation(Handle&lt;Script&gt; script, int start_pos, int end_pos);\012 MessageLocation(Handle&lt;Script&gt; script, int start_pos, int end_pos,\012 Handle&lt;SharedFunctionInfo&gt; shared);\012 MessageLocation();\012\012 Handle&lt;Script&gt; script() const { return script_; }\012 int start_pos() const { return start_pos_; }\012 int end_pos() const { return end_pos_; }\012 Handle&lt;SharedFunctionInfo&gt; shared() const { return shared_; }\012\012 private:\012 Handle&lt;Script&gt; script_;\012 int start_pos_;\012 int end_pos_;\012 Handle&lt;SharedFunctionInfo&gt; shared_;\012};\012\012class StackFrameBase {\012 public:\012 virtual ~StackFrameBase() {}\012\012 virtual Handle&lt;Object&gt; GetReceiver() const = 0;\012 virtual Handle&lt;Object&gt; GetFunction() const = 0;\012\012 virtual Handle&lt;Object&gt; GetFileName() = 0;\012 virtual Handle&lt;Object&gt; GetFunctionName() = 0;\012 virtual Handle&lt;Object&gt; GetScriptNameOrSourceUrl() = 0;\012 virtual Handle&lt;Object&gt; GetMethodName() = 0;\012 virtual Handle&lt;Object&gt; GetTypeName() = 0;\012 virtual Handle&lt;Object&gt; GetEvalOrigin();\012\012 virtual int GetPosition() const = 0;\012 // Return 1-based line number, including line offset.\012 virtual int GetLineNumber() = 0;\012 // Return 1-based column number, including column offset if first line.\012 virtual int GetColumnNumber() = 0;\012\012 virtual bool IsNative() = 0;\012 virtual bool IsToplevel() = 0;\012 virtual bool IsEval();\012 virtual bool IsConstructor() = 0;\012 virtual bool IsStrict() const = 0;\012\012 virtual MaybeHandle&lt;String&gt; ToString() = 0;\012\012 protected:\012 StackFrameBase() {}\012 explicit StackFrameBase(Isolate* isolate) : isolate_(isolate) {}\012 Isolate* isolate_;\012\012 private:\012 virtual bool HasScript() const = 0;\012 virtual Handle&lt;Script&gt; GetScript() const = 0;\012};\012\012class JSStackFrame : public StackFrameBase {\012 public:\012 JSStackFrame(Isolate* isolate, Handle&lt;Object&gt; receiver,\012 Handle&lt;JSFunction&gt; function, Handle&lt;AbstractCode&gt; code,\012 int offset);\012 virtual ~JSStackFrame() {}\012\012 Handle&lt;Object&gt; GetReceiver() const override { return receiver_; }\012 Handle&lt;Object&gt; GetFunction() const override;\012\012 Handle&lt;Object&gt; GetFileName() override;\012 Handle&lt;Object&gt; GetFunctionName() override;\012 Handle&lt;Object&gt; GetScriptNameOrSourceUrl() override;\012 Handle&lt;Object&gt; GetMethodName() override;\012 Handle&lt;Object&gt; GetTypeName() override;\012\012 int GetPosition() const override;\012 int GetLineNumber() override;\012 int GetColumnNumber() override;\012\012 bool IsNative() override;\012 bool IsToplevel() override;\012 bool IsConstructor() override { return is_constructor_; }\012 bool IsStrict() const override { return is_strict_; }\012\012 MaybeHandle&lt;String&gt; ToString() override;\012\012 private:\012 JSStackFrame();\012 void FromFrameArray(Isolate* isolate, Handle&lt;FrameArray&gt; array, int frame_ix);\012\012 bool HasScript() const override;\012 Handle&lt;Script&gt; GetScript() const override;\012\012 Handle&lt;Object&gt; receiver_;\012 Handle&lt;JSFunction&gt; function_;\012 Handle&lt;AbstractCode&gt; code_;\012 int offset_;\012\012 bool is_constructor_;\012 bool is_strict_;\012\012 friend class FrameArrayIterator;\012};\012\012class WasmStackFrame : public StackFrameBase {\012 public:\012 virtual ~WasmStackFrame() {}\012\012 Handle&lt;Object&gt; GetReceiver() const override;\012 Handle&lt;Object&gt; GetFunction() const override;\012\012 Handle&lt;Object&gt; GetFileName() override { return Null(); }\012 Handle&lt;Object&gt; GetFunctionName() override;\012 Handle&lt;Object&gt; GetScriptNameOrSourceUrl() override { return Null(); }\012 Handle&lt;Object&gt; GetMethodName() override { return Null(); }\012 Handle&lt;Object&gt; GetTypeName() override { return Null(); }\012\012 int GetPosition() const override;\012 int GetLineNumber() override { return wasm_func_index_; }\012 int GetColumnNumber() override { return -1; }\012\012 bool IsNative() override { return false; }\012 bool IsToplevel() override { return false; }\012 bool IsConstructor() override { return false; }\012 bool IsStrict() const override { return false; }\012 bool IsInterpreted() const { return code_ == nullptr; }\012\012 MaybeHandle&lt;String&gt; ToString() override;\012\012 protected:\012 Handle&lt;Object&gt; Null() const;\012\012 bool HasScript() const override;\012 Handle&lt;Script&gt; GetScript() const override;\012\012 Handle&lt;WasmInstanceObject&gt; wasm_instance_;\012 uint32_t wasm_func_index_;\012  wasm::WasmCode* code_; // null for interpreted frames.\012 int offset_;\012\012 private:\012 WasmStackFrame();\012 void FromFrameArray(Isolate* isolate, Handle&lt;FrameArray&gt; array, int frame_ix);\012\012 friend class FrameArrayIterator;\012 friend class AsmJsWasmStackFrame;\012};\012\012class AsmJsWasmStackFrame : public WasmStackFrame {\012 public:\012 virtual ~AsmJsWasmStackFrame() {}\012\012 Handle&lt;Object&gt; GetReceiver() const override;\012 Handle&lt;Object&gt; GetFunction() const override;\012\012 Handle&lt;Object&gt; GetFileName() override;\012 Handle&lt;Object&gt; GetScriptNameOrSourceUrl() override;\012\012 int GetPosition() const override;\012 int GetLineNumber() override;\012 int GetColumnNumber() override;\012\012 MaybeHandle&lt;String&gt; ToString() override;\012\012 private:\012 friend class FrameArrayIterator;\012 AsmJsWasmStackFrame();\012 void FromFrameArray(Isolate* isolate, Handle&lt;FrameArray&gt; array, int frame_ix);\012\012 bool is_at_number_conversion_;\012};\012\012class FrameArrayIterator {\012 public:\012 FrameArrayIterator(Isolate* isolate, Handle&lt;FrameArray&gt; array,\012 int frame_ix = 0);\012\012 StackFrameBase* Frame();\012\012 bool HasNext() const;\012 void Next();\012\012 private:\012 Isolate* isolate_;\012\012 Handle&lt;FrameArray&gt; array_;\012 int next_frame_ix_;\012\012 WasmStackFrame wasm_frame_;\012 AsmJsWasmStackFrame asm_wasm_frame_;\012 JSStackFrame js_frame_;\012};\012\012// Determines how stack trace collection skips frames.\012enum FrameSkipMode {\012 // Unconditionally skips the first frame. Used e.g. when the Error constructor\012 // is called, in which case the first frame is always a BUILTIN_EXIT frame.\012  SKIP_FIRST,\012 // Skip all frames until a specified caller function is seen.\012  SKIP_UNTIL_SEEN,\012  SKIP_NONE,\012};\012\012class ErrorUtils : public AllStatic {\012 public:\012 static MaybeHandle&lt;Object&gt; Construct(\012 Isolate* isolate, Handle&lt;JSFunction&gt; target, Handle&lt;Object&gt; new_target,\012 Handle&lt;Object&gt; message, FrameSkipMode mode, Handle&lt;Object&gt; caller,\012 bool suppress_detailed_trace);\012\012 static MaybeHandle&lt;String&gt; ToString(Isolate* isolate, Handle&lt;Object&gt; recv);\012\012 static MaybeHandle&lt;Object&gt; MakeGenericError(\012 Isolate* isolate, Handle&lt;JSFunction&gt; constructor, int template_index,\012 Handle&lt;Object&gt; arg0, Handle&lt;Object&gt; arg1, Handle&lt;Object&gt; arg2,\012 FrameSkipMode mode);\012\012 // Formats a textual stack trace from the given structured stack trace.\012 // Note that this can call arbitrary JS code through Error.prepareStackTrace.\012 static MaybeHandle&lt;Object&gt; FormatStackTrace(Isolate* isolate,\012 Handle&lt;JSObject&gt; error,\012 Handle&lt;Object&gt; stack_trace);\012};\012\012#define MESSAGE_TEMPLATES(T)                                                   \\012 /* Error */                                                                  \\012  T(None, &quot;&quot;)                                                                  \\012  T(CyclicProto, &quot;Cyclic __proto__ value&quot;)                                     \\012  T(Debugger, &quot;Debugger: %&quot;)                                                   \\012  T(DebuggerLoading, &quot;Error loading debugger&quot;)                                 \\012  T(DefaultOptionsMissing, &quot;Internal % error. Default options are missing.&quot;)   \\012  T(DeletePrivateField, &quot;Private fields can not be deleted&quot;)                   \\012  T(UncaughtException, &quot;Uncaught %&quot;)                                           \\012  T(Unsupported, &quot;Not supported&quot;)                                              \\012  T(WrongServiceType, &quot;Internal error, wrong service type: %&quot;)                 \\012  T(WrongValueType, &quot;Internal error. Wrong value type.&quot;)                       \\012  T(IcuError, &quot;Internal error. Icu error.&quot;)                                    \\012 /* TypeError */                                                              \\012  T(ApplyNonFunction,                                                          \\012 &quot;Function.prototype.apply was called on %, which is a % and not a &quot;        \\012 &quot;function&quot;)                                                                \\012  T(ArgumentsDisallowedInInitializer,                                          \\012 &quot;'arguments' is not allowed in class field initializer&quot;)                   \\012  T(ArrayBufferTooShort,                                                       \\012 &quot;Derived ArrayBuffer constructor created a buffer which was too small&quot;)    \\012  T(ArrayBufferSpeciesThis,                                                    \\012 &quot;ArrayBuffer subclass returned this from species constructor&quot;)             \\012  T(ArrayItemNotType, &quot;array %[%] is not type %&quot;)                              \\012  T(AwaitNotInAsyncFunction, &quot;await is only valid in async function&quot;)          \\012  T(AtomicsWaitNotAllowed, &quot;Atomics.wait cannot be called in this context&quot;)    \\012  T(BadSortComparisonFunction,                                                 \\012 &quot;The comparison function must be either a function or undefined&quot;)          \\012  T(BigIntFromNumber,                                                          \\012 &quot;The number % cannot be converted to a BigInt because it is not an &quot;       \\012 &quot;integer&quot;)                                                                 \\012  T(BigIntFromObject, &quot;Cannot convert % to a BigInt&quot;)                          \\012  T(BigIntMixedTypes,                                                          \\012 &quot;Cannot mix BigInt and other types, use explicit conversions&quot;)             \\012  T(BigIntSerializeJSON, &quot;Do not know how to serialize a BigInt&quot;)              \\012  T(BigIntShr, &quot;BigInts have no unsigned right shift, use &gt;&gt; instead&quot;)         \\012  T(BigIntToNumber, &quot;Cannot convert a BigInt value to a number&quot;)               \\012  T(CalledNonCallable, &quot;% is not a function&quot;)                                  \\012  T(CalledOnNonObject, &quot;% called on non-object&quot;)                               \\012  T(CalledOnNullOrUndefined, &quot;% called on null or undefined&quot;)                  \\012  T(CallSiteExpectsFunction,                                                   \\012 &quot;CallSite expects wasm object as first or function as second argument, &quot;   \\012 &quot;got &lt;%, %&gt;&quot;)                                                              \\012  T(CallSiteMethod, &quot;CallSite method % expects CallSite as receiver&quot;)          \\012  T(CannotConvertToPrimitive, &quot;Cannot convert object to primitive value&quot;)      \\012  T(CannotPreventExt, &quot;Cannot prevent extensions&quot;)                             \\012  T(CannotFreeze, &quot;Cannot freeze&quot;)                                             \\012  T(CannotFreezeArrayBufferView,                                               \\012 &quot;Cannot freeze array buffer views with elements&quot;)                          \\012  T(CannotSeal, &quot;Cannot seal&quot;)                                                 \\012  T(CircularStructure, &quot;Converting circular structure to JSON&quot;)                \\012  T(ConstructAbstractClass, &quot;Abstract class % not directly constructable&quot;)     \\012  T(ConstAssign, &quot;Assignment to constant variable.&quot;)                           \\012  T(ConstructorClassField, &quot;Classes may not have a field named 'constructor'&quot;) \\012  T(ConstructorNonCallable,                                                    \\012 &quot;Class constructor % cannot be invoked without 'new'&quot;)                     \\012  T(ConstructorNotFunction, &quot;Constructor % requires 'new'&quot;)                    \\012  T(ConstructorNotReceiver, &quot;The .constructor property is not an object&quot;)      \\012  T(CurrencyCode, &quot;Currency code is required with currency style.&quot;)            \\012  T(CyclicModuleDependency, &quot;Detected cycle while resolving name '%' in '%'&quot;)  \\012  T(DataViewNotArrayBuffer,                                                    \\012 &quot;First argument to DataView constructor must be an ArrayBuffer&quot;)           \\012  T(DateType, &quot;this is not a Date object.&quot;)                                    \\012  T(DebuggerFrame, &quot;Debugger: Invalid frame index.&quot;)                           \\012  T(DebuggerType, &quot;Debugger: Parameters have wrong types.&quot;)                    \\012  T(DeclarationMissingInitializer, &quot;Missing initializer in % declaration&quot;)     \\012  T(DefineDisallowed, &quot;Cannot define property %, object is not extensible&quot;)    \\012  T(DetachedOperation, &quot;Cannot perform % on a detached ArrayBuffer&quot;)           \\012  T(DuplicateTemplateProperty, &quot;Object template has duplicate property '%'&quot;)   \\012  T(ExtendsValueNotConstructor,                                                \\012 &quot;Class extends value % is not a constructor or null&quot;)                      \\012  T(FirstArgumentNotRegExp,                                                    \\012 &quot;First argument to % must not be a regular expression&quot;)                    \\012  T(FunctionBind, &quot;Bind must be called on a function&quot;)                         \\012  T(GeneratorRunning, &quot;Generator is already running&quot;)                          \\012  T(IllegalInvocation, &quot;Illegal invocation&quot;)                                   \\012  T(ImmutablePrototypeSet,                                                     \\012 &quot;Immutable prototype object '%' cannot have their prototype set&quot;)          \\012  T(ImportCallNotNewExpression, &quot;Cannot use new with import&quot;)                  \\012  T(ImportMetaOutsideModule, &quot;Cannot use 'import.meta' outside a module&quot;)      \\012  T(ImportMissingSpecifier, &quot;import() requires a specifier&quot;)                   \\012  T(IncompatibleMethodReceiver, &quot;Method % called on incompatible receiver %&quot;)  \\012  T(InstanceofNonobjectProto,                                                  \\012 &quot;Function has non-object prototype '%' in instanceof check&quot;)               \\012  T(InvalidArgument, &quot;invalid_argument&quot;)                                       \\012  T(InvalidInOperatorUse, &quot;Cannot use 'in' operator to search for '%' in %&quot;)   \\012  T(InvalidRegExpExecResult,                                                   \\012 &quot;RegExp exec method returned something other than an Object or null&quot;)      \\012  T(InvalidUnit, &quot;Invalid unit argument for %() '%'&quot;)                          \\012  T(IteratorResultNotAnObject, &quot;Iterator result % is not an object&quot;)           \\012  T(IteratorSymbolNonCallable, &quot;Found non-callable @@iterator&quot;)                \\012  T(IteratorValueNotAnObject, &quot;Iterator value % is not an entry object&quot;)       \\012  T(LanguageID, &quot;Language ID should be string or object.&quot;)                     \\012  T(LocaleNotEmpty,                                                            \\012 &quot;First argument to Intl.Locale constructor can't be empty or missing&quot;)     \\012  T(LocaleBadParameters, &quot;Incorrect locale information provided&quot;)              \\012  T(ListFormatBadParameters, &quot;Incorrect ListFormat information provided&quot;)      \\012  T(MapperFunctionNonCallable, &quot;flatMap mapper function is not callable&quot;)      \\012  T(MethodCalledOnWrongObject,                                                 \\012 &quot;Method % called on a non-object or on a wrong type of object.&quot;)           \\012  T(MethodInvokedOnNullOrUndefined,                                            \\012 &quot;Method invoked on undefined or null value.&quot;)                              \\012  T(MethodInvokedOnWrongType, &quot;Method invoked on an object that is not %.&quot;)    \\012  T(NoAccess, &quot;no access&quot;)                                                     \\012  T(NonCallableInInstanceOfCheck,                                              \\012 &quot;Right-hand side of 'instanceof' is not callable&quot;)                         \\012  T(NonCoercible, &quot;Cannot destructure 'undefined' or 'null'.&quot;)                 \\012  T(NonCoercibleWithProperty,                                                  \\012 &quot;Cannot destructure property `%` of 'undefined' or 'null'.&quot;)               \\012  T(NonExtensibleProto, &quot;% is not extensible&quot;)                                 \\012  T(NonObjectInInstanceOfCheck,                                                \\012 &quot;Right-hand side of 'instanceof' is not an object&quot;)                        \\012  T(NonObjectPropertyLoad, &quot;Cannot read property '%' of %&quot;)                    \\012  T(NonObjectPropertyStore, &quot;Cannot set property '%' of %&quot;)                    \\012  T(NoSetterInCallback, &quot;Cannot set property % of % which has only a getter&quot;)  \\012  T(NotAnIterator, &quot;% is not an iterator&quot;)                                     \\012  T(NotAPromise, &quot;% is not a promise&quot;)                                         \\012  T(NotConstructor, &quot;% is not a constructor&quot;)                                  \\012  T(NotDateObject, &quot;this is not a Date object.&quot;)                               \\012  T(NotGeneric, &quot;% requires that 'this' be a %&quot;)                               \\012  T(NotCallableOrIterable,                                                     \\012 &quot;% is not a function or its return value is not iterable&quot;)                 \\012  T(NotCallableOrAsyncIterable,                                                \\012 &quot;% is not a function or its return value is not async iterable&quot;)           \\012  T(NotFiniteNumber, &quot;Value need to be finite number for %()&quot;)                 \\012  T(NotIterable, &quot;% is not iterable&quot;)                                          \\012  T(NotAsyncIterable, &quot;% is not async iterable&quot;)                               \\012  T(NotPropertyName, &quot;% is not a valid property name&quot;)                         \\012  T(NotTypedArray, &quot;this is not a typed array.&quot;)                               \\012  T(NotSuperConstructor, &quot;Super constructor % of % is not a constructor&quot;)      \\012  T(NotSuperConstructorAnonymousClass,                                         \\012 &quot;Super constructor % of anonymous class is not a constructor&quot;)             \\012  T(NotIntegerSharedTypedArray, &quot;% is not an integer shared typed array.&quot;)     \\012  T(NotInt32SharedTypedArray, &quot;% is not an int32 shared typed array.&quot;)         \\012  T(ObjectGetterExpectingFunction,                                             \\012 &quot;Object.prototype.__defineGetter__: Expecting function&quot;)                   \\012  T(ObjectGetterCallable, &quot;Getter must be a function: %&quot;)                      \\012  T(ObjectNotExtensible, &quot;Cannot add property %, object is not extensible&quot;)    \\012  T(ObjectSetterExpectingFunction,                                             \\012 &quot;Object.prototype.__defineSetter__: Expecting function&quot;)                   \\012  T(ObjectSetterCallable, &quot;Setter must be a function: %&quot;)                      \\012  T(OrdinaryFunctionCalledAsConstructor,                                       \\012 &quot;Function object that's not a constructor was created with new&quot;)           \\012  T(PromiseCyclic, &quot;Chaining cycle detected for promise %&quot;)                    \\012  T(PromiseExecutorAlreadyInvoked,                                             \\012 &quot;Promise executor has already been invoked with non-undefined arguments&quot;)  \\012  T(PromiseNonCallable, &quot;Promise resolve or reject function is not callable&quot;)  \\012  T(PropertyDescObject, &quot;Property description must be an object: %&quot;)           \\012  T(PropertyNotFunction,                                                       \\012 &quot;'%' returned for property '%' of object '%' is not a function&quot;)           \\012  T(ProtoObjectOrNull, &quot;Object prototype may only be an Object or null: %&quot;)    \\012  T(PrototypeParentNotAnObject,                                                \\012 &quot;Class extends value does not have valid prototype property %&quot;)            \\012  T(ProxyConstructNonObject,                                                   \\012 &quot;'construct' on proxy: trap returned non-object ('%')&quot;)                    \\012  T(ProxyDefinePropertyNonConfigurable,                                        \\012 &quot;'defineProperty' on proxy: trap returned truish for defining &quot;            \\012 &quot;non-configurable property '%' which is either non-existant or &quot;           \\012 &quot;configurable in the proxy target&quot;)                                        \\012  T(ProxyDefinePropertyNonExtensible,                                          \\012 &quot;'defineProperty' on proxy: trap returned truish for adding property '%' &quot; \\012 &quot; to the non-extensible proxy target&quot;)                                     \\012  T(ProxyDefinePropertyIncompatible,                                           \\012 &quot;'defineProperty' on proxy: trap returned truish for adding property '%' &quot; \\012 &quot; that is incompatible with the existing property in the proxy target&quot;)    \\012  T(ProxyDeletePropertyNonConfigurable,                                        \\012 &quot;'deleteProperty' on proxy: trap returned truish for property '%' which &quot;  \\012 &quot;is non-configurable in the proxy target&quot;)                                 \\012  T(ProxyGetNonConfigurableData,                                               \\012 &quot;'get' on proxy: property '%' is a read-only and &quot;                         \\012 &quot;non-configurable data property on the proxy target but the proxy &quot;        \\012 &quot;did not return its actual value (expected '%' but got '%')&quot;)              \\012  T(ProxyGetNonConfigurableAccessor,                                           \\012 &quot;'get' on proxy: property '%' is a non-configurable accessor &quot;             \\012 &quot;property on the proxy target and does not have a getter function, but &quot;   \\012 &quot;the trap did not return 'undefined' (got '%')&quot;)                           \\012  T(ProxyGetOwnPropertyDescriptorIncompatible,                                 \\012 &quot;'getOwnPropertyDescriptor' on proxy: trap returned descriptor for &quot;       \\012 &quot;property '%' that is incompatible with the existing property in the &quot;     \\012 &quot;proxy target&quot;)                                                            \\012  T(ProxyGetOwnPropertyDescriptorInvalid,                                      \\012 &quot;'getOwnPropertyDescriptor' on proxy: trap returned neither object nor &quot;   \\012 &quot;undefined for property '%'&quot;)                                              \\012  T(ProxyGetOwnPropertyDescriptorNonConfigurable,                              \\012 &quot;'getOwnPropertyDescriptor' on proxy: trap reported non-configurability &quot;  \\012 &quot;for property '%' which is either non-existant or configurable in the &quot;    \\012 &quot;proxy target&quot;)                                                            \\012  T(ProxyGetOwnPropertyDescriptorNonExtensible,                                \\012 &quot;'getOwnPropertyDescriptor' on proxy: trap returned undefined for &quot;        \\012 &quot;property '%' which exists in the non-extensible proxy target&quot;)            \\012  T(ProxyGetOwnPropertyDescriptorUndefined,                                    \\012 &quot;'getOwnPropertyDescriptor' on proxy: trap returned undefined for &quot;        \\012 &quot;property '%' which is non-configurable in the proxy target&quot;)              \\012  T(ProxyGetPrototypeOfInvalid,                                                \\012 &quot;'getPrototypeOf' on proxy: trap returned neither object nor null&quot;)        \\012  T(ProxyGetPrototypeOfNonExtensible,                                          \\012 &quot;'getPrototypeOf' on proxy: proxy target is non-extensible but the &quot;       \\012 &quot;trap did not return its actual prototype&quot;)                                \\012  T(ProxyHandlerOrTargetRevoked,                                               \\012 &quot;Cannot create proxy with a revoked proxy as target or handler&quot;)           \\012  T(ProxyHasNonConfigurable,                                                   \\012 &quot;'has' on proxy: trap returned falsish for property '%' which exists in &quot;  \\012 &quot;the proxy target as non-configurable&quot;)                                    \\012  T(ProxyHasNonExtensible,                                                     \\012 &quot;'has' on proxy: trap returned falsish for property '%' but the proxy &quot;    \\012 &quot;target is not extensible&quot;)                                                \\012  T(ProxyIsExtensibleInconsistent,                                             \\012 &quot;'isExtensible' on proxy: trap result does not reflect extensibility of &quot;  \\012 &quot;proxy target (which is '%')&quot;)                                             \\012  T(ProxyNonObject,                                                            \\012 &quot;Cannot create proxy with a non-object as target or handler&quot;)              \\012  T(ProxyOwnKeysMissing,                                                       \\012 &quot;'ownKeys' on proxy: trap result did not include '%'&quot;)                     \\012  T(ProxyOwnKeysNonExtensible,                                                 \\012 &quot;'ownKeys' on proxy: trap returned extra keys but proxy target is &quot;        \\012 &quot;non-extensible&quot;)                                                          \\012  T(ProxyPreventExtensionsExtensible,                                          \\012 &quot;'preventExtensions' on proxy: trap returned truish but the proxy target &quot; \\012 &quot;is extensible&quot;)                                                           \\012  T(ProxyPrivate, &quot;Cannot pass private property name to proxy trap&quot;)           \\012  T(ProxyRevoked, &quot;Cannot perform '%' on a proxy that has been revoked&quot;)       \\012  T(ProxySetFrozenData,                                                        \\012 &quot;'set' on proxy: trap returned truish for property '%' which exists in &quot;   \\012 &quot;the proxy target as a non-configurable and non-writable data property &quot;   \\012 &quot;with a different value&quot;)                                                  \\012  T(ProxySetFrozenAccessor,                                                    \\012 &quot;'set' on proxy: trap returned truish for property '%' which exists in &quot;   \\012 &quot;the proxy target as a non-configurable and non-writable accessor &quot;        \\012 &quot;property without a setter&quot;)                                               \\012  T(ProxySetPrototypeOfNonExtensible,                                          \\012 &quot;'setPrototypeOf' on proxy: trap returned truish for setting a new &quot;       \\012 &quot;prototype on the non-extensible proxy target&quot;)                            \\012  T(ProxyTrapReturnedFalsish, &quot;'%' on proxy: trap returned falsish&quot;)           \\012  T(ProxyTrapReturnedFalsishFor,                                               \\012 &quot;'%' on proxy: trap returned falsish for property '%'&quot;)                    \\012  T(RedefineDisallowed, &quot;Cannot redefine property: %&quot;)                         \\012  T(RedefineExternalArray,                                                     \\012 &quot;Cannot redefine a property of an object with external array elements&quot;)    \\012  T(ReduceNoInitial, &quot;Reduce of empty array with no initial value&quot;)            \\012  T(RegExpFlags,                                                               \\012 &quot;Cannot supply flags when constructing one RegExp from another&quot;)           \\012  T(RegExpNonObject, &quot;% getter called on non-object %&quot;)                        \\012  T(RegExpNonRegExp, &quot;% getter called on non-RegExp object&quot;)                   \\012  T(RelativeDateTimeFormatterBadParameters,                                    \\012 &quot;Incorrect RelativeDateTimeFormatter provided&quot;)                            \\012  T(ResolverNotAFunction, &quot;Promise resolver % is not a function&quot;)              \\012  T(ReturnMethodNotCallable, &quot;The iterator's 'return' method is not callable&quot;) \\012  T(SharedArrayBufferTooShort,                                                 \\012 &quot;Derived SharedArrayBuffer constructor created a buffer which was too &quot;    \\012 &quot;small&quot;)                                                                   \\012  T(SharedArrayBufferSpeciesThis,                                              \\012 &quot;SharedArrayBuffer subclass returned this from species constructor&quot;)       \\012  T(StaticPrototype,                                                           \\012 &quot;Classes may not have a static property named 'prototype'&quot;)                \\012  T(StrictDeleteProperty, &quot;Cannot delete property '%' of %&quot;)                   \\012  T(StrictPoisonPill,                                                          \\012 &quot;'caller', 'callee', and 'arguments' properties may not be accessed on &quot;   \\012 &quot;strict mode functions or the arguments objects for calls to them&quot;)        \\012  T(StrictReadOnlyProperty,                                                    \\012 &quot;Cannot assign to read only property '%' of % '%'&quot;)                        \\012  T(StrictCannotCreateProperty, &quot;Cannot create property '%' on % '%'&quot;)         \\012  T(SymbolIteratorInvalid,                                                     \\012 &quot;Result of the Symbol.iterator method is not an object&quot;)                   \\012  T(SymbolAsyncIteratorInvalid,                                                \\012 &quot;Result of the Symbol.asyncIterator method is not an object&quot;)              \\012  T(SymbolKeyFor, &quot;% is not a symbol&quot;)                                         \\012  T(SymbolToNumber, &quot;Cannot convert a Symbol value to a number&quot;)               \\012  T(SymbolToString, &quot;Cannot convert a Symbol value to a string&quot;)               \\012  T(ThrowMethodMissing, &quot;The iterator does not provide a 'throw' method.&quot;)     \\012  T(UndefinedOrNullToObject, &quot;Cannot convert undefined or null to object&quot;)     \\012  T(ValueAndAccessor,                                                          \\012 &quot;Invalid property descriptor. Cannot both specify accessors and a value &quot;  \\012 &quot;or writable attribute, %&quot;)                                                \\012  T(VarRedeclaration, &quot;Identifier '%' has already been declared&quot;)              \\012  T(WrongArgs, &quot;%: Arguments list has wrong type&quot;)                             \\012 /* ReferenceError */                                                         \\012  T(NotDefined, &quot;% is not defined&quot;)                                            \\012  T(SuperAlreadyCalled, &quot;Super constructor may only be called once&quot;)           \\012  T(UnsupportedSuper, &quot;Unsupported reference to 'super'&quot;)                      \\012 /* RangeError */                                                             \\012  T(BigIntDivZero, &quot;Division by zero&quot;)                                         \\012  T(BigIntNegativeExponent, &quot;Exponent must be positive&quot;)                       \\012  T(BigIntTooBig, &quot;Maximum BigInt size exceeded&quot;)                              \\012  T(DateRange, &quot;Provided date is not in valid range.&quot;)                         \\012  T(ExpectedLocation,                                                          \\012 &quot;Expected letters optionally connected with underscores or hyphens for &quot;   \\012 &quot;a location, got %&quot;)                                                       \\012  T(InvalidArrayBufferLength, &quot;Invalid array buffer length&quot;)                   \\012  T(ArrayBufferAllocationFailed, &quot;Array buffer allocation failed&quot;)             \\012  T(InvalidArrayLength, &quot;Invalid array length&quot;)                                \\012  T(InvalidAtomicAccessIndex, &quot;Invalid atomic access index&quot;)                   \\012  T(InvalidCodePoint, &quot;Invalid code point %&quot;)                                  \\012  T(InvalidCountValue, &quot;Invalid count value&quot;)                                  \\012  T(InvalidCurrencyCode, &quot;Invalid currency code: %&quot;)                           \\012  T(InvalidDataViewAccessorOffset,                                             \\012 &quot;Offset is outside the bounds of the DataView&quot;)                            \\012  T(InvalidDataViewLength, &quot;Invalid DataView length %&quot;)                        \\012  T(InvalidOffset, &quot;Start offset % is outside the bounds of the buffer&quot;)       \\012  T(InvalidHint, &quot;Invalid hint: %&quot;)                                            \\012  T(InvalidIndex, &quot;Invalid value: not (convertible to) a safe integer&quot;)        \\012  T(InvalidLanguageTag, &quot;Invalid language tag: %&quot;)                             \\012  T(InvalidWeakMapKey, &quot;Invalid value used as weak map key&quot;)                   \\012  T(InvalidWeakSetValue, &quot;Invalid value used in weak set&quot;)                     \\012  T(InvalidStringLength, &quot;Invalid string length&quot;)                              \\012  T(InvalidTimeValue, &quot;Invalid time value&quot;)                                    \\012  T(InvalidTimeZone, &quot;Invalid time zone specified: %&quot;)                         \\012  T(InvalidTypedArrayAlignment, &quot;% of % should be a multiple of %&quot;)            \\012  T(InvalidTypedArrayIndex, &quot;Invalid typed array index&quot;)                       \\012  T(InvalidTypedArrayLength, &quot;Invalid typed array length: %&quot;)                  \\012  T(LetInLexicalBinding, &quot;let is disallowed as a lexically bound name&quot;)        \\012  T(LocaleMatcher, &quot;Illegal value for localeMatcher:%&quot;)                        \\012  T(NormalizationForm, &quot;The normalization form should be one of %.&quot;)           \\012  T(ZeroDigitNumericSeparator,                                                 \\012 &quot;Numeric separator can not be used after leading 0.&quot;)                      \\012  T(NumberFormatRange, &quot;% argument must be between 0 and 100&quot;)                 \\012  T(TrailingNumericSeparator,                                                  \\012 &quot;Numeric separators are not allowed at the end of numeric literals&quot;)       \\012  T(ContinuousNumericSeparator,                                                \\012 &quot;Only one underscore is allowed as numeric separator&quot;)                     \\012  T(PropertyValueOutOfRange, &quot;% value is out of range.&quot;)                       \\012  T(StackOverflow, &quot;Maximum call stack size exceeded&quot;)                         \\012  T(ToPrecisionFormatRange,                                                    \\012 &quot;toPrecision() argument must be between 1 and 100&quot;)                        \\012  T(ToRadixFormatRange, &quot;toString() radix argument must be between 2 and 36&quot;)  \\012  T(TypedArraySetOffsetOutOfBounds, &quot;offset is out of bounds&quot;)                 \\012  T(TypedArraySetSourceTooLarge, &quot;Source is too large&quot;)                        \\012  T(ValueOutOfRange, &quot;Value % out of range for % options property %&quot;)          \\012 /* SyntaxError */                                                            \\012  T(AmbiguousExport,                                                           \\012 &quot;The requested module '%' contains conflicting star exports for name '%'&quot;) \\012  T(BadGetterArity, &quot;Getter must not have any formal parameters.&quot;)             \\012  T(BadSetterArity, &quot;Setter must have exactly one formal parameter.&quot;)          \\012  T(BigIntInvalidString, &quot;Invalid BigInt string&quot;)                              \\012  T(ConstructorIsAccessor, &quot;Class constructor may not be an accessor&quot;)         \\012  T(ConstructorIsGenerator, &quot;Class constructor may not be a generator&quot;)        \\012  T(ConstructorIsAsync, &quot;Class constructor may not be an async method&quot;)        \\012  T(DerivedConstructorReturnedNonObject,                                       \\012 &quot;Derived constructors may only return object or undefined&quot;)                \\012  T(DuplicateConstructor, &quot;A class may only have one constructor&quot;)             \\012  T(DuplicateExport, &quot;Duplicate export of '%'&quot;)                                \\012  T(DuplicateProto,                                                            \\012 &quot;Duplicate __proto__ fields are not allowed in object literals&quot;)           \\012  T(ForInOfLoopInitializer,                                                    \\012 &quot;% loop variable declaration may not have an initializer.&quot;)                \\012  T(ForInOfLoopMultiBindings,                                                  \\012 &quot;Invalid left-hand side in % loop: Must have a single binding.&quot;)           \\012  T(GeneratorInSingleStatementContext,                                         \\012 &quot;Generators can only be declared at the top level or inside a block.&quot;)     \\012  T(AsyncFunctionInSingleStatementContext,                                     \\012 &quot;Async functions can only be declared at the top level or inside a &quot;       \\012 &quot;block.&quot;)                                                                  \\012  T(IllegalBreak, &quot;Illegal break statement&quot;)                                   \\012  T(NoIterationStatement,                                                      \\012 &quot;Illegal continue statement: no surrounding iteration statement&quot;)          \\012  T(IllegalContinue,                                                           \\012 &quot;Illegal continue statement: '%' does not denote an iteration statement&quot;)  \\012  T(IllegalLanguageModeDirective,                                              \\012 &quot;Illegal '%' directive in function with non-simple parameter list&quot;)        \\012  T(IllegalReturn, &quot;Illegal return statement&quot;)                                 \\012  T(IntrinsicWithSpread, &quot;Intrinsic calls do not support spread arguments&quot;)    \\012  T(InvalidRestBindingPattern,                                                 \\012 &quot;`...` must be followed by an identifier in declaration contexts&quot;)         \\012  T(InvalidRestAssignmentPattern,                                              \\012 &quot;`...` must be followed by an assignable reference in assignment &quot;         \\012 &quot;contexts&quot;)                                                                \\012  T(InvalidEscapedReservedWord, &quot;Keyword must not contain escaped characters&quot;) \\012  T(InvalidEscapedMetaProperty, &quot;'%' must not contain escaped characters&quot;)     \\012  T(InvalidLhsInAssignment, &quot;Invalid left-hand side in assignment&quot;)            \\012  T(InvalidCoverInitializedName, &quot;Invalid shorthand property initializer&quot;)     \\012  T(InvalidDestructuringTarget, &quot;Invalid destructuring assignment target&quot;)     \\012  T(InvalidLhsInFor, &quot;Invalid left-hand side in for-loop&quot;)                     \\012  T(InvalidLhsInPostfixOp,                                                     \\012 &quot;Invalid left-hand side expression in postfix operation&quot;)                  \\012  T(InvalidLhsInPrefixOp,                                                      \\012 &quot;Invalid left-hand side expression in prefix operation&quot;)                   \\012  T(InvalidRegExpFlags, &quot;Invalid flags supplied to RegExp constructor '%'&quot;)    \\012  T(InvalidOrUnexpectedToken, &quot;Invalid or unexpected token&quot;)                   \\012  T(InvalidPrivateFieldAccess, &quot;Invalid private field '%'&quot;)                    \\012  T(JsonParseUnexpectedEOS, &quot;Unexpected end of JSON input&quot;)                    \\012  T(JsonParseUnexpectedToken, &quot;Unexpected token % in JSON at position %&quot;)      \\012  T(JsonParseUnexpectedTokenNumber, &quot;Unexpected number in JSON at position %&quot;) \\012  T(JsonParseUnexpectedTokenString, &quot;Unexpected string in JSON at position %&quot;) \\012  T(LabelRedeclaration, &quot;Label '%' has already been declared&quot;)                 \\012  T(LabelledFunctionDeclaration,                                               \\012 &quot;Labelled function declaration not allowed as the body of a control flow &quot; \\012 &quot;structure&quot;)                                                               \\012  T(MalformedArrowFunParamList, &quot;Malformed arrow function parameter list&quot;)     \\012  T(MalformedRegExp, &quot;Invalid regular expression: /%/: %&quot;)                     \\012  T(MalformedRegExpFlags, &quot;Invalid regular expression flags&quot;)                  \\012  T(ModuleExportUndefined, &quot;Export '%' is not defined in module&quot;)              \\012  T(HtmlCommentInModule, &quot;HTML comments are not allowed in modules&quot;)           \\012  T(MultipleDefaultsInSwitch,                                                  \\012 &quot;More than one default clause in switch statement&quot;)                        \\012  T(NewlineAfterThrow, &quot;Illegal newline after throw&quot;)                          \\012  T(NoCatchOrFinally, &quot;Missing catch or finally after try&quot;)                    \\012  T(NotIsvar, &quot;builtin %%IS_VAR: not a variable&quot;)                              \\012  T(ParamAfterRest, &quot;Rest parameter must be last formal parameter&quot;)            \\012  T(FlattenPastSafeLength,                                                     \\012 &quot;Flattening % elements on an array-like of length % &quot;                      \\012 &quot;is disallowed, as the total surpasses 2**53-1&quot;)                           \\012  T(PushPastSafeLength,                                                        \\012 &quot;Pushing % elements on an array-like of length % &quot;                         \\012 &quot;is disallowed, as the total surpasses 2**53-1&quot;)                           \\012  T(ElementAfterRest, &quot;Rest element must be last element&quot;)                     \\012  T(BadSetterRestParameter,                                                    \\012 &quot;Setter function argument must not be a rest parameter&quot;)                   \\012  T(ParamDupe, &quot;Duplicate parameter name not allowed in this context&quot;)         \\012  T(ParenthesisInArgString, &quot;Function arg string contains parenthesis&quot;)        \\012  T(ArgStringTerminatesParametersEarly,                                        \\012 &quot;Arg string terminates parameters early&quot;)                                  \\012  T(UnexpectedEndOfArgString, &quot;Unexpected end of arg string&quot;)                  \\012  T(RestDefaultInitializer,                                                    \\012 &quot;Rest parameter may not have a default initializer&quot;)                       \\012  T(RuntimeWrongNumArgs, &quot;Runtime function given wrong number of arguments&quot;)   \\012  T(SuperNotCalled,                                                            \\012 &quot;Must call super constructor in derived class before accessing 'this' or &quot; \\012 &quot;returning from derived constructor&quot;)                                      \\012  T(SingleFunctionLiteral, &quot;Single function literal required&quot;)                 \\012  T(SloppyFunction,                                                            \\012 &quot;In non-strict mode code, functions can only be declared at top level, &quot;   \\012 &quot;inside a block, or as the body of an if statement.&quot;)                      \\012  T(SpeciesNotConstructor,                                                     \\012 &quot;object.constructor[Symbol.species] is not a constructor&quot;)                 \\012  T(StrictDelete, &quot;Delete of an unqualified identifier in strict mode.&quot;)       \\012  T(StrictEvalArguments, &quot;Unexpected eval or arguments in strict mode&quot;)        \\012  T(StrictFunction,                                                            \\012 &quot;In strict mode code, functions can only be declared at top level or &quot;     \\012 &quot;inside a block.&quot;)                                                         \\012  T(StrictOctalLiteral, &quot;Octal literals are not allowed in strict mode.&quot;)      \\012  T(StrictDecimalWithLeadingZero,                                              \\012 &quot;Decimals with leading zeros are not allowed in strict mode.&quot;)             \\012  T(StrictOctalEscape,                                                         \\012 &quot;Octal escape sequences are not allowed in strict mode.&quot;)                  \\012  T(StrictWith, &quot;Strict mode code may not include a with statement&quot;)           \\012  T(TemplateOctalLiteral,                                                      \\012 &quot;Octal escape sequences are not allowed in template strings.&quot;)             \\012  T(ThisFormalParameter, &quot;'this' is not a valid formal parameter name&quot;)        \\012  T(AwaitBindingIdentifier,                                                    \\012 &quot;'await' is not a valid identifier name in an async function&quot;)             \\012  T(AwaitExpressionFormalParameter,                                            \\012 &quot;Illegal await-expression in formal parameters of async function&quot;)         \\012  T(TooManyArguments,                                                          \\012 &quot;Too many arguments in function call (only 65535 allowed)&quot;)                \\012  T(TooManyParameters,                                                         \\012 &quot;Too many parameters in function definition (only 65535 allowed)&quot;)         \\012  T(TooManySpreads,                                                            \\012 &quot;Literal containing too many nested spreads (up to 65534 allowed)&quot;)        \\012  T(TooManyVariables, &quot;Too many variables declared (only 4194303 allowed)&quot;)    \\012  T(TooManyElementsInPromiseAll, &quot;Too many elements passed to Promise.all&quot;)    \\012  T(TypedArrayTooShort,                                                        \\012 &quot;Derived TypedArray constructor created an array which was too small&quot;)     \\012  T(UnexpectedEOS, &quot;Unexpected end of input&quot;)                                  \\012  T(UnexpectedReserved, &quot;Unexpected reserved word&quot;)                            \\012  T(UnexpectedStrictReserved, &quot;Unexpected strict mode reserved word&quot;)          \\012  T(UnexpectedSuper, &quot;'super' keyword unexpected here&quot;)                        \\012  T(UnexpectedNewTarget, &quot;new.target expression is not allowed here&quot;)          \\012  T(UnexpectedTemplateString, &quot;Unexpected template string&quot;)                    \\012  T(UnexpectedToken, &quot;Unexpected token %&quot;)                                     \\012  T(UnexpectedTokenIdentifier, &quot;Unexpected identifier&quot;)                        \\012  T(UnexpectedTokenNumber, &quot;Unexpected number&quot;)                                \\012  T(UnexpectedTokenString, &quot;Unexpected string&quot;)                                \\012  T(UnexpectedTokenRegExp, &quot;Unexpected regular expression&quot;)                    \\012  T(UnexpectedLexicalDeclaration,                                              \\012 &quot;Lexical declaration cannot appear in a single-statement context&quot;)         \\012  T(UnknownLabel, &quot;Undefined label '%'&quot;)                                       \\012  T(UnresolvableExport,                                                        \\012 &quot;The requested module '%' does not provide an export named '%'&quot;)           \\012  T(UnterminatedArgList, &quot;missing ) after argument list&quot;)                      \\012  T(UnterminatedRegExp, &quot;Invalid regular expression: missing /&quot;)               \\012  T(UnterminatedTemplate, &quot;Unterminated template literal&quot;)                     \\012  T(UnterminatedTemplateExpr, &quot;Missing } in template expression&quot;)              \\012  T(FoundNonCallableHasInstance, &quot;Found non-callable @@hasInstance&quot;)           \\012  T(InvalidHexEscapeSequence, &quot;Invalid hexadecimal escape sequence&quot;)           \\012  T(InvalidUnicodeEscapeSequence, &quot;Invalid Unicode escape sequence&quot;)           \\012  T(UndefinedUnicodeCodePoint, &quot;Undefined Unicode code-point&quot;)                 \\012  T(YieldInParameter, &quot;Yield expression not allowed in formal parameter&quot;)      \\012 /* EvalError */                                                              \\012  T(CodeGenFromStrings, &quot;%&quot;)                                                   \\012  T(NoSideEffectDebugEvaluate, &quot;Possible side-effect in debug-evaluate&quot;)       \\012 /* URIError */                                                               \\012  T(URIMalformed, &quot;URI malformed&quot;)                                             \\012 /* Wasm errors (currently Error) */                                          \\012  T(WasmTrapUnreachable, &quot;unreachable&quot;)                                        \\012  T(WasmTrapMemOutOfBounds, &quot;memory access out of bounds&quot;)                     \\012  T(WasmTrapUnalignedAccess, &quot;operation does not support unaligned accesses&quot;)  \\012  T(WasmTrapDivByZero, &quot;divide by zero&quot;)                                       \\012  T(WasmTrapDivUnrepresentable, &quot;divide result unrepresentable&quot;)               \\012  T(WasmTrapRemByZero, &quot;remainder by zero&quot;)                                    \\012  T(WasmTrapFloatUnrepresentable, &quot;float unrepresentable in integer range&quot;)    \\012  T(WasmTrapFuncInvalid, &quot;invalid index into function table&quot;)                  \\012  T(WasmTrapFuncSigMismatch, &quot;function signature mismatch&quot;)                    \\012  T(WasmTrapTypeError, &quot;wasm function signature contains illegal type&quot;)        \\012  T(WasmExceptionError, &quot;wasm exception&quot;)                                      \\012 /* Asm.js validation related */                                              \\012  T(AsmJsInvalid, &quot;Invalid asm.js: %&quot;)                                         \\012  T(AsmJsCompiled, &quot;Converted asm.js to WebAssembly: %&quot;)                       \\012  T(AsmJsInstantiated, &quot;Instantiated asm.js: %&quot;)                               \\012  T(AsmJsLinkingFailed, &quot;Linking failure in asm.js: %&quot;)                        \\012 /* DataCloneError messages */                                                \\012  T(DataCloneError, &quot;% could not be cloned.&quot;)                                  \\012  T(DataCloneErrorOutOfMemory, &quot;Data cannot be cloned, out of memory.&quot;)        \\012  T(DataCloneErrorNeuteredArrayBuffer,                                         \\012 &quot;An ArrayBuffer is neutered and could not be cloned.&quot;)                     \\012  T(DataCloneErrorSharedArrayBufferTransferred,                                \\012 &quot;A SharedArrayBuffer could not be cloned. SharedArrayBuffer must not be &quot;  \\012 &quot;transferred.&quot;)                                                            \\012  T(DataCloneDeserializationError, &quot;Unable to deserialize cloned data.&quot;)       \\012  T(DataCloneDeserializationVersionError,                                      \\012 &quot;Unable to deserialize cloned data due to invalid or unsupported &quot;         \\012 &quot;version.&quot;)                                                                \\012 /* Builtins-Trace Errors */                                                  \\012  T(TraceEventCategoryError, &quot;Trace event category must be a string.&quot;)         \\012  T(TraceEventNameError, &quot;Trace event name must be a string.&quot;)                 \\012  T(TraceEventNameLengthError,                                                 \\012 &quot;Trace event name must not be an empty string.&quot;)                           \\012  T(TraceEventPhaseError, &quot;Trace event phase must be a number.&quot;)               \\012  T(TraceEventIDError, &quot;Trace event id must be a number.&quot;)\012\012class MessageTemplate {\012 public:\012 enum Template {\012#define TEMPLATE(NAME, STRING) k##NAME,\012    MESSAGE_TEMPLATES(TEMPLATE)\012#undef TEMPLATE\012        kLastMessage\012 };\012\012 static const char* TemplateString(int template_index);\012\012 static MaybeHandle&lt;String&gt; FormatMessage(Isolate* isolate, int template_index,\012 Handle&lt;String&gt; arg0,\012 Handle&lt;String&gt; arg1,\012 Handle&lt;String&gt; arg2);\012\012 static Handle&lt;String&gt; FormatMessage(Isolate* isolate, int template_index,\012 Handle&lt;Object&gt; arg);\012};\012\012\012// A message handler is a convenience interface for accessing the list\012// of message listeners registered in an environment\012class MessageHandler {\012 public:\012 // Returns a message object for the API to use.\012 static Handle&lt;JSMessageObject&gt; MakeMessageObject(\012 Isolate* isolate, MessageTemplate::Template type,\012 const MessageLocation* location, Handle&lt;Object&gt; argument,\012 Handle&lt;FixedArray&gt; stack_frames);\012\012 // Report a formatted message (needs JS allocation).\012 static void ReportMessage(Isolate* isolate, const MessageLocation* loc,\012 Handle&lt;JSMessageObject&gt; message);\012\012 static void DefaultMessageReport(Isolate* isolate, const MessageLocation* loc,\012 Handle&lt;Object&gt; message_obj);\012 static Handle&lt;String&gt; GetMessage(Isolate* isolate, Handle&lt;Object&gt; data);\012 static std::unique_ptr&lt;char[]&gt; GetLocalizedMessage(Isolate* isolate,\012 Handle&lt;Object&gt; data);\012\012 private:\012 static void ReportMessageNoExceptions(Isolate* isolate,\012 const MessageLocation* loc,\012 Handle&lt;Object&gt; message_obj,\012                                        v8::Local&lt;v8::Value&gt; api_exception_obj);\012};\012\012\012} // namespace internal\012})<SUB>17</SUB>> ]
 "19" [label = <(METHOD,&lt;global&gt;)<SUB>1</SUB>> ]
 "21" [label = <(METHOD_RETURN,ANY)> ]
   "9" -> "21" 
