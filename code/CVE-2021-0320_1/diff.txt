diff -bur /home/mrt3acher/thesis-implementation/.avuln-workdir/code/CVE-2021-0320_1/secure/out/0-cfg.dot /home/mrt3acher/thesis-implementation/.avuln-workdir/code/CVE-2021-0320_1/vulnerable/out/0-cfg.dot
--- /home/mrt3acher/thesis-implementation/.avuln-workdir/code/CVE-2021-0320_1/secure/out/0-cfg.dot	2023-06-07 19:32:22.837402466 +0330
+++ /home/mrt3acher/thesis-implementation/.avuln-workdir/code/CVE-2021-0320_1/vulnerable/out/0-cfg.dot	2023-06-07 19:32:25.967402165 +0330
@@ -1,5 +1,5 @@
 digraph "&lt;global&gt;" {  
-"7" [label = <(UNKNOWN,namespace keystore {\012/**\012 * This is a specialization of the KeymasterEnforcement class to be used by Keystore to enforce\012 * keymaster requirements on all key operation.\012 */\012class KeystoreKeymasterEnforcement : public KeymasterEnforcement {\012 public:\012 KeystoreKeymasterEnforcement() : KeymasterEnforcement(64, 64) {}\012\012 uint32_t get_current_time() const override {\012 struct timespec tp;\012 int err = clock_gettime(CLOCK_MONOTONIC, &amp;tp);\012 if (err || tp.tv_sec &lt; 0)\012 return 0;\012 return static_cast&lt;uint32_t&gt;(tp.tv_sec);\012 }\012\012 bool activation_date_valid(uint64_t activation_date) const override {\012 time_t now = time(nullptr);\012 if (now == static_cast&lt;time_t&gt;(-1)) {\012 // Failed to obtain current time -- fail safe: activation_date hasn't yet occurred.\012 return false;\012 } else if (now &lt; 0) {\012 // Current time is prior to start of the epoch -- activation_date hasn't yet occurred.\012 return false;\012 }\012\012 // time(NULL) returns seconds since epoch and &quot;loses&quot; milliseconds information. We thus add\012 // 999 ms to now_date to avoid a situation where an activation_date of up to 999ms in the\012 // past may still be considered to still be in the future. This can be removed once\012 // time(NULL) is replaced by a millisecond-precise source of time.\012 uint64_t now_date = static_cast&lt;uint64_t&gt;(now) * 1000 + 999;\012 return now_date &gt;= activation_date;\012 }\012\012 bool expiration_date_passed(uint64_t expiration_date) const override {\012 time_t now = time(nullptr);\012 if (now == static_cast&lt;time_t&gt;(-1)) {\012 // Failed to obtain current time -- fail safe: expiration_date has passed.\012 return true;\012 } else if (now &lt; 0) {\012 // Current time is prior to start of the epoch: expiration_date hasn't yet occurred.\012 return false;\012 }\012\012 // time(NULL) returns seconds since epoch and &quot;loses&quot; milliseconds information. As a result,\012 // expiration_date of up to 999 ms in the past may still be considered in the future. This\012 // is OK.\012 uint64_t now_date = static_cast&lt;uint64_t&gt;(now) * 1000;\012 return now_date &gt; expiration_date;\012 }\012\012 bool auth_token_timed_out(const HardwareAuthToken&amp;, uint32_t) const {\012 // Assume the token has not timed out, because AuthTokenTable would not have returned it if\012 // the timeout were past.  Secure hardware will also check timeouts if it supports them.\012 return false;\012 }\012\012 bool ValidateTokenSignature(const HardwareAuthToken&amp;) const override {\012 // Non-secure world cannot validate token signatures because it doesn't have access to the\012 // signing key. Assume the token is good.\012 return true;\012 }\012\012 bool is_device_locked(int32_t userId) const override {\012        std::lock_guard&lt;std::mutex&gt; lock(is_device_locked_for_user_map_lock_);\012 // If we haven't had a set call for this user yet, assume the device is locked.\012 if (mIsDeviceLockedForUser.count(userId) == 0) return true;\012 return mIsDeviceLockedForUser.find(userId)-&gt;second;\012 }\012\012 void set_device_locked(bool isLocked, int32_t userId) {\012        std::lock_guard&lt;std::mutex&gt; lock(is_device_locked_for_user_map_lock_);\012        mIsDeviceLockedForUser[userId] = isLocked;\012 }\012\012 private:\012 mutable std::mutex is_device_locked_for_user_map_lock_;\012    std::map&lt;int32_t, bool&gt; mIsDeviceLockedForUser;\012};\012\012},namespace keystore {\012/**\012 * This is a specialization of the KeymasterEnforcement class to be used by Keystore to enforce\012 * keymaster requirements on all key operation.\012 */\012class KeystoreKeymasterEnforcement : public KeymasterEnforcement {\012 public:\012 KeystoreKeymasterEnforcement() : KeymasterEnforcement(64, 64) {}\012\012 uint32_t get_current_time() const override {\012 struct timespec tp;\012 int err = clock_gettime(CLOCK_MONOTONIC, &amp;tp);\012 if (err || tp.tv_sec &lt; 0)\012 return 0;\012 return static_cast&lt;uint32_t&gt;(tp.tv_sec);\012 }\012\012 bool activation_date_valid(uint64_t activation_date) const override {\012 time_t now = time(nullptr);\012 if (now == static_cast&lt;time_t&gt;(-1)) {\012 // Failed to obtain current time -- fail safe: activation_date hasn't yet occurred.\012 return false;\012 } else if (now &lt; 0) {\012 // Current time is prior to start of the epoch -- activation_date hasn't yet occurred.\012 return false;\012 }\012\012 // time(NULL) returns seconds since epoch and &quot;loses&quot; milliseconds information. We thus add\012 // 999 ms to now_date to avoid a situation where an activation_date of up to 999ms in the\012 // past may still be considered to still be in the future. This can be removed once\012 // time(NULL) is replaced by a millisecond-precise source of time.\012 uint64_t now_date = static_cast&lt;uint64_t&gt;(now) * 1000 + 999;\012 return now_date &gt;= activation_date;\012 }\012\012 bool expiration_date_passed(uint64_t expiration_date) const override {\012 time_t now = time(nullptr);\012 if (now == static_cast&lt;time_t&gt;(-1)) {\012 // Failed to obtain current time -- fail safe: expiration_date has passed.\012 return true;\012 } else if (now &lt; 0) {\012 // Current time is prior to start of the epoch: expiration_date hasn't yet occurred.\012 return false;\012 }\012\012 // time(NULL) returns seconds since epoch and &quot;loses&quot; milliseconds information. As a result,\012 // expiration_date of up to 999 ms in the past may still be considered in the future. This\012 // is OK.\012 uint64_t now_date = static_cast&lt;uint64_t&gt;(now) * 1000;\012 return now_date &gt; expiration_date;\012 }\012\012 bool auth_token_timed_out(const HardwareAuthToken&amp;, uint32_t) const {\012 // Assume the token has not timed out, because AuthTokenTable would not have returned it if\012 // the timeout were past.  Secure hardware will also check timeouts if it supports them.\012 return false;\012 }\012\012 bool ValidateTokenSignature(const HardwareAuthToken&amp;) const override {\012 // Non-secure world cannot validate token signatures because it doesn't have access to the\012 // signing key. Assume the token is good.\012 return true;\012 }\012\012 bool is_device_locked(int32_t userId) const override {\012        std::lock_guard&lt;std::mutex&gt; lock(is_device_locked_for_user_map_lock_);\012 // If we haven't had a set call for this user yet, assume the device is locked.\012 if (mIsDeviceLockedForUser.count(userId) == 0) return true;\012 return mIsDeviceLockedForUser.find(userId)-&gt;second;\012 }\012\012 void set_device_locked(bool isLocked, int32_t userId) {\012        std::lock_guard&lt;std::mutex&gt; lock(is_device_locked_for_user_map_lock_);\012        mIsDeviceLockedForUser[userId] = isLocked;\012 }\012\012 private:\012 mutable std::mutex is_device_locked_for_user_map_lock_;\012    std::map&lt;int32_t, bool&gt; mIsDeviceLockedForUser;\012};\012\012})<SUB>24</SUB>> ]
+"7" [label = <(UNKNOWN,namespace keystore {\012/**\012 * This is a specialization of the KeymasterEnforcement class to be used by Keystore to enforce\012 * keymaster requirements on all key operation.\012 */\012class KeystoreKeymasterEnforcement : public KeymasterEnforcement {\012 public:\012 KeystoreKeymasterEnforcement() : KeymasterEnforcement(64, 64) {}\012\012 uint32_t get_current_time() const override {\012 struct timespec tp;\012 int err = clock_gettime(CLOCK_MONOTONIC, &amp;tp);\012 if (err || tp.tv_sec &lt; 0)\012 return 0;\012 return static_cast&lt;uint32_t&gt;(tp.tv_sec);\012 }\012\012 bool activation_date_valid(uint64_t activation_date) const override {\012 time_t now = time(nullptr);\012 if (now == static_cast&lt;time_t&gt;(-1)) {\012 // Failed to obtain current time -- fail safe: activation_date hasn't yet occurred.\012 return false;\012 } else if (now &lt; 0) {\012 // Current time is prior to start of the epoch -- activation_date hasn't yet occurred.\012 return false;\012 }\012\012 // time(NULL) returns seconds since epoch and &quot;loses&quot; milliseconds information. We thus add\012 // 999 ms to now_date to avoid a situation where an activation_date of up to 999ms in the\012 // past may still be considered to still be in the future. This can be removed once\012 // time(NULL) is replaced by a millisecond-precise source of time.\012 uint64_t now_date = static_cast&lt;uint64_t&gt;(now) * 1000 + 999;\012 return now_date &gt;= activation_date;\012 }\012\012 bool expiration_date_passed(uint64_t expiration_date) const override {\012 time_t now = time(nullptr);\012 if (now == static_cast&lt;time_t&gt;(-1)) {\012 // Failed to obtain current time -- fail safe: expiration_date has passed.\012 return true;\012 } else if (now &lt; 0) {\012 // Current time is prior to start of the epoch: expiration_date hasn't yet occurred.\012 return false;\012 }\012\012 // time(NULL) returns seconds since epoch and &quot;loses&quot; milliseconds information. As a result,\012 // expiration_date of up to 999 ms in the past may still be considered in the future. This\012 // is OK.\012 uint64_t now_date = static_cast&lt;uint64_t&gt;(now) * 1000;\012 return now_date &gt; expiration_date;\012 }\012\012 bool auth_token_timed_out(const HardwareAuthToken&amp;, uint32_t) const {\012 // Assume the token has not timed out, because AuthTokenTable would not have returned it if\012 // the timeout were past.  Secure hardware will also check timeouts if it supports them.\012 return false;\012 }\012\012 bool ValidateTokenSignature(const HardwareAuthToken&amp;) const override {\012 // Non-secure world cannot validate token signatures because it doesn't have access to the\012 // signing key. Assume the token is good.\012 return true;\012 }\012\012 bool is_device_locked(int32_t userId) const override {\012 // If we haven't had a set call for this user yet, assume the device is locked.\012 if (mIsDeviceLockedForUser.count(userId) == 0) return true;\012 return mIsDeviceLockedForUser.find(userId)-&gt;second;\012 }\012\012 void set_device_locked(bool isLocked, int32_t userId) {\012        mIsDeviceLockedForUser[userId] = isLocked;\012 }\012\012 private:\012    std::map&lt;int32_t, bool&gt; mIsDeviceLockedForUser;\012};\012\012},namespace keystore {\012/**\012 * This is a specialization of the KeymasterEnforcement class to be used by Keystore to enforce\012 * keymaster requirements on all key operation.\012 */\012class KeystoreKeymasterEnforcement : public KeymasterEnforcement {\012 public:\012 KeystoreKeymasterEnforcement() : KeymasterEnforcement(64, 64) {}\012\012 uint32_t get_current_time() const override {\012 struct timespec tp;\012 int err = clock_gettime(CLOCK_MONOTONIC, &amp;tp);\012 if (err || tp.tv_sec &lt; 0)\012 return 0;\012 return static_cast&lt;uint32_t&gt;(tp.tv_sec);\012 }\012\012 bool activation_date_valid(uint64_t activation_date) const override {\012 time_t now = time(nullptr);\012 if (now == static_cast&lt;time_t&gt;(-1)) {\012 // Failed to obtain current time -- fail safe: activation_date hasn't yet occurred.\012 return false;\012 } else if (now &lt; 0) {\012 // Current time is prior to start of the epoch -- activation_date hasn't yet occurred.\012 return false;\012 }\012\012 // time(NULL) returns seconds since epoch and &quot;loses&quot; milliseconds information. We thus add\012 // 999 ms to now_date to avoid a situation where an activation_date of up to 999ms in the\012 // past may still be considered to still be in the future. This can be removed once\012 // time(NULL) is replaced by a millisecond-precise source of time.\012 uint64_t now_date = static_cast&lt;uint64_t&gt;(now) * 1000 + 999;\012 return now_date &gt;= activation_date;\012 }\012\012 bool expiration_date_passed(uint64_t expiration_date) const override {\012 time_t now = time(nullptr);\012 if (now == static_cast&lt;time_t&gt;(-1)) {\012 // Failed to obtain current time -- fail safe: expiration_date has passed.\012 return true;\012 } else if (now &lt; 0) {\012 // Current time is prior to start of the epoch: expiration_date hasn't yet occurred.\012 return false;\012 }\012\012 // time(NULL) returns seconds since epoch and &quot;loses&quot; milliseconds information. As a result,\012 // expiration_date of up to 999 ms in the past may still be considered in the future. This\012 // is OK.\012 uint64_t now_date = static_cast&lt;uint64_t&gt;(now) * 1000;\012 return now_date &gt; expiration_date;\012 }\012\012 bool auth_token_timed_out(const HardwareAuthToken&amp;, uint32_t) const {\012 // Assume the token has not timed out, because AuthTokenTable would not have returned it if\012 // the timeout were past.  Secure hardware will also check timeouts if it supports them.\012 return false;\012 }\012\012 bool ValidateTokenSignature(const HardwareAuthToken&amp;) const override {\012 // Non-secure world cannot validate token signatures because it doesn't have access to the\012 // signing key. Assume the token is good.\012 return true;\012 }\012\012 bool is_device_locked(int32_t userId) const override {\012 // If we haven't had a set call for this user yet, assume the device is locked.\012 if (mIsDeviceLockedForUser.count(userId) == 0) return true;\012 return mIsDeviceLockedForUser.find(userId)-&gt;second;\012 }\012\012 void set_device_locked(bool isLocked, int32_t userId) {\012        mIsDeviceLockedForUser[userId] = isLocked;\012 }\012\012 private:\012    std::map&lt;int32_t, bool&gt; mIsDeviceLockedForUser;\012};\012\012})<SUB>24</SUB>> ]
 "5" [label = <(METHOD,&lt;global&gt;)<SUB>1</SUB>> ]
 "8" [label = <(METHOD_RETURN,ANY)<SUB>1</SUB>> ]
   "7" -> "8" 
